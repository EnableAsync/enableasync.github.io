<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Diffusion 学习</title>
    <url>/uncategorized/DDPM/</url>
    <content><![CDATA[<h1 id="DDPM"><a href="#DDPM" class="headerlink" title="DDPM"></a>DDPM</h1><p><img  src="image-20250403144618848.png"  ><span class="image-caption">ddpm</span></p>
<p>这里从 $x_t$ 到 $x_{t-1}$ 的时候，预测的是 $x_{t-1}$ 的概率分布，也就是说要得到的是 $p(x_{t-1}|x_t)$，所以去噪过程是具有一定的随机性的，从 $p(x_{t-1}|x_t)$ 分布中就可以抽样出 $x_{t-1}$ 了。</p>
<h2 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h2><script type="math/tex; mode=display">
P(x_{t - 1}|x_t) = \frac{P(x_{t - 1}, x_t)}{P(x_t)} = \frac{P(x_t|x_{t - 1})P(x_{t - 1})}{P(x_t)} \quad \text{(1)}</script><p>这里的 $P(x_t|x_{t - 1})$ 是易知的，因为 $x_t = \sqrt{\alpha_t}x_{t - 1} + \sqrt{\beta_t}\epsilon_t$，其中 $\epsilon_t \sim N(0, 1)$，$\sqrt{\beta_t} \sim N(0, \beta_t)$，$x_t \sim N(\sqrt{\alpha_t}x_{t - 1}, \beta_t)$。</p>
<p>$P(x_t|x_{t - 1}) \sim N(\sqrt{\alpha_t}x_{t - 1}, \beta_t)$ 不断推导有 $P(x_t|x_0) \sim N(\sqrt{\bar{\alpha}_t}x_0, 1 - \bar{\alpha}_t)$。</p>
<ul>
<li>原先的去噪过程中 $P(x_{t - 1})$ 和 $P(x_t)$ 无法求得，为去噪过程增加条件：<script type="math/tex; mode=display">
P(x_{t - 1}|x_t, x_0) = \frac{P(x_t|x_{t - 1}, x_0)P(x_{t - 1}|x_0)}{P(x_t|x_0)} = \frac{P(x_t|x_{t - 1})P(x_{t - 1}|x_0)}{P(x_t|x_0)}</script></li>
</ul>
<p>（高斯特性）又 $P(x_t|x_0)$ 已知，则 $P(x_{t - 1}|x_0)$ 已知，得 $P(x_{t - 1}|x_t, x_0) \sim N(\tilde{\mu}_t(x_0, x_t), \tilde{\beta}_t)$。</p>
<p>$x_{t - 1} = \tilde{\mu}_t(x_0, x_t) + \sqrt{\tilde{\beta}_t}\epsilon$，$\epsilon \sim N(0, 1)$，其中 $\tilde{\mu}_t(x_t, x_0)$ 为 $\frac{\sqrt{\alpha_{t - 1}}\beta_t}{1 - \bar{\alpha}_t}x_0 + \frac{\sqrt{\alpha_t}(1 - \bar{\alpha}_{t - 1})}{1 - \bar{\alpha}_t}x_t$  ，$\tilde{\beta}_t = \frac{1 - \bar{\alpha}_{t - 1}}{1 - \bar{\alpha}_t}\beta_t$ 。这里的 $x_0$ 未知。</p>
<ul>
<li><p>于是又有 $x_t = \sqrt{\bar{\alpha}_t}x_0 + \sqrt{1 - \bar{\alpha}_t}\epsilon$ ，则 $x_0 = \frac{1}{\sqrt{\bar{\alpha}_t}}(x_t - \sqrt{1 - \bar{\alpha}_t}\epsilon)$ ，$x_0$ 可由 $x_t$ 得到了，它们之间差一个 $\epsilon$ 。</p>
</li>
<li><p>UNet 预测的就是 $x_0$ 和 $x_t$ 之间的这个噪声。那么能得到 $x_0$ ，是不是原因呢？否定的，因为 $x_0$ 的推导是借助了马尔可夫性质，所以还是要一步步推导。</p>
<p>把 $x_0 = \frac{1}{\sqrt{\bar{\alpha}_t}}(x_t - \sqrt{1 - \bar{\alpha}_t}\epsilon)$ 代入 $\tilde{\mu}_t(x_t, x_0)$ 式中，有 $\frac{1}{\sqrt{\alpha_t}}(x_t - \frac{\beta_t}{\sqrt{1 - \bar{\alpha}_t}}\epsilon)$ 。</p>
</li>
<li><p>总体脉络：从 $P(x_{t - 1}|x_t) \to P(x_{t - 1}|x_t, x_0) \to \tilde{\mu}_t(x_0, x_t) \to x_0 \to \epsilon$</p>
</li>
</ul>
<p><img  src="53dfabcb9844f43a33026fe042dff8c.jpg"  ><span class="image-caption">笔记</span></p>
<h2 id="参数选择"><a href="#参数选择" class="headerlink" title="参数选择"></a>参数选择</h2><ol>
<li>$ T = 1000 $</li>
<li>$ x_t=\sqrt{\alpha_t}x_{t - 1}+\sqrt{\beta_t}\epsilon $，$ \alpha_t<1 $，$ \beta_t>0 $，$ \alpha_t+\beta_t = 1 $<ul>
<li>$ x_t\sim N(\sqrt{\alpha_t}x_{t - 1},\beta_t) $</li>
<li>$ \alpha_t+\beta_t = 1 $ 的设置是为了最后易于得到 $ x_n=\sqrt{\overline{\alpha}_n}x_0+\sqrt{1 - \overline{\alpha}_n}\epsilon $ 的形式</li>
</ul>
</li>
<li><strong>能否直接跳步？</strong><ul>
<li>$ P(x_{t - 1}|x_t,x_0)=\frac{P(x_t|x_{t - 1})P(x_{t - 1}|x_0)}{P(x_t|x_0)} $ 是由贝叶斯定理得到的</li>
<li>结论：不能跳步</li>
</ul>
</li>
<li><strong>为什么不直接预测 $ x_{t - 1} $，而是预测 $ P(x_{t - 1}|x_t) $</strong><ul>
<li>这样有更多的多样性</li>
</ul>
</li>
<li><strong>论文中的变分下界分析</strong><ul>
<li>是为了证明 $ E(-\log P(x_0)) $ 等价于求 $ P(x_{t - 1}|x_t) $ 和 $ P(x_{t - 1}|x_t,x_0) $ 的 KL 散度。</li>
</ul>
</li>
</ol>
<p><img  src="34ff3b1a482f1445724b9f1683bbd71.jpg"  ><span class="image-caption">参数选择</span></p>
<h1 id="DDIM"><a href="#DDIM" class="headerlink" title="DDIM"></a>DDIM</h1><h2 id="去马尔可夫化"><a href="#去马尔可夫化" class="headerlink" title="去马尔可夫化"></a>去马尔可夫化</h2><script type="math/tex; mode=display">
P(x_{t-1} | x_t) = \frac{P(x_t | x_{t-1})P(x_{t-1})}{P(x_t)}</script><p>在 DDPM 不好求，加入 $x_0$</p>
<script type="math/tex; mode=display">
P(x_{t-1} | x_t, x_0) = \frac{P(x_t | x_{t-1}, x_0)P(x_{t-1} | x_0)}{P(x_t | x_0)} \overset{\text{DDPM}}{\Longrightarrow} \frac{P(x_t | x_{t-1})P(x_{t-1} | x_0)}{P(x_t|x_0)}</script><script type="math/tex; mode=display">
\overset{\text{DDIM}}{\Longrightarrow} P(x_s | x_k, x_0) = \frac{\text{①}P(x_k | x_s, x_0) \text{②}P(x_s | x_0)}{\text{③}P(x_k | x_0)} \quad (1)</script><ul>
<li>① ② ③ 这三部分共同决定了 $P(x_s | x_k, x_0)$ 的解。</li>
<li>3 个部分未知的越多，那么说明 $P(x_s | x_k, x_0)$ 的约束越少，解越多。</li>
</ul>
<p>但 DDPM 训练时，要满足 $P(x_t | x_0) = \sqrt{\alpha_t} x_0 + \sqrt{1 - \alpha_t} \epsilon$。若不重新训练，那么这个假设仍然要保留，于是 ② ③ 是知道的。</p>
<p>在 DDPM 中，① 并没有被用到，则 (1) 式的解可以设为：</p>
<script type="math/tex; mode=display">
P(x_s | x_k, x_0) \sim \mathcal{N}(kx_0 + mx_k, \sigma^2 I)</script><p>于是</p>
<script type="math/tex; mode=display">
\begin{align*}
x_s &= (kx_0 + mx_k) + \sigma \epsilon \\
&= kx_0 + m(\sqrt{\bar\alpha_k}x_0 + \sqrt{1 - \bar\alpha_k}\epsilon') + \sigma \epsilon \\
&= (k + m\sqrt{\bar\alpha_k})x_0 + (m\sqrt{1 - \bar\alpha_k}\epsilon' + \sigma \epsilon) \\
&= (k + m\sqrt{\bar\alpha_k})x_0 + \sqrt{m^2(1 - \bar\alpha_k) + \sigma^2}\epsilon \quad \mathcal{N}(0, m^2(1 - \bar\alpha_k))\\
&= \sqrt{\bar\alpha_s}x_0 + \sqrt{1 - \bar\alpha_s}\epsilon
\end{align*}</script><p><strong>待定系数法求出 $m$ 和 $k$</strong></p>
<script type="math/tex; mode=display">
m = \frac{\sqrt{1 - \bar\alpha_s + \sigma^2}}{\sqrt{1 - \bar\alpha_k}}, \quad k = \sqrt{\bar\alpha_s} - \frac{\sqrt{1 - \bar\alpha_s - \sigma^2}}{\sqrt{1 - \bar\alpha_k}}\sqrt{\bar\alpha_k}</script><p>于是有</p>
<script type="math/tex; mode=display">
\mu = mx_k + kx_0 = \sqrt{\bar\alpha_s}x_0 + \frac{\sqrt{1 - \bar\alpha_s - \sigma^2}}{\sqrt{1 - \bar\alpha_k}}(x_k - \sqrt{\bar\alpha_k}x_0)</script><p>以及 $\sigma = \sigma$</p>
<p>相比于 DDPM 的 $s = k - 1$，DDIM 的 $s \leq k - 1$，于是可以跳步了。 </p>
<p><img  src="9ec363832d7635f22955f09c2c27248.jpg"  ><span class="image-caption">去马尔可夫化</span></p>
<h2 id="参数选择-1"><a href="#参数选择-1" class="headerlink" title="参数选择"></a>参数选择</h2><ul>
<li>$\sigma = 0$ 时为决定性采样方式，无随机性。</li>
<li>$\sigma = \sqrt{\frac{1 - \overline{\alpha}_t}{1 - \overline{\alpha}_t} \beta_t}$ 时对应 DDPM 。</li>
</ul>
<script type="math/tex; mode=display">
P(x_s | x_k, x_0) \sim \mathcal{N}(\sqrt{\alpha_s}x_0 + \sqrt{1 - \alpha_s - \sigma^2} \frac{x_k - \sqrt{\alpha_k}x_0}{\sqrt{1 - \alpha_k}}, \sigma^2 I)</script><p>当 $\sigma$ 取 $\sqrt{\frac{1 - \overline{\alpha}_t}{1 - \overline{\alpha}_t} \beta_t}$ 时，原式为 $\mathcal{N}(\frac{1}{\sqrt{\alpha_t}}(x_t - \frac{\beta_t}{\sqrt{1 - \overline{\alpha}_t}}\epsilon), \beta_t)$ 。</p>
<h3 id="DDIM-实验设置"><a href="#DDIM-实验设置" class="headerlink" title="DDIM 实验设置"></a><strong>DDIM 实验设置</strong></h3><p><img  src="image-20250403231724755.png"   style="zoom:80%;" /><span class="image-caption">DDIM 实验结果</span></p>
<p>$\sigma = \eta \sqrt{\frac{1 - \overline{\alpha}_t}{1 - \overline{\alpha}_t} \beta_t}$</p>
<ul>
<li>$\eta = 1$ 时即为可跳步的 DDPM 。</li>
<li>$\eta = 0$ 时，为确定性 DDIM 。</li>
<li>$\eta$ 越小，效果越好（FID 越低）。</li>
</ul>
<p><strong>总结</strong>：</p>
<ul>
<li>DDPM：高斯去噪过程，推理慢。</li>
<li>DDIM：去噪，推理快，待定系数法求 $m$，$k$ 。以及 $\sigma = 0$ 时，对于每一个 $x_t$ 有唯一确定的 $x$ 。 </li>
</ul>
<p><img  src="34ff3b1a482f1445724b9f1683bbd71.jpg"  ><span class="image-caption">参数选择</span></p>
<h1 id="Classifier-Guidance-Classifier-Free-Guidance"><a href="#Classifier-Guidance-Classifier-Free-Guidance" class="headerlink" title="Classifier Guidance / Classifier - Free Guidance"></a>Classifier Guidance / Classifier - Free Guidance</h1><h2 id="内容说明"><a href="#内容说明" class="headerlink" title="内容说明"></a>内容说明</h2><ol>
<li><strong>①</strong>：在分类器引导（CG）之前，FID不如 GAN（生成对抗网络）。  </li>
<li><strong>②</strong>：扩散模型（diffusion model）原本控制性不佳，条件生成可提升 FID。CG 本质是一种采样方法，可利用训练好的 DDPM（Denoising Diffusion Probabilistic Model）。  </li>
</ol>
<h3 id="公式推导"><a href="#公式推导" class="headerlink" title="公式推导"></a>公式推导</h3><ul>
<li>$\hat{q}(x_{t-1} | x_t, y) = \frac{ \hat{q}(x_{t-1} | x_t) \hat{q}(y | x_{t-1}, x_t) }{ \hat{q}(y | x_t) }$<br>注：$\hat{q}(y | x_t)$ 为常数，与 $x_{t-1}$ 无关。 </li>
<li>定义：<br>$\hat{q}(x_t | x_{t-1}, y) := q(x_t | x_{t-1})$，$\hat{q}(x_0) := q(x_0)$，无需重新训练，与 DDPM 相同。 </li>
<li>$\nabla \hat{q}(x_{t-1} | x_0, y) = \prod_{t’=1}^{t} \hat{q}(x_{t’} | x_{t’-1}, y)$（链式展开）。 </li>
</ul>
<h3 id="详细推导步骤"><a href="#详细推导步骤" class="headerlink" title="详细推导步骤"></a>详细推导步骤</h3><ol>
<li><strong>①</strong>：<br>$\hat{q}(x_{t-1} | x_t) = \frac{ \hat{q}(x_t | x_{t-1}) \hat{q}(x_{t-1}) }{ \hat{q}(x_t) }$（贝叶斯公式应用）。</li>
<li><strong>②</strong>： <ul>
<li>推导 $\hat{q}(x_t | x_{t-1})$：<br>$\hat{q}(x_t | x_{t-1}) = \int_y \hat{q}(x_t, y | x_{t-1}) dy$<br>$= \int_y \hat{q}(x_t | y, x_{t-1}) \hat{q}(y | x_{t-1}) dy$<br>$= \int_y q(x_t | x_{t-1}) \hat{q}(y | x_{t-1}) dy$（因 $\hat{q}(x_t | y, x_{t-1}) = q(x_t | x_{t-1})$）<br>$= q(x_t | x_{t-1}) \int_y \hat{q}(y | x_{t-1}) dy$<br>$= q(x_t | x_{t-1})$（因 $\int_y \hat{q}(y | x_{t-1}) dy = 1$）。</li>
<li>推导 $\hat{q}(x_t)$：<br>$\hat{q}(x_t) = \int_{x_{0:t-1}} \hat{q}(x_{0:t}) d x_{0:t-1}$<br>$= \int_{x_{0:t-1}} \hat{q}(x_0) \hat{q}(x_{1:t} | x_0) d x_{0:t-1}$。<br>进一步展开 $\hat{q}(x_{1:t} | x_0)$：<br>$\hat{q}(x_{1:t} | x_0) = \int_y \hat{q}(x_{1:t}, y | x_0) dy$<br>$= \int_y \hat{q}(x_{1:t} | y, x_0) \hat{q}(y | x_0) dy$<br>$= \int_y \hat{q}(y | x_0) \prod_{t’=1}^t \hat{q}(x_{t’} | x_{t’-1}, y) dy$<br>$= \int_y \hat{q}(y | x_0) \prod_{t’=1}^t q(x_{t’} | x_{t’-1}) dy$（因 $\hat{q}(x_{t’} | x_{t’-1}, y) = q(x_{t’} | x_{t’-1})$）<br>$= \int_y \hat{q}(y | x_0) q(x_{1:t} | x_0) dy$。</li>
</ul>
</li>
</ol>
<p>$\hat{q}(x_t)$ 的推导</p>
<script type="math/tex; mode=display">
\hat{q}(x_t) = \int_{x_{0:t-1}} q(x_0) q(x_{1:t} | x_0) dx_{0:t-1} = \int_{x_{0:t-1}} q(x_{0:t}) dx_{0:t-1} = q(x_t)</script><p><strong>说明</strong>：通过积分运算，证明了 $\hat{q}(x_t)$ 与 $q(x_t)$ 相等，体现了分布在积分变换下的不变性。</p>
<p>$q(y | x_t, x_{t-1})$ 的化简</p>
<script type="math/tex; mode=display">
q(y | x_t, x_{t-1}) = \frac{ \hat{q}(x_0 | y, x_{t-1}) \hat{q}(y | x_{t-1}) }{ \hat{q}(x_0 | x_{t-1}) } = \frac{ \hat{q}(x_0 | y, x_{t-1}) }{ \hat{q}(x_0 | x_{t-1}) } \hat{q}(y | x_{t-1})</script><p>进一步化简：</p>
<script type="math/tex; mode=display">
= q(x_t | x_{t-1}) \frac{ \hat{q}(y | x_{t-1}) }{ \hat{q}(x_0 | x_{t-1}) }</script><p><strong>说明</strong>：利用条件概率公式进行变形，结合已知分布关系化简，展示条件概率与其他分布的关联。</p>
<p>$\hat{q}(x_{t-1} | x_t, y)$ 的表达式</p>
<script type="math/tex; mode=display">
\hat{q}(x_{t-1} | x_t, y) = \frac{ q(x_{t-1} | x_t) \hat{q}(y | x_{t-1}) }{... }</script><p><strong>标注说明</strong>：红色标注强调与 <strong>DDPM 模型</strong> 的联系，表明该公式在 DDPM 框架下的应用特性。</p>
<h3 id="采样方式与近似推导"><a href="#采样方式与近似推导" class="headerlink" title="采样方式与近似推导"></a>采样方式与近似推导</h3><ul>
<li><strong>采样式</strong>：$x_t = \mu + \epsilon$，其中 $\epsilon$ 很小。</li>
<li><strong>对数概率展开</strong>：<script type="math/tex; mode=display">
\log P_\phi(y | x_t) \approx \text{泰勒展开近似}</script>进一步对 $\log P_\phi(x_{t-1} | x_t, y)$ 推导：<script type="math/tex; mode=display">
\log P_\phi(x_{t-1} | x_t, y) = -\frac{1}{2}(x_t - \mu)^T \Sigma^{-1}(x_t - \mu) + (x_t - \mu) \nabla + C</script>通过变形：<script type="math/tex; mode=display">
= -\frac{1}{2}(x_t - \mu - \Sigma \nabla)^T \Sigma^{-1}(x_t - \mu - \Sigma \nabla) + C'</script>近似为正态分布：<script type="math/tex; mode=display">
\sim N(\mu + \Sigma \nabla, \Sigma^2) \implies x_t = \mu + \Sigma \nabla + \Sigma \epsilon</script><strong>说明</strong>：描述了采样的形式，通过对数概率的展开和变形，推导得出近似正态分布的结果，展示了从概率表达式到采样公式的推导过程。</li>
</ul>
<p>通过上述推导，展现了分类器引导（CG）相关的采样方法与公式逻辑，基于 DDPM 框架且无需重新训练，体现了其在扩散模型中的应用特性。 </p>
<p><img  src="5d117d10d332d1d5f747467b99e798f.jpg"  ><span class="image-caption">5d117d10d332d1d5f747467b99e798f</span></p>
<p><img  src="c63015d4464ad72db9343356fc0a66c.jpg"  ><span class="image-caption">c63015d4464ad72db9343356fc0a66c</span></p>
<h1 id="SDE（随机微分方程）下的-Diffusion-Model"><a href="#SDE（随机微分方程）下的-Diffusion-Model" class="headerlink" title="SDE（随机微分方程）下的 Diffusion Model"></a>SDE（随机微分方程）下的 Diffusion Model</h1><h2 id="随机过程基础"><a href="#随机过程基础" class="headerlink" title="随机过程基础"></a>随机过程基础</h2><ul>
<li>布朗运动增量：$W(t+\Delta t) - W(t) \sim N(0, \Delta t)$，当 $\Delta t \to 0$ 时，可表示为微分形式 $dW = \sqrt{dt} \epsilon$，其中 $\epsilon \sim N(0,1)$，即 $dW \sim N(0, dt)$。</li>
<li>Itô 过程（扩散过程）：$dX = f(x,t)dt + g(t)dW$，描述了系统状态 $X$ 随时间 $t$ 的变化，包含确定性项 $f(x,t)dt$ 和随机性项 $g(t)dW$。</li>
</ul>
<h2 id="模型与-SDE-关联的优势"><a href="#模型与-SDE-关联的优势" class="headerlink" title="模型与 SDE 关联的优势"></a>模型与 SDE 关联的优势</h2><ol>
<li><strong>数学方法紧密结合</strong>：SDE 提供了丰富的数学工具，便于分析和求解。</li>
<li><strong>刻画分布转换</strong>：能更好地描述数据分布（data distribution）与先验分布（prior distribution）之间的相互转换，因为扩散（加噪）的逆向过程同样是扩散过程。</li>
</ol>
<h2 id="逆向过程公式"><a href="#逆向过程公式" class="headerlink" title="逆向过程公式"></a>逆向过程公式</h2><ul>
<li>一般形式：$dX = [f(x,t) - g^2(t) \nabla_x \log p_t(x)]dt + g_t d\tilde{W}$。</li>
<li>在 DDPM 中：<ul>
<li>正向扩散：$dX = -\frac{1}{2} \beta(t) X(t)dt + \sqrt{\beta(t)} dW$。</li>
<li>逆向过程：$dX = [-\frac{1}{2} \beta(t) X(t) - \beta(t) S_\theta(t)]dt + \sqrt{\beta(t)} dW$，其中 $S_\theta(t) = \nabla_{x_t} \log P(x_t | x_0) = -\frac{x_t - \mu_t}{\sigma^2}$（通过对 $P(x_t | x_0)$ 求梯度得到）。</li>
<li>由 $x_t = \sqrt{\alpha_t} x_0 + \sqrt{1 - \alpha_t} \epsilon$ 代入化简可得 $S_\theta(t) = -\frac{\epsilon}{\sqrt{1 - \alpha_t}}$。</li>
</ul>
</li>
</ul>
<h2 id="数值解法（欧拉方法）"><a href="#数值解法（欧拉方法）" class="headerlink" title="数值解法（欧拉方法）"></a>数值解法（欧拉方法）</h2><ul>
<li><strong>SDE 欧拉近似</strong>：$X(t+\Delta t) = X(t) + f(x,t)\Delta t + g(t)\Delta W$。</li>
<li><strong>ODE 欧拉法</strong>：$\frac{dx}{dt} = a(X(t))$，则 $X(t+\Delta t) = X(t) + a(X(t))\Delta t$。</li>
<li>逆向扩散采样（reverse diffusion sampler）的数值估计：<ul>
<li>$x_{i+1} = x_i + f(x,t) + g(t)\epsilon$（简化形式，$\Delta t$ 融入 $f$ 和 $g$）。</li>
<li>进一步推导 $x_i$ 的表达式：$x_i = x_{i+1} + \frac{1}{2} \beta_{i+1} x_{i+1} + \beta_{i+1} S_\theta + \sqrt{\beta_{i+1}} \epsilon$，通过近似（如泰勒公式 $(1+x)^\alpha \approx 1+\alpha x$）化简，最终得出 DDPM 是欧拉方法的特例，如 $(2 - \sqrt{1 - \beta(t)})x_{t’} + \beta’(t) S_\theta + \sqrt{\beta’(t)} \epsilon$。</li>
</ul>
</li>
</ul>
<p>以上内容系统阐述了 SDE 框架下扩散模型的数学基础、逆向过程及数值解法，体现了 SDE 在扩散模型分析中的重要作用。 </p>
<p><img  src="b012c3a57ba9325b7e6acd7fd6703d0.jpg"  ><span class="image-caption">b012c3a57ba9325b7e6acd7fd6703d0</span></p>
]]></content>
      <tags>
        <tag>data structure, algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>小样本微调研究综述</title>
    <url>/uncategorized/Few-Shot-Fine-Tuning/</url>
    <content><![CDATA[<h1 id="小样本微调领域（2022年至今）的代表性论文"><a href="#小样本微调领域（2022年至今）的代表性论文" class="headerlink" title="小样本微调领域（2022年至今）的代表性论文"></a>小样本微调领域（2022年至今）的代表性论文</h1><p>以下列出几篇2022年以来在计算机视觉领域关于<strong>小样本微调（Few-Shot Fine-Tuning）</strong>的代表性论文。每篇包括论文标题、作者与年份、主要贡献摘要、公开源码情况以及发表的会议或期刊，涵盖图像分类、目标检测、语义分割等方向：</p>
<ol>
<li><p><strong>论文标题</strong>: <em>Pushing the Limits of Simple Pipelines for Few-Shot Learning: External Data and Fine-Tuning Make a Difference</em><br><strong>作者与年份</strong>: Shell Xu Hu，Da Li，Jan Stühmer，Minyoung Kim，Timothy M. Hospedales，2022年<br><strong>摘要</strong>: 提出利用一个简单但有效的三阶段小样本学习流程，包括<strong>在外部数据上预训练</strong>、<strong>小样本任务的元训练</strong>以及<strong>特定任务的微调</strong>。作者探讨了：(1) 外部数据预训练如何提升小样本学习性能，(2) 利用最新Transformer架构的效果，以及 (3) 如何充分利用微调步骤。实验表明，一个基于Transformer的简单管线在Mini-ImageNet、CIFAR-FS、CDFSL和Meta-Dataset等标准小样本分类基准上取得了惊人的性能。这一结果强调了<strong>将大规模外部数据与微调相结合</strong>的策略对提升小样本学习效果的重要作用。<strong>代码</strong>: 提供了开源代码 (GitHub: <code>hushell/pmf_cvpr22</code>)。<br><strong>发表</strong>: CVPR 2022</p>
</li>
<li><p><strong>论文标题</strong>: <em>Conditional Prompt Learning for Vision-Language Models</em><br><strong>作者与年份</strong>: Kaiyang Zhou，Jingkang Yang，Chen Change Loy，Ziwei Liu，2022年<br><strong>摘要</strong>: 针对CLIP等大型视觉-语言模型的小样本适应问题，作者提出了<strong>条件上下文优化（CoCoOp）</strong>方法。此前的方法CoOp通过学习一组固定的可调节提示（prompt）在小样本下取得了显著效果，但存在<strong>对训练类别过拟合、无法泛化到新类别</strong>的问题。CoCoOp通过引入一个轻量级网络为每张图像<strong>动态生成输入相关的提示向量</strong>，使提示根据图像自适应变化，从而减轻了类别移位带来的影响。实验表明，相比静态提示，<strong>动态提示的CoCoOp在未见类别上的泛化性能明显优于CoOp</strong>，在跨数据集迁移和域泛化上也更出色。<strong>代码</strong>: 提供了开源代码 (GitHub: <code>KaiyangZhou/CoOp</code>)。<br><strong>发表</strong>: CVPR 2022</p>
</li>
<li><p><strong>论文标题</strong>: <em>Singular Value Fine-tuning: Few-shot Segmentation requires Few-parameters Fine-tuning</em><br><strong>作者与年份</strong>: Yanpeng Sun，Qiang Chen，Xiangyu He 等，2022年<br><strong>摘要</strong>: 提出了一种针对小样本语义分割的<strong>奇异值微调（SVF）</strong>方法。传统方法为了避免过拟合通常<strong>冻结预训练骨干网络</strong>，仅在其上添加复杂的特征融合或度量模块。作者重新思考这一范式，发现<strong>只微调骨干网络的一小部分参数</strong>同样可以避免过拟合并提升对新类别的泛化性能。具体而言，SVF将预训练卷积权重用奇异值分解拆解为三个矩阵，只<strong>训练中间的奇异值参数</strong>，冻结奇异向量（两侧矩阵）。这种策略在<strong>保持预训练语义信息</strong>的同时<strong>调整特征以适应新类</strong>。在Pascal-5<sup>i</sup>和COCO-20<sup>i</sup>的1-shot和5-shot分割基准上，SVF取得了<strong>当前最佳性能</strong>，显著优于仅冻结骨干的方案。这证明了微调骨干的一小部分参数可以在小样本分割中取得更好效果。<strong>代码</strong>: 提供了官方开源实现 (GitHub: <code>zechao-li/SVF-pytorch</code>)。<br><strong>发表</strong>: NeurIPS 2022</p>
</li>
<li><p><strong>论文标题</strong>: <em>Few-Shot Recognition via Stage-Wise Augmented Finetuning</em><br><strong>作者与年份</strong>: Tian Liu，Huixin Zhang，Shubham Parashar，Shu Kong，2024年<br><strong>摘要</strong>: 提出了一种<strong>分阶段增强微调 (SWAT)</strong> 方法来提升小样本图像识别性能。作者将<strong>检索增强学习 (retrieval-augmented learning, RAL)</strong>引入Few-Shot场景：首先从外部大型图像-文本数据中检索与新类别相关的样本用于辅助训练。研究发现：直接在大量检索数据上微调预训练的视觉-语言模型（VLM，如CLIP）由于数据分布不均衡和域偏差，效果几乎不超越零样本基线；仅使用少量标注样本微调反而已经<strong>大幅超越现有方法</strong>；而<strong>将检索数据与标注的少样本混合微调</strong>可以进一步提升性能。为此，SWAT方法分两阶段进行微调：<strong>第一阶段</strong>在“检索数据+少量标注数据”混合集上端到端微调整个模型，<strong>第二阶段</strong>仅使用少量标注数据重新训练分类头，以缓解不均衡和域差异。这种分阶段策略使模型性能显著提升，在标准few-shot识别基准上<strong>比此前最佳方法准确率高出约10%</strong>。<strong>代码</strong>: 提供了开源代码 (GitHub: <code>tian1327/SWAT</code>)。<br><strong>发表</strong>: CVPR 2024</p>
</li>
<li><p><strong>论文标题</strong>: <em>Strong Baselines for Parameter-Efficient Few-Shot Fine-Tuning</em><br><strong>作者与年份</strong>: Samyadeep Basu，Shell Xu Hu，Daniela Massiceti，Soheil Feizi，2024年<br><strong>摘要</strong>: 本文对<strong>参数高效的小样本微调</strong>方法进行了大规模系统的实证分析，在Meta-Dataset和ORBIT等大型few-shot基准上进行了超过1800次对比实验。研究的主要发现有两点：(i) <strong>仅微调LayerNorm层参数（LN-Tune）</strong>在few-shot图像分类中是一个<strong>极其强大的基线</strong>，无论主干ViT是经自监督还是监督预训练获得。(ii) 对于自监督预训练的ViT模型，<strong>仅为每个注意力矩阵引入可学习的缩放参数（AttnScale）并配合一个轻量的残差适配器模块（DRA）</strong>即可达到当前最优性能，同时参数规模比微调全部参数减少约9倍。这些结果为few-shot微调提供了强基线，并<strong>呼吁重新思考现有参数高效微调方法的设计</strong>。<em>（注：作者在文中未公布官方源码）</em>。<br><strong>发表</strong>: AAAI 2024</p>
</li>
<li><p><strong>论文标题</strong>: <em>Few-Shot Object Detection with Foundation Models</em><br><strong>作者与年份</strong>: Guangxing Han，Ser-Nam Lim，2024年<br><strong>摘要</strong>: 探索了利用<strong>基础模型</strong>解决Few-Shot目标检测（FSOD）的新方法。作者使用两个大型预训练模型：其一是<strong>视觉基础模型DINOv2</strong>，作为<strong>冻结的特征提取骨干</strong>，提供强大的通用视觉特征；其二是<strong>大语言模型 (LLM)</strong>，用于对检测提议区域进行<strong>上下文化的小样本分类</strong>。具体而言，采用Transformer架构（如Deformable DETR）生成<strong>类感知的候选区域</strong>，然后构造文本提示将所有候选及类别标签嵌入到LLM中，通过LLM强大的<strong>上下文推理</strong>能力，对每个候选进行分类。这种方式利用提议之间以及提议与类别之间的关系，大幅提升了少样本情况下的检测准确率。模型在PASCAL VOC和MS COCO等<strong>Few-Shot检测基准</strong>上取得了当前最先进的性能。<em>（注：源码暂未公开，但模型基于Facebook开放的Detrex检测代码库实现）</em>。<br><strong>发表</strong>: CVPR 2024</p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Docker 镜像都失效之后的处理</title>
    <url>/linux/docker-proxy/</url>
    <content><![CDATA[<h1 id="Docker-镜像都失效之后的处理"><a href="#Docker-镜像都失效之后的处理" class="headerlink" title="Docker 镜像都失效之后的处理"></a>Docker 镜像都失效之后的处理</h1><p>在 2024 年，所有的 docker 镜像已经失效了，想要继续进行 <code>docker pull</code> 就需要自建镜像，或者使用代理进行 pull，这里记录一下具体的处理方式。</p>
<h2 id="Docker-system-代理"><a href="#Docker-system-代理" class="headerlink" title="Docker system 代理"></a>Docker system 代理</h2><p><strong>在执行docker pull时，是由守护进程dockerd来执行。因此，代理需要配在dockerd的环境中。而这个环境，则是受systemd所管控，因此实际是systemd的配置。</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">mkdir</span> -p /etc/systemd/system/docker.service.d<br>sudo <span class="hljs-built_in">touch</span> /etc/systemd/system/docker.service.d/proxy.conf<br></code></pre></td></tr></table></figure>
<p>在这个proxy.conf文件（可以是任意*.conf的形式）中，添加以下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[Service]<br>Environment=<span class="hljs-string">&quot;HTTP_PROXY=http://127.0.0.1:10800&quot;</span><br>Environment=<span class="hljs-string">&quot;HTTPS_PROXY=http://127.0.0.1:10800&quot;</span><br>Environment=<span class="hljs-string">&quot;NO_PROXY=localhost,127.0.0.1,.example.com&quot;</span><br></code></pre></td></tr></table></figure>
<p>注意，当使用 k8s 的时候，容器的 <code>http://127.0.0.1:10800</code> 是不可访问的，需要设置为 <code>docker0</code> 的 ip 地址。</p>
<h2 id="Docker-容器内部代理"><a href="#Docker-容器内部代理" class="headerlink" title="Docker 容器内部代理"></a>Docker 容器内部代理</h2><p><strong>在容器运行阶段，如果需要代理上网，则需要配置 ~/.docker/config.json。以下配置，只在Docker 17.07及以上版本生效。</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">&#123;<br> <span class="hljs-string">&quot;proxies&quot;</span>:<br> &#123;<br>   <span class="hljs-string">&quot;default&quot;</span>:<br>   &#123;<br>     <span class="hljs-string">&quot;httpProxy&quot;</span>: <span class="hljs-string">&quot;http://127.0.0.1:10800&quot;</span>,<br>     <span class="hljs-string">&quot;httpsProxy&quot;</span>: <span class="hljs-string">&quot;http://127.0.0.1:10800&quot;</span>,<br>     <span class="hljs-string">&quot;noProxy&quot;</span>: <span class="hljs-string">&quot;localhost,127.0.0.1,.example.com&quot;</span><br>   &#125;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="SSH-端口转发"><a href="#SSH-端口转发" class="headerlink" title="SSH 端口转发"></a>SSH 端口转发</h1><h2 id="本地访问远程端口"><a href="#本地访问远程端口" class="headerlink" title="本地访问远程端口"></a>本地访问远程端口</h2><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">ssh -L [LOCAL_IP:]LOCAL_PORT:DESTINATION:DESTINATION_PORT [USER@]SSH_SERVER<br></code></pre></td></tr></table></figure>
<h2 id="远程访问本地的端口"><a href="#远程访问本地的端口" class="headerlink" title="远程访问本地的端口"></a>远程访问本地的端口</h2><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">ssh -R [REMOTE:]REMOTE_PORT:DESTINATION:DESTINATION_PORT [USER@]SSH_SERVER<br></code></pre></td></tr></table></figure>
<p>比如要把本机的代理 <code>http://127.0.0.1:10800</code> 端口共享到远程的所有 IP 上的 10801 端口，则是</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">ssh -R 0.0.0.0:10801:127.0.0.1:10800 username@ip -p port<br></code></pre></td></tr></table></figure>
<p>注意，默认是无法在远程服务器上监听 <code>0.0.0.0</code> 的，如果想要监听，需要修改 <code>/etc/ssh/sshd_config</code> 中的 <code>GatewayPorts yes</code> 才行。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>幸福论</title>
    <url>/uncategorized/happiness/</url>
    <content><![CDATA[<h1 id="Async-的一些想法"><a href="#Async-的一些想法" class="headerlink" title="Async 的一些想法"></a>Async 的一些想法</h1><p>文明其精神，野蛮其体魄。</p>
<p>在这篇文章里记录关于幸福的观点和思考。</p>
<p>幸福不是一件容易的事：她很难求之于自身，但要想在别处得到则不可能。——尚福尔</p>
<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在这里介绍的内容主要从平常、实用的角度出发，所以保留了与此角度相关的谬误。</p>
<p>一些补充书籍：卡丹奴斯本的《论逆境》。</p>
<p>一般来说，各个时代的智者们，都说过同样的话语，而愚人们——也就是各个时代数不胜数的大多数人——也做着恰恰相反的同一样事情。</p>
<h1 id="一些基本的划分"><a href="#一些基本的划分" class="headerlink" title="一些基本的划分"></a>一些基本的划分</h1><p>亚里士多德把人生能够得到的好处分为三类——外在之物、人的灵魂和人的身体。</p>
<p>在这里，叔本华认为决定凡人命运的根本差别在于三项内容：</p>
<ul>
<li>人的<strong>自身</strong>，最广泛意义上属于人的个性的东西。健康、力量、外貌、气质、道德品格、精神智力、潜在发展。</li>
<li>人所拥有的<strong>身外之物</strong>，财产和其他占有物。</li>
<li>人向其他人所<strong>显示的样子</strong>，人在其他人眼中的样子，亦即人们对他的看法。他人的看法包括：<ul>
<li>名誉</li>
<li>地位</li>
<li>名声</li>
</ul>
</li>
</ul>
<p>其中，最重要的是第一项，也就是<strong>人的自身</strong>，是因为第一项的差别是由大自然决定的，而后两项只是出自人为的划分。</p>
<p>对于一个人的幸福，甚至对于他的整个存在方式，最重要的就是他自身的内在素质，内在素质直接决定了这个人能否得到内心的幸福，因为内心的快乐和痛苦首先是人的感情、意欲和思想的产物。</p>
<p>第二项和第三项属于自身以外的所有事物，他们想要起作用的方式是间接的，通过影响我们的自身感情来实现的。因此，同一样外在的事物和同一样的境遇，对于我们每个人的影响都不尽相同；即使是生活在同一个环境中的每一个人，都生活在不同的世界中。因为与一个人直接相关的是一个人对事物的看法、他的情感和意欲活动。</p>
]]></content>
      <tags>
        <tag>book</tag>
      </tags>
  </entry>
  <entry>
    <title>Internlm-01-书生·浦语大模型全链路开源体系</title>
    <url>/internlm/internlm-01/</url>
    <content><![CDATA[<h1 id="书生·浦语大模型全链路开源体系"><a href="#书生·浦语大模型全链路开源体系" class="headerlink" title="书生·浦语大模型全链路开源体系"></a>书生·浦语大模型全链路开源体系</h1><h2 id="大模型概述"><a href="#大模型概述" class="headerlink" title="大模型概述"></a>大模型概述</h2><h3 id="大模型成为了热门关键词"><a href="#大模型成为了热门关键词" class="headerlink" title="大模型成为了热门关键词"></a>大模型成为了热门关键词</h3><p>大模型成为发展通用人工智能的重要途经，图中展示了大模型的热度增长和 OpenAI GPT 系列的迭代过程。</p>
<p><img  src="image.png"  ><span class="image-caption">大模型成为热门关键词</span></p>
<h3 id="大模型成为了发展通用人工智能的重要途径"><a href="#大模型成为了发展通用人工智能的重要途径" class="headerlink" title="大模型成为了发展通用人工智能的重要途径"></a>大模型成为了发展通用人工智能的重要途径</h3><p><img  src="image-20240104194412083.png"  ><span class="image-caption">大模型成为了发展通用人工智能的重要途径</span></p>
<h2 id="书生·浦语大模型"><a href="#书生·浦语大模型" class="headerlink" title="书生·浦语大模型"></a>书生·浦语大模型</h2><h3 id="开源历程"><a href="#开源历程" class="headerlink" title="开源历程"></a>开源历程</h3><p><img  src="image-20240104194442165.png"  ><span class="image-caption">书生·浦语的开源历程</span></p>
<p>书生·浦语大模型从 6.7 开始，开源了 InternLM-7B、InternLM-Chat-7B、Lagent、InternLM-20B 等项目。</p>
<h3 id="系列模型"><a href="#系列模型" class="headerlink" title="系列模型"></a>系列模型</h3><p><img  src="image-20240104194623711.png"  ><span class="image-caption">书生·浦语系列模型</span></p>
<h3 id="性能比较"><a href="#性能比较" class="headerlink" title="性能比较"></a>性能比较</h3><p><img  src="image-20240104194715248.png"  ><span class="image-caption">性能比较</span></p>
<p>可以看出，书生·浦语 20B 模型全面领先相近量级的开源模型，并且达到了和 Llama2-70B 相近的水平。</p>
<h2 id="书生·浦语全链条开源体系"><a href="#书生·浦语全链条开源体系" class="headerlink" title="书生·浦语全链条开源体系"></a>书生·浦语全链条开源体系</h2><h3 id="体系概述"><a href="#体系概述" class="headerlink" title="体系概述"></a>体系概述</h3><p><strong><a href="https://github.com/orgs/InternLM/repositories?type=all">InternLM (github.com)</a></strong></p>
<p><img  src="image-20240104194911061.png"  ><span class="image-caption">体系概述</span></p>
<h3 id="数据开源"><a href="#数据开源" class="headerlink" title="数据开源"></a>数据开源</h3><p><img  src="image-20240104194948553.png"  ><span class="image-caption">数据开源</span></p>
<h3 id="预训练开源"><a href="#预训练开源" class="headerlink" title="预训练开源"></a>预训练开源</h3><p><img  src="image-20240104195041865.png"  ><span class="image-caption">预训练开源</span></p>
<h3 id="微调开源"><a href="#微调开源" class="headerlink" title="微调开源"></a>微调开源</h3><p><strong><a href="https://github.com/InternLM/xtuner">InternLM/xtuner: A toolkit for efficiently fine-tuning LLM (InternLM, Llama, Baichuan, Qwen, ChatGLM) (github.com)</a></strong></p>
<p><img  src="image-20240104195250624.png"  ><span class="image-caption">微调开源</span></p>
<h3 id="评测开源"><a href="#评测开源" class="headerlink" title="评测开源"></a>评测开源</h3><p><strong><a href="https://github.com/open-compass/OpenCompass/">open-compass/opencompass: OpenCompass is an LLM evaluation platform, supporting a wide range of models (LLaMA, LLaMa2, ChatGLM2, ChatGPT, Claude, etc) over 50+ datasets. (github.com)</a></strong></p>
<p><img  src="image-20240104195322676.png"  ><span class="image-caption">评测开源-题目类型</span></p>
<p><img  src="image-20240104195342281.png"  ><span class="image-caption">评测开源-OpenCompass</span></p>
<p><img  src="image-20240104195354357.png"  ><span class="image-caption">OpenCompass 架构</span></p>
<h3 id="部署开源"><a href="#部署开源" class="headerlink" title="部署开源"></a>部署开源</h3><p><strong><a href="https://github.com/InternLM/lmdeploy">InternLM/lmdeploy: LMDeploy is a toolkit for compressing, deploying, and serving LLMs. (github.com)</a></strong></p>
<p><img  src="image-20240104195614821.png"  ><span class="image-caption">部署开源</span></p>
<h3 id="智能体开源"><a href="#智能体开源" class="headerlink" title="智能体开源"></a>智能体开源</h3><p><strong><a href="https://github.com/InternLM/lagent">InternLM/lagent: A lightweight framework for building LLM-based agents (github.com)</a></strong></p>
<p><img  src="image-20240104195658280.png"  ><span class="image-caption">智能体开源</span></p>
<h3 id="智能体工具箱"><a href="#智能体工具箱" class="headerlink" title="智能体工具箱"></a>智能体工具箱</h3><p><strong><a href="https://github.com/InternLM/agentlego">InternLM/agentlego: Enhance LLM agents with versatile tool APIs (github.com)</a></strong></p>
<p><img  src="image-20240104195750076.png"  ><span class="image-caption">智能体工具箱</span></p>
<h2 id="从模型到应用"><a href="#从模型到应用" class="headerlink" title="从模型到应用"></a>从模型到应用</h2><p><img  src="image-20240104194844022.png"  ><span class="image-caption">如何从模型到应用</span></p>
]]></content>
      <categories>
        <category>internlm</category>
      </categories>
  </entry>
  <entry>
    <title>Internlm-02-浦语大模型趣味 Demo</title>
    <url>/internlm/internlm-02/</url>
    <content><![CDATA[<h1 id="浦语大模型趣味-Demo"><a href="#浦语大模型趣味-Demo" class="headerlink" title="浦语大模型趣味 Demo"></a>浦语大模型趣味 Demo</h1><h2 id="大模型及-InternLM-模型简介"><a href="#大模型及-InternLM-模型简介" class="headerlink" title="大模型及 InternLM 模型简介"></a>大模型及 InternLM 模型简介</h2><h3 id="什么是大模型"><a href="#什么是大模型" class="headerlink" title="什么是大模型"></a>什么是大模型</h3><p>大模型是指在机器学习或人工智能领域中具有巨大参数数量和强大计算能力的模型。它们利用海量数据进行训练，拥有数十亿甚至数千亿个参数。大模型的崛起归因于数据量增长、计算能力提升和算法优化等因素。它们在自然语言处理、计算机视觉、语音识别等任务中展现出惊人性能，常采用深度神经网络结构，如Transformer、BERT、GPT等。</p>
<p>这些模型的优势在于能够捕捉和理解数据中更复杂、抽象的特征和关系。通过大规模参数的学习，它们可以提高泛化能力，在未经大量特定领域数据训练的情况下表现优异。然而，它们也面临着挑战，如巨大计算资源需求、高昂训练成本、对大规模数据的依赖和可解释性等问题。因此，在性能、成本和道德等方面需要权衡考量其应用和发展。</p>
<h2 id="InternLM-模型全链条开源"><a href="#InternLM-模型全链条开源" class="headerlink" title="InternLM 模型全链条开源"></a>InternLM 模型全链条开源</h2><p>包括了 InternLM、Lagent、浦语·灵笔等项目，详情可见：<br><a href="https://github.com/InternLM/InternLM">InternLM</a><br><a href="https://enableasync.github.io/internlm/internlm-01/">EnableAsync 的博客</a></p>
<h2 id="InternLM-Chat-7B-智能对话-Demo"><a href="#InternLM-Chat-7B-智能对话-Demo" class="headerlink" title="InternLM-Chat-7B 智能对话 Demo"></a>InternLM-Chat-7B 智能对话 Demo</h2><p>InternLM已经开源了一个70亿参数的基础模型和一个专为实际场景量身定制的聊天模型。该模型具有以下特点：</p>
<ul>
<li>它利用数万亿高质量标记进行训练，建立了强大的知识库。</li>
<li>支持8,000的上下文窗口长度，能够处理更长的输入序列并具备更强的推理能力。</li>
<li>为用户提供了多功能工具集，灵活构建自己的工作流程。</li>
</ul>
<h3 id="demo-代码"><a href="#demo-代码" class="headerlink" title="demo 代码"></a>demo 代码</h3><p>最简单的 <code>cli_demo</code> 代码如下：<br><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer, AutoModelForCausalLM<br><br><br>model_name_or_path = <span class="hljs-string">&quot;/root/model/Shanghai_AI_Laboratory/internlm-chat-7b&quot;</span><br><br>tokenizer = AutoTokenizer.from_pretrained(model_name_or_path, trust_remote_code=<span class="hljs-literal">True</span>)<br>model = AutoModelForCausalLM.from_pretrained(model_name_or_path, trust_remote_code=<span class="hljs-literal">True</span>, torch_dtype=torch.bfloat16, device_map=<span class="hljs-string">&#x27;auto&#x27;</span>)<br>model = model.<span class="hljs-built_in">eval</span>()<br><br>system_prompt = <span class="hljs-string">&quot;&quot;&quot;You are an AI assistant whose name is InternLM (书生·浦语).</span><br><span class="hljs-string">- InternLM (书生·浦语) is a conversational language model that is developed by Shanghai AI Laboratory (上海人工智能实验室). It is designed to be helpful, honest, and harmless.</span><br><span class="hljs-string">- InternLM (书生·浦语) can understand and communicate fluently in the language chosen by the user such as English and 中文.</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br>messages = [(system_prompt, <span class="hljs-string">&#x27;&#x27;</span>)]<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;=============Welcome to InternLM chatbot, type &#x27;exit&#x27; to exit.=============&quot;</span>)<br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    input_text = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;User  &gt;&gt;&gt; &quot;</span>)<br>    input_text.replace(<span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>)<br>    <span class="hljs-keyword">if</span> input_text == <span class="hljs-string">&quot;exit&quot;</span>:<br>        <span class="hljs-keyword">break</span><br>    response, history = model.chat(tokenizer, input_text, history=messages)<br>    messages.append((input_text, response))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;robot &gt;&gt;&gt; <span class="hljs-subst">&#123;response&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure></p>
<h3 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h3><p>运行效果如下图所示：</p>
<p><img  src="story.png"  ><span class="image-caption">InternLM生成小故事</span></p>
<h2 id="Lagent-智能体工具调用-Demo"><a href="#Lagent-智能体工具调用-Demo" class="headerlink" title="Lagent 智能体工具调用 Demo"></a>Lagent 智能体工具调用 Demo</h2><p>Lagent 是一个轻量级、开源的基于大语言模型的智能体（agent）框架，支持用户快速地将一个大语言模型转变为多种类型的智能体，并提供了一些典型工具为大语言模型赋能。通过 Lagent 框架可以更好的发挥 InternLM 的全部性能。</p>
<h3 id="demo-代码-1"><a href="#demo-代码-1" class="headerlink" title="demo 代码"></a>demo 代码</h3><p>教程中提供了一个 web demo 如下：<br><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> copy<br><span class="hljs-keyword">import</span> os<br><br><span class="hljs-keyword">import</span> streamlit <span class="hljs-keyword">as</span> st<br><span class="hljs-keyword">from</span> streamlit.logger <span class="hljs-keyword">import</span> get_logger<br><br><span class="hljs-keyword">from</span> lagent.actions <span class="hljs-keyword">import</span> ActionExecutor, GoogleSearch, PythonInterpreter<br><span class="hljs-keyword">from</span> lagent.agents.react <span class="hljs-keyword">import</span> ReAct<br><span class="hljs-keyword">from</span> lagent.llms <span class="hljs-keyword">import</span> GPTAPI<br><span class="hljs-keyword">from</span> lagent.llms.huggingface <span class="hljs-keyword">import</span> HFTransformerCasualLM<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SessionState</span>:<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">init_state</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;Initialize session state variables.&quot;&quot;&quot;</span><br>        st.session_state[<span class="hljs-string">&#x27;assistant&#x27;</span>] = []<br>        st.session_state[<span class="hljs-string">&#x27;user&#x27;</span>] = []<br><br>        <span class="hljs-comment">#action_list = [PythonInterpreter(), GoogleSearch()]</span><br>        action_list = [PythonInterpreter()]<br>        st.session_state[<span class="hljs-string">&#x27;plugin_map&#x27;</span>] = &#123;<br>            action.name: action<br>            <span class="hljs-keyword">for</span> action <span class="hljs-keyword">in</span> action_list<br>        &#125;<br>        st.session_state[<span class="hljs-string">&#x27;model_map&#x27;</span>] = &#123;&#125;<br>        st.session_state[<span class="hljs-string">&#x27;model_selected&#x27;</span>] = <span class="hljs-literal">None</span><br>        st.session_state[<span class="hljs-string">&#x27;plugin_actions&#x27;</span>] = <span class="hljs-built_in">set</span>()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">clear_state</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;Clear the existing session state.&quot;&quot;&quot;</span><br>        st.session_state[<span class="hljs-string">&#x27;assistant&#x27;</span>] = []<br>        st.session_state[<span class="hljs-string">&#x27;user&#x27;</span>] = []<br>        st.session_state[<span class="hljs-string">&#x27;model_selected&#x27;</span>] = <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;chatbot&#x27;</span> <span class="hljs-keyword">in</span> st.session_state:<br>            st.session_state[<span class="hljs-string">&#x27;chatbot&#x27;</span>]._session_history = []<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">StreamlitUI</span>:<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, session_state: SessionState</span>):<br>        self.init_streamlit()<br>        self.session_state = session_state<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">init_streamlit</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;Initialize Streamlit&#x27;s UI settings.&quot;&quot;&quot;</span><br>        st.set_page_config(<br>            layout=<span class="hljs-string">&#x27;wide&#x27;</span>,<br>            page_title=<span class="hljs-string">&#x27;lagent-web&#x27;</span>,<br>            page_icon=<span class="hljs-string">&#x27;./docs/imgs/lagent_icon.png&#x27;</span>)<br>        <span class="hljs-comment"># st.header(&#x27;:robot_face: :blue[Lagent] Web Demo &#x27;, divider=&#x27;rainbow&#x27;)</span><br>        st.sidebar.title(<span class="hljs-string">&#x27;模型控制&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">setup_sidebar</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;Setup the sidebar for model and plugin selection.&quot;&quot;&quot;</span><br>        model_name = st.sidebar.selectbox(<br>            <span class="hljs-string">&#x27;模型选择：&#x27;</span>, options=[<span class="hljs-string">&#x27;gpt-3.5-turbo&#x27;</span>,<span class="hljs-string">&#x27;internlm&#x27;</span>])<br>        <span class="hljs-keyword">if</span> model_name != st.session_state[<span class="hljs-string">&#x27;model_selected&#x27;</span>]:<br>            model = self.init_model(model_name)<br>            self.session_state.clear_state()<br>            st.session_state[<span class="hljs-string">&#x27;model_selected&#x27;</span>] = model_name<br>            <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;chatbot&#x27;</span> <span class="hljs-keyword">in</span> st.session_state:<br>                <span class="hljs-keyword">del</span> st.session_state[<span class="hljs-string">&#x27;chatbot&#x27;</span>]<br>        <span class="hljs-keyword">else</span>:<br>            model = st.session_state[<span class="hljs-string">&#x27;model_map&#x27;</span>][model_name]<br><br>        plugin_name = st.sidebar.multiselect(<br>            <span class="hljs-string">&#x27;插件选择&#x27;</span>,<br>            options=<span class="hljs-built_in">list</span>(st.session_state[<span class="hljs-string">&#x27;plugin_map&#x27;</span>].keys()),<br>            default=[<span class="hljs-built_in">list</span>(st.session_state[<span class="hljs-string">&#x27;plugin_map&#x27;</span>].keys())[<span class="hljs-number">0</span>]],<br>        )<br><br>        plugin_action = [<br>            st.session_state[<span class="hljs-string">&#x27;plugin_map&#x27;</span>][name] <span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> plugin_name<br>        ]<br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;chatbot&#x27;</span> <span class="hljs-keyword">in</span> st.session_state:<br>            st.session_state[<span class="hljs-string">&#x27;chatbot&#x27;</span>]._action_executor = ActionExecutor(<br>                actions=plugin_action)<br>        <span class="hljs-keyword">if</span> st.sidebar.button(<span class="hljs-string">&#x27;清空对话&#x27;</span>, key=<span class="hljs-string">&#x27;clear&#x27;</span>):<br>            self.session_state.clear_state()<br>        uploaded_file = st.sidebar.file_uploader(<br>            <span class="hljs-string">&#x27;上传文件&#x27;</span>, <span class="hljs-built_in">type</span>=[<span class="hljs-string">&#x27;png&#x27;</span>, <span class="hljs-string">&#x27;jpg&#x27;</span>, <span class="hljs-string">&#x27;jpeg&#x27;</span>, <span class="hljs-string">&#x27;mp4&#x27;</span>, <span class="hljs-string">&#x27;mp3&#x27;</span>, <span class="hljs-string">&#x27;wav&#x27;</span>])<br>        <span class="hljs-keyword">return</span> model_name, model, plugin_action, uploaded_file<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">init_model</span>(<span class="hljs-params">self, option</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;Initialize the model based on the selected option.&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> option <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> st.session_state[<span class="hljs-string">&#x27;model_map&#x27;</span>]:<br>            <span class="hljs-keyword">if</span> option.startswith(<span class="hljs-string">&#x27;gpt&#x27;</span>):<br>                st.session_state[<span class="hljs-string">&#x27;model_map&#x27;</span>][option] = GPTAPI(<br>                    model_type=option)<br>            <span class="hljs-keyword">else</span>:<br>                st.session_state[<span class="hljs-string">&#x27;model_map&#x27;</span>][option] = HFTransformerCasualLM(<br>                    <span class="hljs-string">&#x27;/root/model/Shanghai_AI_Laboratory/internlm-chat-7b&#x27;</span>)<br>        <span class="hljs-keyword">return</span> st.session_state[<span class="hljs-string">&#x27;model_map&#x27;</span>][option]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">initialize_chatbot</span>(<span class="hljs-params">self, model, plugin_action</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;Initialize the chatbot with the given model and plugin actions.&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> ReAct(<br>            llm=model, action_executor=ActionExecutor(actions=plugin_action))<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">render_user</span>(<span class="hljs-params">self, prompt: <span class="hljs-built_in">str</span></span>):<br>        <span class="hljs-keyword">with</span> st.chat_message(<span class="hljs-string">&#x27;user&#x27;</span>):<br>            st.markdown(prompt)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">render_assistant</span>(<span class="hljs-params">self, agent_return</span>):<br>        <span class="hljs-keyword">with</span> st.chat_message(<span class="hljs-string">&#x27;assistant&#x27;</span>):<br>            <span class="hljs-keyword">for</span> action <span class="hljs-keyword">in</span> agent_return.actions:<br>                <span class="hljs-keyword">if</span> (action):<br>                    self.render_action(action)<br>            st.markdown(agent_return.response)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">render_action</span>(<span class="hljs-params">self, action</span>):<br>        <span class="hljs-keyword">with</span> st.expander(action.<span class="hljs-built_in">type</span>, expanded=<span class="hljs-literal">True</span>):<br>            st.markdown(<br>                <span class="hljs-string">&quot;&lt;p style=&#x27;text-align: left;display:flex;&#x27;&gt; &lt;span style=&#x27;font-size:14px;font-weight:600;width:70px;text-align-last: justify;&#x27;&gt;插    件&lt;/span&gt;&lt;span style=&#x27;width:14px;text-align:left;display:block;&#x27;&gt;:&lt;/span&gt;&lt;span style=&#x27;flex:1;&#x27;&gt;&quot;</span>  <span class="hljs-comment"># noqa E501</span><br>                + action.<span class="hljs-built_in">type</span> + <span class="hljs-string">&#x27;&lt;/span&gt;&lt;/p&gt;&#x27;</span>,<br>                unsafe_allow_html=<span class="hljs-literal">True</span>)<br>            st.markdown(<br>                <span class="hljs-string">&quot;&lt;p style=&#x27;text-align: left;display:flex;&#x27;&gt; &lt;span style=&#x27;font-size:14px;font-weight:600;width:70px;text-align-last: justify;&#x27;&gt;思考步骤&lt;/span&gt;&lt;span style=&#x27;width:14px;text-align:left;display:block;&#x27;&gt;:&lt;/span&gt;&lt;span style=&#x27;flex:1;&#x27;&gt;&quot;</span>  <span class="hljs-comment"># noqa E501</span><br>                + action.thought + <span class="hljs-string">&#x27;&lt;/span&gt;&lt;/p&gt;&#x27;</span>,<br>                unsafe_allow_html=<span class="hljs-literal">True</span>)<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isinstance</span>(action.args, <span class="hljs-built_in">dict</span>) <span class="hljs-keyword">and</span> <span class="hljs-string">&#x27;text&#x27;</span> <span class="hljs-keyword">in</span> action.args):<br>                st.markdown(<br>                    <span class="hljs-string">&quot;&lt;p style=&#x27;text-align: left;display:flex;&#x27;&gt;&lt;span style=&#x27;font-size:14px;font-weight:600;width:70px;text-align-last: justify;&#x27;&gt; 执行内容&lt;/span&gt;&lt;span style=&#x27;width:14px;text-align:left;display:block;&#x27;&gt;:&lt;/span&gt;&lt;/p&gt;&quot;</span>,  <span class="hljs-comment"># noqa E501</span><br>                    unsafe_allow_html=<span class="hljs-literal">True</span>)<br>                st.markdown(action.args[<span class="hljs-string">&#x27;text&#x27;</span>])<br>            self.render_action_results(action)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">render_action_results</span>(<span class="hljs-params">self, action</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;Render the results of action, including text, images, videos, and</span><br><span class="hljs-string">        audios.&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isinstance</span>(action.result, <span class="hljs-built_in">dict</span>)):<br>            st.markdown(<br>                <span class="hljs-string">&quot;&lt;p style=&#x27;text-align: left;display:flex;&#x27;&gt;&lt;span style=&#x27;font-size:14px;font-weight:600;width:70px;text-align-last: justify;&#x27;&gt; 执行结果&lt;/span&gt;&lt;span style=&#x27;width:14px;text-align:left;display:block;&#x27;&gt;:&lt;/span&gt;&lt;/p&gt;&quot;</span>,  <span class="hljs-comment"># noqa E501</span><br>                unsafe_allow_html=<span class="hljs-literal">True</span>)<br>            <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;text&#x27;</span> <span class="hljs-keyword">in</span> action.result:<br>                st.markdown(<br>                    <span class="hljs-string">&quot;&lt;p style=&#x27;text-align: left;&#x27;&gt;&quot;</span> + action.result[<span class="hljs-string">&#x27;text&#x27;</span>] +<br>                    <span class="hljs-string">&#x27;&lt;/p&gt;&#x27;</span>,<br>                    unsafe_allow_html=<span class="hljs-literal">True</span>)<br>            <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;image&#x27;</span> <span class="hljs-keyword">in</span> action.result:<br>                image_path = action.result[<span class="hljs-string">&#x27;image&#x27;</span>]<br>                image_data = <span class="hljs-built_in">open</span>(image_path, <span class="hljs-string">&#x27;rb&#x27;</span>).read()<br>                st.image(image_data, caption=<span class="hljs-string">&#x27;Generated Image&#x27;</span>)<br>            <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;video&#x27;</span> <span class="hljs-keyword">in</span> action.result:<br>                video_data = action.result[<span class="hljs-string">&#x27;video&#x27;</span>]<br>                video_data = <span class="hljs-built_in">open</span>(video_data, <span class="hljs-string">&#x27;rb&#x27;</span>).read()<br>                st.video(video_data)<br>            <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;audio&#x27;</span> <span class="hljs-keyword">in</span> action.result:<br>                audio_data = action.result[<span class="hljs-string">&#x27;audio&#x27;</span>]<br>                audio_data = <span class="hljs-built_in">open</span>(audio_data, <span class="hljs-string">&#x27;rb&#x27;</span>).read()<br>                st.audio(audio_data)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    logger = get_logger(__name__)<br>    <span class="hljs-comment"># Initialize Streamlit UI and setup sidebar</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;ui&#x27;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> st.session_state:<br>        session_state = SessionState()<br>        session_state.init_state()<br>        st.session_state[<span class="hljs-string">&#x27;ui&#x27;</span>] = StreamlitUI(session_state)<br><br>    <span class="hljs-keyword">else</span>:<br>        st.set_page_config(<br>            layout=<span class="hljs-string">&#x27;wide&#x27;</span>,<br>            page_title=<span class="hljs-string">&#x27;lagent-web&#x27;</span>,<br>            page_icon=<span class="hljs-string">&#x27;./docs/imgs/lagent_icon.png&#x27;</span>)<br>        <span class="hljs-comment"># st.header(&#x27;:robot_face: :blue[Lagent] Web Demo &#x27;, divider=&#x27;rainbow&#x27;)</span><br>    model_name, model, plugin_action, uploaded_file = st.session_state[<br>        <span class="hljs-string">&#x27;ui&#x27;</span>].setup_sidebar()<br><br>    <span class="hljs-comment"># Initialize chatbot if it is not already initialized</span><br>    <span class="hljs-comment"># or if the model has changed</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;chatbot&#x27;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> st.session_state <span class="hljs-keyword">or</span> model != st.session_state[<br>            <span class="hljs-string">&#x27;chatbot&#x27;</span>]._llm:<br>        st.session_state[<span class="hljs-string">&#x27;chatbot&#x27;</span>] = st.session_state[<br>            <span class="hljs-string">&#x27;ui&#x27;</span>].initialize_chatbot(model, plugin_action)<br><br>    <span class="hljs-keyword">for</span> prompt, agent_return <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(st.session_state[<span class="hljs-string">&#x27;user&#x27;</span>],<br>                                    st.session_state[<span class="hljs-string">&#x27;assistant&#x27;</span>]):<br>        st.session_state[<span class="hljs-string">&#x27;ui&#x27;</span>].render_user(prompt)<br>        st.session_state[<span class="hljs-string">&#x27;ui&#x27;</span>].render_assistant(agent_return)<br>    <span class="hljs-comment"># User input form at the bottom (this part will be at the bottom)</span><br>    <span class="hljs-comment"># with st.form(key=&#x27;my_form&#x27;, clear_on_submit=True):</span><br><br>    <span class="hljs-keyword">if</span> user_input := st.chat_input(<span class="hljs-string">&#x27;&#x27;</span>):<br>        st.session_state[<span class="hljs-string">&#x27;ui&#x27;</span>].render_user(user_input)<br>        st.session_state[<span class="hljs-string">&#x27;user&#x27;</span>].append(user_input)<br>        <span class="hljs-comment"># Add file uploader to sidebar</span><br>        <span class="hljs-keyword">if</span> uploaded_file:<br>            file_bytes = uploaded_file.read()<br>            file_type = uploaded_file.<span class="hljs-built_in">type</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;image&#x27;</span> <span class="hljs-keyword">in</span> file_type:<br>                st.image(file_bytes, caption=<span class="hljs-string">&#x27;Uploaded Image&#x27;</span>)<br>            <span class="hljs-keyword">elif</span> <span class="hljs-string">&#x27;video&#x27;</span> <span class="hljs-keyword">in</span> file_type:<br>                st.video(file_bytes, caption=<span class="hljs-string">&#x27;Uploaded Video&#x27;</span>)<br>            <span class="hljs-keyword">elif</span> <span class="hljs-string">&#x27;audio&#x27;</span> <span class="hljs-keyword">in</span> file_type:<br>                st.audio(file_bytes, caption=<span class="hljs-string">&#x27;Uploaded Audio&#x27;</span>)<br>            <span class="hljs-comment"># Save the file to a temporary location and get the path</span><br>            file_path = os.path.join(root_dir, uploaded_file.name)<br>            <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file_path, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> tmpfile:<br>                tmpfile.write(file_bytes)<br>            st.write(<span class="hljs-string">f&#x27;File saved at: <span class="hljs-subst">&#123;file_path&#125;</span>&#x27;</span>)<br>            user_input = <span class="hljs-string">&#x27;我上传了一个图像，路径为: &#123;file_path&#125;. &#123;user_input&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<br>                file_path=file_path, user_input=user_input)<br>        agent_return = st.session_state[<span class="hljs-string">&#x27;chatbot&#x27;</span>].chat(user_input)<br>        st.session_state[<span class="hljs-string">&#x27;assistant&#x27;</span>].append(copy.deepcopy(agent_return))<br>        logger.info(agent_return.inner_steps)<br>        st.session_state[<span class="hljs-string">&#x27;ui&#x27;</span>].render_assistant(agent_return)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    root_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))<br>    root_dir = os.path.join(root_dir, <span class="hljs-string">&#x27;tmp_dir&#x27;</span>)<br>    os.makedirs(root_dir, exist_ok=<span class="hljs-literal">True</span>)<br>    main()<br><br></code></pre></td></tr></table></figure></p>
<h3 id="demo-运行方式"><a href="#demo-运行方式" class="headerlink" title="demo 运行方式"></a>demo 运行方式</h3><p>demo 运行方式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">streamlit run /root/code/lagent/examples/react_web_demo.py --server.address 127.0.0.1 --server.port 6006<br></code></pre></td></tr></table></figure>
<h3 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h3><p><img  src="lagent-1.png"  ><span class="image-caption">Lagent效果展示1</span></p>
<p><img  src="lagent-2.png"  ><span class="image-caption">Lagent效果展示2</span></p>
<p><img  src="lagent-3.png"  ><span class="image-caption">Lagent效果展示3</span></p>
<p><img  src="lagent-4.png"  ><span class="image-caption">Lagent效果展示4</span></p>
<p>可以看到，lagent能够通过 python 代码解决一些数学问题，而对于很困难的数学问题，解决起来会出现一些问题。</p>
<h2 id="浦语·灵笔图文理解创作-Demo"><a href="#浦语·灵笔图文理解创作-Demo" class="headerlink" title="浦语·灵笔图文理解创作 Demo"></a>浦语·灵笔图文理解创作 Demo</h2><p><strong>浦语·灵笔</strong>是基于<a href="https://github.com/InternLM/InternLM/tree/main">书生·浦语</a>大语言模型研发的视觉-语言大模型，提供出色的图文理解和创作能力，具有多项优势：</p>
<ul>
<li><p><strong>图文交错创作</strong>: 浦语·灵笔可以为用户打造图文并貌的专属文章。生成的文章文采斐然，图文相得益彰，提供沉浸式的阅读体验。这一能力由以下步骤实现：</p>
<ol>
<li><strong>理解用户指令，创作符合要求的长文章</strong>。</li>
<li><strong>智能分析文章，自动规划插图的理想位置，确定图像内容需求。</strong></li>
<li><strong>多层次智能筛选，从图库中锁定最完美的图片。</strong></li>
</ol>
</li>
<li><p><strong>基于丰富多模态知识的图文理解</strong>: 浦语·灵笔设计了高效的训练策略，为模型注入海量的多模态概念和知识数据，赋予其强大的图文理解和对话能力。</p>
</li>
<li><strong>杰出性能</strong>: 浦语·灵笔在多项视觉语言大模型的主流评测上均取得了最佳性能，包括<a href="https://github.com/BradyFU/Awesome-Multimodal-Large-Language-Models/tree/Evaluation">MME Benchmark</a> (英文评测), <a href="https://opencompass.org.cn/leaderboard-multimodal">MMBench</a> (英文评测), <a href="https://huggingface.co/spaces/AILab-CVC/SEED-Bench_Leaderboard">Seed-Bench</a> (英文评测), <a href="https://opencompass.org.cn/leaderboard-multimodal">CCBench</a>(中文评测), <a href="https://opencompass.org.cn/leaderboard-multimodal">MMBench-CN</a> (中文评测)。<h3 id="demo-代码-2"><a href="#demo-代码-2" class="headerlink" title="demo 代码"></a>demo 代码</h3></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /root/code<br>git <span class="hljs-built_in">clone</span> https://gitee.com/internlm/InternLM-XComposer.git<br><span class="hljs-built_in">cd</span> /root/code/InternLM-XComposer<br>git checkout 3e8c79051a1356b9c388a6447867355c0634932d  <span class="hljs-comment"># 最好保证和教程的 commit 版本一致</span><br></code></pre></td></tr></table></figure>
<h3 id="demo-运行方式-1"><a href="#demo-运行方式-1" class="headerlink" title="demo 运行方式"></a>demo 运行方式</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /root/code/InternLM-XComposer<br>python examples/web_demo.py  \<br>    --folder /root/model/Shanghai_AI_Laboratory/internlm-xcomposer-7b \<br>    --num_gpus 1 \<br>    --port 6006<br></code></pre></td></tr></table></figure>
<h3 id="效果展示-1"><a href="#效果展示-1" class="headerlink" title="效果展示"></a>效果展示</h3><p><img  src="灵笔-1.png"  ><span class="image-caption">浦语·灵笔效果展示1</span></p>
<p><img  src="灵笔-2.png"  ><span class="image-caption">浦语·灵笔效果展示2</span></p>
<p><img  src="灵笔-3.png"  ><span class="image-caption">浦语·灵笔效果展示3</span></p>
<h2 id="huggingface-hub-下载文件"><a href="#huggingface-hub-下载文件" class="headerlink" title="huggingface_hub 下载文件"></a>huggingface_hub 下载文件</h2><p><img  src="huggingface_hub_download.png"  ><span class="image-caption">使用 huggingface_hub 库下载文件</span></p>
]]></content>
      <categories>
        <category>internlm</category>
      </categories>
  </entry>
  <entry>
    <title>Kind 的一些使用心得</title>
    <url>/uncategorized/kind/</url>
    <content><![CDATA[<h1 id="Kind-的一些使用心得"><a href="#Kind-的一些使用心得" class="headerlink" title="Kind 的一些使用心得"></a>Kind 的一些使用心得</h1><p>因为 Kind 启动相比于 Minikube 更快，而且支持多 Node，所以现在换成了 Kind，这里记录一些 Kind 的使用心得。</p>
<h2 id="1-Kind-安装"><a href="#1-Kind-安装" class="headerlink" title="1. Kind 安装"></a>1. Kind 安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">curl -Lo ./kind https://kind.sigs.k8s.io/dl/v0.11.1/kind-linux-amd64<br><span class="hljs-built_in">chmod</span> +x ./kind<br><span class="hljs-built_in">mv</span> ./kind /usr/bin/kind<br></code></pre></td></tr></table></figure>
<h2 id="2-使用-Kind-创建含有两个-Node-的-kubernetes-集群"><a href="#2-使用-Kind-创建含有两个-Node-的-kubernetes-集群" class="headerlink" title="2. 使用 Kind 创建含有两个 Node 的 kubernetes 集群"></a>2. 使用 Kind 创建含有两个 Node 的 kubernetes 集群</h2><h3 id="1-创建配置文件"><a href="#1-创建配置文件" class="headerlink" title="1. 创建配置文件"></a>1. 创建配置文件</h3><p>这里我创建了两个 Node，使用以下配置文件，并将其命名为 <code>kind.yaml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># a cluster with 1 control-plane nodes and 2 workers</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Cluster</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">kind.x-k8s.io/v1alpha4</span><br><span class="hljs-attr">nodes:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">role:</span> <span class="hljs-string">control-plane</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">role:</span> <span class="hljs-string">worker</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">role:</span> <span class="hljs-string">worker</span><br></code></pre></td></tr></table></figure>
<h3 id="2-创建集群"><a href="#2-创建集群" class="headerlink" title="2. 创建集群"></a>2. 创建集群</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 旧版</span><br>sudo kind create cluster --config kind.yaml<br><span class="hljs-comment"># 新版</span><br>kind create cluster --name higress --config=cluster.conf<br></code></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># cluster.conf</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Cluster</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">kind.x-k8s.io/v1alpha4</span><br><span class="hljs-comment"># networking:</span><br>  <span class="hljs-comment"># WARNING: It is _strongly_ recommended that you keep this the default</span><br>  <span class="hljs-comment"># (127.0.0.1) for security reasons. However it is possible to change this.</span><br>  <span class="hljs-comment"># apiServerAddress: &quot;0.0.0.0&quot;</span><br>  <span class="hljs-comment"># By default the API server listens on a random open port.</span><br>  <span class="hljs-comment"># You may choose a specific port but probably don&#x27;t need to in most cases.</span><br>  <span class="hljs-comment"># Using a random port makes it easier to spin up multiple clusters.</span><br>  <span class="hljs-comment"># apiServerPort: 6443</span><br><span class="hljs-attr">networking:</span><br>  <span class="hljs-attr">serviceSubnet:</span> <span class="hljs-string">&quot;10.96.0.0/12&quot;</span><br><span class="hljs-attr">nodes:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">role:</span> <span class="hljs-string">control-plane</span><br>  <span class="hljs-attr">kubeadmConfigPatches:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">|</span><br><span class="hljs-string">    kind: InitConfiguration</span><br><span class="hljs-string">    nodeRegistration:</span><br><span class="hljs-string">      kubeletExtraArgs:</span><br><span class="hljs-string">        node-labels: &quot;ingress-ready=true&quot;</span><br><span class="hljs-string"></span>  <span class="hljs-attr">extraPortMappings:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>    <span class="hljs-attr">hostPort:</span> <span class="hljs-number">80</span><br>    <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">443</span><br>    <span class="hljs-attr">hostPort:</span> <span class="hljs-number">443</span><br>    <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">role:</span> <span class="hljs-string">worker</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">role:</span> <span class="hljs-string">worker</span><br></code></pre></td></tr></table></figure>
<p>这里需要注意的点有：</p>
<ol>
<li>不要设置集群 name，在我本地，如果设置了 name 会导致 kubeconfig 无法导出。（现在已修复，可以设置）</li>
<li>要使用 sudo，在我本地，如果不使用 sudo 会导致无法创建集群，原因未知。（因为 docker 需要 sudo，配置 docker 不用 sudo 之后就可以了）</li>
<li>这里 build image 的时候，会把当前的 proxy 配置也记住，所以如果要修改 proxy 配置，要重新 build image。</li>
<li>在 create 的时候可能会因为代理导致 create 失败，需要在 <code>~/.docker/config.json</code> 设置 no_proxy，如下所示：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">&#123;<br> <span class="hljs-string">&quot;proxies&quot;</span>:<br> &#123;<br>   <span class="hljs-string">&quot;default&quot;</span>:<br>   &#123;<br>     <span class="hljs-string">&quot;httpProxy&quot;</span>: <span class="hljs-string">&quot;http://172.17.0.1:10800&quot;</span>,<br>     <span class="hljs-string">&quot;httpsProxy&quot;</span>: <span class="hljs-string">&quot;http://172.17.0.1:10800&quot;</span>,<br>     <span class="hljs-string">&quot;noProxy&quot;</span>: <span class="hljs-string">&quot;localhost,127.0.0.1,10.96.0.0/12,172.18.0.0/28,172.18.0.3,::1,higress-control-plane&quot;</span><br>   &#125;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>其中最重要的是 <code>higress-control-plan</code>，不过为了防止无法访问 ClusterIP，我也配置了 <code>10.96.0.0/12</code> 和 Docker 网段 <code>172.18.0.0/28</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">Creating cluster <span class="hljs-string">&quot;kind&quot;</span> ...<br> ✓ Ensuring node image (kindest/node:v1.21.1) 🖼<br> ✓ Preparing nodes 📦 📦 📦  <br> ✓ Writing configuration 📜 <br> ✓ Starting control-plane 🕹️ <br> ✓ Installing CNI 🔌 <br> ✓ Installing StorageClass 💾 <br> ✓ Joining worker nodes 🚜 <br>Set kubectl context to <span class="hljs-string">&quot;kind-kind&quot;</span><br>You can now use your cluster with:<br><br>kubectl cluster-info --context kind-kind<br></code></pre></td></tr></table></figure>
<p>如果出现以上信息表示创建成功，可以进行下一步。</p>
<h3 id="3-导出-kubeconfig"><a href="#3-导出-kubeconfig" class="headerlink" title="3. 导出 kubeconfig"></a>3. 导出 kubeconfig</h3><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">kind export kubeconfig<br></code></pre></td></tr></table></figure>
<p>如果不使用这一步，会导致使用 <code>kubectl</code> 的时候必须加上 <code>sudo</code>，否则无法连接到 kubernetes。</p>
<h2 id="3-安装-kubernetes-dashboard"><a href="#3-安装-kubernetes-dashboard" class="headerlink" title="3. 安装 kubernetes-dashboard"></a>3. 安装 kubernetes-dashboard</h2><h3 id="1-使用-helm-安装-dashboard"><a href="#1-使用-helm-安装-dashboard" class="headerlink" title="1. 使用 helm 安装 dashboard"></a>1. 使用 helm 安装 dashboard</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Add kubernetes-dashboard repository</span><br>helm repo add kubernetes-dashboard https://kubernetes.github.io/dashboard/<br>helm repo update<br><span class="hljs-comment"># Deploy a Helm Release named &quot;dashboard&quot; using the kubernetes-dashboard chart</span><br>helm install dashboard kubernetes-dashboard/kubernetes-dashboard<br></code></pre></td></tr></table></figure>
<h3 id="2-转发-dashboard-pod"><a href="#2-转发-dashboard-pod" class="headerlink" title="2. 转发 dashboard pod"></a>2. 转发 dashboard pod</h3><p>这一步的目的是在本地访问部署了 dashboard 的 pod</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> POD_NAME=$(kubectl get pods -n default -l <span class="hljs-string">&quot;app.kubernetes.io/name=kubernetes-dashboard,app.kubernetes.io/instance=dashboard&quot;</span> -o jsonpath=<span class="hljs-string">&quot;&#123;.items[0].metadata.name&#125;&quot;</span>)<br>  <span class="hljs-built_in">echo</span> https://127.0.0.1:8443/<br>  kubectl -n default port-forward <span class="hljs-variable">$POD_NAME</span> 8443:8443<br></code></pre></td></tr></table></figure>
<p>之后会提示</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">Forwarding from 127.0.0.1:8443 -&gt; 8443<br>Forwarding from [::1]:8443 -&gt; 8443<br></code></pre></td></tr></table></figure>
<p>说明转发成功，此时访问 <a href="https://127.0.0.1:8443/">https://127.0.0.1:8443/</a> ，注意是 https</p>
<h3 id="2-1-或者可以不转发使用-service-暴露服务"><a href="#2-1-或者可以不转发使用-service-暴露服务" class="headerlink" title="2.1 或者可以不转发使用 service 暴露服务"></a>2.1 或者可以不转发使用 service 暴露服务</h3><p>这里为了测试使用了 NodePort 方式暴露</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">kubectl expose deploy dashboard-kubernetes-dashboard --name dashboard-nodeport --port 8443 --target-port=8443 --<span class="hljs-built_in">type</span>=NodePort<br></code></pre></td></tr></table></figure>
<h3 id="2-2-新版的-dashboard-的转发"><a href="#2-2-新版的-dashboard-的转发" class="headerlink" title="2.2 新版的 dashboard 的转发"></a>2.2 新版的 dashboard 的转发</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">kubectl -n kubernetes-dashboard port-forward svc/kubernetes-dashboard-kong-proxy 8443:443<br></code></pre></td></tr></table></figure>
<p>当用户在安装了 kind 的电脑上访问 pods 中的服务时，是这样的</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><code class="hljs livescript">user -&gt; docker proxy<span class="hljs-function"><span class="hljs-params">(docker 监听的端口)</span> -&gt;</span> services<span class="hljs-function"><span class="hljs-params">(nodeport 等)</span> -&gt;</span> pod<br></code></pre></td></tr></table></figure>
<p>当用 kubectl 开启了转发时，访问的网络是</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">user</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">kubectl</span> port-forward -&gt;</span> pod<br></code></pre></td></tr></table></figure>
<p>在 kind 中，worker 的 ClusterIP 可以用 <code>docker inspect</code> 查看。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">➜  git:(master) ✗ k -n kubesphere-<span class="hljs-keyword">system</span> <span class="hljs-keyword">get</span> svc ks-console<br><span class="hljs-type">NAME</span>         <span class="hljs-keyword">TYPE</span>       <span class="hljs-keyword">CLUSTER</span>-IP      <span class="hljs-keyword">EXTERNAL</span>-IP   PORT(S)        AGE<br>ks-console   NodePort   <span class="hljs-number">10.99</span><span class="hljs-number">.226</span><span class="hljs-number">.191</span>   &lt;<span class="hljs-keyword">none</span>&gt;        <span class="hljs-number">80</span>:<span class="hljs-number">30880</span>/TCP   <span class="hljs-number">21</span>h<br><br>➜  git:(master) ✗ docker ps | grep kind<br>c46d6ca06e9f        kindest/node:v1<span class="hljs-number">.19</span><span class="hljs-number">.1</span>              &quot;/usr/local/bin/entr…&quot;   <span class="hljs-number">28</span> hours ago        Up <span class="hljs-number">28</span> hours         <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">53079</span>-&gt;<span class="hljs-number">6443</span>/tcp   kind-control-plane<br><br>➜  git:(master) ✗ docker inspect c46d6ca06e9f | grep -i ipadd<br>            &quot;SecondaryIPAddresses&quot;: <span class="hljs-keyword">null</span>,<br>            &quot;IPAddress&quot;: &quot;&quot;,<br>                    &quot;IPAddress&quot;: &quot;172.20.0.2&quot;,<br><br>➜  git:(master) ✗ curl -I <span class="hljs-number">172.20</span><span class="hljs-number">.0</span><span class="hljs-number">.2</span>:<span class="hljs-number">30880</span><br>HTTP/<span class="hljs-number">1.1</span> <span class="hljs-number">302</span> <span class="hljs-built_in">Found</span><br>Vary: Accept-<span class="hljs-keyword">Encoding</span><br><span class="hljs-keyword">Location</span>: /<span class="hljs-keyword">login</span><br>Content-<span class="hljs-keyword">Type</span>: <span class="hljs-type">text</span>/html; charset=utf<span class="hljs-number">-8</span><br>Content-Length: <span class="hljs-number">43</span><br><span class="hljs-type">Date</span>: Fri, <span class="hljs-number">19</span> Mar <span class="hljs-number">2021</span> <span class="hljs-number">07</span>:<span class="hljs-number">56</span>:<span class="hljs-number">34</span> GMT<br><span class="hljs-keyword">Connection</span>: keep-alive<br>Keep-Alive: timeout=<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure>
<h3 id="3-生成-token"><a href="#3-生成-token" class="headerlink" title="3. 生成 token"></a>3. 生成 token</h3><p>不出意外 dashboard 需要 token 来登录，使用以下步骤来生成 token：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">kubectl create serviceaccount dashboard -n default<br>kubectl create rolebinding def-ns-admin --clusterrole=admin --serviceaccount=default:def-ns-admin<br>kubectl create clusterrolebinding dashboard-cluster-admin --clusterrole=cluster-admin --serviceaccount=default:dashboard<br></code></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">kubectl describe sa dashboard<br>Name:                dashboard<br>Namespace:           default<br>Labels:              &lt;none&gt;<br>Annotations:         &lt;none&gt;<br>Image pull secrets:  &lt;none&gt;<br>Mountable secrets:   dashboard-token-vzzjn<br>Tokens:              dashboard-token-vzzjn<br>Events:              &lt;none&gt;<br></code></pre></td></tr></table></figure>
<p>这里可以看到 <code>dashboard-token-vzzjn</code> 就是我们需要的 token，使用以下命令显示具体内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">kubectl describe secret dashboard-token-vzzjn<br></code></pre></td></tr></table></figure>
<p>之后就可以将具体的 token 粘贴在 dashboard 中登录。</p>
<h3 id="3-1-新版的生成"><a href="#3-1-新版的生成" class="headerlink" title="3.1 新版的生成"></a>3.1 新版的生成</h3><p><a href="https://github.com/kubernetes/dashboard/blob/master/docs/user/access-control/creating-sample-user.md">https://github.com/kubernetes/dashboard/blob/master/docs/user/access-control/creating-sample-user.md</a></p>
<h2 id="其他内容"><a href="#其他内容" class="headerlink" title="其他内容"></a>其他内容</h2><h3 id="配置-docker-不用-sudo"><a href="#配置-docker-不用-sudo" class="headerlink" title="配置 docker 不用 sudo"></a>配置 docker 不用 sudo</h3><p>创建名为docker的组，如果之前已经有该组就会报错，可以忽略这个错误。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">sudo groupadd docker<br></code></pre></td></tr></table></figure>
<p>将当前用户加入组docker</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">sudo gpasswd -a <span class="hljs-variable">$&#123;USER&#125;</span> docker<br></code></pre></td></tr></table></figure>
<p>重启docker服务（生产环境请慎用）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">sudo systemctl restart docker<br></code></pre></td></tr></table></figure>
<p>添加访问和执行权限</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">chmod</span> a+rw /var/run/docker.sock<br></code></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>k8s, kind</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 多用户管理</title>
    <url>/uncategorized/linux-user/</url>
    <content><![CDATA[<h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><h4 id="1-1-什么是Linux用户管理？"><a href="#1-1-什么是Linux用户管理？" class="headerlink" title="1.1 什么是Linux用户管理？"></a>1.1 什么是Linux用户管理？</h4><p>Linux用户管理是指在Linux系统中管理用户账户的过程，包括创建、删除和设置用户属性等操作。</p>
<h4 id="1-2-为什么Linux用户管理重要？"><a href="#1-2-为什么Linux用户管理重要？" class="headerlink" title="1.2 为什么Linux用户管理重要？"></a>1.2 为什么Linux用户管理重要？</h4><p>Linux用户管理对于系统安全和资源管理非常重要。良好的用户管理可以确保只有授权的用户能够访问系统，并且可以限制其权限，减少潜在的风险和安全漏洞。</p>
<h3 id="2-用户账户创建和删除"><a href="#2-用户账户创建和删除" class="headerlink" title="2. 用户账户创建和删除"></a>2. 用户账户创建和删除</h3><h4 id="2-0-创建用户文件夹"><a href="#2-0-创建用户文件夹" class="headerlink" title="2.0 创建用户文件夹"></a>2.0 创建用户文件夹</h4><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> john<br></code></pre></td></tr></table></figure>
<h4 id="2-1-创建用户账户"><a href="#2-1-创建用户账户" class="headerlink" title="2.1 创建用户账户"></a>2.1 创建用户账户</h4><p>在Linux中，可以使用<code>useradd</code>命令创建用户账户。例如，要创建名为”john”的用户账户，可以运行以下命令：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">useradd john</span><br></code></pre></td></tr></table></figure>
<h4 id="2-2-删除用户账户"><a href="#2-2-删除用户账户" class="headerlink" title="2.2 删除用户账户"></a>2.2 删除用户账户</h4><p>要删除用户账户，可以使用<code>userdel</code>命令。例如，要删除名为”john”的用户账户，可以运行以下命令：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">userdel john</span><br></code></pre></td></tr></table></figure>
<h4 id="2-3-设置用户账户的属性"><a href="#2-3-设置用户账户的属性" class="headerlink" title="2.3 设置用户账户的属性"></a>2.3 设置用户账户的属性</h4><p>可以使用<code>usermod</code>命令来设置用户账户的属性，如用户主目录、登录Shell等。例如，要将用户”john”的主目录设置为”/home/john”，可以运行以下命令：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">usermod -d <span class="hljs-regexp">/home/</span>john john<br></code></pre></td></tr></table></figure>
<h3 id="3-用户登录和注销"><a href="#3-用户登录和注销" class="headerlink" title="3. 用户登录和注销"></a>3. 用户登录和注销</h3><h4 id="3-1-远程登录"><a href="#3-1-远程登录" class="headerlink" title="3.1 远程登录"></a>3.1 远程登录</h4><p>要通过SSH进行远程登录，可以使用<code>ssh</code>命令。例如，要从本地计算机登录到远程主机”example.com”，可以运行以下命令：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ssh</span> username<span class="hljs-variable">@example</span>.com<br></code></pre></td></tr></table></figure>
<h4 id="3-2-本地登录"><a href="#3-2-本地登录" class="headerlink" title="3.2 本地登录"></a>3.2 本地登录</h4><p>要在本地登录Linux系统，可以使用登录管理器（如GDM或LightDM）或文本模式登录。在登录界面上输入用户名和密码即可登录。</p>
<h4 id="3-3-强制用户注销"><a href="#3-3-强制用户注销" class="headerlink" title="3.3 强制用户注销"></a>3.3 强制用户注销</h4><p>如果需要强制注销用户，可以使用<code>pkill</code>命令。例如，要强制注销用户”john”，可以运行以下命令：</p>
<figure class="highlight cos"><table><tr><td class="code"><pre><code class="hljs cos">pkill -<span class="hljs-keyword">KILL</span> -u john<br></code></pre></td></tr></table></figure>
<h3 id="4-用户密码管理"><a href="#4-用户密码管理" class="headerlink" title="4. 用户密码管理"></a>4. 用户密码管理</h3><h4 id="4-1-密码策略"><a href="#4-1-密码策略" class="headerlink" title="4.1 密码策略"></a>4.1 密码策略</h4><p>为了保护用户账户安全，应采用合理的密码策略。可以通过修改<code>/etc/login.defs</code>文件来设置密码策略，如最小密码长度、密码过期时间等。</p>
<h4 id="4-2-修改用户密码"><a href="#4-2-修改用户密码" class="headerlink" title="4.2 修改用户密码"></a>4.2 修改用户密码</h4><p>要修改用户密码，可以使用<code>passwd</code>命令。例如，要修改用户”john”的密码，可以运行以下命令：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">passwd john</span><br></code></pre></td></tr></table></figure>
<h4 id="4-3-重置用户密码"><a href="#4-3-重置用户密码" class="headerlink" title="4.3 重置用户密码"></a>4.3 重置用户密码</h4><p>如果用户忘记密码或需要管理员重置密码，可以使用<code>passwd</code>命令。管理员可以用以下命令重置用户”john”的密码：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo passwd john</span><br></code></pre></td></tr></table></figure>
<h3 id="5-用户组管理"><a href="#5-用户组管理" class="headerlink" title="5. 用户组管理"></a>5. 用户组管理</h3><h4 id="5-1-什么是用户组？"><a href="#5-1-什么是用户组？" class="headerlink" title="5.1 什么是用户组？"></a>5.1 什么是用户组？</h4><p>用户组是将多个用户集合在一起管理的机制。用户组可以简化权限管理，并允许共享文件和目录访问权限。</p>
<h4 id="5-2-创建用户组"><a href="#5-2-创建用户组" class="headerlink" title="5.2 创建用户组"></a>5.2 创建用户组</h4><p>要创建用户组，可以使用<code>groupadd</code>命令。例如，要创建名为”developers”的用户组，可以运行以下命令：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">groupadd developers</span><br></code></pre></td></tr></table></figure>
<h4 id="5-3-将用户添加到用户组"><a href="#5-3-将用户添加到用户组" class="headerlink" title="5.3 将用户添加到用户组"></a>5.3 将用户添加到用户组</h4><p>要将用户添加到用户组，可以使用<code>usermod</code>命令。例如，要将用户”john”添加到用户组”developers”，可以运行以下命令：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">usermod -aG developers john</span><br></code></pre></td></tr></table></figure>
<h4 id="5-4-从用户组中移除用户"><a href="#5-4-从用户组中移除用户" class="headerlink" title="5.4 从用户组中移除用户"></a>5.4 从用户组中移除用户</h4><p>要从用户组中移除用户，可以使用<code>gpasswd</code>命令。例如，要将用户”john”从用户组”developers”中移除，可以运行以下命令：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">gpasswd -d john developers</span><br></code></pre></td></tr></table></figure>
<h3 id="6-权限和访问控制"><a href="#6-权限和访问控制" class="headerlink" title="6. 权限和访问控制"></a>6. 权限和访问控制</h3><h4 id="6-1-文件权限概述"><a href="#6-1-文件权限概述" class="headerlink" title="6.1 文件权限概述"></a>6.1 文件权限概述</h4><p>在Linux系统中，每个文件和目录都有一组权限，用于控制对其的访问。权限分为三个类别：所有者（文件的拥有者）、群组（文件所属的组）和其他人（除了所有者和群组之外的其他用户）。</p>
<h4 id="6-2-修改文件权限"><a href="#6-2-修改文件权限" class="headerlink" title="6.2 修改文件权限"></a>6.2 修改文件权限</h4><p>要修改文件的权限，可以使用<code>chmod</code>命令。权限可以用数字表示法（如<code>chmod 644 file.txt</code>）或符号表示法（如<code>chmod u+r file.txt</code>）来设置。</p>
<p>示例：</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> chmod <span class="hljs-number">644</span> <span class="hljs-keyword">file</span>.txt<br></code></pre></td></tr></table></figure>
<p>该命令将文件<code>file.txt</code>的权限设置为 <code>-rw-r--r--</code>，即文件所有者可读写，群组和其他人只可读取。</p>
<h4 id="6-3-设置特殊权限"><a href="#6-3-设置特殊权限" class="headerlink" title="6.3 设置特殊权限"></a>6.3 设置特殊权限</h4><p>除了基本的读取、写入和执行权限外，还有一些特殊权限：</p>
<ul>
<li>Setuid（SUID）：允许以文件所有者的权限运行可执行文件。</li>
<li>Setgid（SGID）：允许以文件所属组的权限运行可执行文件。</li>
<li>Sticky位：只有文件所有者才能删除或重命名该文件。</li>
</ul>
<p>可以使用<code>chmod</code>命令的符号表示法来设置特殊权限。</p>
<p>示例：</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> chmod +s <span class="hljs-keyword">file</span>.txt<br></code></pre></td></tr></table></figure>
<p>该命令将文件<code>file.txt</code>的Setuid权限位设置为开启。</p>
<h4 id="6-4-使用访问控制列表（ACL）"><a href="#6-4-使用访问控制列表（ACL）" class="headerlink" title="6.4 使用访问控制列表（ACL）"></a>6.4 使用访问控制列表（ACL）</h4><p>访问控制列表（Access Control Lists，ACL）是一种更灵活的权限控制机制。ACL允许向每个文件或目录添加多个用户或组，并为它们提供不同的权限。可以使用<code>setfacl</code>命令来设置和修改ACL。</p>
<p>示例：</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> setfacl -m u:user:rwx <span class="hljs-keyword">file</span>.txt<br></code></pre></td></tr></table></figure>
<p>该命令将文件<code>file.txt</code>的ACL添加了一个新的用户<code>user</code>，并赋予该用户读、写和执行的权限。</p>
<h4 id="6-5-修改文件所有者"><a href="#6-5-修改文件所有者" class="headerlink" title="6.5 修改文件所有者"></a>6.5 修改文件所有者</h4><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 遇到权限不足的情况自行添加sudo，没sudo权限就联系管理员吧</span><br><span class="hljs-built_in">chown</span> user1 aFile <span class="hljs-comment"># 修改aFile的所属用户为user1；</span><br><span class="hljs-built_in">chown</span> user1: aFile <span class="hljs-comment"># 修改aFile的所属用户为user1，所属用户组为user1所在的主组；</span><br><span class="hljs-built_in">chown</span> :Group1 aFile <span class="hljs-comment"># 修改aFile的所属用户组为Group1，所属用户不变；</span><br><span class="hljs-built_in">chown</span> user1:Group2 aFile <span class="hljs-comment"># 修改aFile的所属用户为user1，所属用户组为Group2；</span><br></code></pre></td></tr></table></figure>
<h3 id="7-用户切换和身份验证"><a href="#7-用户切换和身份验证" class="headerlink" title="7. 用户切换和身份验证"></a>7. 用户切换和身份验证</h3><h4 id="7-1-su命令"><a href="#7-1-su命令" class="headerlink" title="7.1 su命令"></a>7.1 su命令</h4><p><code>su</code>命令（切换用户）允许当前用户切换到其他用户账户。通过<code>su</code>命令，可以以其他用户的身份执行命令，需要输入目标用户的密码。</p>
<p>示例：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><code class="hljs crmsh">$ su <span class="hljs-keyword">user</span><br><span class="hljs-title">Password</span>: <br>$ whoami<br>user<br></code></pre></td></tr></table></figure>
<h4 id="7-2-sudo命令"><a href="#7-2-sudo命令" class="headerlink" title="7.2 sudo命令"></a>7.2 sudo命令</h4><p><code>sudo</code>命令（以超级用户权限执行命令）允许授权的用户以超级用户或其他用户的身份执行命令。使用<code>sudo</code>命令可以在不直接使用超级用户账户的情况下执行特权操作。</p>
<p>示例：</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><code class="hljs n1ql">$ sudo apt-get <span class="hljs-keyword">update</span><br>[sudo] <span class="hljs-keyword">password</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">user</span>: <br></code></pre></td></tr></table></figure>
<h4 id="7-3-SSH密钥身份验证"><a href="#7-3-SSH密钥身份验证" class="headerlink" title="7.3 SSH密钥身份验证"></a>7.3 SSH密钥身份验证</h4><p>SSH密钥身份验证使用公钥和私钥来进行身份验证，比传统的基于密码的身份验证更安全。它允许用户通过生成密钥对，并将公钥复制到目标服务器上的授权文件中，从而无需输入密码即可登录。</p>
<p>示例：</p>
<ol>
<li>生成SSH密钥对：</li>
</ol>
<figure class="highlight armasm"><table><tr><td class="code"><pre><code class="hljs armasm">$ ssh-keygen -t rsa -<span class="hljs-keyword">b</span> <span class="hljs-number">4096</span><br></code></pre></td></tr></table></figure>
<ol>
<li>将公钥复制到目标服务器：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">$ ssh<span class="hljs-operator">-</span><span class="hljs-keyword">copy</span><span class="hljs-operator">-</span>id <span class="hljs-keyword">user</span><span class="hljs-variable">@server</span><br></code></pre></td></tr></table></figure>
<ol>
<li>使用私钥登录：</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript">$ ssh -i ~<span class="hljs-regexp">/.ssh/i</span>d_rsa user<span class="hljs-meta">@server</span><br></code></pre></td></tr></table></figure>
<h3 id="8-用户管理工具"><a href="#8-用户管理工具" class="headerlink" title="8. 用户管理工具"></a>8. 用户管理工具</h3><h4 id="8-1-useradd命令"><a href="#8-1-useradd命令" class="headerlink" title="8.1 useradd命令"></a>8.1 useradd命令</h4><p><code>useradd</code>命令用于创建新用户账户。可以指定用户名、用户ID、主组ID和其他选项来创建用户。</p>
<p>示例：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">$ sudo useradd -m -s <span class="hljs-regexp">/bin/</span>bash username<br></code></pre></td></tr></table></figure>
<p>该命令以默认配置创建一个名为<code>username</code>的新用户。</p>
<h4 id="8-2-userdel命令"><a href="#8-2-userdel命令" class="headerlink" title="8.2 userdel命令"></a>8.2 userdel命令</h4><p><code>userdel</code>命令用于删除用户账户。可以指定要删除的用户以及其他选项来删除用户。</p>
<p>示例：</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>sudo userdel -r username<br></code></pre></td></tr></table></figure>
<p>该命令将删除名为<code>username</code>的用户账户及其相关文件和目录。</p>
<h4 id="8-3-passwd命令"><a href="#8-3-passwd命令" class="headerlink" title="8.3 passwd命令"></a>8.3 passwd命令</h4><p><code>passwd</code>命令用于更改用户的密码。用户可以使用<code>passwd</code>命令自行更改密码，或者管理员可以使用<code>passwd</code>命令为其他用户重置密码。</p>
<p>示例：</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><code class="hljs ada">$ passwd<br>Changing password <span class="hljs-keyword">for</span> user.<br><span class="hljs-keyword">New</span> password: <br>Retype <span class="hljs-keyword">new</span> password: <br></code></pre></td></tr></table></figure>
<h4 id="8-4-groupadd命令"><a href="#8-4-groupadd命令" class="headerlink" title="8.4 groupadd命令"></a>8.4 groupadd命令</h4><p><code>groupadd</code>命令用于创建新的用户组。可以指定组名、组ID和其他选项来创建用户组。</p>
<p>示例：</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>sudo groupadd groupname<br></code></pre></td></tr></table></figure>
<p>该命令创建一个名为<code>groupname</code>的新用户组。</p>
<h4 id="8-5-groupdel命令"><a href="#8-5-groupdel命令" class="headerlink" title="8.5 groupdel命令"></a>8.5 groupdel命令</h4><p><code>groupdel</code>命令用于删除用户组。可以指定要删除的用户组以及其他选项来删除用户组。</p>
<p>示例：</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>sudo groupdel groupname<br></code></pre></td></tr></table></figure>
<p>该命令将删除名为<code>groupname</code>的用户组。</p>
<h4 id="8-6-id命令"><a href="#8-6-id命令" class="headerlink" title="8.6 id命令"></a>8.6 id命令</h4><p><code>id</code>命令用于显示用户和组的信息。可以使用该命令查看用户和组的ID、名称和所属组等信息。</p>
<p>示例：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">$ id username<br><span class="hljs-attribute">uid</span>=1000(username) <span class="hljs-attribute">gid</span>=1000(username) <span class="hljs-attribute">groups</span>=1000(username)<br></code></pre></td></tr></table></figure>
<h3 id="9-用户管理的最佳实践"><a href="#9-用户管理的最佳实践" class="headerlink" title="9. 用户管理的最佳实践"></a>9. 用户管理的最佳实践</h3><h4 id="9-1-最小化权限原则"><a href="#9-1-最小化权限原则" class="headerlink" title="9.1 最小化权限原则"></a>9.1 最小化权限原则</h4><p>根据最小化权限原则，用户仅应被授予完成其工作所需的最低权限级别。这有助于减少潜在的滥用风险和错误操作。</p>
<p>示例：</p>
<ul>
<li>给予普通用户只读权限，而不是完全的读写权限。</li>
</ul>
<h4 id="9-2-定期审查用户账户"><a href="#9-2-定期审查用户账户" class="headerlink" title="9.2 定期审查用户账户"></a>9.2 定期审查用户账户</h4><p>定期审查用户账户可以识别和禁用不再需要的或已过期的账户，确保账户列表的精简和安全。</p>
<p>示例：</p>
<ul>
<li>每个季度对系统中的用户账户进行审查，禁用已经离职或不再需要的账户。</li>
</ul>
<h4 id="9-3-使用复杂密码"><a href="#9-3-使用复杂密码" class="headerlink" title="9.3 使用复杂密码"></a>9.3 使用复杂密码</h4><p>应鼓励或要求用户使用复杂的密码，包括字母、数字和特殊字符的组合，并限制密码长度。</p>
<p>示例：</p>
<ul>
<li>强制要求用户设置至少8位字符的密码，包含大写字母、小写字母、数字和特殊字符。</li>
</ul>
<h4 id="9-4-启用登录审计"><a href="#9-4-启用登录审计" class="headerlink" title="9.4 启用登录审计"></a>9.4 启用登录审计</h4><p>登录审计记录用户的登录行为和活动，有助于检测和调查安全事件。可以通过配置登录审计日志来启用该功能。</p>
<p>示例：</p>
<ul>
<li>配置系统以记录用户登录信息，包括登录时间、IP地址和源地址等。</li>
</ul>
<h3 id="10-总结"><a href="#10-总结" class="headerlink" title="10. 总结"></a>10. 总结</h3><p>Linux用户管理是在Linux操作系统中创建、删除、配置和管理用户账户的过程。本指南旨在提供对Linux用户管理的全面概述，并解释其重要性以及如何有效地管理用户。</p>
<p>在第一部分，我们介绍了Linux用户管理的基础知识，包括什么是Linux用户管理以及为什么它很重要。了解这些基本概念可以帮助我们更好地理解后续章节内容。</p>
<p>接下来，我们详细介绍了用户账户的创建和删除。我们学习了如何创建新的用户账户，设置其属性，并且在需要时如何安全地删除用户账户。这些操作对于管理用户的访问权限非常重要。</p>
<p>第三部分涵盖了用户登录和注销的不同方法。我们介绍了远程登录和本地登录的区别，并了解了如何强制用户注销，从而增强系统的安全性。</p>
<p>密码管理是用户管理的一个重要方面，因此我们专门介绍了密码策略的实施以及如何修改和重置用户密码。这有助于确保用户账户的安全性。</p>
<p>用户组管理是另一个重要主题，我们解释了什么是用户组，如何创建用户组以及如何将用户添加到用户组或从用户组中移除用户。通过使用用户组，我们可以更好地组织和管理用户。</p>
<p>在权限和访问控制部分，我们介绍了文件权限的概念，并讨论了如何修改文件权限以及如何使用访问控制列表（ACL）来更细粒度地控制文件访问。</p>
<p>另外，我们还详细介绍了用户切换和身份验证的不同方法，包括su命令、sudo命令和SSH密钥身份验证。这些方法使得用户能够在系统上执行特定任务或以其他用户身份登录。</p>
<p>最后，在用户管理工具部分，我们列举了一些常用的命令，例如useradd、userdel、passwd、groupadd、groupdel和id，用于在命令行界面中管理用户和用户组。</p>
<p>我们还提供了一些用户管理的最佳实践，如最小化权限原则、定期审查用户账户、使用复杂密码和启用登录审计。这些实践有助于提高系统的安全性和管理效率。</p>
<p>通过本指南，读者可以获得关于Linux用户管理的全面了解，并学习如何在Linux操作系统中高效管理用户账户和权限。</p>
]]></content>
  </entry>
  <entry>
    <title>Linux 的一些使用心得</title>
    <url>/linux/linux/</url>
    <content><![CDATA[<h1 id="SSH-端口转发"><a href="#SSH-端口转发" class="headerlink" title="SSH 端口转发"></a>SSH 端口转发</h1><h2 id="本地访问远程端口"><a href="#本地访问远程端口" class="headerlink" title="本地访问远程端口"></a>本地访问远程端口</h2><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">ssh -L [LOCAL_IP:]LOCAL_PORT:DESTINATION:DESTINATION_PORT [USER@]SSH_SERVER<br></code></pre></td></tr></table></figure>
<h2 id="远程访问本地的端口"><a href="#远程访问本地的端口" class="headerlink" title="远程访问本地的端口"></a>远程访问本地的端口</h2><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">ssh -R [REMOTE:]REMOTE_PORT:DESTINATION:DESTINATION_PORT [USER@]SSH_SERVER<br></code></pre></td></tr></table></figure>
<p>比如要把本机的代理 <code>http://127.0.0.1:10800</code> 端口共享到远程的所有 IP 上的 10801 端口，则是</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">ssh -R 0.0.0.0:10801:127.0.0.1:10800 username@ip -p port<br></code></pre></td></tr></table></figure>
<p>注意，默认是无法在远程服务器上监听 <code>0.0.0.0</code> 的，如果想要监听，需要修改 <code>/etc/ssh/sshd_config</code> 中的 <code>GatewayPorts yes</code> 才行。</p>
<p>如果网络不稳定，容易断开连接，用以下命令将该连接只用作隧道（-N），同时增加心跳<br><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">ssh -o ServerAliveInterval=60 -o ServerAliveCountMax=3 -N -R 0.0.0.0:10800:127.0.0.1:10800 kdzlys@117.139.126.36 -p 2224<br></code></pre></td></tr></table></figure></p>
<h1 id="conda-init-fish-之后-fish-崩溃"><a href="#conda-init-fish-之后-fish-崩溃" class="headerlink" title="conda init fish 之后 fish 崩溃"></a>conda init fish 之后 fish 崩溃</h1><p>原因是 ubuntu 默认的 fish 是 2.x 版本，而 conda init fish 对应的脚本对应 fish 3.x 版本，所以在安装 fish 的时候需要安装 fish 3 版本。<br><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">sudo apt-add-repository ppa:fish-shell/release-3<br>sudo apt update<br>sudo apt install fish<br></code></pre></td></tr></table></figure></p>
<h1 id="关闭-kde-文件索引程序"><a href="#关闭-kde-文件索引程序" class="headerlink" title="关闭 kde 文件索引程序"></a>关闭 kde 文件索引程序</h1><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">balooctl <span class="hljs-built_in">suspend</span><br>balooctl <span class="hljs-built_in">disable</span><br></code></pre></td></tr></table></figure>
<h1 id="Linux-下抓-HTTPS-包"><a href="#Linux-下抓-HTTPS-包" class="headerlink" title="Linux 下抓 HTTPS 包"></a>Linux 下抓 HTTPS 包</h1><h2 id="使用-MITMProxy"><a href="#使用-MITMProxy" class="headerlink" title="使用 MITMProxy"></a>使用 MITMProxy</h2><ol>
<li>运行 MITMProxy</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">docker run --<span class="hljs-built_in">rm</span> -it -p 18080:8080 -p 127.0.0.1:8081:8081 -v ~/.mitmproxy:/home/mitmproxy/.mitmproxy  mitmproxy/mitmproxy mitmweb --web-host 0.0.0.0 --<span class="hljs-built_in">set</span> block_global=<span class="hljs-literal">false</span> --<span class="hljs-built_in">set</span> ssl_insecure=<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure>
<ol>
<li>导入证书至浏览器或其他工具</li>
<li>使用代理访问 HTTPS 页面</li>
</ol>
<h1 id="更新-ubuntu-22-04-之后网易云音乐无法使用"><a href="#更新-ubuntu-22-04-之后网易云音乐无法使用" class="headerlink" title="更新 ubuntu 22.04 之后网易云音乐无法使用"></a>更新 ubuntu 22.04 之后网易云音乐无法使用</h1><p>修改 <code>/opt/netease/netease-cloud-music/netease-cloud-music.bash</code> 为以下内容<br><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/sh</span><br>HERE=<span class="hljs-string">&quot;<span class="hljs-subst">$(dirname <span class="hljs-string">&quot;<span class="hljs-subst">$(readlink -f <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;0&#125;</span>&quot;</span>)</span>&quot;</span>)</span>&quot;</span><br><span class="hljs-built_in">export</span> LD_LIBRARY_PATH=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;HERE&#125;</span>&quot;</span>/libs<br><span class="hljs-built_in">export</span> QT_PLUGIN_PATH=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;HERE&#125;</span>&quot;</span>/plugins <br><span class="hljs-built_in">export</span> QT_QPA_PLATFORM_PLUGIN_PATH=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;HERE&#125;</span>&quot;</span>/plugins/platforms<br><span class="hljs-built_in">cd</span> /lib/x86_64-linux-gnu/<br><span class="hljs-built_in">exec</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;HERE&#125;</span>&quot;</span>/netease-cloud-music <span class="hljs-variable">$@</span><br><br></code></pre></td></tr></table></figure></p>
<h1 id="关闭无用启动项"><a href="#关闭无用启动项" class="headerlink" title="关闭无用启动项"></a>关闭无用启动项</h1><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看启动项</span><br><span class="hljs-built_in">ls</span> -l /etc/xdg/autostart<br><br><span class="hljs-comment"># 重命名</span><br>sudo <span class="hljs-built_in">mv</span> something something.bak<br></code></pre></td></tr></table></figure>
<h1 id="Vmware-更新内核失败"><a href="#Vmware-更新内核失败" class="headerlink" title="Vmware 更新内核失败"></a>Vmware 更新内核失败</h1><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/mkubecek/vmware-host-modules.git<br>git checkout &lt;your_version&gt;<br>sudo make<br>sudo make install<br></code></pre></td></tr></table></figure>
<h1 id="双系统-Windows-更新失败"><a href="#双系统-Windows-更新失败" class="headerlink" title="双系统 Windows 更新失败"></a>双系统 Windows 更新失败</h1><p>我这里双系统 Windows 更新失败的原因是 Windows 引导出现了问题，可以进入 Windows 输入 <code>msconfig</code> 查看引导选项卡下是否有内容，我是用过 systemd boot 来引导的 Windows，所以没有出现内容。</p>
<p>在 BIOS 中更改成直接引导 Windows 之后便可以正常更新了。</p>
<h1 id="按时间降序最近安装的程序"><a href="#按时间降序最近安装的程序" class="headerlink" title="按时间降序最近安装的程序"></a>按时间降序最近安装的程序</h1><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> $(<span class="hljs-built_in">ls</span> -1t /var/log/dpkg.log*); <span class="hljs-keyword">do</span> <br>      zcat -f <span class="hljs-variable">$x</span> |<span class="hljs-built_in">tac</span> |grep -e <span class="hljs-string">&quot; install &quot;</span> -e <span class="hljs-string">&quot; upgrade &quot;</span>; <br><span class="hljs-keyword">done</span> | awk -F <span class="hljs-string">&quot;:a&quot;</span> <span class="hljs-string">&#x27;&#123;print $1 &quot; :a&quot; $2&#125;&#x27;</span> |column -t<br></code></pre></td></tr></table></figure>
<h1 id="常用的一些-gnome-extensions"><a href="#常用的一些-gnome-extensions" class="headerlink" title="常用的一些 gnome extensions"></a>常用的一些 gnome extensions</h1><h2 id="Unite"><a href="#Unite" class="headerlink" title="Unite"></a>Unite</h2><p>最大化时隐藏标题栏</p>
<h2 id="Clear-Top-Bar"><a href="#Clear-Top-Bar" class="headerlink" title="Clear Top Bar"></a>Clear Top Bar</h2><p>状态栏变成透明的</p>
<h2 id="ddterm"><a href="#ddterm" class="headerlink" title="ddterm"></a>ddterm</h2><p>按 <code>F10</code> 快速启动命令行，再按 <code>F10</code> 隐藏，十分方便</p>
<h2 id="Desktop-Icons-NG-DING"><a href="#Desktop-Icons-NG-DING" class="headerlink" title="Desktop Icons NG(DING)"></a>Desktop Icons NG(DING)</h2><p>在桌面上显示图标</p>
<h2 id="Lock-Keys"><a href="#Lock-Keys" class="headerlink" title="Lock Keys"></a>Lock Keys</h2><p>可以显示当前大小写状况</p>
<h2 id="NetSpeed"><a href="#NetSpeed" class="headerlink" title="NetSpeed"></a>NetSpeed</h2><p>显示当前网速</p>
<h2 id="TopIcons-Plus（在-gnome-40-之后使用-Ubuntu-Appindicators-替代）"><a href="#TopIcons-Plus（在-gnome-40-之后使用-Ubuntu-Appindicators-替代）" class="headerlink" title="TopIcons Plus（在 gnome 40 之后使用 Ubuntu Appindicators 替代）"></a>TopIcons Plus（在 gnome 40 之后使用 Ubuntu Appindicators 替代）</h2><p>在顶部显示图标</p>
<h2 id="Dash-to-Dock"><a href="#Dash-to-Dock" class="headerlink" title="Dash to Dock"></a>Dash to Dock</h2><p>在底部智能显示一个 Dock</p>
<h1 id="换-MAC-地址"><a href="#换-MAC-地址" class="headerlink" title="换 MAC 地址"></a>换 MAC 地址</h1><p>有的时候需要更换 linux 的 ip 地址：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">sudo ifconfig eth0 down<br>sudo ifconfig wlo1 hw ether 02:42:41:7d:b7:6e<br>sudo ifconfig wlo1 up<br></code></pre></td></tr></table></figure>
<p>这里 <code>eth0</code> 是网络 interface，ether 之后的参数就是 MAC 地址</p>
<h1 id="输入法"><a href="#输入法" class="headerlink" title="输入法"></a>输入法</h1><h2 id="Fcitx-失效"><a href="#Fcitx-失效" class="headerlink" title="Fcitx 失效"></a>Fcitx 失效</h2><ul>
<li><p>使用 im-config 修复</p>
</li>
<li><p>可能是 fcitx 没有正常启动，即还是 ibus，可以修改 ~/.pam_environment</p>
</li>
<li><p>使用 <code>fcitx5-diagnose</code> 命令根据提示设置环境变量</p>
</li>
<li><p>删除 <code>/etc/profile.d/pop-im-ibus.sh</code> （pop os）</p>
<p> <code>/etc/profile.d/pop-im-ibus.sh</code> （源文件： /etc/gdm3/Xsession ）设置了环境变量 <code>XMODIFIERS</code> ，在 <code>/etc/X11/Xsession.d/70im-config_launch</code> 中有如下代码：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> [ -z <span class="hljs-string">&quot;<span class="hljs-variable">$XMODIFIERS</span>&quot;</span> ] &amp;&amp; \  <span class="hljs-comment"># 如果环境变量 XMODIFIERS 没有被设置</span><br>   ...<br>   <span class="hljs-comment"># 设置环境变量以启动用户指定的输入法</span><br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure>
<p> 因为 <code>XMODIFIERS</code> 被设置了，所以 <code>设置环境变量以启动用户指定的输入法</code> 没有执行，所以 fcitx 没有被启动。</p>
<p> <code>/etc/profile.d/pop-im-ibus.sh</code> 第一次出现于 <code>pop-os_20.10_amd64_intel_4.iso</code> （发布于 2020 年 12 月中旬）</p>
<p> 相关 issue，<a href="https://github.com/pop-os/pop/issues/1445">https://github.com/pop-os/pop/issues/1445</a></p>
</li>
</ul>
<h1 id="Dash-to-dock"><a href="#Dash-to-dock" class="headerlink" title="Dash to dock"></a>Dash to dock</h1><h2 id="Dash-to-dock-重叠问题"><a href="#Dash-to-dock-重叠问题" class="headerlink" title="Dash to dock 重叠问题"></a>Dash to dock 重叠问题</h2><p>   Pop os 自带的 Dock 与 Dash to dock 发生了重叠</p>
   <figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">cd /usr/share/gnome-shell/extensions<br>sudo mv cosmic-dock@system76.com cosmic-dock@system76.com.bak # 关闭自带的 dock<br></code></pre></td></tr></table></figure>
<p>   之后重启 gnome 即可解决</p>
<h1 id="Alt-Tab-时阻止相同应用叠加"><a href="#Alt-Tab-时阻止相同应用叠加" class="headerlink" title="Alt + Tab 时阻止相同应用叠加"></a>Alt + Tab 时阻止相同应用叠加</h1><p>在 gnome 设置中，打开 keyboard shortcut，将 <code>Switch windows</code> 设置为 <code>Alt + Tab</code> ，而不是默认的 <code>Switch applications</code>。</p>
<p>参考：<a href="https://superuser.com/questions/394376/how-to-prevent-gnome-shells-alttab-from-grouping-windows-from-similar-apps">https://superuser.com/questions/394376/how-to-prevent-gnome-shells-alttab-from-grouping-windows-from-similar-apps</a></p>
<h1 id="fluxion"><a href="#fluxion" class="headerlink" title="fluxion"></a>fluxion</h1><h2 id="扫描不到热点"><a href="#扫描不到热点" class="headerlink" title="扫描不到热点"></a>扫描不到热点</h2><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">sudo airmon-ng<br>sudo airmon-ng start fluxwl0<br></code></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> FLUXIONAirmonNG=1<br></code></pre></td></tr></table></figure>
<p>执行上述命令后再运行 fluxion 即可。</p>
<h2 id="解除-53-端口被-systemd-resolved-占用"><a href="#解除-53-端口被-systemd-resolved-占用" class="headerlink" title="解除 53 端口被 systemd-resolved 占用"></a>解除 53 端口被 systemd-resolved 占用</h2><ol>
<li>先停用 systemd-resolved 服务</li>
</ol>
<figure class="highlight nsis"><table><tr><td class="code"><pre><code class="hljs nsis"><span class="hljs-params">system</span>ctl stop <span class="hljs-params">system</span>d-resolved<br></code></pre></td></tr></table></figure>
<ol>
<li>编辑 /etc/systemd/resolved.conf 文件</li>
</ol>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">vi <span class="hljs-regexp">/etc/</span>systemd/resolved.conf<br></code></pre></td></tr></table></figure>
<ol>
<li>换下面说明更改，然后按一下“esc”键，再输入“:wq”（不要输入引号），回车保存即可。</li>
</ol>
<figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[Resolve]</span><br><span class="hljs-attr">DNS</span>=<span class="hljs-number">8.8</span>.<span class="hljs-number">8.8</span>  <span class="hljs-comment">#取消注释，增加dns</span><br><span class="hljs-comment">#FallbackDNS=</span><br><span class="hljs-comment">#Domains=</span><br><span class="hljs-comment">#LLMNR=no</span><br><span class="hljs-comment">#MulticastDNS=no</span><br><span class="hljs-comment">#DNSSEC=no</span><br><span class="hljs-comment">#Cache=yes</span><br><span class="hljs-attr">DNSStubListener</span>=<span class="hljs-literal">no</span>  <span class="hljs-comment">#取消注释，把yes改为no</span><br></code></pre></td></tr></table></figure>
<ol>
<li>最后运行下面命令即可。</li>
</ol>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">ln -sf <span class="hljs-regexp">/run/</span>systemd<span class="hljs-regexp">/resolve/</span>resolv.conf <span class="hljs-regexp">/etc/</span>resolv.conf<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>MCP 协议学习</title>
    <url>/ai/mcp/</url>
    <content><![CDATA[<h1 id="MCP-协议是什么"><a href="#MCP-协议是什么" class="headerlink" title="MCP 协议是什么"></a>MCP 协议是什么</h1><p>MCP 是一个开放协议，用于标准化应用程序如何为大语言模型（LLM）提供上下文。可以将 MCP 想象成 AI 应用程序的 USB-C 接口。就像 USB-C 为连接各种外围设备和配件提供了标准化的方式，MCP 为将 AI 模型连接到不同的数据源和工具提供了标准化的方式。</p>
<p><img  src="f92b54d519822246291cc942866d4db.png"  ><span class="image-caption">MCP协议说明</span></p>
<h1 id="MCP-使用"><a href="#MCP-使用" class="headerlink" title="MCP 使用"></a>MCP 使用</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">pip install mcp<br>pip install mcp[cli]<br></code></pre></td></tr></table></figure>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>python 创建 server.py 文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> mcp.server.fastmcp <span class="hljs-keyword">import</span> FastMCP<br><br><span class="hljs-comment"># Create an MCP server</span><br>mcp = FastMCP(<span class="hljs-string">&quot;Demo&quot;</span>)<br><br><br><span class="hljs-comment"># Add an addition tool</span><br><span class="hljs-meta">@mcp.tool()</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a: <span class="hljs-built_in">int</span>, b: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;Add two numbers&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">return</span> a + b<br><br><br><span class="hljs-comment"># Add a dynamic greeting resource</span><br><span class="hljs-meta">@mcp.resource(<span class="hljs-params"><span class="hljs-string">&quot;greeting://&#123;name&#125;&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_greeting</span>(<span class="hljs-params">name: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;Get a personalized greeting&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;Hello, <span class="hljs-subst">&#123;name&#125;</span>!&quot;</span><br></code></pre></td></tr></table></figure>
<p>运行 dev</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">mcp dev server.py<br></code></pre></td></tr></table></figure>
<p>然后在浏览器打开 <a href="http://localhost:5173/">http://localhost:5173/</a></p>
<p>能够看到</p>
<p><img  src="image-20250328113411422.png"  ><span class="image-caption">MCP Inspector</span></p>
<h2 id="与-Claude-Desktop-联调"><a href="#与-Claude-Desktop-联调" class="headerlink" title="与 Claude Desktop 联调"></a>与 Claude Desktop 联调</h2><p>执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">mcp install server.py<br></code></pre></td></tr></table></figure>
<p>然后会在 claude 目录下 <code>AppData\Roaming\Claude</code> 下生成 <code>claude_desktop_config.json</code> 文件，默认是包含 <code>uv</code> 命令的，我修改为以下内容：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;mcpServers&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;Demo&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;command&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;mcp&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;args&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-string">&quot;run&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;D:\\sjj\\script\\mcp_test\\server.py&quot;</span><br>      <span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>
<p>然后重启 Claude Desktop ，出现了以下内容：</p>
<p><img  src="image-20250328113652395.png"   style="zoom:67%;" /><span class="image-caption">image-20250328113652395</span></p>
<p>执行加法：</p>
<p><img  src="image-20250328113721120.png"   style="zoom:67%;" /><span class="image-caption">image-20250328113721120</span></p>
<h1 id="自己编写一个操作数据库的-MCP-Server"><a href="#自己编写一个操作数据库的-MCP-Server" class="headerlink" title="自己编写一个操作数据库的 MCP Server"></a>自己编写一个操作数据库的 MCP Server</h1><h2 id="server-py-代码"><a href="#server-py-代码" class="headerlink" title="server.py 代码"></a>server.py 代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> MySQLdb<br><span class="hljs-keyword">from</span> mcp.server.fastmcp <span class="hljs-keyword">import</span> FastMCP<br><br>mcp = FastMCP(<span class="hljs-string">&quot;MySQL Explorer&quot;</span>)<br><br>conn = MySQLdb.connect(<br>    host=<span class="hljs-string">&quot;127.0.0.1&quot;</span>,<br>    port=<span class="hljs-number">3306</span>,<br>    user=<span class="hljs-string">&quot;root&quot;</span>,<br>    password=<span class="hljs-string">&quot;root&quot;</span>,<br>)<br><br><span class="hljs-meta">@mcp.resource(<span class="hljs-params"><span class="hljs-string">&quot;schema://main&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_schema</span>() -&gt; <span class="hljs-built_in">str</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;Provide the database schema as a resource&quot;&quot;&quot;</span><br>    cursor = conn.cursor()<br>    cursor.execute(<span class="hljs-string">&quot;SHOW TABLES&quot;</span>)  <span class="hljs-comment"># Get a list of all tables</span><br><br>    tables = cursor.fetchall()<br>    schema = []<br><br>    <span class="hljs-keyword">for</span> table <span class="hljs-keyword">in</span> tables:<br>        table_name = table[<span class="hljs-number">0</span>]<br>        cursor.execute(<span class="hljs-string">f&quot;SHOW CREATE TABLE `<span class="hljs-subst">&#123;table_name&#125;</span>`&quot;</span>)  <span class="hljs-comment"># Get the create statement for each table</span><br>        create_table_sql = cursor.fetchone()[<span class="hljs-number">1</span>]<br>        schema.append(create_table_sql)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;\n&quot;</span>.join(schema)<br><br><br><br><span class="hljs-meta">@mcp.tool()</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">query_data</span>(<span class="hljs-params">sql: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;Execute SQL queries safely&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">try</span>:<br>        cursor = conn.cursor()<br>        cursor.execute(sql)<br>        result = cursor.fetchall()<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;\n&quot;</span>.join(<span class="hljs-built_in">str</span>(row) <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> result)<br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;Error: <span class="hljs-subst">&#123;<span class="hljs-built_in">str</span>(e)&#125;</span>&quot;</span><br>    <br><br></code></pre></td></tr></table></figure>
<h2 id="然后-MCP-Inspector-获取-resource"><a href="#然后-MCP-Inspector-获取-resource" class="headerlink" title="然后 MCP Inspector 获取 resource"></a>然后 MCP Inspector 获取 resource</h2><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">curl <span class="hljs-string">&#x27;http://localhost:3000/message?sessionId=c73d174d-8772-441a-bfa1-1771ad358aa1&#x27;</span> \<br>  -H <span class="hljs-string">&#x27;Accept: */*&#x27;</span> \<br>  -H <span class="hljs-string">&#x27;Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6&#x27;</span> \<br>  -H <span class="hljs-string">&#x27;Connection: keep-alive&#x27;</span> \<br>  -H <span class="hljs-string">&#x27;Origin: http://localhost:5173&#x27;</span> \<br>  -H <span class="hljs-string">&#x27;Referer: http://localhost:5173/&#x27;</span> \<br>  -H <span class="hljs-string">&#x27;Sec-Fetch-Dest: empty&#x27;</span> \<br>  -H <span class="hljs-string">&#x27;Sec-Fetch-Mode: cors&#x27;</span> \<br>  -H <span class="hljs-string">&#x27;Sec-Fetch-Site: same-site&#x27;</span> \<br>  -H <span class="hljs-string">&#x27;User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/134.0.0.0 Safari/537.36 Edg/134.0.0.0&#x27;</span> \<br>  -H <span class="hljs-string">&#x27;content-type: application/json&#x27;</span> \<br>  -H <span class="hljs-string">&#x27;sec-ch-ua: &quot;Chromium&quot;;v=&quot;134&quot;, &quot;Not:A-Brand&quot;;v=&quot;24&quot;, &quot;Microsoft Edge&quot;;v=&quot;134&quot;&#x27;</span> \<br>  -H <span class="hljs-string">&#x27;sec-ch-ua-mobile: ?0&#x27;</span> \<br>  -H <span class="hljs-string">&#x27;sec-ch-ua-platform: &quot;Windows&quot;&#x27;</span> \<br>  --data-raw <span class="hljs-string">&#x27;&#123;&quot;method&quot;:&quot;resources/list&quot;,&quot;params&quot;:&#123;&#125;,&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;id&quot;:1&#125;&#x27;</span><br></code></pre></td></tr></table></figure>
<h2 id="在网页上得到了-schema"><a href="#在网页上得到了-schema" class="headerlink" title="在网页上得到了 schema"></a>在网页上得到了 schema</h2><p><img  src="image-20250328151443784.png"  ><span class="image-caption">image-20250328151443784</span></p>
<h2 id="安装到-Claude"><a href="#安装到-Claude" class="headerlink" title="安装到 Claude"></a>安装到 Claude</h2><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">mcp install .\mysql_server.py --with mysqlclient<br></code></pre></td></tr></table></figure>
<p>Claude 配置文件</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;mcpServers&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;Demo&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;command&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;mcp&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;args&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-string">&quot;run&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;D:\\sjj\\script\\mcp_test\\server.py&quot;</span><br>      <span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;MySQL Explorer&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;command&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;mcp&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;args&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-string">&quot;run&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;--with&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;mysqlclient&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;D:\\sjj\\script\\mcp_test\\mysql_server.py&quot;</span><br>      <span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>
<h2 id="开始测试"><a href="#开始测试" class="headerlink" title="开始测试"></a>开始测试</h2><p><img  src="image-20250328153747577.png"    /><span class="image-caption">image-20250328153747577</span></p>
<p><img  src="image-20250328153758113.png"  ><span class="image-caption">image-20250328153758113</span></p>
<p><img  src="image-20250328153822340.png"  ><span class="image-caption">image-20250328153822340</span></p>
<p><img  src="image-20250328153835288.png"  ><span class="image-caption">image-20250328153835288</span></p>
<p><img  src="image-20250328153845382.png"  ><span class="image-caption">image-20250328153845382</span></p>
<p><img  src="image-20250328153857103.png"  ><span class="image-caption">image-20250328153857103</span></p>
<p><img  src="image-20250328153916122.png"  ><span class="image-caption">image-20250328153916122</span></p>
<p><img  src="image-20250328153926680.png"  ><span class="image-caption">image-20250328153926680</span></p>
]]></content>
      <categories>
        <category>ai</category>
      </categories>
  </entry>
  <entry>
    <title>一些有意思的图</title>
    <url>/uncategorized/meme/</url>
    <content><![CDATA[<h1 id="关于是否写脚本自动化"><a href="#关于是否写脚本自动化" class="headerlink" title="关于是否写脚本自动化"></a>关于是否写脚本自动化</h1><p><img  src="v2-7012fc4ee97f0b520094f731152eaac5_b.jpg"  ><span class="image-caption">img</span></p>
]]></content>
  </entry>
  <entry>
    <title>人性的弱点笔记</title>
    <url>/uncategorized/people/</url>
    <content><![CDATA[<h1 id="来自-Async-的-Tips"><a href="#来自-Async-的-Tips" class="headerlink" title="来自 Async 的 Tips"></a>来自 Async 的 Tips</h1><p>注意，在使用这些技巧的时候，不要过度，我们不必要太过迁就和顺从任何人。</p>
<p>人们不会珍惜轻易得到的东西。</p>
<h1 id="一、基本技巧"><a href="#一、基本技巧" class="headerlink" title="一、基本技巧"></a>一、基本技巧</h1><p>1、不要批评（待人接物的第一大忌）</p>
<p>2、自我价值感、对尊重和真诚欣赏的渴望（这种说话方式非常值钱）</p>
<p>3、站在对方的角度思考问题。诉诸对方的内在需要。（让整个世界前来为你助力）</p>
<h1 id="二、如何让大家都喜欢你"><a href="#二、如何让大家都喜欢你" class="headerlink" title="二、如何让大家都喜欢你"></a>二、如何让大家都喜欢你</h1><p>4、真的喜欢别人、注意小节。我们都喜欢那些喜欢我们的人。（这样做，谁会不喜欢你？）</p>
<p>5、一笑值千金。（这能留下美好的第一印象）</p>
<p>6、记住名字。（这会让人一下子喜欢上你）</p>
<p>7、全心关注，是一种微妙的恭维，很少有人，很少有人抵抗得住。倾听，鼓励对方多聊自己。（怎样才叫“会聊天”）</p>
<p>8、聊对方感兴趣的话题。（提高你的影响力）</p>
<p>9、和人们聊他们自己，他们会听几个小时都不烦。使对方感到自己是重要的，要真心实意。（一句话焐热人心）</p>
<h1 id="三、如何有逻辑地说服他人"><a href="#三、如何有逻辑地说服他人" class="headerlink" title="三、如何有逻辑地说服他人"></a>三、如何有逻辑地说服他人</h1><p>10、不要信任自己的第一直觉冲动。在意见不合时，我们的第一自然反应是抗辩。小心！保持冷静，小心你的第一反应。那是你最糟糕的瞬间，而不是最好的时候。试着建立理解的桥梁，不要构建误解的深渊。<br>赢得争论的唯一方法是避免争论。（第一大忌：伤敌一万，自损八千）</p>
<p>11、我们偶尔知道自己会毫无阻力地改变主意，没有什么沉重心情，但如果有人说我们错了，我们就会因为对指责的憎恨而铁下心来。我们在形成信念时很随意，随意得叫人吃惊，但当任何人提出要剥离这些信念时，我们就会充满保卫它们的可怕激情。显然，并非那些想法很重要，而是我们的自尊受到了威胁……<br>尊重对方的观点，永远别说“你不对”。（第二大忌：一句惹怒全世界的话）</p>
<p>12、有勇气承认自己的错误，会产生某种满足感。它不仅能让内疚感和自卫感一扫而光，还常能解决错误所带来的问题。<br>假如你错了，立刻真心诚意地承认。（拆招卸力）</p>
<p>13、先说友善的话，气氛对了之后再说别的。（开口前结局已定）</p>
<p>14、先让对方回答“对”“是的”。（如何引导对方的思路）</p>
<p>15、尽量让对方多说。（贵人语迟）</p>
<p>16、我们喜欢别人问我们希望什么，我们需要什么，我们有什么观点。<br>让对方感觉，那是他自己的主意。（洗脑术：如何让人深信不疑）</p>
<p>17、努力从对方的视角看问题，要诚实。（如何让别人关注你）</p>
<p>18、你现在这样感觉，我没有任何理由怪你，如果我是你，我一定也会是那个感觉。<br>真正体会和感受对方的观点和渴望。（提高你的人格魅力）</p>
<p>19、我们所有人在心底都是理想家，喜欢认为自己拥有高尚的情操。<br>诉诸高尚的情操。（如何让人乐意服你）</p>
<p>20、把你的观点，演成故事。（说不透时，卖个故事）</p>
<p>21、抛出挑战。（最后一招，下封战书）</p>
<h1 id="四、成为一个领袖：如何改变他人而不冒犯人或引起反感、愤怒或怨恨"><a href="#四、成为一个领袖：如何改变他人而不冒犯人或引起反感、愤怒或怨恨" class="headerlink" title="四、成为一个领袖：如何改变他人而不冒犯人或引起反感、愤怒或怨恨"></a>四、成为一个领袖：如何改变他人而不冒犯人或引起反感、愤怒或怨恨</h1><p>22、先要懂得欣赏，不做作地称赞。（如何让大家都尊重你）</p>
<p>23、让人们注意自己的错误时，间接一点儿。（批评但不招人恨）</p>
<p>24、批评对方之前，不妨先说说自己犯过的错。（服人而不得罪人）</p>
<p>25、不要直接下命令，而要利用问句。（世界上没有任何人能指使我）</p>
<p>26、让对方保全颜面。（第一大忌：犯众怒）</p>
<p>27、每个人都喜欢称赞，但表扬必须具体，否则就特别假，成了说好话哄骗人。记住，我们都渴望赞美和认可，会不惜一切去争取。但没有人喜欢虚假，所有人都讨厌奉承。<br>称赞最细小的进步，称赞每一个进步。不要吝啬你的嘉许和赞扬，要真诚。（水涨船高：激励下属成事儿）</p>
<p>28、给人一个无法抗拒、无法辜负的好评。（你的期望永远不会落空）</p>
<p>29、学会鼓励人，鼓励会使改变看起来很容易。（让人乐意照你说的去改）</p>
<p>30、一个高产能的领袖，在改变别人的态度和行为时，应该牢记以下原则：</p>
<ul>
<li>要真诚。做不到的承诺，不要承诺。忘记对自己的好处，关注对方的利益。</li>
<li>精确地知道你想让对方做什么。</li>
<li>要共情。问自己：对方想要的到底是什么？</li>
<li>想想如果按照你说的做，对方会得到什么。</li>
<li>把这么做所能带来的好处，和对方的需要进行匹配。</li>
<li>发出要求时，要更改方式，要传达给对方一个观念：对方本人将是受益者。我们不能这么粗鲁地下令：“约翰，明天有客户来，我需要一个整洁的仓库。所以，去打扫干净，把货架上的货物摆放整齐，把货柜擦亮。”我们可以换一个方式来说同一件事，告诉约翰完成这个任务对他会有什么好处：“约翰，我们有件事得马上做好。现在就做，回头就不用手忙脚乱了。我明天会带几个客户来看我们的设施。我想带他们去看看仓库，但现在乱糟糟的。如果你愿意清理一下，把货架上的货物摆放整齐，把货柜擦一擦，我们就会显得更干练，你就给公司形象贡献了自己的那份力量。”</li>
<li>使人们乐意去做你要他们做的事。（让人乐意照你说的去做）</li>
</ul>
]]></content>
      <tags>
        <tag>book</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust的一些学习心得</title>
    <url>/rust/rust/</url>
    <content><![CDATA[<h1 id="Rust-标准库-trait"><a href="#Rust-标准库-trait" class="headerlink" title="Rust 标准库 trait"></a>Rust 标准库 trait</h1><p>假设有以下变量：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">t</span> = T::<span class="hljs-title function_ invoke__">new</span>()<br></code></pre></td></tr></table></figure>
<h2 id="impl-From-lt-U-gt-for-T"><a href="#impl-From-lt-U-gt-for-T" class="headerlink" title="impl From&lt;U&gt; for T"></a><code>impl From&lt;U&gt; for T</code></h2><p>如果为 <code>T</code> 实现了 <code>From&lt;U&gt;</code> 则可以通过 <code>T::from(U)</code> 得到 <code>T</code>。</p>
<p>例如 <code>String</code> 实现了 <code>From&lt;&amp;str&gt;</code>，所以 <code>String</code> 可以从 <code>&amp;str</code> 生成。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">string</span> = <span class="hljs-string">&quot;hello&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>();<br><span class="hljs-keyword">let</span> <span class="hljs-variable">other_string</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><br><span class="hljs-built_in">assert_eq!</span>(string, other_string);<br></code></pre></td></tr></table></figure>
<p><code>impl Into&lt;U&gt; for T</code></p>
<p>如果为 <code>T</code> 实现了 <code>Into&lt;U&gt;</code> 则可以通过 <code>t.into()</code> 消耗自己得到 <code>U</code>。</p>
<p>例如 <code>String</code> 类型实现了 <code>Into&lt;Vec&lt;u8&gt;&gt;</code>。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">is_hello</span>&lt;T: <span class="hljs-built_in">Into</span>&lt;<span class="hljs-type">Vec</span>&lt;<span class="hljs-type">u8</span>&gt;&gt;&gt;(s: T) &#123;<br>   <span class="hljs-keyword">let</span> <span class="hljs-variable">bytes</span> = <span class="hljs-string">b&quot;hello&quot;</span>.<span class="hljs-title function_ invoke__">to_vec</span>();<br>   <span class="hljs-built_in">assert_eq!</span>(bytes, s.<span class="hljs-title function_ invoke__">into</span>());<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-string">&quot;hello&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>();<br><span class="hljs-title function_ invoke__">is_hello</span>(s);<br></code></pre></td></tr></table></figure>
<p>在实际编程中，用来接收多种类型的参数，如 <code>Into&lt;String&gt;</code> 可以同时接收 <code>String</code> 和 <code>&amp;str</code>。</p>
<h2 id="impl-AsRef-lt-U-gt-for-T"><a href="#impl-AsRef-lt-U-gt-for-T" class="headerlink" title="impl AsRef&lt;U&gt; for T"></a><code>impl AsRef&lt;U&gt; for T</code></h2><p>如果为 <code>T</code> 实现了 <code>AsRef&lt;U&gt;</code> 则可以通过 <code>t.as_ref()</code> 得到 <code>&amp;U</code>。</p>
<p>注：</p>
<ol>
<li>与 <code>Into&lt;U&gt;</code> 不同的是，<code>AsRef&lt;U&gt;</code> 只是类型转换，<code>t</code> 对象本身没有被消耗；</li>
<li><code>T: AsRef&lt;U&gt;</code> 中的 <code>T</code>，可以接受 资源拥有者（owned）类型，共享引用（shared referrence）类型 ，可变引用（mutable referrence）类型。</li>
</ol>
<p>例如 <code>String</code> 和 <code>&amp;str</code> 都实现了 <code>AsRef&lt;str&gt;</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">is_hello</span>&lt;T: <span class="hljs-built_in">AsRef</span>&lt;<span class="hljs-type">str</span>&gt;&gt;(s: T) &#123;<br>   <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-string">&quot;hello&quot;</span>, s.<span class="hljs-title function_ invoke__">as_ref</span>());<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-string">&quot;hello&quot;</span>;<br><span class="hljs-title function_ invoke__">is_hello</span>(s);<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-string">&quot;hello&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>();<br><span class="hljs-title function_ invoke__">is_hello</span>(s);<br></code></pre></td></tr></table></figure>
<h2 id="impl-AsMut-lt-U-gt-for-T"><a href="#impl-AsMut-lt-U-gt-for-T" class="headerlink" title="impl AsMut&lt;U&gt; for T"></a><code>impl AsMut&lt;U&gt; for T</code></h2><p>如果为 <code>T</code> 实现了 <code>AsRef&lt;U&gt;</code> 则可以通过 <code>t.as_mut()</code> 得到 <code>&amp;mut U</code>。</p>
<h2 id="impl-Borror-lt-U-gt-for-T"><a href="#impl-Borror-lt-U-gt-for-T" class="headerlink" title="impl Borror&lt;U&gt; for T"></a><code>impl Borror&lt;U&gt; for T</code></h2><p>如果 <code>T</code> 实现了 <code>Borrow&lt;U&gt;</code>，那么，<code>t</code> 可执行 <code>.borrow()</code> 操作，即 <code>t.borrow()</code>。操作的结果，我们得到了一个类型为 <code>&amp;U</code> 的新引用。</p>
<p><code>Borrow</code> 可以认为是 <code>AsRef</code> 的严格版本，它对普适引用操作的前后类型之间附加了一些其它限制。</p>
<p><code>Borrow</code> 的前后类型之间要求必须有内部等价性。不具有这个等价性的两个类型之间，不能实现 <code>Borrow</code>。</p>
<p><code>AsRef</code> 更通用，更普遍，覆盖类型更多，是 <code>Borrow</code> 的超集。</p>
<p>举例：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::borrow::Borrow;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">check</span>&lt;T: Borrow&lt;<span class="hljs-type">str</span>&gt;&gt;(s: T) &#123;<br>    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-string">&quot;Hello&quot;</span>, s.<span class="hljs-title function_ invoke__">borrow</span>());<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-string">&quot;Hello&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>();<br><br><span class="hljs-title function_ invoke__">check</span>(s);<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-string">&quot;Hello&quot;</span>;<br><br><span class="hljs-title function_ invoke__">check</span>(s);<br></code></pre></td></tr></table></figure>
<h2 id="impl-BorrowMut-lt-U-gt-for-T"><a href="#impl-BorrowMut-lt-U-gt-for-T" class="headerlink" title="impl BorrowMut&lt;U&gt; for T"></a><code>impl BorrowMut&lt;U&gt; for T</code></h2><p>如果 <code>T</code> 实现了 <code>BorrowMut&lt;U&gt;</code>，那么，<code>t</code> 可执行 <code>.borrow_mut()</code> 操作，即 <code>t.borrow_mut()</code>。操作的结果我们得到类型为 <code>&amp;mut U</code> 的一个可变（mutable）引用。</p>
<h2 id="impl-ToOwned-for-T"><a href="#impl-ToOwned-for-T" class="headerlink" title="impl ToOwned for T"></a><code>impl ToOwned for T</code></h2><p><code>ToOwned</code> 为 <code>Clone</code> 的普适版本。它提供了 <code>.to_owned()</code> 方法，用于类型转换。</p>
<p>有些实现了 <code>Clone</code> 的类型 <code>T</code> 可以从引用状态实例 <code>&amp;T</code> 通过 <code>.clone()</code> 方法，生成具有所有权的 <code>T</code> 的实例。但是它只能由 <code>&amp;T</code> 生成 <code>T</code>。而对于其它形式的引用，<code>Clone</code> 就无能为力了。</p>
<p>而 <code>ToOwned</code> trait 能够从任意引用类型实例，生成具有所有权的类型实例。</p>
<h2 id="impl-Deref-for-T"><a href="#impl-Deref-for-T" class="headerlink" title="impl Deref for T"></a><code>impl Deref for T</code></h2><p><code>Deref</code> 是 <code>deref</code> 操作符 <code>*</code> 的 trait，比如 <code>*v</code>。</p>
<p>一般理解，<code>*t</code> 操作，是 <code>&amp;t</code> 的反向操作，即试图由资源的引用获取到资源的拷贝（如果资源类型实现了 <code>Copy</code>），或所有权（资源类型没有实现 <code>Copy</code>）。</p>
<p>Rust 中，本操作符行为可以重载。这也是 Rust 操作符的基本特点。本身没有什么特别的。</p>
<h3 id="强制隐式转换（coercion）"><a href="#强制隐式转换（coercion）" class="headerlink" title="强制隐式转换（coercion）"></a>强制隐式转换（coercion）</h3><p><code>Deref</code> 神奇的地方并不在本身 <code>解引</code> 这个意义上，Rust 的设计者在它之上附加了一个特性：<code>强制隐式转换</code>，这才是它神奇之处。</p>
<p>这种隐式转换的规则为：</p>
<p>一个类型为 <code>T</code> 的对象 <code>t</code>，如果 <code>T: Deref&lt;Target=U&gt;</code>，那么，相关 <code>t</code> 的某个智能指针或引用（比如 <code>&amp;foo</code>）在应用的时候会自动转换成 <code>&amp;U</code>。</p>
<p>粗看这条规则，貌似有点类似于 <code>AsRef</code>，而跟 <code>解引</code> 似乎风马牛不相及。实际里面有些玄妙之处。</p>
<p>Rust 编译器会在做 <code>*v</code> 操作的时候，自动先把 <code>v</code> 做引用归一化操作，即转换成内部通用引用的形式 <code>&amp;v</code>，整个表达式就变成 <code>*&amp;v</code>。这里面有两种情况：</p>
<ol>
<li>把其它类型的指针（比如在库中定义的，<code>Box</code>, <code>Rc</code>, <code>Arc</code>, <code>Cow</code> 等），转成内部标准形式 <code>&amp;v</code>；</li>
<li>把多重 <code>&amp;</code> （比如：<code>&amp;&amp;&amp;&amp;&amp;&amp;&amp;v</code>），简化成 <code>&amp;v</code>（通过插入足够数量的 <code>*</code> 进行解引）。</li>
</ol>
<p>所以，它实际上在解引用之前做了一个引用的归一化操作。</p>
<p>为什么要转呢？ 因为编译器设计的能力是，只能够对 <code>&amp;v</code> 这种引用进行解引用。其它形式的它不认识，所以要做引用归一化操作。</p>
<p>使用引用进行过渡也是为了能够防止不必要的拷贝。</p>
<p>下面举一些例子：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">foo</span>(s: &amp;<span class="hljs-type">str</span>) &#123;<br>    <span class="hljs-comment">// borrow a string for a second</span><br>&#125;<br><br><span class="hljs-comment">// String implements Deref&lt;Target=str&gt;</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">owned</span> = <span class="hljs-string">&quot;Hello&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>();<br><br><span class="hljs-comment">// therefore, this works:</span><br><span class="hljs-title function_ invoke__">foo</span>(&amp;owned);<br></code></pre></td></tr></table></figure>
<p>因为 <code>String</code> 实现了 <code>Deref&lt;Target=str&gt;</code>。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::rc::Rc;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">foo</span>(s: &amp;<span class="hljs-type">str</span>) &#123;<br>    <span class="hljs-comment">// borrow a string for a second</span><br>&#125;<br><br><span class="hljs-comment">// String implements Deref&lt;Target=str&gt;</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">owned</span> = <span class="hljs-string">&quot;Hello&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>();<br><span class="hljs-keyword">let</span> <span class="hljs-variable">counted</span> = Rc::<span class="hljs-title function_ invoke__">new</span>(owned);<br><br><span class="hljs-comment">// therefore, this works:</span><br><span class="hljs-title function_ invoke__">foo</span>(&amp;counted);<br></code></pre></td></tr></table></figure>
<p>因为 <code>Rc&lt;T&gt;</code> 实现了 <code>Deref&lt;Target=T&gt;</code>。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">foo</span>(s: &amp;[<span class="hljs-type">i32</span>]) &#123;<br>    <span class="hljs-comment">// borrow a slice for a second</span><br>&#125;<br><br><span class="hljs-comment">// Vec&lt;T&gt; implements Deref&lt;Target=[T]&gt;</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">owned</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><br><span class="hljs-title function_ invoke__">foo</span>(&amp;owned);<br></code></pre></td></tr></table></figure>
<p>因为 <code>Vec&lt;T&gt;</code> 实现了 <code>Deref&lt;Target=[T]&gt;</code>。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Foo</span>;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Foo</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">foo</span>(&amp;<span class="hljs-keyword">self</span>) &#123; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Foo&quot;</span>); &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = &amp;&amp;Foo;<br><br>f.<span class="hljs-title function_ invoke__">foo</span>();<br>(&amp;f).<span class="hljs-title function_ invoke__">foo</span>();<br>(&amp;&amp;f).<span class="hljs-title function_ invoke__">foo</span>();<br>(&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;f).<span class="hljs-title function_ invoke__">foo</span>();<br></code></pre></td></tr></table></figure>
<p>上面那几种函数的调用，效果是一样的。</p>
<p><code>coercion</code> 的设计，是 Rust 中仅有的类型隐式转换，设计它的目的，是为了简化程序的书写，让代码不至于过于繁琐。把人从无尽的类型细节中解脱出来，让书写 Rust 代码变成一件快乐的事情。</p>
<h2 id="Cow"><a href="#Cow" class="headerlink" title="Cow"></a><code>Cow</code></h2><p><code>Clone-on-write</code>，即写时克隆。本质上是一个智能指针。</p>
<p>它有两个可选值：</p>
<ul>
<li><code>Borrowed</code>，用于包裹对象的引用（通用引用）；</li>
<li><code>Owned</code>，用于包裹对象的所有者；</li>
</ul>
<p><code>Cow</code> 提供</p>
<ol>
<li>对此对象的不可变访问（比如可直接调用此对象原有的不可变方法）；</li>
<li>如果遇到需要修改此对象，或者需要获得此对象的所有权的情况，<code>Cow</code> 提供方法做克隆处理，并避免多次重复克隆。</li>
</ol>
<p><code>Cow</code> 的设计目的是提高性能（减少复制）同时增加灵活性，因为大部分情况下，业务场景都是读多写少。利用 <code>Cow</code>，可以用统一，规范的形式实现，需要写的时候才做一次对象复制。这样就可能会大大减少复制的次数。</p>
<p>它有以下几个要点需要掌握：</p>
<ol>
<li><code>Cow&lt;T&gt;</code> 能直接调用 <code>T</code> 的不可变方法，因为 <code>Cow</code> 这个枚举，实现了 <code>Deref</code>；</li>
<li>在需要写 <code>T</code>的时候，可以使用 <code>.to_mut()</code> 方法得到一个具有所有权的值的可变借用；<ol>
<li>注意，调用 <code>.to_mut()</code> 不一定会产生克隆；</li>
<li>在已经具有所有权的情况下，调用 <code>.to_mut()</code> 有效，但是不会产生新的克隆；</li>
<li>多次调用 <code>.to_mut()</code> 只会产生一次克隆。</li>
</ol>
</li>
<li>在需要写 <code>T</code> 的时候，可以使用 <code>.into_owned()</code> 创建新的拥有所有权的对象，这个过程往往意味着内存拷贝并创建新对象；<ol>
<li>如果之前 <code>Cow</code> 中的值是借用状态，调用此操作将执行克隆；</li>
<li>本方法，参数是<code>self</code>类型，它会“吃掉”原先的那个对象，调用之后原先的对象的生命周期就截止了，在 <code>Cow</code> 上不能调用多次；</li>
</ol>
</li>
</ol>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p><code>.to_mut()</code> 举例</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::borrow::Cow;<br><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">cow</span>: Cow&lt;[_]&gt; = Cow::<span class="hljs-title function_ invoke__">Owned</span>(<span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">hello</span> = cow.<span class="hljs-title function_ invoke__">to_mut</span>();<br><br><span class="hljs-built_in">assert_eq!</span>(hello, &amp;[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br></code></pre></td></tr></table></figure>
<p><code>.into_owned()</code> 举例</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::borrow::Cow;<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">cow</span>: Cow&lt;[_]&gt; = Cow::<span class="hljs-title function_ invoke__">Owned</span>(<span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">hello</span> = cow.<span class="hljs-title function_ invoke__">into_owned</span>();<br><br><span class="hljs-built_in">assert_eq!</span>(<span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], hello);<br></code></pre></td></tr></table></figure>
<p>综合举例</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::borrow::Cow;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">abs_all</span>(input: &amp;<span class="hljs-keyword">mut</span> Cow&lt;[<span class="hljs-type">i32</span>]&gt;) &#123;<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..input.<span class="hljs-title function_ invoke__">len</span>() &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = input[i];<br>        <span class="hljs-keyword">if</span> v &lt; <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-comment">// clones into a vector the first time (if not already owned)</span><br>            input.<span class="hljs-title function_ invoke__">to_mut</span>()[i] = -v;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="更多的例子"><a href="#更多的例子" class="headerlink" title="更多的例子"></a>更多的例子</h3><p>题目：写一个函数，过滤掉输入的字符串中的所有空格字符，并返回过滤后的字符串。</p>
<p>对这个简单的问题，不用思考，我们都可以很快写出代码：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">remove_spaces</span>(input: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123;<br>   <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">buf</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">with_capacity</span>(input.<span class="hljs-title function_ invoke__">len</span>());<br><br>   <span class="hljs-keyword">for</span> <span class="hljs-variable">c</span> <span class="hljs-keyword">in</span> input.<span class="hljs-title function_ invoke__">chars</span>() &#123;<br>      <span class="hljs-keyword">if</span> c != <span class="hljs-string">&#x27; &#x27;</span> &#123;<br>         buf.<span class="hljs-title function_ invoke__">push</span>(c);<br>      &#125;<br>   &#125;<br><br>   buf<br>&#125;<br></code></pre></td></tr></table></figure>
<p>设计函数输入参数的时候，我们会停顿一下，这里，用 <code>&amp;str</code> 好呢，还是 <code>String</code> 好呢？思考一番，从性能上考虑，有如下结论：</p>
<ol>
<li>如果使用 <code>String</code> 则外部在调用此函数的时候，<ol>
<li>如果外部的字符串是 <code>&amp;str</code>，那么，它需要做一次克隆，才能调用此函数；</li>
<li>如果外部的字符串是 <code>String</code>，那么，它不需要做克隆，就可以调用此函数。但是，一旦调用后，外部那个字符串的所有权就被 <code>move</code> 到此函数中了，外部的后续代码将无法再使用原字符串。</li>
</ol>
</li>
<li>如果使用 <code>&amp;str</code>，则不存在上述两个问题。但可能会遇到生命周期的问题，需要注意。</li>
</ol>
<p>继续分析上面的例子，我们发现，在函数体内，做了一次新字符串对象的生成和拷贝。</p>
<p>让我们来仔细分析一下业务需求。最坏的情况下，如果字符串中没有空白字符，那最好是直接原样返回。这种情况做这样一次对象的拷贝，完全就是浪费了。</p>
<p>于是我们心想改进这个算法。很快，又遇到了另一个问题，返回值是 <code>String</code> 的嘛，我不论怎样，要把 <code>&amp;str</code> 转换成 <code>String</code> 返回，始终都要经历一次复制。于是我们快要放弃了。</p>
<p>好吧，<code>Cow</code> 君这时出马了。写出了如下代码：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::borrow::Cow;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">remove_spaces</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(input: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> Cow&lt;<span class="hljs-symbol">&#x27;a</span>, <span class="hljs-type">str</span>&gt; &#123;<br>    <span class="hljs-keyword">if</span> input.<span class="hljs-title function_ invoke__">contains</span>(<span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">buf</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">with_capacity</span>(input.<span class="hljs-title function_ invoke__">len</span>());<br><br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">c</span> <span class="hljs-keyword">in</span> input.<span class="hljs-title function_ invoke__">chars</span>() &#123;<br>            <span class="hljs-keyword">if</span> c != <span class="hljs-string">&#x27; &#x27;</span> &#123;<br>                buf.<span class="hljs-title function_ invoke__">push</span>(c);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> Cow::<span class="hljs-title function_ invoke__">Owned</span>(buf);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> Cow::<span class="hljs-title function_ invoke__">Borrowed</span>(input);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>完美解决了业务逻辑与返回值类型冲突的问题。本例可细细品味。</p>
<p>外部程序，拿到这个 <code>Cow</code> 返回值后，按照我们上文描述的 <code>Cow</code> 的特性使用就好了。</p>
<h2 id="Send-和-Sync"><a href="#Send-和-Sync" class="headerlink" title="Send 和 Sync"></a><code>Send</code> 和 <code>Sync</code></h2><p><code>std::marker</code> 模块中，有两个 trait：<code>Send</code> 和 <code>Sync</code>，它们与多线程安全相关。</p>
<p>标记为 <code>marker trait</code> 的 trait，它实际就是一种约定，没有方法的定义，也没有关联元素（associated items）。仅仅是一种约定，实现了它的类型必须满足这种约定。一种类型是否加上这种约定，要么是编译器的行为，要么是人工手动的行为。</p>
<p><code>Send</code> 和 <code>Sync</code> 在大部分情况下（针对 Rust 的基础类型和 std 中的大部分类型），会由编译器自动推导出来。对于不能由编译器自动推导出来的类型，要使它们具有 <code>Send</code> 或 <code>Sync</code> 的约定，可以由人手动实现。实现的时候，必须使用 <code>unsafe</code> 前缀，因为 Rust 默认不信任程序员，由程序员自己控制的东西，统统标记为 <code>unsafe</code>，出了问题（比如，把不是线程安全的对象加上 <code>Sync</code> 约定）由程序员自行负责。</p>
<p>它们的定义如下：</p>
<p>如果 <code>T: Send</code>，那么将 <code>T</code> 传到另一个线程中时（按值传送），不会导致数据竞争或其它不安全情况。</p>
<ol>
<li><code>Send</code> 是对象可以安全发送到另一个执行体中；</li>
<li><code>Send</code> 使被发送对象可以和产生它的线程解耦，防止原线程将此资源释放后，在目标线程中使用出错（use after free）。</li>
</ol>
<p>如果 <code>T: Sync</code>，那么将 <code>&amp;T</code> 传到另一个线程中时，不会导致数据竞争或其它不安全情况。</p>
<ol>
<li><code>Sync</code> 是可以被同时多个执行体访问而不出错；</li>
<li><code>Sync</code> 防止的是竞争；</li>
</ol>
<p>推论：</p>
<ol>
<li><code>T: Sync</code> 意味着 <code>&amp;T: Send</code>；</li>
<li><code>Sync + Copy = Send</code>；</li>
<li>当 <code>T: Send</code> 时，可推导出 <code>&amp;mut T: Send</code>；</li>
<li>当 <code>T: Sync</code> 时，可推导出 <code>&amp;mut T: Sync</code>；</li>
<li>当 <code>&amp;mut T: Send</code> 时，不能推导出 <code>T: Send</code>；</li>
</ol>
<p>（注：<code>T</code>, <code>&amp;T</code>, <code>&amp;mut T</code>，<code>Box&lt;T&gt;</code> 等都是不同的类型）</p>
<p>具体的类型：</p>
<ol>
<li>原始类型（比如： u8, f64），都是 <code>Sync</code>，都是 <code>Copy</code>，因此都是 <code>Send</code>；</li>
<li>只包含原始类型的复合类型，都是 <code>Sync</code>，都是 <code>Copy</code>，因此都是 <code>Send</code>；</li>
<li>当 <code>T: Sync</code>，<code>Box&lt;T&gt;</code>, <code>Vec&lt;T&gt;</code> 等集合类型是 <code>Sync</code>；</li>
<li>具有内部可变性的的指针，不是 <code>Sync</code> 的，比如 <code>Cell</code>, <code>RefCell</code>, <code>UnsafeCell</code>；</li>
<li><code>Rc</code> 不是 <code>Sync</code>。因为只要一做 <code>&amp;Rc&lt;T&gt;</code> 操作，就会克隆一个新引用，它会以非原子性的方式修改引用计数，所以是不安全的；</li>
<li>被 <code>Mutex</code> 和 <code>RWLock</code> 锁住的类型 <code>T: Send</code>，是 <code>Sync</code> 的；</li>
<li>原始指针（<code>*mut</code>, <code>*const</code>）既不是 <code>Send</code> 也不是 <code>Sync</code>；</li>
</ol>
<p>Rust 正是通过这两大武器：<code>所有权和生命周期</code> + <code>Send 和 Sync</code>（本质上为类型系统）来为并发编程提供了安全可靠的基础设施。使得程序员可以放心在其上构建稳健的并发模型。这也正是 Rust 的核心设计观的体现：内核只提供最基础的原语，真正的实现能分离出去就分离出去。并发也是如此。</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ol>
<li><a href="https://github.com/rustcc/RustPrimer">https://github.com/rustcc/RustPrimer</a></li>
</ol>
]]></content>
      <categories>
        <category>rust</category>
      </categories>
      <tags>
        <tag>rust</tag>
      </tags>
  </entry>
  <entry>
    <title>远程服务器的 Git 使用本地的密钥——ssh-agent</title>
    <url>/linux/ssh-agent/</url>
    <content><![CDATA[<h1 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h1><p>有的时候我们在远程服务器上开发，但是远程服务器有多个人使用，我们并不想把自己的私钥放到服务器上，但是又想通过私钥连接到 Github 等远程仓库，那么该怎么做呢？</p>
<h1 id="SSH-Agent"><a href="#SSH-Agent" class="headerlink" title="SSH Agent"></a>SSH Agent</h1><p>SSH Agent 是一个程序，用于管理多个 SSH 密钥并为 SSH 协议提供身份验证服务。它主要用于以下几点：</p>
<ul>
<li>密钥管理：SSH Agent 可以存储用户的私钥，并在需要时提供给 SSH 客户端，从而避免每次连接时都需要输入密码。</li>
<li>身份验证：当用户尝试连接到远程服务器时，SSH Agent 会自动处理身份验证过程，提高安全性。</li>
<li>多会话支持：用户可以在多个终端会话或应用程序中使用同一个 SSH Agent，而不需要重复加载密钥。</li>
<li>在使用 SSH 进行远程操作时，启动 SSH Agent 并将私钥添加到其中，可以简化连接过程并提高效率。</li>
</ul>
<p>例如，在 Linux 系统中，可以通过以下命令启动 SSH Agent 并添加私钥：<br><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">eval</span> `ssh-agent -s`<br>ssh-add ~/.ssh/id_rsa<br></code></pre></td></tr></table></figure><br>这样，后续的 SSH 连接将自动使用这些密钥进行身份验证。</p>
<h1 id="在-Windows-上开启-SSH-Agent"><a href="#在-Windows-上开启-SSH-Agent" class="headerlink" title="在 Windows 上开启 SSH Agent"></a>在 Windows 上开启 SSH Agent</h1><p>根据微软帮助，我们能够通过以下方式开启 ssh-agent 并加入我们的私钥：<br><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># By default the ssh-agent service is disabled. Configure it to start automatically.</span><br><span class="hljs-comment"># Make sure you&#x27;re running as an Administrator.</span><br>Get-Service ssh-agent | Set-Service -StartupType Automatic<br><br><span class="hljs-comment"># Start the service</span><br>Start-Service ssh-agent<br><br><span class="hljs-comment"># This should return a status of Running</span><br>Get-Service ssh-agent<br><br><span class="hljs-comment"># Now load your key files into ssh-agent</span><br>ssh-add <span class="hljs-variable">$env</span>:USERPROFILE\.ssh\id_ecdsa<br><br><span class="hljs-comment"># Check that it worked</span><br>ssh-add -l<br></code></pre></td></tr></table></figure></p>
<h1 id="vscode-中启用-SSH-Agent"><a href="#vscode-中启用-SSH-Agent" class="headerlink" title="vscode 中启用 SSH Agent"></a>vscode 中启用 SSH Agent</h1><p>首先要在 ssh 中开启 <code>ForwardAgent</code>，具体方法是编辑 ssh config：<br><figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript">Host <span class="hljs-keyword">async</span><span class="hljs-number">-004</span><br>    HostName IP<br>    ForwardAgent <span class="hljs-literal">yes</span><br></code></pre></td></tr></table></figure><br>之后在本地的 vsocde 设置中搜索 <code>Enable Agent Forwarding</code> 并开启。</p>
<p>之后 F1 搜索 Kill，关闭远程 vscode server，之后重新连接远程服务器，这个时候远程服务器上输入 <code>ssh-add -l</code> 应该能看到我们之前在 Windows 上添加的私钥，就实现了密钥的安全转发。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://learn.microsoft.com/zh-cn/windows-server/administration/openssh/openssh_keymanagement">https://learn.microsoft.com/zh-cn/windows-server/administration/openssh/openssh_keymanagement</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/394555196">https://zhuanlan.zhihu.com/p/394555196</a></li>
</ol>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>tensorflow 中的一些坑</title>
    <url>/uncategorized/tensorflow/</url>
    <content><![CDATA[<h1 id="Tensorflow-安装之后无法使用-GPU，但是-Pytorch-可以"><a href="#Tensorflow-安装之后无法使用-GPU，但是-Pytorch-可以" class="headerlink" title="Tensorflow 安装之后无法使用 GPU，但是 Pytorch 可以"></a>Tensorflow 安装之后无法使用 GPU，但是 Pytorch 可以</h1><p>有错误提示：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs pain">tensorflow/core/common_runtime/gpu/gpu_device.cc:2251] Cannot dlopen some GPU libraries. Please make sure the missing libraries mentioned above are installed properly if you would like to use GPU. Follow the guide at https://www.tensorflow.org/install/gpu for how to download and setup the required libraries for your platform.<br></code></pre></td></tr></table></figure></p>
<p>原因是 Tensorflow 无法使用 cudnn 的库，找个安装了 Pytorch 的环境，导出其中的 cudnn 路径：<br><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> CUDNN_PATH=~/miniconda3/envs/sd/lib/python3.12/site-packages/nvidia/cudnn<br><span class="hljs-built_in">export</span> LD_LIBRARY_PATH=<span class="hljs-string">&quot;<span class="hljs-variable">$CUDNN_PATH</span>/lib&quot;</span>:<span class="hljs-variable">$LD_LIBRARY_PATH</span><br></code></pre></td></tr></table></figure></p>
<p>之后测试通过：<br><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<br><span class="hljs-built_in">print</span>(tf.test.is_gpu_available())<br></code></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>ai</tag>
      </tags>
  </entry>
  <entry>
    <title>一些杂记</title>
    <url>/uncategorized/%E6%9D%82%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>本杂记包括了一些思考和记录，具体涉及到的内容包括：</p>
<ul>
<li><a href="https://space.bilibili.com/391930545/channel/collectiondetail?sid=598034">Maki的完美算术教室的个人空间-Maki的完美算术教室个人主页-哔哩哔哩视频 (bilibili.com)</a></li>
</ul>
<h1 id="如何高效地读数学书"><a href="#如何高效地读数学书" class="headerlink" title="如何高效地读数学书"></a>如何高效地读数学书</h1><p>“the best way to learn is to teach“. 学习的方法按效率从低到高可以排为</p>
<ul>
<li>传统的上课听讲模式, 完全被老师牵着鼻子走</li>
<li>自己啃书, 补全细节, 勤用互联网, 老师, 同学等资源</li>
<li>以教会别人为目的的学习</li>
</ul>
<p><strong>数学的核心</strong>（对于小学数学、中学数学、大学数学乃至数学家学习数学都是需要掌握这些，数学的核心对于不同人可以不一样）</p>
<ul>
<li><strong>概念</strong>（不是每一个概念都是重要的概念，但是作为老师教的每一个概念都是重要的）</li>
<li><strong>定理</strong>（连接不同的概念，有些是联系（贯穿）两个领域，用A领域的方法解决B领域的问题）</li>
<li><strong>方法</strong>（最难教的就是方法。概括，归纳，总结之后才会有方法。每一门数学（代数，分析，几何）都有对应的方法。方法和经验成正比。方法有基础和进阶的，学会性质和做练习掌握基本的方法，通过掌握引理和定理加做练习掌握高级的方法）</li>
</ul>
<p><strong>数学书的内容</strong></p>
<ul>
<li><strong>定义</strong>：花很多时间在问自己为什么这么定义（看数学书很多时候，搞明白了为什么这么定义才能读懂。定义是必须要记住的，定理性质引理都是围绕定义概念展开）</li>
<li>例子（证明）</li>
<li>性质（证明）（定义的简单性质）</li>
<li>引理（证明）</li>
<li>定理（（包含推论）（证明）（历史上很多时候是先有定理）怎么记住定理：问自己为什么会有这个定理）要能举出例子，不能停留在会证明。定理是非常重要的命题。群同构第一定理为什么重要，因为很多地方用到</li>
<li>练习（证明）</li>
</ul>
<h1 id="如何燃起自己的热情"><a href="#如何燃起自己的热情" class="headerlink" title="如何燃起自己的热情"></a>如何燃起自己的热情</h1><h2 id="有限VS无限"><a href="#有限VS无限" class="headerlink" title="有限VS无限"></a>有限VS无限</h2><p>当你的目标有限时，你就有了一个上确界，不会超过它。比如拿菲尔茨奖不是一个好目标，一是比较虚荣，二是拿到了之后论文数量少了25%，而且写出来论文引用频率下降了（菲尔茨奖的魔咒）。</p>
<p><strong>理想情况</strong>是目标趋于+∞，目标是变动的，趋于+∞越快越好。</p>
<h2 id="热情从何而来"><a href="#热情从何而来" class="headerlink" title="热情从何而来"></a>热情从何而来</h2><p>最小的想法是一个小火苗，可遇可不求。弱者思维会觉得很好笑，并评价自己肯定做不到，自我菲薄，强者思维也会笑，笑完之后觉得是可行的，并专注地执行下去，一直坚持。</p>
<p>坚持坚持再坚持，直到一个里程碑（反馈，新的热情）。</p>
<p>真正阻碍你的<strong>只有你自己</strong>。</p>
<p>没有借口、阻力、绝对要求，每天至少8小时。切勿三分钟热度， 每天都学，可以少量的微习惯。由积分中值定理可知，<strong>平均值</strong>很重要。</p>
<h2 id="纯粹"><a href="#纯粹" class="headerlink" title="纯粹"></a>纯粹</h2><p>不想太多，不去纠结，想想自己的目标，今天要写多少页讲义。</p>
<p>重在每天的努力，120分钟的电影，在人生中是努力119分钟，成功1分钟。</p>
<h2 id="一定完成的紧迫感"><a href="#一定完成的紧迫感" class="headerlink" title="一定完成的紧迫感"></a>一定完成的紧迫感</h2><p>每天早晨醒来，第一个想法是冥想。不必放假，每天时刻有一定要完成的紧迫感，一定要把“家里的漏水”处理好。重要的事，内因，非做不可，不做不行，日拱一卒。</p>
<h2 id="承诺"><a href="#承诺" class="headerlink" title="承诺"></a>承诺</h2><p>你敢不敢承诺？弱者思维不敢承诺，承诺了就一定要去做到，可以晚点。积分总值会是100，但是平均相对会动态变化。</p>
<p>先胜后战：先确定自己能大概率打赢，再去打，心里有数。不可以心里没数没有目标再去做事！</p>
<p>战什么？人性。不动脑子，是懒惰；想得太多。是贪婪。是在承诺的先决条件下，最好的状况是中庸和谐。</p>
<h2 id="不要让热情一次性烧完"><a href="#不要让热情一次性烧完" class="headerlink" title="不要让热情一次性烧完"></a>不要让热情一次性烧完</h2><p>手机到1%充电也可以，不要烧完。但是0%关机了再充电，就是要几分钟才能启动，内心要承受巨大的压力。</p>
<h1 id="克服自己的无知和无能"><a href="#克服自己的无知和无能" class="headerlink" title="克服自己的无知和无能"></a>克服自己的无知和无能</h1><p>无知不意味着自己的愚蠢、不思上进、头脑空空，而是意味着自己承认自己的认知（知识、思维等）存在盲区，需要提升。即承认无知不是否定自己，而是承认自己存在进步空间。</p>
<p>无能同理，是承认自己没有做到本可以做到的事情，而非自我贬低成废物。 如何克服？很难，要吃苦。</p>
<p>欲戴王冠，必承其重。 </p>
<p>我们很容易将平易的生活看做理所当然，将他人的成功看做天才的必然，殊不知生活中有许多等着我们处理的事，他人为了成功做出改变、克服困难、花费努力。 </p>
<p>这是一种认知上的“桎梏”，需要跳出过去的失败、现在的迷惘、“娱乐至死”的陷阱以及情绪化的泥淖。</p>
<h2 id="克服“情绪无能”"><a href="#克服“情绪无能”" class="headerlink" title="克服“情绪无能”"></a>克服“情绪无能”</h2><p>（即沉湎于无尽或突然的情绪之中并无法自拔，对学业、事业产生长期或短期的恶性影响）</p>
<p>下法“替代批判”，用（某种角度或层面的）事实来替代：如生气→他人的问题，自卑、沮丧→自己的问题。</p>
<p>在面对自己的问题时，不可一味否定自己，尊重事实，并且给予自己鼓励。</p>
<p>中法“不批判”，跳出情绪的坑，不过多浪费时间。 上法“化批判为动力”，不受影响，从批判中汲取动力向前。</p>
<p>我们可以将“评价”、“情绪”、“结果”进行一个剥离。通常的逻辑是不理想的结果→较低的自我评价→负面情绪→下次行动时逃避或“惯性失败”循环。</p>
<p>客观认识不理想的结果，分析出其中的主客观上的问题，提升自己的认知与能力；客观认识情绪，知道情绪是长期进化所形成的，接纳情绪而非为情绪所困；正视自己，不夸大自己的能力，也不轻易贬低自己。</p>
<h2 id="克服“事业无能"><a href="#克服“事业无能" class="headerlink" title="克服“事业无能"></a>克服“事业无能</h2><p>（即不能做/做好事情，指事项、事务、事业）</p>
<p>（1）依旧是克服情绪化，即情绪干扰做事；（2）投入与产出，即用相对客观的视角评价目前的方法、进度；（3）人与贡献，更加注意区分数量与质量。</p>
<p>做事不能只凭着一腔热血或者跟着感觉走，就好比走路，一个人不可能在不知道自己的方向、位置、速度、时间的情况下走到终点，因此做事时必然要不时进行评估。同时在许多情况下，数量堆叠不能换来质量飞升，但是许多人早已习惯把数量当质量，就如同盲目刷题那样，不知所以。</p>
<p>（4）把握关键目标（某种意义、价值），并且将其拆解成可执行、可评价的阶段目标。</p>
<p>（5）识别做事的关键方法，并且无局限地优化。 所做的事情拥有某种崇高价值时人才会有较强的动力，但虚无缥缈的目标不利于指导人的行为，因此要进行拆解。至于优化方法，则是一种不断优化、追求进步的突破，这种突破的追求往往因为得过且过的心理而不能发生，因此要保持这种追求。</p>
<p>（6）小本本记想法 看起来简单甚至有些笨的想法，但是功用巨大。记录想法、做法、结果，我想我可以尝试（总是苦恼某些碎片化的想法转瞬即逝）。 </p>
<p>（7）突破认知、超越前人。“圣人无常师”，学习是为了提升自己，而当有超越一位老师（亦或是友人、亲长、前辈等）的心思时，才有了站在ta的肩上拾级而上、继续发展的基础。 </p>
<p>（8）批判性视角。从局中抽离，准确认知人事物。</p>
<p>“无能之无能” 认识到能力问题，不回避能力问题，解决能力问题。 </p>
<p>问题是提升能力问题很痛苦。 解决自己的无能、解决情绪化、解决愚笨（慢反应）与小聪明（自以为是）。 </p>
<p>将自己与社会、世界联系起来，不能遗世而独立。 继承昨日的优秀，改善昨日的问题，让问题在今日消失，让渺远的未来不在迷惘。</p>
<h1 id="学习专注力"><a href="#学习专注力" class="headerlink" title="学习专注力"></a>学习专注力</h1><p>1、SMART Goal原理 围绕一个目标专注（目标感）</p>
<p>Specific 具体的<br>Measurable 可量化<br>Attainable 可实现<br>Reward 奖励，适当奖励<br>Time 时间投入</p>
<p>常见误区：高估一天能做到的事情，低估一年能做到的事情。急于求成，没有长期规划，没有持续投入。</p>
<p>2、在于质量，不在于数量，追求效果</p>
<p>3、环境很重要，避免干扰</p>
<p>4、专注力锻炼，干扰下强制专注</p>
<p> 5、避免社会诱惑的干扰</p>
<p>6、善于利用辅助工具，减少工作量，提升正向反馈出现的概率。</p>
<h1 id="预备队思想"><a href="#预备队思想" class="headerlink" title="预备队思想"></a>预备队思想</h1><p>以正合以奇胜。</p>
<p>奇兵：预备队</p>
<p>未雨绸缪</p>
<p>凡事预则立，不预则废</p>
<h1 id="关于嘲笑"><a href="#关于嘲笑" class="headerlink" title="关于嘲笑"></a>关于嘲笑</h1><p>本质：传递负面能量的方式，人性之恶。</p>
<p>一种刻意塑造的对立和优越感，是为浮躁。</p>
<p>「千万不要像……样子」、「你什么档次，跟我……」</p>
<p>刻意对立 <code>-&gt;</code> 抬高优越感 <code>-&gt;</code> 嘲笑不断 <code>-&gt;</code> 形成本能</p>
]]></content>
  </entry>
  <entry>
    <title>非暴力沟通</title>
    <url>/uncategorized/%E9%9D%9E%E6%9A%B4%E5%8A%9B%E6%B2%9F%E9%80%9A/</url>
    <content><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>本文是对《非暴力沟通-两性篇》的总结和记录</p>
<p><strong>子曰：“仁远乎哉？我欲仁，斯仁至矣。”</strong></p>
<p>作者的核心观点是：人的需要在得到满足的时候会产生一些感受，在没有得到满足时会产生另一些感受。我们需要听到感受和隐藏在感受之后的核心需要以及对方需要我们怎么做来满足他们的核心需要。</p>
<p>我没有把他写成正面感受或者负面感受，是因为作者认为负面情绪和正面情绪都是有价值的，因为它们都是对生命的诉说，即都表达了需求有没有得到满足。（如果你爱的人愿意将自己的痛苦表达出来，你是否会认为这是一种消极和不愉快的体验呢？）</p>
<p>当我们开始生气或即将发动攻势时，我们首先要做的就是意识到我们可能没有听清对方的话。</p>
<p>少评判，多想想对方到底想表达什么。</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="感受词汇卡"><a href="#感受词汇卡" class="headerlink" title="感受词汇卡"></a>感受词汇卡</h2><h3 id="需要得到满足时的感受"><a href="#需要得到满足时的感受" class="headerlink" title="需要得到满足时的感受"></a>需要得到满足时的感受</h3><p>兴奋、喜悦、欣喜、甜蜜、精力充沛、兴高采烈</p>
<p>感激、感动、乐观、自信、振作、振奋、开心、高兴</p>
<p>快乐、愉快、幸福、陶醉、满足、欣慰、心旷神怡</p>
<p>喜出望外、平静、自在、舒适、放松、踏实、安全</p>
<p>温暖、放心、无忧无虑</p>
<h3 id="需要没有得到满足时的感受"><a href="#需要没有得到满足时的感受" class="headerlink" title="需要没有得到满足时的感受"></a>需要没有得到满足时的感受</h3><p>害怕、担心、焦虑、忧虑、着急、紧张、心神不宁</p>
<p>心烦意乱、忧伤、沮丧、灰心、气馁、泄气、绝望</p>
<p>伤感、凄凉、悲伤、恼怒、愤怒、烦恼、苦恼、生气</p>
<p>厌烦、不满、不快、不耐烦、不高兴、震惊、失望</p>
<p>困惑、茫然、寂寞、孤独、郁闷、难过、悲观、沉重</p>
<p>麻木、精疲力尽、萎靡不振、疲惫不堪、昏昏欲睡</p>
<p>无精打采、尴尬、惭愧、内疚、妒忌、遗憾、不舒服</p>
<h2 id="两性相处时的典型冲突"><a href="#两性相处时的典型冲突" class="headerlink" title="两性相处时的典型冲突"></a>两性相处时的典型冲突</h2><p>女性认为男性并没有清楚地表达出自己内心的感受和想法，像约翰·韦恩这样的男人就是通过简单粗暴地给别人“贴标签”模式来交流的，即在他的眼里，要么是好人，要么是坏蛋，是好人就请他喝一杯，是坏人就直接干掉好了。</p>
<p>通过这样的沟通方式，很多男人根本不知道怎样和自己的情绪建立联系。事实上，作为一名男性，作者（马歇尔）之前接受的基本上也是这种沟通方式的训练。如果他被训练成了一名战斗英雄，那么他就不希望自己的意识受制于自己的感受。所以，对于一个可能一直在玩洋娃娃的女人来说，嫁给一个长年在枪林弹雨里摸爬滚打的战斗英雄并不见得是一种很美好的体验。因为女人希望他们之间保持亲密，而这位战斗英雄的词典中压根儿就没有“亲密”这个词。</p>
<p>另外，很多女人并没有学会怎样清楚地了解自己的需要。几个世纪以来，她们被灌输的思想都是如何忽略和克制自己内心的需要，以体谅和照顾男人的感受。因此，她们常常依赖于男人的引领，并在某种程度上期望男人能够猜出她们需要什么、想要什么，继而顾及并满足她们的需要。</p>
<h1 id="关于婚姻"><a href="#关于婚姻" class="headerlink" title="关于婚姻"></a>关于婚姻</h1><p>由于我们被灌输了太多关于“婚姻意味着什么”的疯狂观念，所以我们会发现，维系夫妻间的婚内关系要比处理情侣间的未婚关系复杂得多。但同时，我发现，当我不再把和我一起生活的那个人看作“我的妻子”的时候，我就能更好地享受婚姻，因为在我所处的文化环境中，当有人提到“我的妻子”时，他会不由自主地认为妻子是他的某种私人财产。</p>
<p>非暴力沟通能帮助我们建立起一种关系，在这种关系中，我们彼此能够发自内心地互相给予。这就意味着，当与伴侣相处时，我们不会再因为自己顶着“妻子”“丈夫”的名头而暗含着我们“有责任”、“有义务”、“理应”或“必须”为对方做些什么，也不必再因为内疚、羞愧、潜意识、恐惧、义务或责任而去给予。在我看来，如果我们为伴侣做任何事情都是在这类动因的驱使下才完成的，我们每个人也会因此而迷失自我。当我们接受源自这类动因而被给予的任何东西时，我们也知道自己必将为此付出代价，因为这种给予是以牺牲对方的利益为前提的。因此，非暴力沟通真正令我感兴趣的是，这是一种能够让我们为对方真诚付出的沟通方式。</p>
<p>如果我们学会了发自内心地给予，并在给予时感觉就像接受时一样快乐，结果会怎么样呢？当我们以一种极富人情味的方式去做一件事情时，我认为给予者与接受者并没有太大的区别。反之，当我们以一种我称之为评判的方式彼此互动时，给予才会显得不那么有趣。</p>
<h1 id="四个问题"><a href="#四个问题" class="headerlink" title="四个问题"></a>四个问题</h1><p>你能告诉我，作为你的伴侣或朋友，我曾经做过哪件事，让你感到你的生活不那么美好吗？（观察）</p>
<p>当我做这件令你感到不开心的事时，你的感受如何？（感受）</p>
<p>你的哪些需要没有得到满足呢？（需要）【“我有这样的感受是因为我原本喜欢<strong>_</strong>（或者因为我原本想<strong>_</strong>/原本希望<strong>_</strong>/原本渴望<strong>_</strong>）】</p>
<p>我们能够做些什么，让彼此的生活变得更加美好呢？（请求）</p>
<p>非暴力沟通的主旨就是，在任一特定情境下，将这四个方面的内容准确地传递给对方。当然，我们的需要并不是总能得到满足。在非暴力沟通中，我们也会说“谢谢”，并通过回答前三个问题来告诉对方，他们怎样真正地充实了我们的生活。我们会告诉他们：（1）他们所做的哪些事情充实了我们的人生；（2）我们有什么样的感受；（3）我们的哪些需要因他们的行为而得到了满足。</p>
<h2 id="评判"><a href="#评判" class="headerlink" title="评判"></a>评判</h2><p>阻碍人们坦诚交流的沟通方式主要有两种。第一种是任何听起来含有评判对方之意的讯息。</p>
<p>你只是在第一个问题描述他们的行为时涉及了他们，并没有评判他们的行为。第二个到第四个问题都是关于你自己的：你的感受、你未得到满足的需要和你的请求。如果你的问题中有什么字眼容易被对方听成是对他们的指责，我猜想你肯定是在这四部分内容中夹杂了自己的一些评判。</p>
<h2 id="强制"><a href="#强制" class="headerlink" title="强制"></a>强制</h2><p>第二种阻碍人们坦诚交流的沟通方式是任何带有强迫意味的暗示。作为一名想用非暴力沟通方式进行交流的人，你希望向对方传达你刚才所写下的这四个方面的内容，让他觉得这是一份礼物、一个交心的机会，而不是一种要求或者命令。</p>
<p>在非暴力沟通语言中，评判和命令是要杜绝的。当我们告诉他人自己的请求需要什么时，我们传达的信息是：“如果你愿意，请这样做，但不要以牺牲你自己的需要为代价为我做任何事情，也永远不要为我做任何可能会给你带来哪怕一丝恐惧、内疚、羞愧、怨恨或屈服感的事情，不然，我们都会感到痛苦。请遵从你的内心，如果你觉得，满足我的需要对你自己而言也是一份礼物，那么我希望你能尊重我的请求。”只有当彼此都不觉得自己是在损失、付出或屈服时，这一行为才是双赢的。</p>
<h2 id="同理倾听"><a href="#同理倾听" class="headerlink" title="同理倾听"></a>同理倾听</h2><p>非暴力沟通主要由两个关键部分组成：第一部分是要向对方清楚明白地传达有关这四个方面的信息，但不能让对方觉得你是在评判或者命令他。第二部分则是学会去倾听对方发出的有关这四个方面的信息，而<strong>不要去关注他们是在指责你还是在以非暴力沟通方式与你交流。</strong></p>
<p>例如，当对方说“你知道吗？你的问题就在于<strong><strong>”时，通过这对耳朵我听到的是“我希望你能</strong></strong>”。我并没有听到任何评判、指责或攻击。通过这样一对耳朵，我能够意识到，所有批评都是对方的需要没有得到满足时的一种值得同理的宣泄。</p>
<p>之所以说其值得同理，是因为这样的表达方式通常说明表达者的需要没有得到满足时，会导致各种紧张局面相继出现。凭借非暴力沟通语言的技巧，我们就能够越过这个坎。因为我们从来听不见指责，我们听到的永远只有对方那些<strong>未被满足的需要</strong>。</p>
<h2 id="安慰和同理心的区别"><a href="#安慰和同理心的区别" class="headerlink" title="安慰和同理心的区别"></a>安慰和同理心的区别</h2><p>马歇尔：如果对方说他们确实需要安慰，而与此同时，我们也心甘情愿地想去安慰他们，那就没有什么问题。但如果他们想要的是同理心，而我们给他们的却是安慰，这时，问题就来了。比如，有一次，我的大女儿一边照镜子，一边说：“我丑得像头猪。”“不，你是世界上最美丽的女孩！”我立马说道。她喊了声“爸呀”，然后就摔上门出去了。事实上，我当时就是在那里做着评判，而她其实是希望我留意她的感受，但是我却尝试着去安慰她，我这么做实则是为了满足我自己的需要。然后，你们猜猜我做了什么？我对自己做了一番检讨之后，走进了另外一个房间，边走边说：“你一年到头每一天都在宣扬这个，但当它发生在你自己身上时，你却忘记了。你忘了那句箴言：‘不要急着做什么，站在那里就好。’”之后，我走到她面前，对她说：</p>
<p>我猜你需要的是我能体会到你对自己形象的失望之情，而不是我的安慰。</p>
<p>女儿（参与者I扮演）：是的，你总想着和稀泥敷衍我。（观众发出笑声）</p>
<p>马歇尔：嗯，我认罪。</p>
<h1 id="如何表达感激"><a href="#如何表达感激" class="headerlink" title="如何表达感激"></a>如何表达感激</h1><p>马歇尔：在表达感激时，我们需要记住三个要素。不要试图通过语言去赞扬，因为在非暴力沟通中并没有赞扬之类的东西，赞扬实际上是一种典型的评判技巧。赞扬是为了操纵对方，让对方按照我们希望的方式去行事，而感激则只是表明对方的行为给我们带来了一种美好的感受。经理们会觉得赞扬很管用，他们说，有研究表明，如果他们每天至少赞扬员工一次，员工会更加努力地工作。虽然赞扬在短时间内可能有效，但一旦员工们发现经理们的赞扬是出于操纵他们的目的，赞扬就将失去作用。在非暴力沟通中，我从来不会为了尝试得到任何回报而去表达感激。我们表达感激只是为了去“祝贺”他人的行为，为了让对方知道他们所做的一些事情给我们带来了很棒的感受。表达发自内心的感激的三个要素是：</p>
<p>（1） 我们需要很明确地知道对方做了什么让我们想要感激；</p>
<p>（2） 我们的感受；</p>
<p>（3） 这让我们的什么需要得到了满足。</p>
<h1 id="非暴力沟通对“爱”是如何理解的"><a href="#非暴力沟通对“爱”是如何理解的" class="headerlink" title="非暴力沟通对“爱”是如何理解的"></a>非暴力沟通对“爱”是如何理解的</h1><p>马歇尔：以上阐述可能会让你明白，非暴力沟通实际上来源于我在理解爱、表达爱和践行爱方面所做的尝试。我所得出的结论是，爱不只是我们所感受到的，还是我们所表达的、所做的和所拥有的。同时，爱还是我们能够给予别人的：我们通过某种方式奉献自己的时间和精力。任何时候，当你真诚地展示自己，敞开心扉，别无所求时，这本身就是一种恩赐。不指责，不批评，也不惩罚，只是告诉你自己：“这就是我，这就是我想要的，这就是我脆弱的地方。”而在我看来，这种给予就是爱的表现。</p>
<p>我们对他人的倾听是我们奉献自己的另外一种方式。带着同理心去倾听他人，与他们的内心联系在一起，不做任何评判，这就是一份礼物。当我们尝试去倾听别人的心声和他们想要的东西时，这也是一种礼物。所以，非暴力沟通只是我所理解的爱的一种表现。这么看来，它就类似于“爱人如己”和“不论断人，就不受论断”的观念。</p>
<p>当我们以这种方式与人交流时，不可思议的事情就会发生。这种美、这种力量将我们与一种神奇的能量联系在了一起。所以，非暴力沟通能够帮助我将这种美丽而神圣的能量长留在心中，让我能够通过这种能量与他人建立联系，而这就是我所经历过的最接近于“爱”的东西。</p>
]]></content>
  </entry>
  <entry>
    <title>阿德勒心理学讲义</title>
    <url>/uncategorized/%E9%98%BF%E5%BE%B7%E5%8B%92%E5%BF%83%E7%90%86%E5%AD%A6%E8%AE%B2%E4%B9%89/</url>
    <content><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>本文是对《阿德勒心理学讲义》的总结和记录</p>
<p><strong>子曰：“仁远乎哉？我欲仁，斯仁至矣。”</strong></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>阿尔弗雷德·阿德勒（Adler Alfred,1870-1937），奥地利心理学家，个体心理学派创始人，人本主义心理学先驱，现代自我心理学之父。阿德勒认为人们为得到满足和实现自我而一生努力奋斗，以补偿产生自童年时期的强烈自卑感。大部分人可以满意地实现补偿，而那些没有成功实现补偿的则发展为神经症。他与弗洛伊德和荣格并称为20世纪精神分析学派三大巨擘。</p>
<p>阿德勒出生在奥地利维也纳郊区的一个犹太粮商家庭，家境富裕。他在家中六个孩子中排行老三。3岁时，睡在身旁的弟弟去世，他幼年又有两次被车撞的经历，使他十分畏惧死亡。5岁时得了肺炎，痊愈后他决定当医生。</p>
<p>1895年，阿德勒进入维也纳大学学习，取得医学博士学位，成为一名眼科医师，他特别注意身体器官的自卑，认为它是驱使个人采取行动的真正动力。后转向精神病学研究，曾追随弗洛伊德探讨神经症问题。</p>
<p>1896年4月到9月，他应征服役，在奥地利军队的一所医院工作。1897年到1898年，他又回到维也纳大学深造。期间，他和来自俄国的留学生罗莎（Raissa Timofeyewna Epstein）结婚。他们生育四个孩子，三女一男，其中亚历山德拉（Alexandra）和库尔特（Kurt）后来成为阿德勒学派的心理学家。</p>
<p>1899年至1900年，他与弗洛伊德在同一个城市行医，两人结识并成为好友。不久，他又和威廉·斯特克尔一起从事《心理分析汇编》的编辑工作。1902年，阿德勒与精神分析创始人弗洛伊德成为当时精神分析学派的核心成员。他是第一个虔诚地对弗洛伊德理论产生兴趣的人，认识到其理论打开了精神病学和心理学一个新发展阶段。</p>
<p>1908年在奥地利萨尔茨堡召开的第一次国际心理分析会议上，阿德勒发表了关于“好斗的冲动”的报告。1910年任维也纳精神分析学会主席。1911年因突出强调社会因素的作用，拒绝接受弗洛伊德将性作为人类行为的重要动机的观点，公开反对弗洛伊德的泛性论而两人关系破裂，阿德勒创立个体心理学（Individual Psychology），另建自由精神分析研究会。1912年改称个体心理学会，成为一个颇有影响的学派。1914年他创办《国际个体心理学杂志》。1920年后他任教于维也纳教育学院，并在学校系统中组织儿童指导临床活动，成立儿童指导中心。1922年至1930年期间，他主持召开了五次国际个体心理学会议。1926年任美国哥伦比亚大学客座教授。1932年他到长岛医学院主持美国医学心理学的第一个讲座。1934年定居纽约。1937年赴苏格兰亚伯丁做讲演旅行时病逝。</p>
<p>阿德勒的学说以“自卑感”与“创造性自我”为中心，并强调“社会意识”。主要概念是创造性自我、生活风格、假想的目的论、追求优越、自卑感、补偿和社会兴趣。他继承了弗洛伊德的精神分析理念，但其基本观点与之大相径庭。</p>
<p>个体心理学认为人的行为是由社会力量决定的。阿德勒认为人天生就是一种社会存在物，在社会生活中，人们进行交往，相互依赖，相互合作；而弗洛伊德则强调人的生物学本能，人的成长过程是本能的自然展开，其行为是先天决定的。</p>
<p>个体心理学视人格为统一的整体，强调其不可分割。阿德勒认为每个人的人格都是内在各种动机、特质、兴趣、价值所构成的统一整体；弗洛伊德把人格分为本我、自我、超我这些不同的部分，各部分各司其职。</p>
<p>阿德勒认为人是一个有意识的存在物。通常，人能意识到行为的动机，意识与无意识并非绝对对立。对某些事物，如果我们意会到了，那么就是意识的；如果失于意会，那么就是无意识的。意识的行为是人类主要的行为。</p>
<p>阿德勒强调未来对人的行为的影响。他认为，人既然是有意识的，就能意识到未来的种种条件，制定某种计划用以指导自己的行为。阿德勒也承认过去的经验（特别是原始的经验）对人的行为有影响，但他认为不是决定性的。</p>
<p>个体心理学认为性只是人类行为的动力因素之一。阿德勒并不完全否认性的作用，但他认为性的作用在决定人的行为方面只扮演一个极不重要的角色。他认为，真正对人的行为起作用的还是人的社会需要。</p>
<p>阿德勒个体心理学思想主要概念包括以下方面：</p>
<p>一是追求优越。阿德勒认为，追求优越是人们行为的根本动力，也是阿德勒个体心理学的核心。他认为人人都有一种向往权力意志这种天生的内驱力，力图做一个没有缺陷的、完善的人。因此羡慕别人、胜过别人、征服别人等都是这种追求优越的人格体现。阿德勒区分了追求优越的两种不同方法：一种是只追求个人优越，很少关心他人，其行为往往受过度夸张的自卑感驱使。另一种是追求一种优越、完善的社会，使每个人都获得益处。</p>
<p>二是自卑与补偿。阿德勒把自卑与补偿看作是追求优越的动力根源。他指出，自卑与补偿是与生俱来的。因为人在婴幼儿时期，在生理、心理和社会三方面都处于劣势，需要依赖成年人才能生存，他们由此必然产生自卑和补偿心理。当然，这种自卑与补偿心理在大多数情况下是正常的健康的反应，可以驱使人们实现自己的潜能。但是，如果不能成功地进行补偿，就会产生自卑情结，导致心理疾病的发生。</p>
<p>三是生活风格。阿德勒把个人追求优越的目标的生活方式称为生活风格。阿德勒认为儿童到5岁左右便形成了生活风格。其家庭关系、生活条件和经验决定了他今后一生的生活特点。他提出三种研究途径：出生顺序、早期记忆和梦的分析。</p>
<p>他指出，在家庭中，父母对子女教养的方式或给予的关注会根据子女的出生顺序而变化，同胞兄弟姐妹之间也常常因要争取父母的爱而相互竞争。因此，长子的性格特征是聪明、有成就需要但害怕竞争；次子喜欢竞争、有强烈的反抗性；最小的孩子有雄心但懒散、难以实现抱负。独生子女的性格类似于长子，因为其竞争对手往往来自学校的同学。</p>
<p>阿德勒根据人的记忆具有主观性、创造性和想象性的特点，认为个体对于自己早年生活的记忆往往为人们了解其独特的个性提供了线索。阿德勒认为意识和潜意识共同构成一个统一的整体，因此，梦能够显示一个人的生活风格。</p>
<p>四是创造性自我。阿德勒认为，每个人在形成自己的生活风格时并不是消极被动的，人是有意识的个体，可以选择自己的生活道路，参与决定自己的命运。创造性自我能够使我们成为自己生活的主人，决定了人的心理健康与否、社会兴趣正确与否。影响人的成长有三个要素，即遗传、环境和创造能力。其中创造能力起重要作用，它与其他两个要素结合起来，才能克服人生障碍。阿德勒反对弗洛伊德的宿命论观点，他认为人从遗传与早期经验中获得的只是一些“砖块”。它追求经验，甚至创造经验以帮助个人完成他独特的生活作风。</p>
<p>五是社会兴趣。社会兴趣是阿德勒个体心理学中的基本概念之一，是指对所有社会成员的一种情感，或指人具有一种为他人、为社会的先天思想准备和自然倾向。他认为人是社会性生物，人的本性具有社会兴趣的潜能。社会兴趣不仅是一种涉及与别人交往时的情感，它也是一种对生活的评价态度和认同能力。阿德勒还认为有无社会兴趣是衡量个体是否健康的主要标准，社会兴趣的水平决定一个人生活意义的大小和对社会贡献的程度。阿德勒认为社会兴趣是人类本性的一部分，植根于每个人的潜能之中，因此，必须先发展起社会兴趣，才能形成有用的生活风格。</p>
<p>阿德勒指出，可以通过人们的职业选择、参与社会活动和爱情婚姻这三大任务的解决情况来衡量其社会兴趣的发展状况。三大任务的顺利解决反映了个体具有丰富的社会兴趣，反之则是缺乏社会兴趣。缺乏社会兴趣的人会产生两种错误的生活风格：一种是优越情结；另一种是自卑情结。他还根据人们所具有的社会兴趣表现的特点，把人划分为四种类型：一是统治——支配型；二是索取——依赖型；三是回避型；四是社会利益型。他认为，前三种类型的人的社会兴趣和生活风格都是错误的，只有第四种类型的人具有正确的社会兴趣和健康的生活风格。</p>
<p>1927年，《阿德勒心理学讲义》（又译作《生活的科学》，The Science of Living）在英国首次出版，书中包括了个体心理学的主要原则。本书尤其有趣的是阿德勒的研究方法，他用大量的例子来说明他提出的理论观点。贯穿全书的主线是具有社会需要的理解和我们的意愿，有效地尽我们所能，为公共福利做出贡献的重要性。读者还会发现，常识在阿德勒的思维中起着重要作用。事实上，有一个故事，在一次心理学讲座上，有人评论他所说的一切都是些常识。“常识有什么不好？”他回答说。</p>
<p>阿德勒致力于倡导与人直接相关的心理学，即生活的心理学，他教给我们生活的“常识”，帮助我们了解自己的人生目标，从而活出生命的意义。人与生俱来就有追求成功和幸福的意愿，但并非总能如愿以偿。阿德勒认为，人如果丧失了具有社会价值的人生目标，就会产生自卑情结，从而陷入无益的生活面向。</p>
<p>阿德勒首创“自卑情结”一词，首度将“补偿作用”运用于心理学，开创了心理自助运动的先河——帮助人们与自卑感共存共荣，拥有有益的人生目标，进而活出生命的意义。</p>
<p>阿德勒指出：“每个人都有自卑感。”他所创立的个体心理学，紧扣“自卑感的问题与力量”发展，形成一套阿德勒的不完美生活哲学。自卑感是人类努力与成就的基础，却也是一切心理问题的根源。因此，阿德勒深入分析自卑感，揭开其副产品——“自卑情结”与“优越情结”对人们的戕害，并提出过好生活该有的“常识”“社会兴趣”与“社会适应能力”，期盼能帮助人们与自卑感共存共荣，消除情结的障碍，设定有用与健全的人生目标，进而活出生命的意义。</p>
<p>阿德勒主张，决定我们生活形态的“人生风格”（the style of life）在四五岁时就由“人生原型”决定。因此，对于孩童的教育要从小开始，而且方向必须正确。童年时期如果出了差错（如父母过于溺爱），未来就得付出很大的代价（如犯罪）。而对于行为出现偏差的人，最好的方法就是减低他们的自卑感（但无须完全根除，因为自卑感也是让人向上的力量），让他们发展出对人生有用的“社会兴趣”（social interest），进而导正他们的人生目标。</p>
<p>《阿德勒心理学讲义》以社会兴趣为核心，从原型、人格、童年、家庭、梦境、教育、人际关系、爱情与婚姻等人生百景出发，论道说理，揭示重点，并用形形色色的临床故事，来阐释、佐证，非常具有可读性和教育意义。</p>
<p>通过本书，你将能正确地认识自己，拥抱人人都有的自卑感，并将其化为养分，萌生勇气，面对一切挑战与逆境。</p>
<p>人，因不完美而奋发向上，而人生会因不完美而更趋完美。</p>
<p>阿德勒说：人，做得到任何事！他不在乎过去，不认同宿命论与天注定，主张事在人为，并如此相信：唯有你自己，能决定你人生的样貌；也唯有你自己，才能改写人生的剧本。阿德勒用一生观察并剖析“何而为人”，终得此结论。</p>
<h1 id="生活的科学-The-Science-of-Living"><a href="#生活的科学-The-Science-of-Living" class="headerlink" title="生活的科学-The Science of Living"></a>生活的科学-The Science of Living</h1><p>以阿德勒来说，他对心理学的兴趣源于行医。行医让我明了目的论（又称目标论）的观点。如果想了解心理事实，目的论是不可或缺的</p>
<p>在医学界，所有的器官都有明确的目标，并朝着该目标努力发展，等发展到一定的形态，就代表这些器官已发育成熟。此外，当器官出现缺陷时，自然会采取特别的方式来克服缺憾，或者改由其他器官承担缺损器官的功能。<strong>生命总会设法延续下去，而且在面对外来阻碍时，生命的力量绝不会还没挣扎就先高举白旗。</strong></p>
<p>人类心理层面的活动也和生命的功能面向类似。<strong>每一个人心里都有一个类似目标或理想的概念，一心想要超越现状，并通过制订出具体的未来方向，来克服目前的缺憾和困难。通过这个具体目标，人们得以想象未来成功的样貌，进而感受并认定自己必能超越当下的困境。要是感受不到目标，个人的所作所为只是行礼如仪，毫无意义可言。</strong></p>
]]></content>
  </entry>
  <entry>
    <title>2025 年的 Diffusion 在研究什么</title>
    <url>/uncategorized/Diffusion-2025/</url>
    <content><![CDATA[<h1 id="2024–2025年扩散模型最新研究综述"><a href="#2024–2025年扩散模型最新研究综述" class="headerlink" title="2024–2025年扩散模型最新研究综述"></a>2024–2025年扩散模型最新研究综述</h1><p>近年来，<strong>扩散模型</strong>（Diffusion Models）在生成建模领域取得了令人瞩目的成绩，特别是在图像合成等任务上达到了新的水准。2024年至2025年间，围绕扩散模型的学术研究进一步深入，集中在<strong>新方法、新架构和理论进展</strong>等方面。本文将对这一时期的代表性研究方向进行综述，涵盖模型效率提升、条件控制改进、生成质量优化、理论分析突破以及大模型架构升级等内容。我们将介绍每项研究的技术细节和贡献点，并指出其是否开源提供了代码。最后，附上一张汇总表格列出相关研究的名称、作者、来源、发布日期、内容简述和代码链接。</p>
<h2 id="模型效率与采样加速"><a href="#模型效率与采样加速" class="headerlink" title="模型效率与采样加速"></a>模型效率与采样加速</h2><p><strong>扩散模型的高计算量</strong>长期以来限制了其实用性，因此不少研究致力于<strong>提升采样效率、减少采样步数</strong>。2024年起，这一方向涌现出多种新方案：</p>
<ul>
<li><p><strong>潜在一致性模型的高效训练</strong>：Dao等人提出改进的潜在一致性模型训练方法。一致性模型（Consistency Model）是一类可单步生成样本的模型，但直接在大规模<strong>潜在空间</strong>（latent space）训练时表现不佳。该研究通过<strong>Cauchy损失</strong>替换Pseudo-Huber损失以抑制潜在空间中的<strong>离群值</strong>，并在早期扩散步加入额外的扩散损失，利用<strong>最优传输耦合</strong>降低噪声，引入<strong>自适应缩放调度</strong>和<strong>非缩放LayerNorm</strong>等技术，显著提升了一致性模型在潜在空间的训练稳定性。他们成功训练出<strong>一步或两步即可采样高质量图像</strong>的潜在一致性模型，使其生成质量接近常规多步扩散模型。实现代码已开源（项目<strong>sLCT</strong>）。这一工作缩小了一致性模型与扩散模型在潜在空间性能差距，对于<strong>加速文本到图像等大型扩散模型采样</strong>具有重要意义。</p>
</li>
<li><p><strong>上采样扩散概率模型（UDPM）</strong>：Abu-Hussein等人提出“Upsampling Diffusion Probabilistic Model”。不同于标准扩散模型在每一步仅降噪，该方法在<strong>正向过程</strong>中同时对数据进行<strong>降采样和加噪</strong>，即逐步降低分辨率并添加噪声；在<strong>逆过程</strong>则逐步<strong>去噪并上采样</strong>恢复清晰图像。这种设计大幅减少了所需的网络 eval 次数。在实验中，UDPM<strong>仅用3次网络eval</strong>即可生成图像，计算成本总计甚至<strong>低于传统DDPM一次迭代</strong>。它在CIFAR-10等数据集上取得了<strong>FID=6.86</strong>的优异成绩，超越了现有单步生成的高效扩散模型。此外，UDPM提供了<strong>可解释且可插值的潜在空间</strong>，弥补了扩散模型潜在空间难以解释的缺点。作者已在GitHub开源了代码，实现了在FFHQ等数据集上的高保真图像合成。</p>
</li>
<li><p><strong>高阶采样算法与加速理论</strong>：针对扩散模型<strong>采样步骤多、速度慢</strong>的问题，Li等人提出了<strong>无需重新训练</strong>即可加速采样的高阶算法。他们设计了改进的确定性采样器和随机采样器：新的确定性采样器（对应DDIM）收敛速率提升为$O(1/T^2)$，优于原DDIM的$O(1/T)$；改进的随机采样器（对应DDPM）收敛速率达$O(1/T)$，优于原DDPM的$O(1/\sqrt{T})$。这种方法借鉴了<strong>高阶ODE求解器</strong>（如DPM-Solver）的思想，并从理论上证明了采样效率的大幅提升。值得注意的是，该算法<strong>不需要额外训练</strong>，对扩散模型的打分估计误差具有鲁棒性。这一研究为<strong>扩散模型快速采样</strong>提供了坚实的理论支持。</p>
</li>
</ul>
<p>上述方法显著改善了扩散模型的采样效率，使高质量图像的生成可在极少步内完成。这对于扩散模型在实时应用中的部署具有深远意义。</p>
<h2 id="条件控制与多模态指导"><a href="#条件控制与多模态指导" class="headerlink" title="条件控制与多模态指导"></a>条件控制与多模态指导</h2><p>为了<strong>增强扩散模型生成的可控性</strong>，研究者提出了多种<strong>条件控制和引导机制</strong>，使模型能灵活地接受不同模态的条件或关注数据分布的稀有部分。</p>
<ul>
<li><p><strong>通用指导（Universal Guidance）</strong>：Bansal等人在ICLR 2024提出了一种<strong>通用条件引导算法</strong>。传统扩散模型通常针对特定条件（如文本）训练，无法直接应用新条件。该算法允许在<strong>不重新训练扩散模型</strong>的情况下，用任意模态的引导函数来控制生成过程。具体而言，在采样时通过与扩散过程并行的优化迭代，将外部条件（如分割图、人脸识别结果、目标检测框、图像风格或分类器输出等）转化为对噪声预测的附加引导，从而<strong>使预训练扩散模型接受新的条件约束</strong>。实验表明，该方法可成功利用多种指导信号生成相应图像。由于不需重新训练，通用指导具有很强的<strong>泛用性</strong>。作者提供了官方实现，验证了在不同条件下高质量图像生成的效果。</p>
</li>
<li><p><strong>少数样本指导（Minority Guidance）</strong>：Um等人在ICLR 2024提出了一个关注<strong>低密度区域样本</strong>的生成框架。扩散模型倾向于生成数据流形上高密度区域（多数类）的样本，对于<strong>低概率的少数类样本</strong>往往难以覆盖。该工作首先定义了一个衡量样本“独特性”的指标，以识别<strong>数据分布中的少数样本</strong>。然后提出了“少数指导”的采样技术，在扩散采样过程中引入一个<strong>引导项偏向低密度区域</strong>，鼓励模型探索具有目标罕见度的样本。通过这种引导，扩散模型生成<strong>高质量少数样本</strong>的能力大大提高。在医学影像等真实场景中，该方法依然显著提升了模型生成稀有案例的覆盖率和质量。作者已将代码开源，有助于后续研究者在<strong>公平性和多样性</strong>方向拓展扩散模型应用。</p>
</li>
<li><p><strong>跨模态上下文扩散模型（ContextDiff）</strong>：Yang等人在ICLR 2024提出<strong>ContextDiff</strong>框架，旨在<strong>增强文本指导下图像/视频生成的语义对齐</strong>。以往<strong>文本-图像扩散模型</strong>大多只在逆过程融入文本条件，对正向扩散过程的文本相关性考虑不足。这种不一致可能限制文本语义向生成结果的精确传达。为此，ContextDiff在<strong>正向和逆向过程</strong>中都注入跨模态的<strong>文本-视觉上下文信息</strong>，使文本条件在扩散的每个时间步都对噪声演化产生影响。通过对DDPM和DDIM过程的扩展，ContextDiff确保了<strong>扩散轨迹与文本条件的一致性</strong>。在文本到图像生成和文本引导视频编辑任务中，该方法取得了新的<strong>SOTA</strong>表现，大幅提升了生成图像与文本条件的语义一致性。作者提供了代码和模型，证明了在复杂跨模态任务中的有效性。</p>
</li>
</ul>
<p>通过上述改进，扩散模型在<strong>条件可控生成</strong>方面变得更加灵活强大。不仅能适应多种模态的条件约束，还能关注数据中的少数模式和增强跨模态语义对应，从而拓宽了扩散模型在<strong>可控生成和多样性</strong>领域的应用前景。</p>
<h2 id="图像质量提升与训练优化"><a href="#图像质量提升与训练优化" class="headerlink" title="图像质量提升与训练优化"></a>图像质量提升与训练优化</h2><p>除了速度和控制，<strong>提升生成内容的质量</strong>也是研究热点。2024年出现的若干工作聚焦于<strong>改进训练目标</strong>或<strong>生成过程细节</strong>，以获取更高保真的合成图像：</p>
<ul>
<li><p><strong>级联扩散模型结合感知损失</strong>：Jie An等人提出<strong>级联扩散模型（Cas-DM）</strong>，探索将<strong>度量函数（感知损失）引入扩散模型训练</strong>。以LPIPS感知损失为代表的度量在一致性模型中证明有效，但在扩散模型中直接加入会因<strong>训练目标不匹配</strong>而失败。Cas-DM通过<strong>两阶段网络级联</strong>解决了这一问题：第一阶段网络与标准DDPM类似，预测噪声$\epsilon$；第二阶段网络以初步重构的图像$x_0$为输入，输出精细的$x_0$预测，并预测一个动态加权系数用于融合两阶段输出。训练时，对第二阶段预测的$x_0$施加LPIPS损失并<strong>停止梯度回传给第一阶段</strong>，从而既优化图像感知质量又不干扰噪声预测分支。实验证明，Cas-DM成功将LPIPS等感知指标用于扩散模型训练，<strong>在多个基准数据集上取得了最先进的图像质量</strong>（FID、sFID和IS指标显著提升），生成图像的细节和逼真度明显改善。这一方法表明，通过合适的架构设计，<strong>感知级别的度量函数</strong>可以有效提升扩散模型的生成效果。目前论文未公开完整代码，但相关方法为扩散模型融入<strong>感知损失</strong>提供了范式。</p>
</li>
<li><p><strong>频域特征引导的生成优化（DMFFT）</strong>：2025年有研究将<strong>传统傅里叶频域分析</strong>引入扩散模型的生成过程。Wang等人在Scientific Reports发表文章，提出无需额外训练即可提升生成质量的<strong>DMFFT方法</strong>。他们分析了扩散模型U-Net中<strong>上采样阶段</strong>的特征，发现通过调整特征的<strong>频率分量（高频/低频）幅度和相位</strong>可以影响输出图像的质量。具体地，DMFFT在扩散模型上采样的<strong>交叉注意块（CrossAttnUpBlock）</strong>入口处嵌入一个傅里叶变换模块，根据经验调整不同频段的缩放系数，对特征进行频域调制。大量实验表明，该方法能够<strong>显著改善扩散模型生成图像/视频的语义对齐、结构布局、色彩纹理以及时序一致性</strong>，同时提升艺术表现力和多样性，而<strong>无需对扩散模型进行任何额外训练或参数改动</strong>。这意味着只需在推理阶段对特征做频域处理，即可增强输出质量。DMFFT开辟了一个从信号处理角度优化扩散生成的新思路。</p>
</li>
</ul>
<p>这些工作从训练目标和生成过程两个角度出发，提高了扩散模型生成结果的主观和客观质量。例如，Cas-DM通过引入感知损失使生成图像更加清晰自然，DMFFT则通过频域调控增强了图像的细节和一致性。这些改进对<strong>实际应用中获得高保真、无失真的生成结果</strong>非常关键。</p>
<h2 id="理论进展与分析"><a href="#理论进展与分析" class="headerlink" title="理论进展与分析"></a>理论进展与分析</h2><p>随着扩散模型的应用日趋广泛，<strong>理论研究</strong>也在努力解释和提高这些模型的性能。2024年至2025年出现了一系列工作，从<strong>收敛性理论</strong>到<strong>解析扩散过程</strong>等方面取得进展，加深了对扩散模型原理的理解：</p>
<ul>
<li><p><strong>扩散模型收敛率的提升分析</strong>：Li和Jiao等人在2024年针对扩散概率模型（DPM）的收敛性给出了更优的理论保证。此前的研究（如2023年Gupta等）已将扩散采样视作随机过程，并分析了迭代复杂度。Li等人通过引入<strong>随机中点方法</strong>，证明在无对数凹假设下，若采样误差容许$\epsilon$，则扩散模型要达到精度$\epsilon$所需的迭代次数可缩减为$O(d^{1/3}\epsilon^{-2/3})$（其中$d$为数据维度）。这一结果优于先前最佳的$O(d^{5/12}\epsilon^{-1})$复杂度，将依赖维度的阶降低了，并缩小了理论与实践间的差距。该工作无需假设目标分布对数凹，且允许近似的得分估计，更贴近真实扩散模型的条件。此理论进展为理解扩散模型的效率提供了新视角，并证明了<strong>更快采样收敛率</strong>在理论上是可实现的。</p>
</li>
<li><p><strong>确定性采样器的统一收敛分析</strong>：传统的扩散模型理论多依赖随机过程工具（如Girsanov定理）分析随机采样器，对<strong>确定性采样</strong>（如DDIM）缺乏统一理论。Runjia Li等人在2024年提出了一个<strong>统一分析框架</strong>，专门研究<strong>确定性扩散采样器</strong>的收敛性质。他们构建了一般性的分析方法，可适用于各种前向过程和确定性逆过程，弥补了以往只针对特定采样器分析的不足。利用该框架，作者举例分析了<strong>方差保持型前向扩散（VP-SDE）</strong>结合<strong>指数积分采样方案</strong>的情形，证明了$\tilde{O}(d^2/\epsilon)$的迭代复杂度；同时对常用的<strong>DDIM采样器</strong>给出了多项式复杂度的严格证明。这一统一理论为不同类型的扩散采样器提供了<strong>可比的收敛保证</strong>，有助于系统理解各种改进采样算法的性能边界。</p>
</li>
</ul>
<p>上述理论工作为扩散模型提供了更坚实的数学基础。不论是提高收敛速率的算法设计，还是统一解析不同采样过程的框架，都为未来<strong>设计更快更稳健的扩散模型</strong>指明了方向。此外，还有研究将扩散模型视作<strong>策略优化或控制问题</strong>加以分析（如将生成目标融入强化学习奖励框架等），这些也拓宽了扩散模型理论研究的思路。</p>
<h2 id="大模型与架构创新"><a href="#大模型与架构创新" class="headerlink" title="大模型与架构创新"></a>大模型与架构创新</h2><p>在实践层面，2024年前后也出现了<strong>更大规模、更强性能</strong>的扩散模型。<strong>Stable Diffusion XL（SDXL）</strong>是这一时期的代表模型之一：</p>
<ul>
<li><strong>Stable Diffusion XL (SDXL)</strong>：由Stability AI的Podell等人在2023年提出的SDXL模型是<strong>潜在扩散模型（Latent Diffusion）</strong>在高分辨率图像合成上的一次重大升级。与之前的Stable Diffusion版本相比，SDXL的U-Net主干参数量增加了3倍，主要得益于引入<strong>更多的注意力模块</strong>以及<strong>更大的跨模态注意力上下文</strong>。具体来说，SDXL使用了<strong>双文本编码器</strong>（在原有CLIP文本编码器基础上增加第二个文本编码器）来提供更丰富的文本条件语义；设计了多种新的<strong>条件融合机制</strong>，并采用<strong>多长宽比训练</strong>使模型能胜任不同尺寸的图像生成。此外，SDXL还训练了一个<strong>后置精炼模型（refiner）</strong>：先由基础模型生成1024×1024图像，再由精炼模型通过<strong>图像到图像扩散</strong>细化，提高最终输出的视觉保真度。实验结果显示，SDXL相较之前版本的稳定扩散在图像质量上有<strong>显著提升</strong>，在开放评测中达到可与某些封闭源SOTA生成模型媲美的水平。Stability AI已开放了SDXL的代码和模型权重，促进研究者在其基础上进行进一步开发。例如，基于SDXL的模型调优、知识蒸馏等后续研究也陆续出现，使大模型的性能得以在更广泛应用中发挥。</li>
</ul>
<p>SDXL的成功表明，通过<strong>扩大模型规模、改进架构和训练策略</strong>，扩散模型在保持多样性的同时能够生成更高分辨率、更精细的图像。这也为今后<strong>更大、更多模态</strong>的扩散模型（如视频扩散、3D扩散）的研发提供了经验借鉴。</p>
<h2 id="研究汇总表"><a href="#研究汇总表" class="headerlink" title="研究汇总表"></a>研究汇总表</h2><p>如下表格汇总了2024–2025年扩散模型领域的重要研究成果，包括研究名称、主要作者、来源（会议/期刊或预印本）、发布日期、主要贡献简述以及代码链接：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>研究名称</strong></th>
<th><strong>作者</strong></th>
<th><strong>来源</strong></th>
<th><strong>发布日期</strong></th>
<th><strong>研究内容简述</strong></th>
<th><strong>代码链接</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Stable Diffusion XL (SDXL)</td>
<td>Dustin Podell 等（Stability AI）</td>
<td>arXiv预印本（据ICLR 2024）</td>
<td>2023年7月4日 (v1)</td>
<td>提出大规模<strong>潜在扩散模型</strong>用于高分辨率文本图像生成。U-Net参数扩大3倍，引入<strong>双文本编码器</strong>和新条件机制，支持多尺度、多长宽比训练；另加精炼扩散模型提升细节。生成质量较以往Stable Diffusion大幅提高，开放提供模型权重。</td>
<td><a href="https://github.com/Stability-AI/generative-models">Stability-AI/generative-models</a> (含SDXL代码和模型)</td>
</tr>
<tr>
<td>改进的一致性模型潜在空间训练 (sLCT)</td>
<td>Quan Dao, Khanh Doan 等</td>
<td>arXiv预印本</td>
<td>2025年2月3日</td>
<td>提出潜在空间下一致性模型的训练改进：使用<strong>Cauchy损失</strong>处理离群值，增加小步扩散损失和<strong>最优传输</strong>变分技术，配合<strong>自适应缩放调度</strong>和非缩放归一化。使一致性模型在VAE潜在空间中可<strong>一到两步生成高质量图像</strong>，性能接近原扩散模型。</td>
<td><a href="https://github.com/quandao10/sLCT/">quandao10/sLCT</a></td>
</tr>
<tr>
<td>Upsampling Diffusion Probabilistic Model (UDPM)</td>
<td>Shady Abu-Hussein, Raja Giryes</td>
<td>NeurIPS 2024 (Poster)</td>
<td>2024年12月</td>
<td>提出<strong>降采样+加噪/上采样+去噪</strong>的扩散新流程。在正向过程将数据降维，加快逆过程。<strong>仅需3次网络推理</strong>即可生成图像，FID达6.86，优于以往单步生成方法。提供了可解释潜在空间和更高生成效率。</td>
<td><a href="https://github.com/shadyabh/UDPM/">shadyabh/UDPM</a></td>
</tr>
<tr>
<td>Universal Guidance for Diffusion Models</td>
<td>Arpit Bansal 等</td>
<td>ICLR 2024 (Poster)</td>
<td>2024年1月16日</td>
<td>提出<strong>通用指导算法</strong>，可在<strong>无额外训练</strong>情况下，用任意模态的引导信号控制扩散生成。支持分割、检测、风格等多种条件，同一扩散模型即可多条件通用。方法通过采样阶段优化实现，生成结果质量优秀。</td>
<td><a href="https://github.com/arpitbansal297/Universal-Guided-Diffusion">arpitbansal297/Universal-Guided-Diffusion</a></td>
</tr>
<tr>
<td>“不偏不倚”：少数样本指导</td>
<td>Soobin Um 等</td>
<td>ICLR 2024 (Poster)</td>
<td>2024年1月16日</td>
<td>提出<strong>少数样本生成框架</strong>，通过定义样本独特性度量和<strong>少数指导</strong>采样技术，引导扩散模型关注数据分布中<strong>低概率区域</strong>。显著提升模型生成<strong>罕见样本</strong>的能力和多样性。在医疗图像等场景下亦有效。</td>
<td><a href="https://github.com/soobin-um/minority-guidance">soobin-um/minority-guidance</a></td>
</tr>
<tr>
<td>ContextDiff 跨模态上下文扩散</td>
<td>Ling Yang 等</td>
<td>ICLR 2024 (Poster)</td>
<td>2024年1月16日</td>
<td>提出在<strong>正向+逆向扩散过程中融合文本-图像上下文</strong>的模型。通过在所有时间步传播文本条件信息，增强生成结果与文本语义的一致性。用于文本图像生成和文本指导视频编辑均达<strong>SOTA性能</strong>，语义对齐显著改善。</td>
<td><a href="https://github.com/YangLing0818/ContextDiff">YangLing0818/ContextDiff</a></td>
</tr>
<tr>
<td>Cascaded Diffusion Model (Cas-DM)</td>
<td>Jie An 等（微软）</td>
<td>IJCAI 2024 (Oral)</td>
<td>2024年1月4日</td>
<td>提出<strong>级联两阶段扩散网络</strong>，第一阶段预测噪声，第二阶段预测图像，从而可对第二阶段应用LPIPS等<strong>感知损失</strong>。巧妙避免损失干扰噪声预测，实现感知优化。实现在CIFAR-10、ImageNet等上<strong>FID、IS刷新SOTA</strong>，生成图像伪影更少、细节更佳。</td>
<td>（论文方法证明有效，代码暂未公布）</td>
</tr>
<tr>
<td>DMFFT 频域特征调制方法</td>
<td>Tianrong Wang 等</td>
<td>Scientific Reports</td>
<td>2025年3月25日</td>
<td>提出利用<strong>快速傅里叶变换</strong>调整扩散模型特征频率分量以提升生成质量的方法。在不上线性结构中，对<strong>高低频、幅值和相位</strong>进行缩放，<strong>无需模型训练</strong>即可改善输出的语义一致性、结构和纹理。适用于文本图像和文本视频生成，增强艺术性和多样性。</td>
<td>（方法基于开源Stable Diffusion实现，附于论文）</td>
</tr>
<tr>
<td>加速Score-Based扩散收敛 (Provably Accelerating)</td>
<td>Gen Li 等</td>
<td>arXiv预印本</td>
<td>2024年3月6日</td>
<td>从理论上<strong>加速扩散采样</strong>：设计了<strong>高阶确定性/随机采样器</strong>，将DDIM采样收敛阶从$O(1/T)$提升至$O(1/T^2)$，DDPM采样从$O(1/\sqrt{T})$提升至$O(1/T)$。算法无需额外训练，证明了扩散模型采样的可达更高效率。</td>
<td>（算法伪代码在论文中给出，无单独代码）</td>
</tr>
<tr>
<td>扩散模型收敛率改进分析</td>
<td>Gen Li, Yuchen Jiao</td>
<td>arXiv预印本</td>
<td>2024年10月18日</td>
<td>提出改进的扩散模型收敛复杂度：证明迭代复杂度为$O(d^{1/3}\epsilon^{-2/3})$，优于此前最佳的$O(d^{5/12}\epsilon^{-1})$（$d$为数据维度)。基于随机中点方法的理论分析进一步缩小了理论与实践差距。</td>
<td>（理论研究，无代码）</td>
</tr>
<tr>
<td>确定性扩散采样统一分析</td>
<td>Runjia Li 等</td>
<td>arXiv预印本</td>
<td>2024年10月18日</td>
<td>针对<strong>DDIM等确定性采样</strong>缺乏统一理论的问题，提出通用分析框架。对VP扩散+指数积分方案给出$\tilde{O}(d^2/\epsilon)$复杂度，对DDIM采样证明多项式收敛。为各种扩散采样策略提供了统一的收敛性保证。</td>
<td>（理论研究，无代码）</td>
</tr>
</tbody>
</table>
</div>
<p>上述汇总表中的研究成果体现了2024–2025年扩散模型领域的主要进展。从工程上的模型改进到理论层面的深入分析，这些工作共同推动了扩散模型在<strong>效率、可控性、质量和理解</strong>等方面的提升。展望未来，随着社区持续探索，我们有望见到扩散模型在更多元的任务和更大尺度数据上取得突破，并逐步解决当前存在的速度瓶颈和控制局限，使其在生成AI领域发挥更大的作用。</p>
]]></content>
      <tags>
        <tag>diffusion</tag>
      </tags>
  </entry>
  <entry>
    <title>扩散模型在图像分类域泛化中的应用研究综述</title>
    <url>/uncategorized/Generalization-Diffusion/</url>
    <content><![CDATA[<h1 id="扩散模型在图像分类域泛化中的应用研究综述"><a href="#扩散模型在图像分类域泛化中的应用研究综述" class="headerlink" title="扩散模型在图像分类域泛化中的应用研究综述"></a>扩散模型在图像分类域泛化中的应用研究综述</h1><p>过去三年中，扩散模型（Diffusion Models）在图像分类的<strong>域泛化</strong>（Domain Generalization）任务中展现出新颖而有效的应用。域泛化旨在训练出能够直接适应未知目标域的数据分布的模型，而无需在目标域上进行任何微调。以下我们将从核心方法、所用扩散模型类型、应用场景、实验评估及代表性研究等方面进行综述。</p>
<h2 id="核心方法与思想"><a href="#核心方法与思想" class="headerlink" title="核心方法与思想"></a>核心方法与思想</h2><p><strong>1. 基于数据增广的扩散生成</strong>：许多方法利用扩散模型强大的图像生成能力来<strong>扩充源域数据的多样性</strong>，缩小不同域之间的差异。这类方法通过在训练时引入<strong>跨域合成图像</strong>来模拟未见过的目标域分布。例如，Hemati等人提出<strong>跨域生成增广（CDGA）</strong>方法，借助预训练的潜变量扩散模型（latent diffusion model）生成<strong>填补多个源域分布间隙</strong>的图像。简单而言，CDGA从任意两个源域出发，在其“附近”合成新样本，从而<strong>减少域间分布差异</strong>，实践中显著提升了模型在未见域的表现。Noori等人提出的<strong>FDS（Feedback-guided Domain Synthesis）</strong>则通过<strong>多源条件扩散模型</strong>来进行“域混合”生成。他们在源域数据上训练扩散模型，<strong>插值噪声级和条件</strong>以混合多个源域特征，生成“新域”样本，并筛选出对源模型具有挑战性的难例加入训练。这种反馈生成策略确保训练集覆盖更广泛的分布，从而<strong>将模型鲁棒性提升到新的水平</strong>。</p>
<p><strong>2. 文本引导与条件控制</strong>：扩散模型允许通过<strong>文本或图像条件</strong>引导生成不同风格的图像。Ren等人（2025）提出<strong>“语言引导的扩散”</strong>数据增广框架，利用大型语言模型（LLM）<strong>生成描述新域风格的文本提示</strong>，然后用文本条件扩散模型合成相应风格的图像。他们还结合CLIP模型进行多样性分析，确保生成的数据既提升泛化性又保持多样性和效率。实验证明，在PACS等基准上，该方法显著优于传统增广技术。另外，Lin等人关注<strong>公平域泛化</strong>问题，提出<strong>FADE</strong>方法：先预训练扩散模型和分类器，然后用<strong>分类器指导扩散模型去除生成图像中的敏感属性信息</strong>，生成“公平”的数据用于训练。这一<strong>分类器引导的扩散</strong>生成不仅减轻了偏见，还提升了分布偏移下的模型准确度。综上，这些方法通过<strong>条件控制扩散模型</strong>来<strong>合成多样且具有特定属性的图像</strong>（不同风格、新环境、无敏感信息等），增强模型对新域的适应力。</p>
<p><strong>3. 扩散模型辅助的域不变特征提取</strong>：除了直接生成图像，一些方法利用扩散模型的<strong>中间表征</strong>来提升域泛化模型的特征学习。Huang等人提出的<strong>DomainFusion</strong>框架同时在<strong>潜空间</strong>和<strong>像素空间</strong>利用预训练的潜变量扩散模型（如Stable Diffusion）来辅助分类模型训练。在潜空间，DomainFusion设计了<strong>梯度得分蒸馏（GSD）</strong>，从扩散模型中提取<strong>梯度先验</strong>来指导分类模型的优化，理论上可逼近两模型输出分布的KL散度最小化。在像素空间，他们通过<strong>自回归采样策略</strong>生成并洗牌合成样本，优化合成图像的语义和非语义因素，使其更贴近未见域。该方法相当于将稳定扩散模型中蕴含的大规模图像分布知识<strong>融入判别模型</strong>，因而相比仅用生成数据的方法取得了更大的性能提升。Thomas和Ghadiyaram（2025）提出的<strong>GUIDE</strong>方法则完全不依赖域标签，<strong>直接利用扩散模型的表征来推断伪域</strong>。他们观察到扩散模型（如Stable Diffusion或DiT）的潜空间中<strong>自然形成了风格聚类</strong>，可代表数据的不同“伪域”。GUIDE首先用预训练扩散模型提取训练样本的潜向量并聚类，以获得若干伪域质心，然后将这些伪域表示与原始特征拼接一起训练分类器。这种融合了“域信息”的特征空间比仅用图像特征更能抵抗域移变，在多个基准上显著提高了分类准确率（例如OfficeHome数据集上比强基线提升3%）。上述方法表明，<strong>扩散模型的知识可通过蒸馏或特征拼接等方式提升模型的域不变表征能力</strong>。</p>
<p><strong>4. 模型参数空间的扩散建模</strong>：一种独特的思路是将扩散模型用于<strong>直接生成模型参数</strong>，以实现对未来域的自适应。Xie等人在NeurIPS 2024提出<strong>Weight Diffusion (W-Diff)</strong>框架，针对<strong>持续变化的非平稳环境</strong>下的域泛化。W-Diff在<strong>参数空间</strong>训练条件扩散模型：将历次源域训练得到的分类器权重存入队列，计算当前（最新）域分类器与历史分类器之间的<strong>权重差</strong>，并将这种权重残差作为diffusion的训练数据。扩散模型以历史域的分类器为条件、以当前域的类别原型为附加条件，学习从历史权重过渡到当前权重的<strong>演化模式</strong>。通过这种方式，模型捕获了参数随域分布演进的规律。推理时，以当前已训练分类器为锚点，让扩散模型生成<strong>大量针对未来域定制的分类器权重</strong>，并对它们的预测结果做集成。实验证明，与以往仅在特征层面外推未来域的方法相比，W-Diff在模拟未来未知域时更加有效，在合成和真实的<strong>时间演变域</strong>数据上都取得了更优的性能。这一方法开创性地将扩散模型用于<strong>学习模型参数的渐变规律</strong>，为持续学习和未来域预测提供了新思路。</p>
<h2 id="使用的扩散模型类型及用途"><a href="#使用的扩散模型类型及用途" class="headerlink" title="使用的扩散模型类型及用途"></a>使用的扩散模型类型及用途</h2><p><strong>1. DDPM及其扩展</strong>：大部分方法使用<strong>扩散概率模型</strong>的典型实现——<strong>DDPM</strong>（Denoising Diffusion Probabilistic Models）及其变种。<strong>Stable Diffusion</strong>等潜变量扩散模型（Latent Diffusion Models, LDM）是最常用的选择。它在低维潜空间进行扩散，大幅提高了采样效率，同时通过融合<strong>文本编码</strong>实现可控生成。许多域泛化研究直接利用开源的Stable Diffusion模型作为图像生成器。例如CDGA使用了Stable Diffusion对源域图像应用提示词（prompt）引导，生成不同域风格的样本；在PACS、OfficeHome等风格域数据上，CDGA主要通过<strong>文本提示</strong>控制生成，而在VLCS等现实数据上则使用<strong>图像混合引导</strong>来生成跨域样本。另外，FDS方法则<strong>微调</strong>了预训练扩散模型并引入<strong>多条件控制</strong>：将“域标签”作为条件嵌入到扩散模型的噪声预测网络中，然后在推断时对不同域条件进行<strong>分层插值</strong>（如对噪声级、文本embedding插值），合成混合域图像。通过这种<strong>条件扩散</strong>，FDS能够严格控制生成图像所属的域分布，保证生成样本的多样性和跨域跨度。</p>
<p><strong>2. Score-based模型</strong>：部分工作采用<strong>score-based</strong>扩散模型（本质上与DDPM等价，只是从概率流角度定义），特别是在需要自定义训练扩散模型的场景。Lin等人的FADE框架即在其特定数据集上预训练了<strong>得分匹配扩散模型</strong>，并训练了两个分类器（任务分类器和敏感属性分类器），然后通过<strong>分类器指导采样</strong>的方式来引导扩散模型产生不含敏感信息的图像。这里使用的“分类器指导”技术与Diffusion模型生成图像时添加引导梯度相似，可以看作对<strong>score-based生成过程</strong>的条件微调，以<strong>去除特定特征</strong>。相比直接使用预训练的大模型，这种自训练的扩散模型更易于在<strong>小型专用数据集</strong>（如公平学习场景）上操控。需要注意的是，score-based模型生成质量虽高，但计算开销也大，因而有些研究仍倾向于利用预训练的稳定扩散模型，以减少训练负担。</p>
<p><strong>3. 文本与图像条件</strong>：为了实现<strong>精细的生成控制</strong>，研究中广泛使用了<strong>条件扩散模型</strong>。最常见的是<strong>文本条件扩散</strong>（如Stable Diffusion），用于根据描述生成具有某种风格或属性的图像。例如语言引导扩散方法中，LLM产生的描述提示通过Stable Diffusion生成全新风格的图像。同时也有方法采用<strong>图像条件</strong>（image-to-image扩散），即给定一张源域图像，通过扩散模型添加噪声再去噪，将其<strong>转换到另一种域的外观</strong>。Niemeijer等（WACV 2024）的研究在语义分割背景下使用了图像条件扩散模型，将合成源域图像的风格转化为真实目标域风格，从而提升模型在真实场景的泛化。在图像分类任务中，类似的思想被用于将源域图像“风格迁移”到其他域：例如Truong等人的<strong>ED-SAM</strong>方法，在扩散模型最后一步加噪后对潜变量进行扰动，再映射回图像，产生在造型和风格上有所变化的样本。此外，<strong>多模态扩散</strong>也被探索，如DomainFusion除了文本条件外，还利用扩散模型的<strong>内部梯度</strong>信息（可视为条件）来指导判别模型训练。总的来说，各方法充分利用了扩散模型<strong>灵活加入条件</strong>的特性，通过文本描述域属性、图像示例目标风格或直接针对特定特征进行引导，来<strong>精确地控制生成内容</strong>并服务于域泛化目标。</p>
<p><strong>4. 潜空间与参数空间扩散</strong>：有别于传统的像素空间生成，一些方法探索了<strong>非像素空间</strong>的扩散模型应用。GUIDE利用扩散模型<strong>潜空间</strong>提取的隐变量代表图像的域属性；通过对这些隐变量聚类获得伪域标签，再将其反馈给判别模型训练，从而在不生成额外图像的情况下利用了扩散模型的“见多识广”来增强域泛化能力。W-Diff则是在<strong>模型权重空间</strong>实施扩散：它训练的扩散模型输入是历史域的分类器参数，输出是下一域的分类器参数（以残差形式），实质是在参数空间进行“去噪”推理来预测未来域的模型。这种创新用法展示了扩散模型在除图像像素以外的数据分布上（如特征、参数）的强大建模能力，可用于生成<strong>域不变特征</strong>或<strong>自适应模型参数</strong>。</p>
<h2 id="域泛化应用场景"><a href="#域泛化应用场景" class="headerlink" title="域泛化应用场景"></a>域泛化应用场景</h2><p><strong>1. 跨视觉风格的泛化</strong>：许多研究集中在<strong>风格或外观差异</strong>明显的图像域上，如绘画风格 vs. 实拍照片等典型情形。<strong>PACS</strong>数据集是此类场景的代表，它包含照片、艺术画作、卡通和素描四个域，相同物体在不同域中呈现出<strong>显著的形状、颜色和纹理差异</strong>。扩散模型可以方便地在这些风格之间进行转换或生成过渡风格的图像，从而提升模型对任意风格的新图像的识别能力。例如，CDGA在PACS上通过文本提示生成介于真实照片和卡通画之间风格的图像，以弥合二者差异。<strong>Office-Home</strong>数据集类似地涉及艺术画、剪贴画、产品照片和真实拍摄四种域，主要差别在于物体的绘制风格和背景环境。对这类<strong>多风格对象分类</strong>任务，扩散模型生成的<strong>多样风格合成图像</strong>显著提高了模型的鲁棒性，例如GUIDE在Office-Home上无须域标签就挖掘出了潜在风格信息，使准确率相比不使用扩散特征时提高了约3个百分点。</p>
<p><strong>2. 跨合成与真实域</strong>：在一些应用中，训练域为模拟/合成数据，而测试域为真实世界数据，二者存在<strong>显著的视觉差异</strong>。这类问题常见于自动驾驶、遥感等领域，如语义分割中的GTA5（合成游戏画面）到Cityscapes（真实街景）转换。在图像分类中，<strong>DomainNet</strong>数据集提供了类似场景：它包含照片、剪贴画、画作、素描、模拟画（infograph）和涂鸦（quickdraw）等<strong>六种不同来源的图像</strong>。不同来源之间不仅风格迥异，甚至图像细节复杂度也不同（例如Quickdraw域是非常简化的线条画）。扩散模型可以用文本描述这些合成域的特征，生成与真实域更接近的样本，或者反过来从真实图像生成具有合成风格的样本来丰富训练集。例如，有方法构建<strong>文本库</strong>描述DomainNet中潜在的新域，然后通过扩散模型生成相应图像以补充训练。实践表明，通过这种<strong>跨合成-真实的对齐生成</strong>，模型在DomainNet等复杂多源数据上的平均性能有明显提升，证明扩散模型有助于<strong>模拟潜在的新域</strong>。</p>
<p><strong>3. 跨拍摄环境和设备</strong>：另一类场景涉及<strong>成像条件或环境改变</strong>导致的域差异，例如不同相机、不同光照/天气、不同地点等。在<strong>Terra Incognita</strong>数据集中，不同域对应不同的相机陷阱拍摄地点，因而<strong>背景植被、地形纹理等环境特征各异</strong>。这种情况下，域泛化要求模型关注与任务相关的主体而忽略环境变化。扩散模型可以通过<strong>改变背景或环境元素</strong>生成新的训练样本。例如，将一张森林中动物的照片扩散生成在荒漠背景下的版本，从而让模型学会在极端不同的环境中仍能识别动物。上述GUIDE方法的分析显示，Stable Diffusion这类模型能够捕捉诸如<strong>植被密度、地形模式</strong>等细微环境差异。通过在训练集中合成各种环境下的图像，模型在Terra Incognita未见地点上的表现得以提升。同样，针对不同摄像头成像差异、不同图像质量（清晰度、噪声水平）等，扩散模型均可用于制造这些条件下的样本，帮助模型实现<strong>跨设备、跨条件</strong>的泛化。</p>
<p><strong>4. 非传统视觉任务</strong>：值得一提的是，扩散模型在一些特殊领域泛化任务中也开始展现作用。例如在<strong>故障诊断</strong>中，不同机器或传感器采集的振动信号可视为不同“域”。Liu等人（2025）提出一种频域引导的潜变量扩散模型，将机械设备的振动频谱图表示为图像，在潜空间引入噪声扰动并生成不同工况下的频谱，从而提升模型对新机台故障的诊断准确率。又如<strong>公平人脸分类</strong>场景中，把不同性别或种族视作域，FADE通过去除敏感属性信息来生成中性人脸数据训练模型，实现对未见人群分布的公平泛化。这些应用表明，扩散模型的域泛化价值不局限于一般物体分类；对于各种需要跨域（跨设备、跨人群、跨时间）鲁棒性的任务，都可以设计相应的扩散模型策略来提高模型可靠性。</p>
<h2 id="实验设置与评估基准"><a href="#实验设置与评估基准" class="headerlink" title="实验设置与评估基准"></a>实验设置与评估基准</h2><p><strong>1. 多源域训练与留一法测试</strong>：域泛化研究通常采用<strong>多源域训练、目标域留出</strong>的实验范式。也就是给定若干个来源域的数据集，用其中的全部或部分域作为源域训练模型，然后在<strong>从未参与训练的目标域</strong>上直接测试模型表现。例如在PACS上，典型做法是依次选取其中一个域作为目标域，其余三个域一起训练模型，然后测试模型在该目标域的准确率；对每个域如此重复，最后报告平均性能。类似地，Office-Home、DomainNet等多域数据也采取这种<strong>交叉验证式</strong>评估。许多工作使用统一的开源框架<strong>DomainBed</strong>来进行评测，该框架涵盖PACS、VLCS、Office-Home、Terra Incognita、DomainNet五大经典数据集。使用DomainBed可以确保不同方法在<strong>相同数据划分和模型架构</strong>下比较性能，增强公平性。</p>
<p><strong>2. 常用基准数据集</strong>：上述数据集中，<strong>PACS</strong>与<strong>Office-Home</strong>因为规模适中且域差异直观，最为常用。PACS有4个域共9991张图像，Office-Home有4个域共约15,500张图像，各包含数十类对象。<strong>VLCS</strong>较早期，包含4个摄影图像数据集的组合（PASCAL VOC2007、LabelMe、Caltech101、SUN09），共有5类对象，每个子数据集作为一个域。<strong>Terra Incognita</strong>聚焦野生动物相机陷阱数据，共4个域约24,788张图片，包含10类动物，每个域对应不同地理位置。<strong>DomainNet</strong>规模最大，6个域合计约0.6百万张图，涵盖345类日常物体，是目前<strong>最具挑战</strong>的域泛化基准之一。由于DomainNet数据量巨大，一些研究只选取其中部分域或类进行实验，以控制训练时间。对于特定场景，有时也会引入额外数据集，如FADE在公平性实验中可能使用人脸属性数据集，W-Diff在持续学习实验中可能构造序列化的多个数据流（例如数字图像不断旋转变化形成一系列域）等。这些数据集和设置共同确保评价<strong>模型在未知域上的性能</strong>。</p>
<p><strong>3. 评价指标</strong>：图像分类域泛化主要采用<strong>分类准确率</strong>（Accuracy）作为指标，关注模型在各目标域上的准确率以及<strong>平均准确率</strong>。通常报告在每个单独留出域的准确率以及所有域的宏平均。有时也关注<strong>相对提升</strong>：如相比经验风险最小化(ERM)基线方法提升了多少个百分点。另外，一些研究引入了<strong>域泛化特有分析</strong>指标。例如，Hemati等利用<strong>Fréchet距离</strong>定量评估源域与合成数据分布的差异，以验证生成数据确实缩小了域间距离。还有工作度量<strong>特征空间的Hessian矩阵距离</strong>或<strong>loss landscape平坦度</strong>来解释模型泛化性的提升。然而最终评价仍以<strong>目标域识别准确率</strong>为主，辅以统计显著性检验确保结果可靠。</p>
<p><strong>4. 实验结果概况</strong>：基于扩散模型的策略目前在各大基准上均取得了<strong>领先性能</strong>。例如，前文提到的CDGA方法在PACS和Office-Home上分别达到<strong>88.4%</strong>和<strong>70.2%</strong>的平均准确率，大幅超过传统ERM基线的78.3%和63.9%。相比其它数据增广方法，CDGA在这两个数据集上均名列前茅。又如DomainFusion在PACS、VLCS、Office-Home、DomainNet上全面超过先前的生成式方法，取得当前最优的平均成绩。FDS方法在PACS上达到<strong>89.7%</strong>的最高准确率，在VLCS和Office-Home上也有显著提升，据报道刷新了这些基准的SOTA。GUIDE方法在无需域标签的情况下，性能甚至赶超了部分使用域标签的算法，在DomainBed五个数据集的平均准确率上名列前茅。此外，W-Diff在其设定的<strong>持续演变域</strong>任务中表现出色，实现了对未来域的准确预测。总体而言，引入扩散模型后的方法在标准基准的<strong>稳健性和平均性能</strong>上均优于以往无生成模型的方案，证明了扩散模型在提升域泛化能力方面的价值。</p>
<h2 id="最新代表性论文与综述"><a href="#最新代表性论文与综述" class="headerlink" title="最新代表性论文与综述"></a>最新代表性论文与综述</h2><p>近三年出现了多篇将扩散模型用于域泛化的代表性论文和综述，下面列出其中具有代表性的工作：</p>
<ul>
<li><p><strong>Cross Domain Generative Augmentation: Domain Generalization with Latent Diffusion Models</strong> – Sobhan Hemati等人，TMLR 2024（arXiv 2023）。主要贡献：提出CDGA数据增广方法，利用预训练潜变量扩散模型生成源域对之间的中间态图像，显著缩小域间分布差距，提升了DomainBed基准下的SOTA性能。作者通过生成超过500万张合成图像并进行丰富的分析（数据分布可视化、损失景观等）解释了该方法效果。</p>
</li>
<li><p><strong>DomainFusion: Generalizing to Unseen Domains with Latent Diffusion Models</strong> – Yuyang Huang等人，ECCV 2024。主要贡献：提出将大规模<strong>潜变量扩散模型</strong>融入判别模型训练的框架。在潜空间提出梯度得分蒸馏（GSD）指导特征学习，在像素空间设计高效采样策略生成多样样本。DomainFusion在多个基准上超过此前所有基于扩散的数据生成方法，达到新的SOTA水平。</p>
</li>
<li><p><strong>Feedback-guided Domain Synthesis with Multi-Source Conditional Diffusion Models for Domain Generalization</strong> – Mehrdad Noori等人，arXiv 2024。主要贡献：提出FDS方法，将<strong>多源条件扩散模型</strong>用于域泛化数据合成。通过在源数据上训练扩散模型并交叉混合多个域的条件来生成新域样本，同时设计难例筛选机制。综合实验在PACS、VLCS、OfficeHome等数据集上取得了新的最佳成绩。该方法代码已开源，促进复现和扩展。</p>
</li>
<li><p><strong>Weight Diffusion for Future: Learn to Generalize in Non-Stationary Environments</strong> – Mixue Xie等人，NeurIPS 2024。主要贡献：开创性地将扩散模型引入<strong>模型权重空间</strong>，解决持续变化环境下的域泛化。通过条件扩散模拟分类器随时间演化的模式，生成面向未来域的多个分类器并集成预测。在合成序列数据和真实非静态数据上均证明了优异的泛化性能，推动了<strong>渐变域泛化</strong>研究。</p>
</li>
<li><p><strong>“What’s in a Latent? Leveraging Diffusion Latent Space for Domain Generalization”</strong> – Xavier Thomas, Deepti Ghadiyaram，arXiv 2025。主要贡献：提出GUIDE方法，不借助域标签直接<strong>利用扩散模型潜空间</strong>来推断域结构。通过聚类扩散模型的特征表示得到伪域，再用于指导分类模型训练，实现了在未知域上的高性能，同时揭示了扩散模型潜空间中蕴含的丰富域信息。</p>
</li>
<li><p><strong>Language-Guided Diffusion for Domain Generalization</strong> – Haolin Ren等人，ICLR 2025研讨会。主要贡献：首次将<strong>大语言模型与扩散模型结合</strong>用于域泛化数据增广。由LLM生成描述新域风格的文本提示，再经Stable Diffusion合成对应图像。并引入CLIP度量确保生成样本既丰富又贴合任务需求，实验证明在PACS等数据集上显著提升了模型泛化性能。</p>
</li>
<li><p><strong>FADE: Towards Fairness-aware Augmentation for Domain Generalization via Classifier-Guided Score-based Diffusion Models</strong> – Yujie Lin等人，arXiv 2024。主要贡献：针对公平学习，提出结合扩散模型的域泛化方法。通过预训练<strong>得分基扩散模型</strong>和分类器，并在采样过程中用分类器梯度引导去除敏感属性，从而生成公平且域不变的数据用于训练。在多个真实数据集上，FADE同时提高了模型在新域中的准确性和决策公平性。</p>
</li>
<li><p><strong>Domain Generalization Through Data Augmentation: A Survey of Methods, Applications, and Challenges</strong> – Jianing Mai等人，_Mathematics_期刊 (MDPI) 2025。主要内容：综述了域泛化中数据增广的方法，将其分为规则、梯度和生成三类，并比较了输入层面和特征层面增广的效果。特别地，综述指出<strong>基于扩散模型的生成增广</strong>在近年来表现突出：如CDGA方法利用扩散模型使PACS和Office-Home的ResNet-18准确率达到88.4%和70.2%，显著优于不使用生成的78.3%和63.9%。文章还讨论了这类方法的多样性优势和计算代价等问题。</p>
</li>
</ul>
<p>以上工作体现了扩散模型在提升域泛化能力上的多种思路和优越性。从数据层面的多域合成、特征层面的知识蒸馏，到参数层面的模型生成，扩散模型为长期存在的域移变问题提供了新的解法。展望未来，随着扩散模型生成质量和效率的进一步提高，以及与其他技术（如大模型、增量学习）的结合，基于扩散模型的域泛化方法有望在更大规模、更复杂的跨域场景中取得突破，为提升视觉模型的鲁棒性和泛化性奠定坚实基础。</p>
]]></content>
  </entry>
  <entry>
    <title>Higress AI Wasm 插件开发记录</title>
    <url>/higress/higress/</url>
    <content><![CDATA[<h1 id="Higress-背景"><a href="#Higress-背景" class="headerlink" title="Higress 背景"></a>Higress 背景</h1><p>Higress 是基于阿里内部两年多的 Envoy Gateway 实践沉淀，以开源 Istio 与 Envoy 为核心构建的云原生 API 网关。</p>
<p><img  src="overview.png"   style="zoom: 33%;" /><span class="image-caption">image</span></p>
<p>Higress 实现了安全防护网关、流量网关、微服务网关三层网关合一，可以显著降低网关的部署和运维成本。</p>
<p><img  src="云原生网关.png"   style="zoom:50%;" /><span class="image-caption">image</span></p>
<h1 id="Higress-与大模型"><a href="#Higress-与大模型" class="headerlink" title="Higress 与大模型"></a>Higress 与大模型</h1><p>以 ChatGPT 为代表的 AIGC（人工智能生成内容）技术正在引领企业生产的巨大变革，并在企业应用开发领域中占据了重要地位。AI 大模型凭借其卓越的学习和理解能力，可以辅助完成各种复杂的任务，极大地提升了工作效率和创新能力。</p>
<p>在软件开发领域，AI 大模型能够显著提高开发人员的工作效率。它们可以协助编写和调试代码，自动生成测试用例，并提供最佳实践建议，从而加速开发周期，降低错误率。科研领域的研究人员则利用这些模型快速获取和理解最新的科研进展，自动化文献综述和数据分析，节省大量时间和精力。</p>
<p>然而，随着 AI 大模型在企业中的应用不断深入，许多企业开始探索如何降低这些技术的使用成本。一个常见的解决方案是通过网关进行 AI 大模型的 API 管理。这样的管理方式不仅能够集中控制和优化模型的调用频率和资源使用，还可以保障数据安全和隐私合规。通过网关，企业能够灵活地调整使用策略，以更低的成本享受 AI 技术带来的高效益。</p>
<p>Higress 前瞻性地通过 Wasm 实现了LLM Proxy 插件和 AI Assistant 插件帮助开发者快速构建 RAG 应用。</p>
<h1 id="为-Higress-开发-ai-cache-插件的意义"><a href="#为-Higress-开发-ai-cache-插件的意义" class="headerlink" title="为 Higress 开发 ai-cache 插件的意义"></a>为 Higress 开发 ai-cache 插件的意义</h1><p><img  src="arch.png"   style="zoom: 33%;" /><span class="image-caption">image-20240826154248690</span></p>
<p>AI 缓存插件的目标是在构建 AI 应用时，通过智能缓存机制，<strong>减少对LLM提供商API的请求数量，从而降低使用成本，同时确保返回结果的质量</strong>。</p>
<p>在具体实现过程中，Higress AI-Cache 利用向量相似度技术，通过分析和比较用户查询的特征向量，与缓存中已有的查询结果进行匹配。当用户发起新的查询时，Higress 首先计算该查询的向量表示，并在缓存中寻找相似度较高的结果。如果找到足够相似的缓存结果，插件将直接返回该结果，而无需再向LLM提供商API发出新的请求。</p>
<p>该插件适用于多个LLM提供商API，例如通义千问、moonshot、OpenAI等。通过集成这些API，插件可以在不同的AI应用场景中灵活应用，包括但不限于智能客服、内容生成、代码编写和调试等领域。</p>
<p>Higress AI 缓存插件核心优势在于，通过减少不必要的API调用，显著降低了使用大型语言模型的成本。同时，向量相似度技术确保了缓存结果的准确性和相关性，使得用户体验不受影响。插件还具备动态更新和管理缓存的功能，能够根据查询频率和变化情况，自动调整缓存策略，以保持最佳性能。</p>
<h1 id="AI-Cache-插件运行流程"><a href="#AI-Cache-插件运行流程" class="headerlink" title="AI-Cache 插件运行流程"></a>AI-Cache 插件运行流程</h1><p><img  src="seq.png"   style="zoom:50%;" /><span class="image-caption">image-20240826155252868</span></p>
<ol>
<li>当用户请求 LLM API 时，首先在 AI-Cache 插件中对用户的请求内容进行 Embedding 操作，将用户的请求转换为向量数据。</li>
<li>之后在向量数据库中进行相似度搜索。当相似度高于预先设定的阈值时直接返回 Cache 中的内容，不请求 LLM API。否则执行下一个步骤。</li>
<li>当相似度低于预先设定的阈值时，使用 AI-Proxy 插件进行请求转发，向 LLM API 发送请求。并将请求结果缓存在本地的向量数据库中，并把结果返回给用户。</li>
</ol>
<h1 id="Docker-compose-部署-Higress-进行插件开发"><a href="#Docker-compose-部署-Higress-进行插件开发" class="headerlink" title="Docker compose 部署 Higress 进行插件开发"></a>Docker compose 部署 Higress 进行插件开发</h1><p>使用 K8s 进行 Higress 开发时复杂度较高，这里介绍使用 Docker compose 开发的方法。</p>
<h2 id="docker-compose-文件编写"><a href="#docker-compose-文件编写" class="headerlink" title="docker-compose 文件编写"></a>docker-compose 文件编写</h2><p>首先是 <code>docker-compose.yml</code> 文件的编写，这里给出我使用的文件内容，其中的要点主要有：</p>
<ol>
<li>对 higress 的环境变量设置：<code>--component-log-level wasm:debug</code> 和 <code>/etc/envoy/envoy.yaml</code> 分别指定日志级别和配置文件。</li>
<li>wasm 文件和 envoy.yaml 文件的映射。</li>
<li>higress 的上游服务需要和 higress 在同一个 network 中。</li>
<li>higress 的上游服务需要在 higress 之前启动完成。</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3.7&#x27;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">envoy:</span><br>    <span class="hljs-comment"># image: higress-registry.cn-hangzhou.cr.aliyuncs.com/higress/gateway:v1.4.0-rc.1</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">higress-registry.cn-hangzhou.cr.aliyuncs.com/higress/gateway:1.4.2</span><br>    <span class="hljs-attr">entrypoint:</span> <span class="hljs-string">/usr/local/bin/envoy</span><br>    <span class="hljs-comment"># 注意这里对wasm开启了debug级别日志，正式部署时则默认info级别</span><br>    <span class="hljs-attr">command:</span> <span class="hljs-string">-c</span> <span class="hljs-string">/etc/envoy/envoy.yaml</span> <span class="hljs-string">--component-log-level</span> <span class="hljs-string">wasm:debug</span><br>    <span class="hljs-attr">depends_on:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">httpbin</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">redis</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">chroma</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">es</span><br>    <span class="hljs-attr">networks:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">wasmtest</span><br>    <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;10000:10000&quot;</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;9901:9901&quot;</span><br>    <span class="hljs-attr">volumes:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">./envoy.yaml:/etc/envoy/envoy.yaml</span><br>    <span class="hljs-comment"># 注意默认没有这两个 wasm 的时候，docker 会创建文件夹，这样会出错，需要有 wasm 文件之后 down 然后重新 up</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">./ai-cache.wasm:/etc/envoy/ai-cache.wasm</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">./ai-proxy.wasm:/etc/envoy/ai-proxy.wasm</span><br><br>  <span class="hljs-attr">chroma:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">chromadb/chroma</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;8001:8000&quot;</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">chroma-data:/chroma/chroma</span><br><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">redis:latest</span><br>    <span class="hljs-attr">networks:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">wasmtest</span><br>    <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;6379:6379&quot;</span><br><br>  <span class="hljs-attr">httpbin:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">kennethreitz/httpbin:latest</span><br>    <span class="hljs-attr">networks:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">wasmtest</span><br>    <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;12345:80&quot;</span><br><br>  <span class="hljs-attr">es:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">elasticsearch:8.15.0</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;TZ=Asia/Shanghai&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;discovery.type=single-node&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;xpack.security.http.ssl.enabled=false&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;xpack.license.self_generated.type=trial&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;ELASTIC_PASSWORD=123456&quot;</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;9200:9200&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;9300:9300&quot;</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">wasmtest</span><br><br><span class="hljs-attr">volumes:</span><br>  <span class="hljs-attr">weaviate_data:</span> &#123;&#125;<br>  <span class="hljs-attr">chroma-data:</span><br>    <span class="hljs-attr">driver:</span> <span class="hljs-string">local</span><br><br><span class="hljs-attr">networks:</span><br>  <span class="hljs-attr">wasmtest:</span> &#123;&#125;<br></code></pre></td></tr></table></figure>
<h2 id="envoy-yaml-文件编写"><a href="#envoy-yaml-文件编写" class="headerlink" title="envoy.yaml 文件编写"></a>envoy.yaml 文件编写</h2><p>在这里踩过许多坑，一一记录下来：</p>
<ol>
<li>在 wasm 插件中如果需要请求外部服务，需要在 <code>envoy.yaml</code> 中的 <code>clusters</code> 中一一指定并使用 <code>cluster_name</code> 访问，比如需要访问远程的 Dashscope Embedding 接口，则需要创建 <code>cluster_name</code> 名为 <code>outbound|443||dashvector.dns</code> 的 cluster，之后在代码中通过以下方式访问：</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">client := wrapper.NewClusterClient(wrapper.DnsCluster&#123;<br>			ServiceName: c.serviceName,<br>			Port:        c.servicePort,<br>			Domain:      c.serviceHost,<br>		&#125;)<br></code></pre></td></tr></table></figure>
<p>   这里的 client 支持以下方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> HttpClient <span class="hljs-keyword">interface</span> &#123;<br>	Get(path <span class="hljs-type">string</span>, headers [][<span class="hljs-number">2</span>]<span class="hljs-type">string</span>, cb ResponseCallback, timeoutMillisecond ...<span class="hljs-type">uint32</span>) <span class="hljs-type">error</span><br>	Head(path <span class="hljs-type">string</span>, headers [][<span class="hljs-number">2</span>]<span class="hljs-type">string</span>, cb ResponseCallback, timeoutMillisecond ...<span class="hljs-type">uint32</span>) <span class="hljs-type">error</span><br>	Options(path <span class="hljs-type">string</span>, headers [][<span class="hljs-number">2</span>]<span class="hljs-type">string</span>, cb ResponseCallback, timeoutMillisecond ...<span class="hljs-type">uint32</span>) <span class="hljs-type">error</span><br>	Post(path <span class="hljs-type">string</span>, headers [][<span class="hljs-number">2</span>]<span class="hljs-type">string</span>, body []<span class="hljs-type">byte</span>, cb ResponseCallback, timeoutMillisecond ...<span class="hljs-type">uint32</span>) <span class="hljs-type">error</span><br>	Put(path <span class="hljs-type">string</span>, headers [][<span class="hljs-number">2</span>]<span class="hljs-type">string</span>, body []<span class="hljs-type">byte</span>, cb ResponseCallback, timeoutMillisecond ...<span class="hljs-type">uint32</span>) <span class="hljs-type">error</span><br>	Patch(path <span class="hljs-type">string</span>, headers [][<span class="hljs-number">2</span>]<span class="hljs-type">string</span>, body []<span class="hljs-type">byte</span>, cb ResponseCallback, timeoutMillisecond ...<span class="hljs-type">uint32</span>) <span class="hljs-type">error</span><br>	Delete(path <span class="hljs-type">string</span>, headers [][<span class="hljs-number">2</span>]<span class="hljs-type">string</span>, body []<span class="hljs-type">byte</span>, cb ResponseCallback, timeoutMillisecond ...<span class="hljs-type">uint32</span>) <span class="hljs-type">error</span><br>	Connect(path <span class="hljs-type">string</span>, headers [][<span class="hljs-number">2</span>]<span class="hljs-type">string</span>, body []<span class="hljs-type">byte</span>, cb ResponseCallback, timeoutMillisecond ...<span class="hljs-type">uint32</span>) <span class="hljs-type">error</span><br>	Trace(path <span class="hljs-type">string</span>, headers [][<span class="hljs-number">2</span>]<span class="hljs-type">string</span>, body []<span class="hljs-type">byte</span>, cb ResponseCallback, timeoutMillisecond ...<span class="hljs-type">uint32</span>) <span class="hljs-type">error</span><br>	Call(method, path <span class="hljs-type">string</span>, headers [][<span class="hljs-number">2</span>]<span class="hljs-type">string</span>, body []<span class="hljs-type">byte</span>, cb ResponseCallback, timeoutMillisecond ...<span class="hljs-type">uint32</span>) <span class="hljs-type">error</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>   <strong>注意，这里的 HttpClient 是异步的，所以如果需要对结果进行处理之后再继续进行，则需要把逻辑写在 <code>ResponseCallback</code> 中。</strong></p>
<ol>
<li>如果请求的服务是 HTTPS，则需要在 <code>cluster</code> 中指定是 <code>tls</code> 以及服务对应的 <code>sni</code>。</li>
<li>envoy.yaml 里配置 Redis cluster 时，socketAddr 要尽量用 IP，不要用主机名。详细原因在 Wasm 插件编写中解释。</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">admin:</span><br>  <span class="hljs-attr">address:</span><br>    <span class="hljs-attr">socket_address:</span><br>      <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>      <span class="hljs-attr">address:</span> <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><br>      <span class="hljs-attr">port_value:</span> <span class="hljs-number">9901</span><br><span class="hljs-attr">static_resources:</span><br>  <span class="hljs-attr">listeners:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">listener_0</span><br>    <span class="hljs-attr">address:</span><br>      <span class="hljs-attr">socket_address:</span><br>        <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>        <span class="hljs-attr">address:</span> <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><br>        <span class="hljs-attr">port_value:</span> <span class="hljs-number">10000</span><br>    <span class="hljs-attr">filter_chains:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">filters:</span><br>      <span class="hljs-comment"># httpbin</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">envoy.filters.network.http_connection_manager</span><br>        <span class="hljs-attr">typed_config:</span><br>          <span class="hljs-string">&quot;@type&quot;</span><span class="hljs-string">:</span> <span class="hljs-string">type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager</span><br>          <span class="hljs-attr">scheme_header_transformation:</span><br>            <span class="hljs-attr">scheme_to_overwrite:</span> <span class="hljs-string">https</span><br>          <span class="hljs-attr">stat_prefix:</span> <span class="hljs-string">ingress_http</span><br>          <span class="hljs-attr">route_config:</span><br>            <span class="hljs-attr">name:</span> <span class="hljs-string">local_route</span><br>            <span class="hljs-attr">virtual_hosts:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">local_service</span><br>              <span class="hljs-attr">domains:</span> [<span class="hljs-string">&quot;*&quot;</span>]<br>              <span class="hljs-attr">routes:</span><br>              <span class="hljs-bullet">-</span> <span class="hljs-attr">match:</span><br>                  <span class="hljs-attr">prefix:</span> <span class="hljs-string">&quot;/&quot;</span><br>                <span class="hljs-attr">route:</span><br>                  <span class="hljs-attr">cluster:</span> <span class="hljs-string">llm</span><br>                  <span class="hljs-attr">timeout:</span> <span class="hljs-string">300s</span><br><br>          <span class="hljs-attr">http_filters:</span><br>          <span class="hljs-comment"># ai-cache</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">ai-cache</span><br>            <span class="hljs-attr">typed_config:</span><br>              <span class="hljs-string">&quot;@type&quot;</span><span class="hljs-string">:</span> <span class="hljs-string">type.googleapis.com/udpa.type.v1.TypedStruct</span><br>              <span class="hljs-attr">type_url:</span> <span class="hljs-string">type.googleapis.com/envoy.extensions.filters.http.wasm.v3.Wasm</span><br>              <span class="hljs-attr">value:</span><br>                <span class="hljs-attr">config:</span><br>                  <span class="hljs-attr">name:</span> <span class="hljs-string">ai-cache</span><br>                  <span class="hljs-attr">vm_config:</span><br>                    <span class="hljs-attr">runtime:</span> <span class="hljs-string">envoy.wasm.runtime.v8</span><br>                    <span class="hljs-attr">code:</span><br>                      <span class="hljs-attr">local:</span><br>                        <span class="hljs-attr">filename:</span> <span class="hljs-string">/etc/envoy/ai-cache.wasm</span><br>                  <span class="hljs-attr">configuration:</span><br>                    <span class="hljs-string">&quot;@type&quot;</span><span class="hljs-string">:</span> <span class="hljs-string">&quot;type.googleapis.com/google.protobuf.StringValue&quot;</span><br>                    <span class="hljs-attr">value:</span> <span class="hljs-string">|</span><br><span class="hljs-string">                      &#123;</span><br><span class="hljs-string">                        &quot;embeddingProvider&quot;: &#123;</span><br><span class="hljs-string">                          &quot;type&quot;: &quot;dashscope&quot;,</span><br><span class="hljs-string">                          &quot;serviceName&quot;: &quot;dashscope&quot;,</span><br><span class="hljs-string">                          &quot;apiKey&quot;: &quot;sk-key&quot;,</span><br><span class="hljs-string">                          &quot;DashScopeServiceName&quot;: &quot;dashscope&quot;</span><br><span class="hljs-string">                        &#125;,</span><br><span class="hljs-string">                        &quot;vectorProvider&quot;: &#123;</span><br><span class="hljs-string">                          &quot;VectorStoreProviderType&quot;: &quot;elasticsearch&quot;,</span><br><span class="hljs-string">                          &quot;ThresholdRelation&quot;: &quot;gte&quot;,</span><br><span class="hljs-string">                          &quot;ESThreshold&quot;: 0.7,</span><br><span class="hljs-string">                          &quot;ESServiceName&quot;: &quot;es&quot;,</span><br><span class="hljs-string">                          &quot;ESIndex&quot;: &quot;higress&quot;,</span><br><span class="hljs-string">                          &quot;ESUsername&quot;: &quot;elastic&quot;,</span><br><span class="hljs-string">                          &quot;ESPassword&quot;: &quot;123456&quot;</span><br><span class="hljs-string">                        &#125;,</span><br><span class="hljs-string">                        &quot;cacheKeyFrom&quot;: &#123;</span><br><span class="hljs-string">                          &quot;requestBody&quot;: &quot;&quot;</span><br><span class="hljs-string">                        &#125;,</span><br><span class="hljs-string">                        &quot;cacheValueFrom&quot;: &#123;</span><br><span class="hljs-string">                          &quot;responseBody&quot;: &quot;&quot;</span><br><span class="hljs-string">                        &#125;,</span><br><span class="hljs-string">                        &quot;cacheStreamValueFrom&quot;: &#123;</span><br><span class="hljs-string">                          &quot;responseBody&quot;: &quot;&quot;</span><br><span class="hljs-string">                        &#125;,</span><br><span class="hljs-string">                        &quot;returnResponseTemplate&quot;: &quot;&quot;,</span><br><span class="hljs-string">                        &quot;returnTestResponseTemplate&quot;: &quot;&quot;,</span><br><span class="hljs-string">                        &quot;ReturnStreamResponseTemplate&quot;: &quot;&quot;,</span><br><span class="hljs-string">                        &quot;redis&quot;: &#123;</span><br><span class="hljs-string">                          &quot;serviceName&quot;: &quot;redis_cluster&quot;,</span><br><span class="hljs-string">                          &quot;timeout&quot;: 2000</span><br><span class="hljs-string">                        &#125;</span><br><span class="hljs-string">                      &#125;</span><br><span class="hljs-string"></span><br>          <span class="hljs-comment"># 上面的配置中 redis 的配置名字是 redis，而不是 golang tag 中的 redisConfig</span><br>                        <span class="hljs-comment"># &quot;vectorProvider&quot;: &#123;</span><br>                        <span class="hljs-comment">#   &quot;VectorStoreProviderType&quot;: &quot;chroma&quot;,</span><br>                        <span class="hljs-comment">#   &quot;ChromaServiceName&quot;: &quot;chroma&quot;,</span><br>                        <span class="hljs-comment">#   &quot;ChromaCollectionID&quot;: &quot;0294deb1-8ef5-4582-b21c-75f23093db2c&quot;</span><br>                        <span class="hljs-comment"># &#125;,</span><br><br>                        <span class="hljs-comment"># &quot;vectorProvider&quot;: &#123;</span><br>                        <span class="hljs-comment">#   &quot;VectorStoreProviderType&quot;: &quot;elasticsearch&quot;,</span><br>                        <span class="hljs-comment">#   &quot;ThresholdRelation&quot;: &quot;gte&quot;,</span><br>                        <span class="hljs-comment">#   &quot;ESThreshold&quot;: 0.7,</span><br>                        <span class="hljs-comment">#   &quot;ESServiceName&quot;: &quot;es&quot;,</span><br>                        <span class="hljs-comment">#   &quot;ESIndex&quot;: &quot;higress&quot;,</span><br>                        <span class="hljs-comment">#   &quot;ESUsername&quot;: &quot;elastic&quot;,</span><br>                        <span class="hljs-comment">#   &quot;ESPassword&quot;: &quot;123456&quot;</span><br>                        <span class="hljs-comment"># &#125;,</span><br>          <span class="hljs-comment"># llm-proxy</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">llm-proxy</span><br>            <span class="hljs-attr">typed_config:</span><br>              <span class="hljs-string">&quot;@type&quot;</span><span class="hljs-string">:</span> <span class="hljs-string">type.googleapis.com/udpa.type.v1.TypedStruct</span><br>              <span class="hljs-attr">type_url:</span> <span class="hljs-string">type.googleapis.com/envoy.extensions.filters.http.wasm.v3.Wasm</span><br>              <span class="hljs-attr">value:</span><br>                <span class="hljs-attr">config:</span><br>                  <span class="hljs-attr">name:</span> <span class="hljs-string">llm</span><br>                  <span class="hljs-attr">vm_config:</span><br>                    <span class="hljs-attr">runtime:</span> <span class="hljs-string">envoy.wasm.runtime.v8</span><br>                    <span class="hljs-attr">code:</span><br>                      <span class="hljs-attr">local:</span><br>                        <span class="hljs-attr">filename:</span> <span class="hljs-string">/etc/envoy/ai-proxy.wasm</span><br>                  <span class="hljs-attr">configuration:</span><br>                    <span class="hljs-string">&quot;@type&quot;</span><span class="hljs-string">:</span> <span class="hljs-string">&quot;type.googleapis.com/google.protobuf.StringValue&quot;</span><br>                    <span class="hljs-attr">value:</span> <span class="hljs-string">|</span> <span class="hljs-comment"># 插件配置</span><br>                      &#123;<br>                        <span class="hljs-attr">&quot;provider&quot;:</span> &#123;<br>                          <span class="hljs-attr">&quot;type&quot;:</span> <span class="hljs-string">&quot;openai&quot;</span>,                                <br>                          <span class="hljs-attr">&quot;apiTokens&quot;:</span> [<br>                            <span class="hljs-string">&quot;YOUR_API_TOKEN&quot;</span><br>                          ],<br>                          <span class="hljs-attr">&quot;openaiCustomUrl&quot;:</span> <span class="hljs-string">&quot;172.17.0.1:8000/v1/chat/completions&quot;</span><br>                        &#125;<br>                      &#125;<br><br><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">envoy.filters.http.router</span><br>      <br>  <span class="hljs-attr">clusters:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">httpbin</span><br>    <span class="hljs-attr">connect_timeout:</span> <span class="hljs-string">30s</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">LOGICAL_DNS</span><br>    <span class="hljs-comment"># Comment out the following line to test on v6 networks</span><br>    <span class="hljs-attr">dns_lookup_family:</span> <span class="hljs-string">V4_ONLY</span><br>    <span class="hljs-attr">lb_policy:</span> <span class="hljs-string">ROUND_ROBIN</span><br>    <span class="hljs-attr">load_assignment:</span><br>      <span class="hljs-attr">cluster_name:</span> <span class="hljs-string">httpbin</span><br>      <span class="hljs-attr">endpoints:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">lb_endpoints:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">endpoint:</span><br>            <span class="hljs-attr">address:</span><br>              <span class="hljs-attr">socket_address:</span><br>                <span class="hljs-attr">address:</span> <span class="hljs-string">httpbin</span><br>                <span class="hljs-attr">port_value:</span> <span class="hljs-number">80</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">outbound|6379||redis_cluster</span><br>    <span class="hljs-attr">connect_timeout:</span> <span class="hljs-string">1s</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">strict_dns</span><br>    <span class="hljs-attr">lb_policy:</span> <span class="hljs-string">ROUND_ROBIN</span><br>    <span class="hljs-attr">load_assignment:</span><br>      <span class="hljs-attr">cluster_name:</span> <span class="hljs-string">outbound|6379||redis_cluster</span><br>      <span class="hljs-attr">endpoints:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">lb_endpoints:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">endpoint:</span><br>                <span class="hljs-attr">address:</span><br>                  <span class="hljs-attr">socket_address:</span><br>                    <span class="hljs-attr">address:</span> <span class="hljs-number">172.17</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><br>                    <span class="hljs-attr">port_value:</span> <span class="hljs-number">6379</span><br>    <span class="hljs-attr">typed_extension_protocol_options:</span><br>      <span class="hljs-attr">envoy.filters.network.redis_proxy:</span><br>        <span class="hljs-string">&quot;@type&quot;</span><span class="hljs-string">:</span> <span class="hljs-string">type.googleapis.com/envoy.extensions.filters.network.redis_proxy.v3.RedisProtocolOptions</span><br>  <span class="hljs-comment"># chroma</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">outbound|8001||chroma.dns</span><br>    <span class="hljs-attr">connect_timeout:</span> <span class="hljs-string">30s</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">LOGICAL_DNS</span><br>    <span class="hljs-attr">dns_lookup_family:</span> <span class="hljs-string">V4_ONLY</span><br>    <span class="hljs-attr">lb_policy:</span> <span class="hljs-string">ROUND_ROBIN</span><br>    <span class="hljs-attr">load_assignment:</span><br>      <span class="hljs-attr">cluster_name:</span> <span class="hljs-string">outbound|8001||chroma.dns</span><br>      <span class="hljs-attr">endpoints:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">lb_endpoints:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">endpoint:</span><br>                <span class="hljs-attr">address:</span><br>                  <span class="hljs-attr">socket_address:</span><br>                    <span class="hljs-attr">address:</span> <span class="hljs-number">172.17</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span> <span class="hljs-comment"># 本地 API 服务地址，这里是 docker0</span><br>                    <span class="hljs-attr">port_value:</span> <span class="hljs-number">8001</span><br><br>  <span class="hljs-comment"># es</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">outbound|9200||es.dns</span><br>    <span class="hljs-attr">connect_timeout:</span> <span class="hljs-string">30s</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">LOGICAL_DNS</span><br>    <span class="hljs-attr">dns_lookup_family:</span> <span class="hljs-string">V4_ONLY</span><br>    <span class="hljs-attr">lb_policy:</span> <span class="hljs-string">ROUND_ROBIN</span><br>    <span class="hljs-attr">load_assignment:</span><br>      <span class="hljs-attr">cluster_name:</span> <span class="hljs-string">outbound|9200||es.dns</span><br>      <span class="hljs-attr">endpoints:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">lb_endpoints:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">endpoint:</span><br>                <span class="hljs-attr">address:</span><br>                  <span class="hljs-attr">socket_address:</span><br>                    <span class="hljs-attr">address:</span> <span class="hljs-number">172.17</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span> <span class="hljs-comment"># 本地 API 服务地址，这里是 docker0</span><br>                    <span class="hljs-attr">port_value:</span> <span class="hljs-number">9200</span><br><br>  <span class="hljs-comment"># llm</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">llm</span><br>    <span class="hljs-attr">connect_timeout:</span> <span class="hljs-string">30s</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">LOGICAL_DNS</span><br>    <span class="hljs-attr">dns_lookup_family:</span> <span class="hljs-string">V4_ONLY</span><br>    <span class="hljs-attr">lb_policy:</span> <span class="hljs-string">ROUND_ROBIN</span><br>    <span class="hljs-attr">load_assignment:</span><br>      <span class="hljs-attr">cluster_name:</span> <span class="hljs-string">llm</span><br>      <span class="hljs-attr">endpoints:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">lb_endpoints:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">endpoint:</span><br>                <span class="hljs-attr">address:</span><br>                  <span class="hljs-attr">socket_address:</span><br>                    <span class="hljs-attr">address:</span> <span class="hljs-number">172.17</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span> <span class="hljs-comment"># 本地 API 服务地址，这里是 docker0</span><br>                    <span class="hljs-attr">port_value:</span> <span class="hljs-number">8000</span><br>  <span class="hljs-comment"># dashvector</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">outbound|443||dashvector.dns</span><br>    <span class="hljs-attr">connect_timeout:</span> <span class="hljs-string">30s</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">LOGICAL_DNS</span><br>    <span class="hljs-attr">dns_lookup_family:</span> <span class="hljs-string">V4_ONLY</span><br>    <span class="hljs-attr">lb_policy:</span> <span class="hljs-string">ROUND_ROBIN</span><br>    <span class="hljs-attr">load_assignment:</span><br>      <span class="hljs-attr">cluster_name:</span> <span class="hljs-string">outbound|443||dashvector.dns</span><br>      <span class="hljs-attr">endpoints:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">lb_endpoints:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">endpoint:</span><br>                <span class="hljs-attr">address:</span><br>                  <span class="hljs-attr">socket_address:</span><br>                    <span class="hljs-attr">address:</span> <span class="hljs-string">vrs-cn-0dw3vnaqs0002z.dashvector.cn-hangzhou.aliyuncs.com</span><br>                    <span class="hljs-attr">port_value:</span> <span class="hljs-number">443</span><br>    <span class="hljs-attr">transport_socket:</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">envoy.transport_sockets.tls</span><br>      <span class="hljs-attr">typed_config:</span><br>        <span class="hljs-string">&quot;@type&quot;</span><span class="hljs-string">:</span> <span class="hljs-string">type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext</span><br>        <span class="hljs-attr">&quot;sni&quot;:</span> <span class="hljs-string">&quot;vrs-cn-0dw3vnaqs0002z.dashvector.cn-hangzhou.aliyuncs.com&quot;</span><br>  <span class="hljs-comment"># dashscope</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">outbound|443||dashscope.dns</span><br>    <span class="hljs-attr">connect_timeout:</span> <span class="hljs-string">30s</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">LOGICAL_DNS</span><br>    <span class="hljs-attr">dns_lookup_family:</span> <span class="hljs-string">V4_ONLY</span><br>    <span class="hljs-attr">lb_policy:</span> <span class="hljs-string">ROUND_ROBIN</span><br>    <span class="hljs-attr">load_assignment:</span><br>      <span class="hljs-attr">cluster_name:</span> <span class="hljs-string">outbound|443||dashscope.dns</span><br>      <span class="hljs-attr">endpoints:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">lb_endpoints:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">endpoint:</span><br>                <span class="hljs-attr">address:</span><br>                  <span class="hljs-attr">socket_address:</span><br>                    <span class="hljs-attr">address:</span> <span class="hljs-string">dashscope.aliyuncs.com</span><br>                    <span class="hljs-attr">port_value:</span> <span class="hljs-number">443</span><br>    <span class="hljs-attr">transport_socket:</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">envoy.transport_sockets.tls</span><br>      <span class="hljs-attr">typed_config:</span><br>        <span class="hljs-string">&quot;@type&quot;</span><span class="hljs-string">:</span> <span class="hljs-string">type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext</span><br>        <span class="hljs-attr">&quot;sni&quot;:</span> <span class="hljs-string">&quot;dashscope.aliyuncs.com&quot;</span><br></code></pre></td></tr></table></figure>
<h2 id="Wasm-插件编写"><a href="#Wasm-插件编写" class="headerlink" title="Wasm 插件编写"></a>Wasm 插件编写</h2><h3 id="Wasm-插件中无法使用-golang-的-net-http-库发送请求，必须使用-higress-封装的-HTTP-client"><a href="#Wasm-插件中无法使用-golang-的-net-http-库发送请求，必须使用-higress-封装的-HTTP-client" class="headerlink" title="Wasm 插件中无法使用 golang 的 net/http 库发送请求，必须使用 higress 封装的 HTTP client"></a>Wasm 插件中无法使用 golang 的 <code>net/http</code> 库发送请求，必须使用 higress 封装的 HTTP client</h3><h3 id="Wasm-插件请求-Redis-时，提示-“bad-argument”-错误"><a href="#Wasm-插件请求-Redis-时，提示-“bad-argument”-错误" class="headerlink" title="Wasm 插件请求 Redis 时，提示 “bad argument” 错误"></a>Wasm 插件请求 Redis 时，提示 “bad argument” 错误</h3><p>   解决办法：envoy.yaml 里配置 Redis cluster 时，socketAddr 要用 IP，不要用主机名。</p>
<p>   在开发 Wasm 插件过程中，我们镜像会使用 Docker Compose + Envoy + Volume Mount 的方式测试本地构建出来的插件。如果插件需要连接 Redis，那么我们就需要在 envoy.yaml 中配置一个 Redis 的 cluster。如果配置中的 Redis 节点地址使用机器名，那么在启动插件的时候可能会出现初始化 Redis 客户端报“bad argument”的错误。</p>
<p>   原因：这种错误一般只发生在插件在 <code>parseConfig</code> 阶段调用 <code>RedisClusterClient.Init()</code> 函数的时候。、</p>
<p>   在 Envoy 初始化的过程中，集群信息的初始化与 Wasm 插件的初始化可以认为是并行进行的。如果使用主机名进行配置，要获取实例的实际 IP 就需要经过 DNS 解析。而 DNS 解析一般是需要一些时间的，Redis 客户端的初始化又需要与 Redis 集群建立连接和通信。这一延迟就可能会导致 Wasm 插件进行初始化时 Redis 的集群信息还没有就绪，进而引发上述报错。</p>
<p>   而在 Higress 的实际运行过程中，集群信息是通过 xDS 进行下发的，这个延迟的问题不会非常显著。</p>
<h3 id="proxywasm-ResumeHttpRequest-的使用"><a href="#proxywasm-ResumeHttpRequest-的使用" class="headerlink" title="proxywasm.ResumeHttpRequest() 的使用"></a><code>proxywasm.ResumeHttpRequest()</code> 的使用</h3><p>下面是一个 wasm 插件访问外部请求并返回给下游的例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">onHttpRequestHeaders</span><span class="hljs-params">(ctx wrapper.HttpContext, config MyConfig, log wrapper.Log)</span></span> types.Action &#123;<br>  <span class="hljs-comment">// 使用client的Get方法发起HTTP Get调用，此处省略了timeout参数，默认超时时间500毫秒</span><br>  config.client.Get(config.requestPath, <span class="hljs-literal">nil</span>,<br>    <span class="hljs-comment">// 回调函数，将在响应异步返回时被执行</span><br>    <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(statusCode <span class="hljs-type">int</span>, responseHeaders http.Header, responseBody []<span class="hljs-type">byte</span>)</span></span> &#123;<br>      <span class="hljs-comment">// 请求没有返回200状态码，进行处理</span><br>      <span class="hljs-keyword">if</span> statusCode != http.StatusOK &#123;<br>        log.Errorf(<span class="hljs-string">&quot;http call failed, status: %d&quot;</span>, statusCode)<br>        proxywasm.SendHttpResponse(http.StatusInternalServerError, <span class="hljs-literal">nil</span>,<br>          []<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;http call failed&quot;</span>), <span class="hljs-number">-1</span>)<br>        <span class="hljs-keyword">return</span><br>      &#125;<br>      <span class="hljs-comment">// 打印响应的HTTP状态码和应答body</span><br>      log.Infof(<span class="hljs-string">&quot;get status: %d, response body: %s&quot;</span>, statusCode, responseBody)<br>      <span class="hljs-comment">// 从应答头中解析token字段设置到原始请求头中</span><br>      token := responseHeaders.Get(config.tokenHeader)<br>      <span class="hljs-keyword">if</span> token != <span class="hljs-string">&quot;&quot;</span> &#123;<br>        proxywasm.AddHttpRequestHeader(config.tokenHeader, token)<br>      &#125;<br>      <span class="hljs-comment">// 恢复原始请求流程，继续往下处理，才能正常转发给后端服务</span><br>      proxywasm.ResumeHttpRequest()<br>    &#125;)<br>  <span class="hljs-comment">// 需要等待异步回调完成，返回Pause状态，可以被ResumeHttpRequest恢复</span><br>  <span class="hljs-keyword">return</span> types.ActionPause<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在这里需要注意的是 <code>onHttpRequestHeaders</code> 方法返回了 <code>types.ActionPause</code> 等待了 <code>Get</code> 方法，我们前面说过 <code>client.Get</code> 是一个异步请求，如果不显式地进行等待，那么下游无法得到 higress 的请求结果。因此这里返回 <code>types.ActionPause</code> 等待请求完成之后，在 <code>client.Get</code> 的 response callback 函数中调用 <code>proxywasm.ResumeHttpRequest()</code> 恢复原始请求流程，继续往下处理，才能正常转发给后端服务。</p>
]]></content>
      <categories>
        <category>higress</category>
      </categories>
  </entry>
  <entry>
    <title>Internlm-03-基于 InternLM 和 LangChain 搭建你的知识库</title>
    <url>/internlm/internlm-03/</url>
    <content><![CDATA[<h1 id="基于-InternLM-和-LangChain-搭建你的知识库"><a href="#基于-InternLM-和-LangChain-搭建你的知识库" class="headerlink" title="基于 InternLM 和 LangChain 搭建你的知识库"></a>基于 InternLM 和 LangChain 搭建你的知识库</h1><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><h3 id="InternLM-环境"><a href="#InternLM-环境" class="headerlink" title="InternLM 环境"></a>InternLM 环境</h3><p>开发环境除了 <code>pytorch</code> 等库以外，还需要安装以下库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 升级pip</span><br>python -m pip install --upgrade pip<br><br>pip install modelscope==1.9.5<br>pip install transformers==4.35.2<br>pip install streamlit==1.24.0<br>pip install sentencepiece==0.1.99<br>pip install accelerate==0.24.1<br></code></pre></td></tr></table></figure>
<h3 id="模型下载"><a href="#模型下载" class="headerlink" title="模型下载"></a>模型下载</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">import torch<br>from modelscope import snapshot_download, AutoModel, AutoTokenizer<br>import os<br>model_dir = snapshot_download(<span class="hljs-string">&#x27;Shanghai_AI_Laboratory/internlm-chat-7b&#x27;</span>, cache_dir=<span class="hljs-string">&#x27;/root/data/model&#x27;</span>, revision=<span class="hljs-string">&#x27;v1.0.3&#x27;</span>)<br></code></pre></td></tr></table></figure>
<h3 id="配置-Langchain"><a href="#配置-Langchain" class="headerlink" title="配置 Langchain"></a>配置 Langchain</h3><p>除了配置大模型的运行环境以外，还需要配置 Langchain 运行环境。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">pip install langchain==0.0.292<br>pip install gradio==4.4.0<br>pip install chromadb==0.4.15<br>pip install sentence-transformers==2.2.2<br>pip install unstructured==0.10.30<br>pip install markdown==3.3.7<br></code></pre></td></tr></table></figure>
<p><img  src="安装依赖.png"  ><span class="image-caption">安装依赖</span></p>
<h3 id="下载-Embedding-模型"><a href="#下载-Embedding-模型" class="headerlink" title="下载 Embedding 模型"></a>下载 Embedding 模型</h3><p>同时，我们需要使用到开源词向量模型 <a href="https://huggingface.co/sentence-transformers/paraphrase-multilingual-MiniLM-L12-v2">Sentence Transformer - paraphrase-multilingual-MiniLM-L12-v2</a>:（我们也可以选用别的开源词向量模型来进行 Embedding，教程中选用这个模型是相对轻量、支持中文且效果较好的，我这里选择使用了更为好用的 bge 系列的 Embedding 模型 <a href="[BAAI/bge-large-zh-v1.5 · Hugging Face](https://huggingface.co/BAAI/bge-large-zh-v1.5">BAAI/bge-large-zh-v1.5</a>)）</p>
<p>首先需要使用 <code>huggingface</code> 官方提供的 <code>huggingface-cli</code> 命令行工具。安装依赖:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">pip install -U huggingface_hub<br></code></pre></td></tr></table></figure>
<p>然后在和 <code>/root/data</code> 目录下新建python文件 <code>download_hf.py</code>，填入以下代码：</p>
<ul>
<li>resume-download：断点续下</li>
<li>local-dir：本地存储路径。（linux环境下需要填写绝对路径）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><br><span class="hljs-comment"># 下载模型</span><br>os.system(<span class="hljs-string">&#x27;huggingface-cli download --resume-download BAAI/bge-large-zh-v1.5 --local-dir /root/data/model/bge-large-zh-v1.5&#x27;</span>)<br></code></pre></td></tr></table></figure>
<p>但是，使用 huggingface 下载可能速度较慢，我们可以使用 huggingface 镜像下载。与使用hugginge face下载相同，只需要填入镜像地址即可。</p>
<p>将 <code>download_hf.py</code> 中的代码修改为以下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><br><span class="hljs-comment"># 设置环境变量</span><br>os.environ[<span class="hljs-string">&#x27;HF_ENDPOINT&#x27;</span>] = <span class="hljs-string">&#x27;https://hf-mirror.com&#x27;</span><br><br><span class="hljs-comment"># 下载模型</span><br>os.system(<span class="hljs-string">&#x27;huggingface-cli download --resume-download BAAI/bge-large-zh-v1.5 --local-dir /root/data/model/bge-large-zh-v1.5&#x27;</span>)<br></code></pre></td></tr></table></figure>
<p>然后，在 <code>/root/data</code> 目录下执行该脚本即可自动开始下载：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">python download_hf.py<br></code></pre></td></tr></table></figure>
<p><img  src="下载bge.png"  ><span class="image-caption">下载bge模型</span></p>
<h3 id="下载-NLTK-相关资源"><a href="#下载-NLTK-相关资源" class="headerlink" title="下载 NLTK 相关资源"></a>下载 NLTK 相关资源</h3><p>我们在使用开源词向量模型构建开源词向量的时候，需要用到第三方库 <code>nltk</code> 的一些资源。正常情况下，其会自动从互联网上下载，但可能由于网络原因会导致下载中断，此处我们可以从国内仓库镜像地址下载相关资源，保存到服务器上。</p>
<p>我们用以下命令下载 nltk 资源并解压到服务器上：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /root<br>git <span class="hljs-built_in">clone</span> https://gitee.com/yzy0612/nltk_data.git  --branch gh-pages<br><span class="hljs-built_in">cd</span> nltk_data<br><span class="hljs-built_in">mv</span> packages/*  ./<br><span class="hljs-built_in">cd</span> tokenizers<br>unzip punkt.zip<br><span class="hljs-built_in">cd</span> ../taggers<br>unzip averaged_perceptron_tagger.zip<br></code></pre></td></tr></table></figure>
<p>之后使用时服务器即会自动使用已有资源，无需再次下载。</p>
<h3 id="下载教程代码"><a href="#下载教程代码" class="headerlink" title="下载教程代码"></a>下载教程代码</h3><p>我们在仓库中同步提供了所有脚本，可以查看该教程文件的同级目录的 <code>demo</code> 文件夹。</p>
<p>建议通过以下目录将仓库 clone 到本地，可以直接在本地运行相关代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /root/data<br>git <span class="hljs-built_in">clone</span> https://github.com/InternLM/tutorial<br></code></pre></td></tr></table></figure>
<p>通过上述命令，可以将本仓库 clone 到本地 <code>root/data/tutorial</code> 目录下，在之后的过程中可以对照仓库中的脚本来完成自己的代码，也可以直接使用仓库中的脚本。</p>
<h2 id="知识库搭建"><a href="#知识库搭建" class="headerlink" title="知识库搭建"></a>知识库搭建</h2><h3 id="数据收集"><a href="#数据收集" class="headerlink" title="数据收集"></a>数据收集</h3><p>教程选择了由上海人工智能实验室开源的一系列大模型工具开源仓库作为语料库来源，包括：</p>
<ul>
<li><a href="https://gitee.com/open-compass/opencompass">OpenCompass</a>：面向大模型评测的一站式平台</li>
<li><a href="https://gitee.com/InternLM/lmdeploy">IMDeploy</a>：涵盖了 LLM 任务的全套轻量化、部署和服务解决方案的高效推理工具箱</li>
<li><a href="https://gitee.com/InternLM/xtuner">XTuner</a>：轻量级微调大语言模型的工具库</li>
<li><a href="https://gitee.com/InternLM/InternLM-XComposer">InternLM-XComposer</a>：浦语·灵笔，基于书生·浦语大语言模型研发的视觉-语言大模型</li>
<li><a href="https://gitee.com/InternLM/lagent">Lagent</a>：一个轻量级、开源的基于大语言模型的智能体（agent）框架</li>
<li><a href="https://gitee.com/InternLM/InternLM">InternLM</a>：一个开源的轻量级训练框架，旨在支持大模型训练而无需大量的依赖</li>
</ul>
<p>首先我们需要将上述远程开源仓库 Clone 到本地，可以使用以下命令：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># 进入到数据库盘</span><br>cd <span class="hljs-regexp">/root/</span>data<br><span class="hljs-comment"># clone 上述开源仓库</span><br>git clone https:<span class="hljs-regexp">//gi</span>tee.com<span class="hljs-regexp">/open-compass/</span>opencompass.git<br>git clone https:<span class="hljs-regexp">//gi</span>tee.com<span class="hljs-regexp">/InternLM/</span>lmdeploy.git<br>git clone https:<span class="hljs-regexp">//gi</span>tee.com<span class="hljs-regexp">/InternLM/</span>xtuner.git<br>git clone https:<span class="hljs-regexp">//gi</span>tee.com<span class="hljs-regexp">/InternLM/</span>InternLM-XComposer.git<br>git clone https:<span class="hljs-regexp">//gi</span>tee.com<span class="hljs-regexp">/InternLM/</span>lagent.git<br>git clone https:<span class="hljs-regexp">//gi</span>tee.com<span class="hljs-regexp">/InternLM/</span>InternLM.git<br></code></pre></td></tr></table></figure>
<p>接着，为语料处理方便，我们将选用上述仓库中所有的 markdown、txt 文件作为示例语料库。注意，也可以选用其中的代码文件加入到知识库中，但需要针对代码文件格式进行额外处理（因为代码文件对逻辑联系要求较高，且规范性较强，在分割时最好基于代码模块进行分割再加入向量数据库）。</p>
<p>我们首先将上述仓库中所有满足条件的文件路径找出来，我们定义一个函数，该函数将递归指定文件夹路径，返回其中所有满足条件（即后缀名为 .md 或者 .txt 的文件）的文件路径：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_files</span>(<span class="hljs-params">dir_path</span>):<br>    <span class="hljs-comment"># args：dir_path，目标文件夹路径</span><br>    file_list = []<br>    <span class="hljs-keyword">for</span> filepath, dirnames, filenames <span class="hljs-keyword">in</span> os.walk(dir_path):<br>        <span class="hljs-comment"># os.walk 函数将递归遍历指定文件夹</span><br>        <span class="hljs-keyword">for</span> filename <span class="hljs-keyword">in</span> filenames:<br>            <span class="hljs-comment"># 通过后缀名判断文件类型是否满足要求</span><br>            <span class="hljs-keyword">if</span> filename.endswith(<span class="hljs-string">&quot;.md&quot;</span>):<br>                <span class="hljs-comment"># 如果满足要求，将其绝对路径加入到结果列表</span><br>                file_list.append(os.path.join(filepath, filename))<br>            <span class="hljs-keyword">elif</span> filename.endswith(<span class="hljs-string">&quot;.txt&quot;</span>):<br>                file_list.append(os.path.join(filepath, filename))<br>    <span class="hljs-keyword">return</span> file_list<br></code></pre></td></tr></table></figure>
<h3 id="加载数据"><a href="#加载数据" class="headerlink" title="加载数据"></a>加载数据</h3><p>得到所有目标文件路径之后，我们可以使用 LangChain 提供的 FileLoader 对象来加载目标文件，得到由目标文件解析出的纯文本内容。由于不同类型的文件需要对应不同的 FileLoader，我们判断目标文件类型，并针对性调用对应类型的 FileLoader，同时，调用 FileLoader 对象的 load 方法来得到加载之后的纯文本对象：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> tqdm <span class="hljs-keyword">import</span> tqdm<br><span class="hljs-keyword">from</span> langchain.document_loaders <span class="hljs-keyword">import</span> UnstructuredFileLoader<br><span class="hljs-keyword">from</span> langchain.document_loaders <span class="hljs-keyword">import</span> UnstructuredMarkdownLoader<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_text</span>(<span class="hljs-params">dir_path</span>):<br>    <span class="hljs-comment"># args：dir_path，目标文件夹路径</span><br>    <span class="hljs-comment"># 首先调用上文定义的函数得到目标文件路径列表</span><br>    file_lst = get_files(dir_path)<br>    <span class="hljs-comment"># docs 存放加载之后的纯文本对象</span><br>    docs = []<br>    <span class="hljs-comment"># 遍历所有目标文件</span><br>    <span class="hljs-keyword">for</span> one_file <span class="hljs-keyword">in</span> tqdm(file_lst):<br>        file_type = one_file.split(<span class="hljs-string">&#x27;.&#x27;</span>)[-<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">if</span> file_type == <span class="hljs-string">&#x27;md&#x27;</span>:<br>            loader = UnstructuredMarkdownLoader(one_file)<br>        <span class="hljs-keyword">elif</span> file_type == <span class="hljs-string">&#x27;txt&#x27;</span>:<br>            loader = UnstructuredFileLoader(one_file)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 如果是不符合条件的文件，直接跳过</span><br>            <span class="hljs-keyword">continue</span><br>        docs.extend(loader.load())<br>    <span class="hljs-keyword">return</span> docs<br></code></pre></td></tr></table></figure>
<p>使用上文函数，我们得到的 <code>docs</code> 为一个纯文本对象对应的列表。</p>
<h3 id="构建向量数据库"><a href="#构建向量数据库" class="headerlink" title="构建向量数据库"></a>构建向量数据库</h3><p>得到该列表之后，我们就可以将它引入到 LangChain 框架中构建向量数据库。由纯文本对象构建向量数据库，我们需要先对文本进行分块，接着对文本块进行向量化。</p>
<p>LangChain 提供了多种文本分块工具，此处我们使用字符串递归分割器，并选择分块大小为 500，块重叠长度为 150（由于篇幅限制，此处没有展示切割效果，学习者可以自行尝试一下，想要深入学习 LangChain 文本分块可以参考教程 <a href="https://github.com/datawhalechina/prompt-engineering-for-developers/blob/9dbcb48416eb8af9ff9447388838521dc0f9acb0/content/LangChain Chat with Your Data/1.简介 Introduction.md">《LangChain - Chat With Your Data》</a>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> langchain.text_splitter <span class="hljs-keyword">import</span> RecursiveCharacterTextSplitter<br><br>text_splitter = RecursiveCharacterTextSplitter(<br>    chunk_size=<span class="hljs-number">500</span>, chunk_overlap=<span class="hljs-number">150</span>)<br>split_docs = text_splitter.split_documents(docs)<br></code></pre></td></tr></table></figure>
<p>接着我们选用开源词向量模型 <a href="https://huggingface.co/sentence-transformers/paraphrase-multilingual-MiniLM-L12-v2">Sentence Transformer</a> 来进行文本向量化。LangChain 提供了直接引入 HuggingFace 开源社区中的模型进行向量化的接口：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> langchain.embeddings.huggingface <span class="hljs-keyword">import</span> HuggingFaceEmbeddings<br><br>embeddings = HuggingFaceEmbeddings(model_name=<span class="hljs-string">&quot;/root/data/model/bge-large-zh-v1.5&quot;</span>)<br></code></pre></td></tr></table></figure>
<p>同时，考虑到 Chroma 是目前最常用的入门数据库，我们选择 Chroma 作为向量数据库，基于上文分块后的文档以及加载的开源向量化模型，将语料加载到指定路径下的向量数据库：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> langchain.vectorstores <span class="hljs-keyword">import</span> Chroma<br><br><span class="hljs-comment"># 定义持久化路径</span><br>persist_directory = <span class="hljs-string">&#x27;data_base/vector_db/chroma&#x27;</span><br><span class="hljs-comment"># 加载数据库</span><br>vectordb = Chroma.from_documents(<br>    documents=split_docs,<br>    embedding=embeddings,<br>    persist_directory=persist_directory  <span class="hljs-comment"># 允许我们将persist_directory目录保存到磁盘上</span><br>)<br><span class="hljs-comment"># 将加载的向量数据库持久化到磁盘上</span><br>vectordb.persist()<br></code></pre></td></tr></table></figure>
<h3 id="整体脚本"><a href="#整体脚本" class="headerlink" title="整体脚本"></a>整体脚本</h3><p>将上述代码整合在一起为知识库搭建的脚本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 首先导入所需第三方库</span><br><span class="hljs-keyword">from</span> langchain.document_loaders <span class="hljs-keyword">import</span> UnstructuredFileLoader<br><span class="hljs-keyword">from</span> langchain.document_loaders <span class="hljs-keyword">import</span> UnstructuredMarkdownLoader<br><span class="hljs-keyword">from</span> langchain.text_splitter <span class="hljs-keyword">import</span> RecursiveCharacterTextSplitter<br><span class="hljs-keyword">from</span> langchain.vectorstores <span class="hljs-keyword">import</span> Chroma<br><span class="hljs-keyword">from</span> langchain.embeddings.huggingface <span class="hljs-keyword">import</span> HuggingFaceEmbeddings<br><span class="hljs-keyword">from</span> tqdm <span class="hljs-keyword">import</span> tqdm<br><span class="hljs-keyword">import</span> os<br><br><span class="hljs-comment"># 获取文件路径函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_files</span>(<span class="hljs-params">dir_path</span>):<br>    <span class="hljs-comment"># args：dir_path，目标文件夹路径</span><br>    file_list = []<br>    <span class="hljs-keyword">for</span> filepath, dirnames, filenames <span class="hljs-keyword">in</span> os.walk(dir_path):<br>        <span class="hljs-comment"># os.walk 函数将递归遍历指定文件夹</span><br>        <span class="hljs-keyword">for</span> filename <span class="hljs-keyword">in</span> filenames:<br>            <span class="hljs-comment"># 通过后缀名判断文件类型是否满足要求</span><br>            <span class="hljs-keyword">if</span> filename.endswith(<span class="hljs-string">&quot;.md&quot;</span>):<br>                <span class="hljs-comment"># 如果满足要求，将其绝对路径加入到结果列表</span><br>                file_list.append(os.path.join(filepath, filename))<br>            <span class="hljs-keyword">elif</span> filename.endswith(<span class="hljs-string">&quot;.txt&quot;</span>):<br>                file_list.append(os.path.join(filepath, filename))<br>    <span class="hljs-keyword">return</span> file_list<br><br><span class="hljs-comment"># 加载文件函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_text</span>(<span class="hljs-params">dir_path</span>):<br>    <span class="hljs-comment"># args：dir_path，目标文件夹路径</span><br>    <span class="hljs-comment"># 首先调用上文定义的函数得到目标文件路径列表</span><br>    file_lst = get_files(dir_path)<br>    <span class="hljs-comment"># docs 存放加载之后的纯文本对象</span><br>    docs = []<br>    <span class="hljs-comment"># 遍历所有目标文件</span><br>    <span class="hljs-keyword">for</span> one_file <span class="hljs-keyword">in</span> tqdm(file_lst):<br>        file_type = one_file.split(<span class="hljs-string">&#x27;.&#x27;</span>)[-<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">if</span> file_type == <span class="hljs-string">&#x27;md&#x27;</span>:<br>            loader = UnstructuredMarkdownLoader(one_file)<br>        <span class="hljs-keyword">elif</span> file_type == <span class="hljs-string">&#x27;txt&#x27;</span>:<br>            loader = UnstructuredFileLoader(one_file)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 如果是不符合条件的文件，直接跳过</span><br>            <span class="hljs-keyword">continue</span><br>        docs.extend(loader.load())<br>    <span class="hljs-keyword">return</span> docs<br><br><span class="hljs-comment"># 目标文件夹</span><br>tar_dir = [<br>    <span class="hljs-string">&quot;/root/data/InternLM&quot;</span>,<br>    <span class="hljs-string">&quot;/root/data/InternLM-XComposer&quot;</span>,<br>    <span class="hljs-string">&quot;/root/data/lagent&quot;</span>,<br>    <span class="hljs-string">&quot;/root/data/lmdeploy&quot;</span>,<br>    <span class="hljs-string">&quot;/root/data/opencompass&quot;</span>,<br>    <span class="hljs-string">&quot;/root/data/xtuner&quot;</span><br>]<br><br><span class="hljs-comment"># 加载目标文件</span><br>docs = []<br><span class="hljs-keyword">for</span> dir_path <span class="hljs-keyword">in</span> tar_dir:<br>    docs.extend(get_text(dir_path))<br><br><span class="hljs-comment"># 对文本进行分块</span><br>text_splitter = RecursiveCharacterTextSplitter(<br>    chunk_size=<span class="hljs-number">500</span>, chunk_overlap=<span class="hljs-number">150</span>)<br>split_docs = text_splitter.split_documents(docs)<br><br><span class="hljs-comment"># 加载开源词向量模型</span><br>embeddings = HuggingFaceEmbeddings(model_name=<span class="hljs-string">&quot;/root/data/model/bge-large-zh-v1.5&quot;</span>)<br><br><span class="hljs-comment"># 构建向量数据库</span><br><span class="hljs-comment"># 定义持久化路径</span><br>persist_directory = <span class="hljs-string">&#x27;data_base/vector_db/chroma&#x27;</span><br><span class="hljs-comment"># 加载数据库</span><br>vectordb = Chroma.from_documents(<br>    documents=split_docs,<br>    embedding=embeddings,<br>    persist_directory=persist_directory  <span class="hljs-comment"># 允许我们将persist_directory目录保存到磁盘上</span><br>)<br><span class="hljs-comment"># 将加载的向量数据库持久化到磁盘上</span><br>vectordb.persist()<br></code></pre></td></tr></table></figure>
<p>可以在 <code>/root/data</code> 下新建一个 <code>demo</code>目录，将该脚本和后续脚本均放在该目录下运行。运行上述脚本，即可在本地构建已持久化的向量数据库，后续直接导入该数据库即可，无需重复构建。</p>
<h2 id="InternLM-接入-LangChain"><a href="#InternLM-接入-LangChain" class="headerlink" title="InternLM 接入 LangChain"></a>InternLM 接入 LangChain</h2><p>为便捷构建 LLM 应用，我们需要基于本地部署的 InternLM，继承 LangChain 的 LLM 类自定义一个 InternLM LLM 子类，从而实现将 InternLM 接入到 LangChain 框架中。完成 LangChain 的自定义 LLM 子类之后，可以以完全一致的方式调用 LangChain 的接口，而无需考虑底层模型调用的不一致。</p>
<p>基于本地部署的 InternLM 自定义 LLM 类并不复杂，我们只需从 LangChain.llms.base.LLM 类继承一个子类，并重写构造函数与 <code>_call</code> 函数即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> langchain.llms.base <span class="hljs-keyword">import</span> LLM<br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">Any</span>, <span class="hljs-type">List</span>, <span class="hljs-type">Optional</span><br><span class="hljs-keyword">from</span> langchain.callbacks.manager <span class="hljs-keyword">import</span> CallbackManagerForLLMRun<br><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer, AutoModelForCausalLM<br><span class="hljs-keyword">import</span> torch<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">InternLM_LLM</span>(<span class="hljs-title class_ inherited__">LLM</span>):<br>    <span class="hljs-comment"># 基于本地 InternLM 自定义 LLM 类</span><br>    tokenizer : AutoTokenizer = <span class="hljs-literal">None</span><br>    model: AutoModelForCausalLM = <span class="hljs-literal">None</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, model_path :<span class="hljs-built_in">str</span></span>):<br>        <span class="hljs-comment"># model_path: InternLM 模型路径</span><br>        <span class="hljs-comment"># 从本地初始化模型</span><br>        <span class="hljs-built_in">super</span>().__init__()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在从本地加载模型...&quot;</span>)<br>        self.tokenizer = AutoTokenizer.from_pretrained(model_path, trust_remote_code=<span class="hljs-literal">True</span>)<br>        self.model = AutoModelForCausalLM.from_pretrained(model_path, trust_remote_code=<span class="hljs-literal">True</span>).to(torch.bfloat16).cuda()<br>        self.model = self.model.<span class="hljs-built_in">eval</span>()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;完成本地模型的加载&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_call</span>(<span class="hljs-params">self, prompt : <span class="hljs-built_in">str</span>, stop: <span class="hljs-type">Optional</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]] = <span class="hljs-literal">None</span>,</span><br><span class="hljs-params">                run_manager: <span class="hljs-type">Optional</span>[CallbackManagerForLLMRun] = <span class="hljs-literal">None</span>,</span><br><span class="hljs-params">                **kwargs: <span class="hljs-type">Any</span></span>):<br>        <span class="hljs-comment"># 重写调用函数</span><br>        system_prompt = <span class="hljs-string">&quot;&quot;&quot;You are an AI assistant whose name is InternLM (书生·浦语).</span><br><span class="hljs-string">        - InternLM (书生·浦语) is a conversational language model that is developed by Shanghai AI Laboratory (上海人工智能实验室). It is designed to be helpful, honest, and harmless.</span><br><span class="hljs-string">        - InternLM (书生·浦语) can understand and communicate fluently in the language chosen by the user such as English and 中文.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <br>        messages = [(system_prompt, <span class="hljs-string">&#x27;&#x27;</span>)]<br>        response, history = self.model.chat(self.tokenizer, prompt , history=messages)<br>        <span class="hljs-keyword">return</span> response<br>        <br><span class="hljs-meta">    @property</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_llm_type</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">str</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;InternLM&quot;</span><br></code></pre></td></tr></table></figure>
<p>在上述类定义中，重写了构造函数和 <code>_call</code> 函数：对于构造函数，我们在对象实例化的一开始加载本地部署的 InternLM 模型，从而避免每一次调用都需要重新加载模型带来的时间过长；<code>_call</code> 函数是 LLM 类的核心函数，LangChain 会调用该函数来调用 LLM，在该函数中，我们调用已实例化模型的 chat 方法，从而实现对模型的调用并返回调用结果。</p>
<p>在整体项目中，我们将上述代码封装为 LLM.py，后续将直接从该文件中引入自定义的 LLM 类。</p>
<h2 id="构建检索问答链"><a href="#构建检索问答链" class="headerlink" title="构建检索问答链"></a>构建检索问答链</h2><p>LangChain 通过提供检索问答链对象来实现对于 RAG 全流程的封装。所谓检索问答链，即通过一个对象完成检索增强问答（即RAG）的全流程，针对 RAG 的更多概念，我们会在视频内容中讲解，也欢迎读者查阅该教程来进一步了解：<a href="https://github.com/datawhalechina/llm-universe/tree/main">《LLM Universe》</a>。我们可以调用一个 LangChain 提供的 <code>RetrievalQA</code> 对象，通过初始化时填入已构建的数据库和自定义 LLM 作为参数，来简便地完成检索增强问答的全流程，LangChain 会自动完成基于用户提问进行检索、获取相关文档、拼接为合适的 Prompt 并交给 LLM 问答的全部流程。</p>
<h3 id="加载向量数据库"><a href="#加载向量数据库" class="headerlink" title="加载向量数据库"></a>加载向量数据库</h3><p>首先我们需要将上文构建的向量数据库导入进来，我们可以直接通过 Chroma 以及上文定义的词向量模型来加载已构建的数据库：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> langchain.vectorstores <span class="hljs-keyword">import</span> Chroma<br><span class="hljs-keyword">from</span> langchain.embeddings.huggingface <span class="hljs-keyword">import</span> HuggingFaceEmbeddings<br><span class="hljs-keyword">import</span> os<br><br><span class="hljs-comment"># 定义 Embeddings</span><br>embeddings = HuggingFaceEmbeddings(model_name=<span class="hljs-string">&quot;/root/data/model/bge-large-zh-v1.5&quot;</span>)<br><br><span class="hljs-comment"># 向量数据库持久化路径</span><br>persist_directory = <span class="hljs-string">&#x27;data_base/vector_db/chroma&#x27;</span><br><br><span class="hljs-comment"># 加载数据库</span><br>vectordb = Chroma(<br>    persist_directory=persist_directory, <br>    embedding_function=embeddings<br>)<br></code></pre></td></tr></table></figure>
<p>上述代码得到的 <code>vectordb</code> 对象即为我们已构建的向量数据库对象，该对象可以针对用户的 <code>query</code> 进行语义向量检索，得到与用户提问相关的知识片段。</p>
<h3 id="实例化自定义-LLM-与-Prompt-Template"><a href="#实例化自定义-LLM-与-Prompt-Template" class="headerlink" title="实例化自定义 LLM 与 Prompt Template"></a>实例化自定义 LLM 与 Prompt Template</h3><p>接着，我们实例化一个基于 InternLM 自定义的 LLM 对象：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> LLM <span class="hljs-keyword">import</span> InternLM_LLM<br>llm = InternLM_LLM(model_path = <span class="hljs-string">&quot;/root/data/model/Shanghai_AI_Laboratory/internlm-chat-7b&quot;</span>)<br>llm.predict(<span class="hljs-string">&quot;你是谁&quot;</span>)<br></code></pre></td></tr></table></figure>
<p>构建检索问答链，还需要构建一个 Prompt Template，该 Template 其实基于一个带变量的字符串，在检索之后，LangChain 会将检索到的相关文档片段填入到 Template 的变量中，从而实现带知识的 Prompt 构建。我们可以基于 LangChain 的 Template 基类来实例化这样一个 Template 对象：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> langchain.prompts <span class="hljs-keyword">import</span> PromptTemplate<br><br><span class="hljs-comment"># 我们所构造的 Prompt 模板</span><br>template = <span class="hljs-string">&quot;&quot;&quot;使用以下上下文来回答用户的问题。如果你不知道答案，就说你不知道。总是使用中文回答。</span><br><span class="hljs-string">问题: &#123;question&#125;</span><br><span class="hljs-string">可参考的上下文：</span><br><span class="hljs-string">···</span><br><span class="hljs-string">&#123;context&#125;</span><br><span class="hljs-string">···</span><br><span class="hljs-string">如果给定的上下文无法让你做出回答，请回答你不知道。</span><br><span class="hljs-string">有用的回答:&quot;&quot;&quot;</span><br><br><span class="hljs-comment"># 调用 LangChain 的方法来实例化一个 Template 对象，该对象包含了 context 和 question 两个变量，在实际调用时，这两个变量会被检索到的文档片段和用户提问填充</span><br>QA_CHAIN_PROMPT = PromptTemplate(input_variables=[<span class="hljs-string">&quot;context&quot;</span>,<span class="hljs-string">&quot;question&quot;</span>],template=template)<br></code></pre></td></tr></table></figure>
<h3 id="构建检索问答链-1"><a href="#构建检索问答链-1" class="headerlink" title="构建检索问答链"></a>构建检索问答链</h3><p>最后，可以调用 LangChain 提供的检索问答链构造函数，基于我们的自定义 LLM、Prompt Template 和向量知识库来构建一个基于 InternLM 的检索问答链：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> langchain.chains <span class="hljs-keyword">import</span> RetrievalQA<br><br>qa_chain = RetrievalQA.from_chain_type(llm,retriever=vectordb.as_retriever(),return_source_documents=<span class="hljs-literal">True</span>,chain_type_kwargs=&#123;<span class="hljs-string">&quot;prompt&quot;</span>:QA_CHAIN_PROMPT&#125;)<br></code></pre></td></tr></table></figure>
<p>得到的 <code>qa_chain</code> 对象即可以实现我们的核心功能，即基于 InternLM 模型的专业知识库助手。我们可以对比该检索问答链和纯 LLM 的问答效果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 检索问答链回答效果</span><br>question = <span class="hljs-string">&quot;什么是InternLM&quot;</span><br>result = qa_chain(&#123;<span class="hljs-string">&quot;query&quot;</span>: question&#125;)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;检索问答链回答 question 的结果：&quot;</span>)<br><span class="hljs-built_in">print</span>(result[<span class="hljs-string">&quot;result&quot;</span>])<br><br><span class="hljs-comment"># 仅 LLM 回答效果</span><br>result_2 = llm(question)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;大模型回答 question 的结果：&quot;</span>)<br><span class="hljs-built_in">print</span>(result_2)<br></code></pre></td></tr></table></figure>
<h2 id="部署一个-Web-Demo"><a href="#部署一个-Web-Demo" class="headerlink" title="部署一个 Web Demo"></a>部署一个 Web Demo</h2><p>之后我们可以基于 Gradio 框架将其部署到 Web 网页，从而搭建一个小型 Demo，便于测试与使用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 导入必要的库</span><br><span class="hljs-keyword">import</span> gradio <span class="hljs-keyword">as</span> gr<br><span class="hljs-keyword">from</span> langchain.vectorstores <span class="hljs-keyword">import</span> Chroma<br><span class="hljs-keyword">from</span> langchain.embeddings.huggingface <span class="hljs-keyword">import</span> HuggingFaceEmbeddings<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">from</span> LLM <span class="hljs-keyword">import</span> InternLM_LLM<br><span class="hljs-keyword">from</span> langchain.prompts <span class="hljs-keyword">import</span> PromptTemplate<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">load_chain</span>():<br>    <span class="hljs-comment"># 加载问答链</span><br>    <span class="hljs-comment"># 定义 Embeddings</span><br>    embeddings = HuggingFaceEmbeddings(model_name=<span class="hljs-string">&quot;/root/data/model/bge-large-zh-v1.5&quot;</span>)<br><br>    <span class="hljs-comment"># 向量数据库持久化路径</span><br>    persist_directory = <span class="hljs-string">&#x27;data_base/vector_db/chroma&#x27;</span><br><br>    <span class="hljs-comment"># 加载数据库</span><br>    vectordb = Chroma(<br>        persist_directory=persist_directory,  <span class="hljs-comment"># 允许我们将persist_directory目录保存到磁盘上</span><br>        embedding_function=embeddings<br>    )<br><br>    llm = InternLM_LLM(model_path = <span class="hljs-string">&quot;/root/data/model/Shanghai_AI_Laboratory/internlm-chat-7b&quot;</span>)<br><br>    template = <span class="hljs-string">&quot;&quot;&quot;使用以下上下文来回答用户的问题。如果你不知道答案，就说你不知道。总是使用中文回答。</span><br><span class="hljs-string">    问题: &#123;question&#125;</span><br><span class="hljs-string">    可参考的上下文：</span><br><span class="hljs-string">    ···</span><br><span class="hljs-string">    &#123;context&#125;</span><br><span class="hljs-string">    ···</span><br><span class="hljs-string">    如果给定的上下文无法让你做出回答，请回答你不知道。</span><br><span class="hljs-string">    有用的回答:&quot;&quot;&quot;</span><br><br>    QA_CHAIN_PROMPT = PromptTemplate(input_variables=[<span class="hljs-string">&quot;context&quot;</span>,<span class="hljs-string">&quot;question&quot;</span>],<br>                                    template=template)<br><br>    <span class="hljs-comment"># 运行 chain</span><br>    <span class="hljs-keyword">from</span> langchain.chains <span class="hljs-keyword">import</span> RetrievalQA<br><br>    qa_chain = RetrievalQA.from_chain_type(llm,<br>                                        retriever=vectordb.as_retriever(),<br>                                        return_source_documents=<span class="hljs-literal">True</span>,<br>                                        chain_type_kwargs=&#123;<span class="hljs-string">&quot;prompt&quot;</span>:QA_CHAIN_PROMPT&#125;)<br>    <br>    <span class="hljs-keyword">return</span> qa_chain<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Model_center</span>():<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    存储问答 Chain 的对象 </span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.chain = load_chain()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">qa_chain_self_answer</span>(<span class="hljs-params">self, question: <span class="hljs-built_in">str</span>, chat_history: <span class="hljs-built_in">list</span> = []</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        调用不带历史记录的问答链进行回答</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> question == <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">len</span>(question) &lt; <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, chat_history<br>        <span class="hljs-keyword">try</span>:<br>            chat_history.append(<br>                (question, self.chain(&#123;<span class="hljs-string">&quot;query&quot;</span>: question&#125;)[<span class="hljs-string">&quot;result&quot;</span>]))<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, chat_history<br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>            <span class="hljs-keyword">return</span> e, chat_history<br><br><br>model_center = Model_center()<br><br>block = gr.Blocks()<br><span class="hljs-keyword">with</span> block <span class="hljs-keyword">as</span> demo:<br>    <span class="hljs-keyword">with</span> gr.Row(equal_height=<span class="hljs-literal">True</span>):   <br>        <span class="hljs-keyword">with</span> gr.Column(scale=<span class="hljs-number">15</span>):<br>            gr.Markdown(<span class="hljs-string">&quot;&quot;&quot;&lt;h1&gt;&lt;center&gt;InternLM&lt;/center&gt;&lt;/h1&gt;</span><br><span class="hljs-string">                &lt;center&gt;书生浦语&lt;/center&gt;</span><br><span class="hljs-string">                &quot;&quot;&quot;</span>)<br>        <span class="hljs-comment"># gr.Image(value=LOGO_PATH, scale=1, min_width=10,show_label=False, show_download_button=False)</span><br><br>    <span class="hljs-keyword">with</span> gr.Row():<br>        <span class="hljs-keyword">with</span> gr.Column(scale=<span class="hljs-number">4</span>):<br>            chatbot = gr.Chatbot(height=<span class="hljs-number">450</span>, show_copy_button=<span class="hljs-literal">True</span>)<br>            <span class="hljs-comment"># 创建一个文本框组件，用于输入 prompt。</span><br>            msg = gr.Textbox(label=<span class="hljs-string">&quot;Prompt/问题&quot;</span>)<br><br>            <span class="hljs-keyword">with</span> gr.Row():<br>                <span class="hljs-comment"># 创建提交按钮。</span><br>                db_wo_his_btn = gr.Button(<span class="hljs-string">&quot;Chat&quot;</span>)<br>            <span class="hljs-keyword">with</span> gr.Row():<br>                <span class="hljs-comment"># 创建一个清除按钮，用于清除聊天机器人组件的内容。</span><br>                clear = gr.ClearButton(<br>                    components=[chatbot], value=<span class="hljs-string">&quot;Clear console&quot;</span>)<br>                <br>        <span class="hljs-comment"># 设置按钮的点击事件。当点击时，调用上面定义的 qa_chain_self_answer 函数，并传入用户的消息和聊天历史记录，然后更新文本框和聊天机器人组件。</span><br>        db_wo_his_btn.click(model_center.qa_chain_self_answer, inputs=[<br>                            msg, chatbot], outputs=[msg, chatbot])<br>        <br>    gr.Markdown(<span class="hljs-string">&quot;&quot;&quot;提醒：&lt;br&gt;</span><br><span class="hljs-string">    1. 初始化数据库时间可能较长，请耐心等待。</span><br><span class="hljs-string">    2. 使用中如果出现异常，将会在文本输入框进行展示，请不要惊慌。 &lt;br&gt;</span><br><span class="hljs-string">    &quot;&quot;&quot;</span>)<br><span class="hljs-comment"># threads to consume the request</span><br>gr.close_all()<br><span class="hljs-comment"># 启动新的 Gradio 应用，设置分享功能为 True，并使用环境变量 PORT1 指定服务器端口。</span><br><span class="hljs-comment"># demo.launch(share=True, server_port=int(os.environ[&#x27;PORT1&#x27;]))</span><br><span class="hljs-comment"># 直接启动</span><br>demo.launch()<br></code></pre></td></tr></table></figure>
<p>运行截图如下：</p>
<p><img  src="gradio.png"  ><span class="image-caption">运行gradio</span></p>
<p><img  src="Langchain+InternLM问答.png"  ><span class="image-caption">Langchain+InternLM问答</span></p>
<p>如图，能够正确地回答知识库中的知识。</p>
<h2 id="问题解决以及-Langchain-调试"><a href="#问题解决以及-Langchain-调试" class="headerlink" title="问题解决以及 Langchain 调试"></a>问题解决以及 Langchain 调试</h2><p>我们在遇到奇怪问题的时候，想要调试 Langchain，这个时候可以借助 Langchain 的全局设置设置调试模式，设置方式如下所示：</p>
<p><a href="https://python.langchain.com/docs/guides/debugging">Debugging | 🦜️🔗 Langchain</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> langchain.<span class="hljs-built_in">globals</span> <span class="hljs-keyword">import</span> set_verbose <span class="hljs-comment"># 我这里用的 langchain 版本为 0.1.0</span><br><br>set_verbose(<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure>
<p><img  src="langchain-debug.png"  ><span class="image-caption">langchain 的调试输出</span></p>
<h2 id="将应用部署在-OpenXLab-上"><a href="#将应用部署在-OpenXLab-上" class="headerlink" title="将应用部署在 OpenXLab 上"></a>将应用部署在 OpenXLab 上</h2><p><a href="https://openxlab.org.cn/apps/detail/EnableAsync/network-bot">计算机网络问答机器人</a></p>
<h3 id="Sqlite-问题1"><a href="#Sqlite-问题1" class="headerlink" title="Sqlite 问题1"></a>Sqlite 问题<sup><a href="#fn_1" id="reffn_1">1</a></sup></h3><p>OpenXLab 上的 sqlite3 版本低于我们项目用的 Chroma 要求。可参考<a href="https://link.zhihu.com/?target=https%3A//docs.trychroma.com/troubleshooting%23sqlite"> Troubleshooting | Chroma (trychroma.com)</a>，在 <code>requirements.txt</code> 中添加 <code>pysqlite3-binary</code> ，之后加载 sqlite3 库来绕过这个问题。否则就要写脚本在运行时自己安装上更新版本的sqlite3了。下面是修改加载 sqlite3 库的 trick 命令：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">__import__</span>(<span class="hljs-string">&#x27;pysqlite3&#x27;</span>)<br><span class="hljs-keyword">import</span> sys<br>sys.modules[<span class="hljs-string">&#x27;sqlite3&#x27;</span>] = sys.modules.pop(<span class="hljs-string">&#x27;pysqlite3&#x27;</span>)<br></code></pre></td></tr></table></figure>
<h3 id="运行截图"><a href="#运行截图" class="headerlink" title="运行截图"></a>运行截图</h3><p><img  src="openxlab-deploy.png"  ><span class="image-caption">openxlab-deploy</span></p>
<p><img  src="loading.png"  ><span class="image-caption">加载模型</span></p>
<p><img  src="部署.png"  ><span class="image-caption">部署</span></p>
<p><img  src="运行日志.png"  ><span class="image-caption">运行日志</span></p>
<h2 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h2><blockquote id="fn_1">
<sup>1</sup>. <a href="https://zhuanlan.zhihu.com/p/676719586">书生・浦语大模型实战营第三课作业(基础+进阶) - 知乎 (zhihu.com)</a><a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a>
</blockquote>
]]></content>
      <categories>
        <category>internlm</category>
      </categories>
  </entry>
  <entry>
    <title>Internlm-04-XTuner 大模型单卡低成本微调实战</title>
    <url>/internlm/internlm-04/</url>
    <content><![CDATA[<h1 id="XTuner-大模型单卡低成本微调实战"><a href="#XTuner-大模型单卡低成本微调实战" class="headerlink" title="XTuner 大模型单卡低成本微调实战"></a>XTuner 大模型单卡低成本微调实战</h1><p>微调前<br><img  src="官方回答.png"  ><span class="image-caption">官方回答</span></p>
<p>微调后<br><img  src="微调后.png"  ><span class="image-caption">微调后.png</span></p>
<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><h3 id="1-1-XTuner"><a href="#1-1-XTuner" class="headerlink" title="1.1 XTuner"></a>1.1 XTuner</h3><p>一个大语言模型微调工具箱。由 MMRazor 和 MMDeploy 联合开发。</p>
<h3 id="1-2-支持的开源LLM-2023-11-01"><a href="#1-2-支持的开源LLM-2023-11-01" class="headerlink" title="1.2 支持的开源LLM (2023.11.01)"></a>1.2 支持的开源LLM (2023.11.01)</h3><ul>
<li><a href="https://huggingface.co/internlm/internlm-7b">InternLM</a></li>
<li><a href="https://huggingface.co/meta-llama">Llama，Llama2</a></li>
<li><a href="https://huggingface.co/THUDM/chatglm2-6b">ChatGLM2</a>，<a href="https://huggingface.co/THUDM/chatglm3-6b-base">ChatGLM3</a></li>
<li><a href="https://huggingface.co/Qwen/Qwen-7B">Qwen</a></li>
<li><a href="https://huggingface.co/baichuan-inc/Baichuan-7B">Baichuan</a>，<a href="https://huggingface.co/baichuan-inc/Baichuan2-7B-Base">Baichuan2</a></li>
<li><a href="https://huggingface.co/HuggingFaceH4/zephyr-7b-beta">Zephyr</a> </li>
</ul>
<h3 id="1-3-特色"><a href="#1-3-特色" class="headerlink" title="1.3 特色"></a>1.3 特色</h3><ul>
<li><strong>傻瓜化：</strong> 以 配置文件 的形式封装了大部分微调场景，<strong>0基础的非专业人员也能一键开始微调</strong>。</li>
<li><strong>轻量级：</strong> 对于 7B 参数量的LLM，<strong>微调所需的最小显存仅为 8GB</strong></li>
</ul>
<h3 id="1-4-微调原理"><a href="#1-4-微调原理" class="headerlink" title="1.4 微调原理"></a>1.4 微调原理</h3><blockquote>
<p>想象一下，你有一个超大的玩具，现在你想改造这个超大的玩具。但是，<strong>对整个玩具进行全面的改动会非常昂贵</strong>。</p>
</blockquote>
<p>※ 因此，你找到了一种叫 <strong>LoRA</strong> 的方法：<strong>只对玩具中的某些零件进行改动，而不是对整个玩具进行全面改动</strong>。</p>
<p>※ 而 <strong>QLoRA</strong> 是 LoRA 的一种改进</p>
<h2 id="2-快速上手"><a href="#2-快速上手" class="headerlink" title="2 快速上手"></a>2 快速上手</h2><h3 id="2-1-平台"><a href="#2-1-平台" class="headerlink" title="2.1 平台"></a>2.1 平台</h3><p>Ubuntu + Anaconda + CUDA/CUDNN + 8GB nvidia显卡</p>
<h3 id="2-2-安装"><a href="#2-2-安装" class="headerlink" title="2.2 安装"></a>2.2 安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 如果你是在 InternStudio 平台，则从本地 clone 一个已有 pytorch 2.0.1 的环境：</span><br>/root/share/install_conda_env_internlm_base.sh xtuner0.1.9<br><span class="hljs-comment"># 如果你是在其他平台：</span><br>conda create --name xtuner0.1.9 python=3.10 -y<br><br><span class="hljs-comment"># 激活环境</span><br>conda activate xtuner0.1.9<br><span class="hljs-comment"># 进入家目录 （~的意思是 “当前用户的home路径”）</span><br><span class="hljs-built_in">cd</span> ~<br><span class="hljs-comment"># 创建版本文件夹并进入，以跟随本教程</span><br><span class="hljs-built_in">mkdir</span> xtuner019 &amp;&amp; <span class="hljs-built_in">cd</span> xtuner019<br><br><br><span class="hljs-comment"># 拉取 0.1.9 的版本源码</span><br>git <span class="hljs-built_in">clone</span> -b v0.1.9  https://github.com/InternLM/xtuner<br><span class="hljs-comment"># 无法访问github的用户请从 gitee 拉取:</span><br><span class="hljs-comment"># git clone -b v0.1.9 https://gitee.com/Internlm/xtuner</span><br><br><span class="hljs-comment"># 进入源码目录</span><br><span class="hljs-built_in">cd</span> xtuner<br><br><span class="hljs-comment"># 从源码安装 XTuner</span><br>pip install -e <span class="hljs-string">&#x27;.[all]&#x27;</span><br></code></pre></td></tr></table></figure>
<p>安装完后，就开始搞搞准备工作了。（准备在 oasst1 数据集上微调 internlm-7b-chat）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建一个微调 oasst1 数据集的工作路径，进入</span><br><span class="hljs-built_in">mkdir</span> ~/ft-oasst1 &amp;&amp; <span class="hljs-built_in">cd</span> ~/ft-oasst1<br></code></pre></td></tr></table></figure>
<h3 id="2-3-微调"><a href="#2-3-微调" class="headerlink" title="2.3 微调"></a>2.3 微调</h3><h4 id="2-3-1-准备配置文件"><a href="#2-3-1-准备配置文件" class="headerlink" title="2.3.1 准备配置文件"></a>2.3.1 准备配置文件</h4><p>XTuner 提供多个开箱即用的配置文件，用户可以通过下列命令查看：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># 列出所有内置配置</span><br>xtuner list-cfg<br></code></pre></td></tr></table></figure>
<blockquote>
<p>假如显示bash: xtuner: command not found的话可以考虑在终端输入 export PATH=$PATH:’/root/.local/bin’</p>
</blockquote>
<p><img  src="cfg-list.png"  ><span class="image-caption">部分配置文件展示</span></p>
<p>拷贝一个配置文件到当前目录：<br><code># xtuner copy-cfg $&#123;CONFIG_NAME&#125; $&#123;SAVE_PATH&#125;</code></p>
<p>在本案例中即：（注意最后有个英文句号，代表复制到当前路径）<br><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">cd</span> ~/ft-oasst1<br>xtuner copy-cfg internlm_chat_7b_qlora_oasst1_e3 .<br></code></pre></td></tr></table></figure></p>
<p>配置文件名的解释：</p>
<blockquote>
<p>xtuner copy-cfg internlm_chat_7b_qlora_oasst1_e3 .</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th>模型名</th>
<th>internlm_chat_7b</th>
</tr>
</thead>
<tbody>
<tr>
<td>使用算法</td>
<td>qlora</td>
</tr>
<tr>
<td>数据集</td>
<td>oasst1</td>
</tr>
<tr>
<td>把数据集跑几次</td>
<td>跑3次：e3 (epoch 3 )</td>
</tr>
</tbody>
</table>
</div>
<p>*无 chat比如 <code>internlm-7b</code> 代表是基座(base)模型</p>
<h4 id="2-3-2-模型下载"><a href="#2-3-2-模型下载" class="headerlink" title="2.3.2 模型下载"></a>2.3.2 模型下载</h4><blockquote>
<p>由于下载模型很慢，用教学平台的同学可以直接复制模型。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">cp</span> -r /root/share/temp/model_repos/internlm-chat-7b ~/ft-oasst1/<br></code></pre></td></tr></table></figure>
<blockquote>
<p>以下是自己下载模型的步骤。</p>
</blockquote>
<p>不用 xtuner 默认的<code>从 huggingface 拉取模型</code>，而是提前从 ModelScope 下载模型到本地</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># 创建一个目录，放模型文件，防止散落一地</span><br><span class="hljs-built_in">mkdir</span> ~/ft-oasst1/internlm-chat-7b<br><br><span class="hljs-comment"># 装一下拉取模型文件要用的库</span><br>pip install modelscope<br><br><span class="hljs-comment"># 从 modelscope 下载下载模型文件</span><br><span class="hljs-built_in">cd</span> ~/ft-oasst1<br>apt install git git-lfs -y<br>git lfs install<br>git lfs <span class="hljs-built_in">clone</span> https://modelscope.cn/Shanghai_AI_Laboratory/internlm-chat-7b.git -b v1.0.3<br></code></pre></td></tr></table></figure>
<h4 id="2-3-3-数据集下载"><a href="#2-3-3-数据集下载" class="headerlink" title="2.3.3 数据集下载"></a>2.3.3 数据集下载</h4><blockquote>
<p><a href="https://huggingface.co/datasets/timdettmers/openassistant-guanaco/tree/main">https://huggingface.co/datasets/timdettmers/openassistant-guanaco/tree/main</a></p>
</blockquote>
<p>由于 huggingface 网络问题，咱们已经给大家提前下载好了，复制到正确位置即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/ft-oasst1<br><span class="hljs-comment"># ...-guanaco 后面有个空格和英文句号啊</span><br><span class="hljs-built_in">cp</span> -r /root/share/temp/datasets/openassistant-guanaco .<br></code></pre></td></tr></table></figure>
<p>此时，当前路径的文件应该长这样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">|-- internlm-chat-7b<br>|   |-- README.md<br>|   |-- config.json<br>|   |-- configuration.json<br>|   |-- configuration_internlm.py<br>|   |-- generation_config.json<br>|   |-- modeling_internlm.py<br>|   |-- pytorch_model-00001-of-00008.bin<br>|   |-- pytorch_model-00002-of-00008.bin<br>|   |-- pytorch_model-00003-of-00008.bin<br>|   |-- pytorch_model-00004-of-00008.bin<br>|   |-- pytorch_model-00005-of-00008.bin<br>|   |-- pytorch_model-00006-of-00008.bin<br>|   |-- pytorch_model-00007-of-00008.bin<br>|   |-- pytorch_model-00008-of-00008.bin<br>|   |-- pytorch_model.bin.index.json<br>|   |-- special_tokens_map.json<br>|   |-- tokenization_internlm.py<br>|   |-- tokenizer.model<br>|   `-- tokenizer_config.json<br>|-- internlm_chat_7b_qlora_oasst1_e3_copy.py<br>`-- openassistant-guanaco<br>    |-- openassistant_best_replies_eval.jsonl<br>    `-- openassistant_best_replies_train.jsonl<br></code></pre></td></tr></table></figure>
<h4 id="2-3-4-修改配置文件"><a href="#2-3-4-修改配置文件" class="headerlink" title="2.3.4 修改配置文件"></a>2.3.4 修改配置文件</h4><p>修改其中的模型和数据集为 本地路径</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/ft-oasst1<br>vim internlm_chat_7b_qlora_oasst1_e3_copy.py<br></code></pre></td></tr></table></figure>
<blockquote>
<p>在vim界面完成修改后，请输入:wq退出。假如认为改错了可以用:q!退出且不保存。当然我们也可以考虑打开python文件直接修改，但注意修改完后需要按下Ctrl+S进行保存。</p>
</blockquote>
<p>减号代表要删除的行，加号代表要增加的行。<br><figure class="highlight diff"><table><tr><td class="code"><pre><code class="hljs diff"># 修改模型为本地路径<br><span class="hljs-deletion">- pretrained_model_name_or_path = &#x27;internlm/internlm-chat-7b&#x27;</span><br><span class="hljs-addition">+ pretrained_model_name_or_path = &#x27;./internlm-chat-7b&#x27;</span><br><br># 修改训练数据集为本地路径<br><span class="hljs-deletion">- data_path = &#x27;timdettmers/openassistant-guanaco&#x27;</span><br><span class="hljs-addition">+ data_path = &#x27;./openassistant-guanaco&#x27;</span><br></code></pre></td></tr></table></figure></p>
<p><strong>常用超参</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数名</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>data_path</strong></td>
<td>数据路径或 HuggingFace 仓库名</td>
</tr>
<tr>
<td>max_length</td>
<td>单条数据最大 Token 数，超过则截断</td>
</tr>
<tr>
<td>pack_to_max_length</td>
<td>是否将多条短数据拼接到 max_length，提高 GPU 利用率</td>
</tr>
<tr>
<td>accumulative_counts</td>
<td>梯度累积，每多少次 backward 更新一次参数</td>
</tr>
<tr>
<td>evaluation_inputs</td>
<td>训练过程中，会根据给定的问题进行推理，便于观测训练状态</td>
</tr>
<tr>
<td>evaluation_freq</td>
<td>Evaluation 的评测间隔 iter 数</td>
</tr>
<tr>
<td>……</td>
<td>……</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>如果想把显卡的现存吃满，充分利用显卡资源，可以将 <code>max_length</code> 和 <code>batch_size</code> 这两个参数调大。</p>
</blockquote>
<h4 id="2-3-5-开始微调"><a href="#2-3-5-开始微调" class="headerlink" title="2.3.5 开始微调"></a>2.3.5 开始微调</h4><p><strong>训练：</strong></p>
<p>xtuner train ${CONFIG_NAME_OR_PATH}</p>
<p><strong>也可以增加 deepspeed 进行训练加速：</strong></p>
<p>xtuner train ${CONFIG_NAME_OR_PATH} —deepspeed deepspeed_zero2</p>
<p>例如，我们可以利用 QLoRA 算法在 oasst1 数据集上微调 InternLM-7B：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># 单卡</span><br><span class="hljs-comment">## 用刚才改好的config文件训练</span><br>xtuner train ./internlm_chat_7b_qlora_oasst1_e3_copy.py<br><br><span class="hljs-comment"># 多卡</span><br>NPROC_PER_NODE=<span class="hljs-variable">$&#123;GPU_NUM&#125;</span> xtuner train ./internlm_chat_7b_qlora_oasst1_e3_copy.py<br><br><span class="hljs-comment"># 若要开启 deepspeed 加速，增加 --deepspeed deepspeed_zero2 即可</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>微调得到的 PTH 模型文件和其他杂七杂八的文件都默认在当前的 <code>./work_dirs</code> 中。</p>
</blockquote>
<p><img  src="train.png"  ><span class="image-caption">训练截图</span></p>
<p>跑完训练后，当前路径应该长这样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs Bash">|-- internlm-chat-7b<br>|-- internlm_chat_7b_qlora_oasst1_e3_copy.py<br>|-- openassistant-guanaco<br>|   |-- openassistant_best_replies_eval.jsonl<br>|   `-- openassistant_best_replies_train.jsonl<br>`-- work_dirs<br>    `-- internlm_chat_7b_qlora_oasst1_e3_copy<br>        |-- 20231101_152923<br>        |   |-- 20231101_152923.<span class="hljs-built_in">log</span><br>        |   `-- vis_data<br>        |       |-- 20231101_152923.json<br>        |       |-- config.py<br>        |       `-- scalars.json<br>        |-- epoch_1.pth<br>        |-- epoch_2.pth<br>        |-- epoch_3.pth<br>        |-- internlm_chat_7b_qlora_oasst1_e3_copy.py<br>        `-- last_checkpoint<br></code></pre></td></tr></table></figure>
<h4 id="2-3-6-将得到的-PTH-模型转换为-HuggingFace-模型，即：生成-Adapter-文件夹"><a href="#2-3-6-将得到的-PTH-模型转换为-HuggingFace-模型，即：生成-Adapter-文件夹" class="headerlink" title="2.3.6 将得到的 PTH 模型转换为 HuggingFace 模型，即：生成 Adapter 文件夹"></a>2.3.6 将得到的 PTH 模型转换为 HuggingFace 模型，<strong>即：生成 Adapter 文件夹</strong></h4><p><code>xtuner convert pth_to_hf $&#123;CONFIG_NAME_OR_PATH&#125; $&#123;PTH_file_dir&#125; $&#123;SAVE_PATH&#125;</code></p>
<p>在本示例中，为：<br><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> hf<br><span class="hljs-built_in">export</span> MKL_SERVICE_FORCE_INTEL=1<br><br>xtuner convert pth_to_hf ./internlm_chat_7b_qlora_oasst1_e3_copy.py ./work_dirs/internlm_chat_7b_qlora_oasst1_e3_copy/epoch_1.pth ./hf<br></code></pre></td></tr></table></figure><br>此时，路径中应该长这样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs Bash">|-- internlm-chat-7b<br>|-- internlm_chat_7b_qlora_oasst1_e3_copy.py<br>|-- openassistant-guanaco<br>|   |-- openassistant_best_replies_eval.jsonl<br>|   `-- openassistant_best_replies_train.jsonl<br>|-- hf<br>|   |-- README.md<br>|   |-- adapter_config.json<br>|   |-- adapter_model.bin<br>|   `-- xtuner_config.py<br>`-- work_dirs<br>    `-- internlm_chat_7b_qlora_oasst1_e3_copy<br>        |-- 20231101_152923<br>        |   |-- 20231101_152923.<span class="hljs-built_in">log</span><br>        |   `-- vis_data<br>        |       |-- 20231101_152923.json<br>        |       |-- config.py<br>        |       `-- scalars.json<br>        |-- epoch_1.pth<br>        |-- epoch_2.pth<br>        |-- epoch_3.pth<br>        |-- internlm_chat_7b_qlora_oasst1_e3_copy.py<br>        `-- last_checkpoint<br></code></pre></td></tr></table></figure>
<p><span style="color: red;"><strong>此时，hf 文件夹即为我们平时所理解的所谓 “LoRA 模型文件”</strong></span></p>
<blockquote>
<p>可以简单理解：LoRA 模型文件 = Adapter</p>
</blockquote>
<h3 id="2-4-部署与测试"><a href="#2-4-部署与测试" class="headerlink" title="2.4 部署与测试"></a>2.4 部署与测试</h3><h4 id="2-4-1-将-HuggingFace-adapter-合并到大语言模型："><a href="#2-4-1-将-HuggingFace-adapter-合并到大语言模型：" class="headerlink" title="2.4.1 将 HuggingFace adapter 合并到大语言模型："></a>2.4.1 将 HuggingFace adapter 合并到大语言模型：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs Bash">xtuner convert merge ./internlm-chat-7b ./hf ./merged --max-shard-size 2GB<br><span class="hljs-comment"># xtuner convert merge \</span><br><span class="hljs-comment">#     $&#123;NAME_OR_PATH_TO_LLM&#125; \</span><br><span class="hljs-comment">#     $&#123;NAME_OR_PATH_TO_ADAPTER&#125; \</span><br><span class="hljs-comment">#     $&#123;SAVE_PATH&#125; \</span><br><span class="hljs-comment">#     --max-shard-size 2GB</span><br></code></pre></td></tr></table></figure>
<h4 id="2-4-2-与合并后的模型对话："><a href="#2-4-2-与合并后的模型对话：" class="headerlink" title="2.4.2 与合并后的模型对话："></a>2.4.2 与合并后的模型对话：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># 加载 Adapter 模型对话（Float 16）</span><br>xtuner chat ./merged --prompt-template internlm_chat<br><br><span class="hljs-comment"># 4 bit 量化加载</span><br><span class="hljs-comment"># xtuner chat ./merged --bits 4 --prompt-template internlm_chat</span><br></code></pre></td></tr></table></figure>
<h4 id="2-4-3-Demo"><a href="#2-4-3-Demo" class="headerlink" title="2.4.3 Demo"></a>2.4.3 Demo</h4><ul>
<li>修改 <code>cli_demo.py</code> 中的模型路径<figure class="highlight diff"><table><tr><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">- model_name_or_path = &quot;/root/model/Shanghai_AI_Laboratory/internlm-chat-7b&quot;</span><br><span class="hljs-addition">+ model_name_or_path = &quot;merged&quot;</span><br></code></pre></td></tr></table></figure></li>
<li>运行 <code>cli_demo.py</code> 以目测微调效果<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">python ./cli_demo.py<br></code></pre></td></tr></table></figure>
</li>
</ul>
<p><strong><code>xtuner chat</code></strong> <strong>的启动参数</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>启动参数</th>
<th>干哈滴</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>—prompt-template</strong></td>
<td>指定对话模板</td>
</tr>
<tr>
<td>—system</td>
<td>指定SYSTEM文本</td>
</tr>
<tr>
<td>—system-template</td>
<td>指定SYSTEM模板</td>
</tr>
<tr>
<td>-<strong>-bits</strong></td>
<td>LLM位数</td>
</tr>
<tr>
<td>—bot-name</td>
<td>bot名称</td>
</tr>
<tr>
<td>—with-plugins</td>
<td>指定要使用的插件</td>
</tr>
<tr>
<td><strong>—no-streamer</strong></td>
<td>是否启用流式传输</td>
</tr>
<tr>
<td><strong>—lagent</strong></td>
<td>是否使用lagent</td>
</tr>
<tr>
<td>—command-stop-word</td>
<td>命令停止词</td>
</tr>
<tr>
<td>—answer-stop-word</td>
<td>回答停止词</td>
</tr>
<tr>
<td>—offload-folder</td>
<td>存放模型权重的文件夹（或者已经卸载模型权重的文件夹）</td>
</tr>
<tr>
<td>—max-new-tokens</td>
<td>生成文本中允许的最大 <code>token</code> 数量</td>
</tr>
<tr>
<td><strong>—temperature</strong></td>
<td>温度值</td>
</tr>
<tr>
<td>—top-k</td>
<td>保留用于顶k筛选的最高概率词汇标记数</td>
</tr>
<tr>
<td>—top-p</td>
<td>如果设置为小于1的浮点数，仅保留概率相加高于 <code>top_p</code> 的最小一组最有可能的标记</td>
</tr>
<tr>
<td>—seed</td>
<td>用于可重现文本生成的随机种子</td>
</tr>
</tbody>
</table>
</div>
<h2 id="3-自定义微调"><a href="#3-自定义微调" class="headerlink" title="3 自定义微调"></a>3 自定义微调</h2><blockquote>
<p>以 <strong><a href="https://github.com/abachaa/Medication_QA_MedInfo2019">Medication QA</a></strong> <strong>数据集</strong>为例</p>
</blockquote>
<h3 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h3><h4 id="3-1-1-场景需求"><a href="#3-1-1-场景需求" class="headerlink" title="3.1.1 场景需求"></a>3.1.1 <strong>场景需求</strong></h4><p>   基于 InternLM-chat-7B 模型，用 MedQA 数据集进行微调，将其往<code>医学问答</code>领域对齐。</p>
<h4 id="3-1-2-真实数据预览"><a href="#3-1-2-真实数据预览" class="headerlink" title="3.1.2 真实数据预览"></a>3.1.2 <strong>真实数据预览</strong></h4><div class="table-container">
<table>
<thead>
<tr>
<th>问题</th>
<th>答案</th>
</tr>
</thead>
<tbody>
<tr>
<td>What are ketorolac eye drops?（什么是酮咯酸滴眼液？）</td>
<td>Ophthalmic   ketorolac is used to treat itchy eyes caused by allergies. It also is used to   treat swelling and redness (inflammation) that can occur after cataract   surgery. Ketorolac is in a class of medications called nonsteroidal   anti-inflammatory drugs (NSAIDs). It works by stopping the release of   substances that cause allergy symptoms and inflammation.</td>
</tr>
<tr>
<td>What medicines raise blood sugar? （什么药物会升高血糖？）</td>
<td>Some   medicines for conditions other than diabetes can raise your blood sugar   level. This is a concern when you have diabetes. Make sure every doctor you   see knows about all of the medicines, vitamins, or herbal supplements you   take. This means anything you take with or without a prescription. Examples include:     Barbiturates.     Thiazide diuretics.     Corticosteroids.     Birth control pills (oral contraceptives) and progesterone.     Catecholamines.     Decongestants that contain beta-adrenergic agents, such as pseudoephedrine.     The B vitamin niacin. The risk of high blood sugar from niacin lowers after you have taken it for a few months. The antipsychotic medicine olanzapine (Zyprexa).</td>
</tr>
</tbody>
</table>
</div>
<h3 id="3-2-数据准备"><a href="#3-2-数据准备" class="headerlink" title="3.2 数据准备"></a>3.2 数据准备</h3><blockquote>
<p><strong>以</strong> <strong><a href="https://github.com/abachaa/Medication_QA_MedInfo2019">Medication QA</a></strong> <strong>数据集为例</strong></p>
</blockquote>
<p><strong>原格式：(.xlsx)</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>问题</strong></th>
<th>药物类型</th>
<th>问题类型</th>
<th><strong>回答</strong></th>
<th>主题</th>
<th>URL</th>
</tr>
</thead>
<tbody>
<tr>
<td>aaa</td>
<td>bbb</td>
<td>ccc</td>
<td>ddd</td>
<td>eee</td>
<td>fff</td>
</tr>
</tbody>
</table>
</div>
<h4 id="3-2-1-将数据转为-XTuner-的数据格式"><a href="#3-2-1-将数据转为-XTuner-的数据格式" class="headerlink" title="3.2.1 将数据转为 XTuner 的数据格式"></a>3.2.1 将数据转为 XTuner 的数据格式</h4><p><strong>目标格式：(.jsonL)</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs JSON"><span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;conversation&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;system&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;xxx&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;input&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;xxx&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;output&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;xxx&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;conversation&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;system&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;xxx&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;input&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;xxx&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;output&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;xxx&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure>
<p>通过 pytho n脚本：将 <code>.xlsx</code> 中的 问题 和 回答 两列 提取出来，再放入 <code>.jsonL</code> 文件的每个 conversation 的 input 和 output 中。</p>
<blockquote>
<p>这一步的 python 脚本可以请 ChatGPT 来完成。</p>
</blockquote>
<figure class="highlight text"><table><tr><td class="code"><pre><code class="hljs text">Write a python file for me. using openpyxl. input file name is MedQA2019.xlsx<br>Step1: The input file is .xlsx. Exact the column A and column D in the sheet named &quot;DrugQA&quot; .<br>Step2: Put each value in column A into each &quot;input&quot; of each &quot;conversation&quot;. Put each value in column D into each &quot;output&quot; of each &quot;conversation&quot;.<br>Step3: The output file is .jsonL. It looks like:<br>[&#123;<br>    &quot;conversation&quot;:[<br>        &#123;<br>            &quot;system&quot;: &quot;xxx&quot;,<br>            &quot;input&quot;: &quot;xxx&quot;,<br>            &quot;output&quot;: &quot;xxx&quot;<br>        &#125;<br>    ]<br>&#125;,<br>&#123;<br>    &quot;conversation&quot;:[<br>        &#123;<br>            &quot;system&quot;: &quot;xxx&quot;,<br>            &quot;input&quot;: &quot;xxx&quot;,<br>            &quot;output&quot;: &quot;xxx&quot;<br>        &#125;<br>    ]<br>&#125;]<br>Step4: All &quot;system&quot; value changes to &quot;You are a professional, highly experienced doctor professor. You always provide accurate, comprehensive, and detailed answers based on the patients&#x27; questions.&quot;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>ChatGPT 生成的 python 代码见本仓库的 <a href="./xlsx2jsonl.py">xlsx2jsonl.py</a></p>
</blockquote>
<p>执行 python 脚本，获得格式化后的数据集：<br><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">python xlsx2jsonl.py<br></code></pre></td></tr></table></figure></p>
<p>此时，当然也可以对数据进行训练集和测试集的分割，同样可以让 ChatGPT 写 python 代码。当然如果你没有严格的科研需求、不在乎“训练集泄露”的问题，也可以不做训练集与测试集的分割。</p>
<h4 id="3-2-2-划分训练集和测试集"><a href="#3-2-2-划分训练集和测试集" class="headerlink" title="3.2.2 划分训练集和测试集"></a>3.2.2 划分训练集和测试集</h4><figure class="highlight text"><table><tr><td class="code"><pre><code class="hljs text">my .jsonL file looks like:<br>[&#123;<br>    &quot;conversation&quot;:[<br>        &#123;<br>            &quot;system&quot;: &quot;xxx&quot;,<br>            &quot;input&quot;: &quot;xxx&quot;,<br>            &quot;output&quot;: &quot;xxx&quot;<br>        &#125;<br>    ]<br>&#125;,<br>&#123;<br>    &quot;conversation&quot;:[<br>        &#123;<br>            &quot;system&quot;: &quot;xxx&quot;,<br>            &quot;input&quot;: &quot;xxx&quot;,<br>            &quot;output&quot;: &quot;xxx&quot;<br>        &#125;<br>    ]<br>&#125;]<br>Step1, read the .jsonL file.<br>Step2, count the amount of the &quot;conversation&quot; elements.<br>Step3, randomly split all &quot;conversation&quot; elements by 7:3. Targeted structure is same as the input.<br>Step4, save the 7/10 part as train.jsonl. save the 3/10 part as test.jsonl<br></code></pre></td></tr></table></figure>
<p>生成的python代码见 <a href="./split2train_and_test.py">split2train_and_test.py</a></p>
<h3 id="3-3-开始自定义微调"><a href="#3-3-开始自定义微调" class="headerlink" title="3.3 开始自定义微调"></a>3.3 开始自定义微调</h3><p>此时，我们重新建一个文件夹来玩“微调自定义数据集”<br><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> ~/ft-medqa &amp;&amp; <span class="hljs-built_in">cd</span> ~/ft-medqa<br></code></pre></td></tr></table></figure></p>
<p>把前面下载好的internlm-chat-7b模型文件夹拷贝过来。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cp</span> -r ~/ft-oasst1/internlm-chat-7b .<br></code></pre></td></tr></table></figure>
<p>别忘了把自定义数据集，即几个 <code>.jsonL</code>，也传到服务器上。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/InternLM/tutorial<br></code></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cp</span> ~/tutorial/xtuner/MedQA2019-structured-train.jsonl .<br></code></pre></td></tr></table></figure>
<h4 id="3-3-1-准备配置文件"><a href="#3-3-1-准备配置文件" class="headerlink" title="3.3.1 准备配置文件"></a>3.3.1 准备配置文件</h4><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 复制配置文件到当前目录</span><br>xtuner copy-cfg internlm_chat_7b_qlora_oasst1_e3 .<br><span class="hljs-comment"># 改个文件名</span><br><span class="hljs-built_in">mv</span> internlm_chat_7b_qlora_oasst1_e3_copy.py internlm_chat_7b_qlora_medqa2019_e3.py<br><br><span class="hljs-comment"># 修改配置文件内容</span><br>vim internlm_chat_7b_qlora_medqa2019_e3.py<br></code></pre></td></tr></table></figure>
<p>减号代表要删除的行，加号代表要增加的行。<br><figure class="highlight diff"><table><tr><td class="code"><pre><code class="hljs diff"># 修改import部分<br><span class="hljs-deletion">- from xtuner.dataset.map_fns import oasst1_map_fn, template_map_fn_factory</span><br><span class="hljs-addition">+ from xtuner.dataset.map_fns import template_map_fn_factory</span><br><br># 修改模型为本地路径<br><span class="hljs-deletion">- pretrained_model_name_or_path = &#x27;internlm/internlm-chat-7b&#x27;</span><br><span class="hljs-addition">+ pretrained_model_name_or_path = &#x27;./internlm-chat-7b&#x27;</span><br><br># 修改训练数据为 MedQA2019-structured-train.jsonl 路径<br><span class="hljs-deletion">- data_path = &#x27;timdettmers/openassistant-guanaco&#x27;</span><br><span class="hljs-addition">+ data_path = &#x27;MedQA2019-structured-train.jsonl&#x27;</span><br><br># 修改 train_dataset 对象<br>train_dataset = dict(<br>    type=process_hf_dataset,<br><span class="hljs-deletion">-   dataset=dict(type=load_dataset, path=data_path),</span><br><span class="hljs-addition">+   dataset=dict(type=load_dataset, path=&#x27;json&#x27;, data_files=dict(train=data_path)),</span><br>    tokenizer=tokenizer,<br>    max_length=max_length,<br><span class="hljs-deletion">-   dataset_map_fn=alpaca_map_fn,</span><br><span class="hljs-addition">+   dataset_map_fn=None,</span><br>    template_map_fn=dict(<br>        type=template_map_fn_factory, template=prompt_template),<br>    remove_unused_columns=True,<br>    shuffle_before_pack=True,<br>    pack_to_max_length=pack_to_max_length)<br></code></pre></td></tr></table></figure></p>
<h4 id="3-3-2-XTuner！启动！"><a href="#3-3-2-XTuner！启动！" class="headerlink" title="3.3.2 XTuner！启动！"></a>3.3.2 <strong>XTuner！启动！</strong></h4><p><img  src="imgs/ysqd.png"  ><span class="image-caption">tH8udZzECYl5are.png</span></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">xtuner train internlm_chat_7b_qlora_medqa2019_e3.py --deepspeed deepspeed_zero2<br></code></pre></td></tr></table></figure>
<h4 id="3-3-3-pth-转-huggingface"><a href="#3-3-3-pth-转-huggingface" class="headerlink" title="3.3.3 pth 转 huggingface"></a>3.3.3 pth 转 huggingface</h4><p>同前述，这里不赘述了。<a href="#236-将得到的-pth-模型转换为-huggingface-模型即生成adapter文件夹">将得到的-pth-模型转换为-huggingface-模型即生成adapter文件夹</a>  </p>
<h4 id="3-3-4-部署与测试"><a href="#3-3-4-部署与测试" class="headerlink" title="3.3.4 部署与测试"></a>3.3.4 部署与测试</h4><p>同前述。<a href="#24-部署与测试">部署与测试</a></p>
<h2 id="4-用-MS-Agent-数据集-赋予-LLM-以-Agent-能力"><a href="#4-用-MS-Agent-数据集-赋予-LLM-以-Agent-能力" class="headerlink" title="4 用 MS-Agent 数据集 赋予 LLM 以 Agent 能力"></a>4 用 MS-Agent 数据集 赋予 LLM 以 Agent 能力</h2><h3 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h3><p>MSAgent 数据集每条样本包含一个对话列表（conversations），其里面包含了 system、user、assistant 三种字段。其中：</p>
<ul>
<li><p>system: 表示给模型前置的人设输入，其中有告诉模型如何调用插件以及生成请求</p>
</li>
<li><p>user: 表示用户的输入 prompt，分为两种，通用生成的prompt和调用插件需求的 prompt</p>
</li>
<li><p>assistant: 为模型的回复。其中会包括插件调用代码和执行代码，调用代码是要 LLM 生成的，而执行代码是调用服务来生成结果的</p>
</li>
</ul>
<p>一条调用网页搜索插件查询“上海明天天气”的数据样本示例如下图所示：<br><img  src="imgs/msagent_data.png"  ><span class="image-caption">BlgfEqpiRFO5G6L.png</span></p>
<h3 id="4-2-微调步骤"><a href="#4-2-微调步骤" class="headerlink" title="4.2 微调步骤"></a>4.2 微调步骤</h3><h4 id="4-2-1-准备工作"><a href="#4-2-1-准备工作" class="headerlink" title="4.2.1 准备工作"></a>4.2.1 准备工作</h4><blockquote>
<p>xtuner 是从国内的 ModelScope 平台下载 MS-Agent 数据集，因此不用提前手动下载数据集文件。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 准备工作</span><br><span class="hljs-built_in">mkdir</span> ~/ft-msagent &amp;&amp; <span class="hljs-built_in">cd</span> ~/ft-msagent<br><span class="hljs-built_in">cp</span> -r ~/ft-oasst1/internlm-chat-7b .<br><br><span class="hljs-comment"># 查看配置文件</span><br>xtuner list-cfg | grep msagent<br><br><span class="hljs-comment"># 复制配置文件到当前目录</span><br>xtuner copy-cfg internlm_7b_qlora_msagent_react_e3_gpu8 .<br><br><span class="hljs-comment"># 修改配置文件中的模型为本地路径</span><br>vim ./internlm_7b_qlora_msagent_react_e3_gpu8_copy.py <br></code></pre></td></tr></table></figure>
<figure class="highlight diff"><table><tr><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">- pretrained_model_name_or_path = &#x27;internlm/internlm-chat-7b&#x27;</span><br><span class="hljs-addition">+ pretrained_model_name_or_path = &#x27;./internlm-chat-7b&#x27;</span><br></code></pre></td></tr></table></figure>
<h4 id="4-2-2-开始微调"><a href="#4-2-2-开始微调" class="headerlink" title="4.2.2 开始微调"></a>4.2.2 开始微调</h4><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs Bash">xtuner train ./internlm_7b_qlora_msagent_react_e3_gpu8_copy.py --deepspeed deepspeed_zero2<br></code></pre></td></tr></table></figure>
<h3 id="4-3-直接使用"><a href="#4-3-直接使用" class="headerlink" title="4.3 直接使用"></a>4.3 直接使用</h3><blockquote>
<p>由于 msagent 的训练非常费时，大家如果想尽快把这个教程跟完，可以直接从 modelScope 拉取咱们已经微调好了的 Adapter。如下演示。</p>
</blockquote>
<h4 id="4-3-1-下载-Adapter"><a href="#4-3-1-下载-Adapter" class="headerlink" title="4.3.1 下载 Adapter"></a>4.3.1 下载 Adapter</h4><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">cd</span> ~/ft-msagent<br>apt install git git-lfs<br>git lfs install<br>git lfs <span class="hljs-built_in">clone</span> https://www.modelscope.cn/xtuner/internlm-7b-qlora-msagent-react.git<br></code></pre></td></tr></table></figure>
<p>OK，现在目录应该长这样：</p>
<ul>
<li>internlm_7b_qlora_msagent_react_e3_gpu8_copy.py</li>
<li>internlm-7b-qlora-msagent-react</li>
<li>internlm-chat-7b</li>
<li>work_dir（可有可无）</li>
</ul>
<p>有了这个在 msagent 上训练得到的Adapter，模型现在已经有 agent 能力了！就可以加 —lagent 以调用来自 lagent 的代理功能了！</p>
<h4 id="4-3-2-添加-serper-环境变量"><a href="#4-3-2-添加-serper-环境变量" class="headerlink" title="4.3.2 添加 serper 环境变量"></a>4.3.2 添加 serper 环境变量</h4><blockquote>
<p><strong>开始 chat 之前，还要加个 serper 的环境变量：</strong></p>
<p>去 serper.dev 免费注册一个账号，生成自己的 api key。这个东西是用来给 lagent 去获取 google 搜索的结果的。等于是 serper.dev 帮你去访问 google，而不是从你自己本地去访问 google 了。</p>
</blockquote>
<p><img  src="imgs/serper.png"  ><span class="image-caption">kDSdpQrhHfTWYsc.png</span></p>
<p>添加 serper api key 到环境变量：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> SERPER_API_KEY=abcdefg<br></code></pre></td></tr></table></figure>
<h4 id="4-3-3-xtuner-agent，启动！"><a href="#4-3-3-xtuner-agent，启动！" class="headerlink" title="4.3.3 xtuner + agent，启动！"></a>4.3.3 xtuner + agent，启动！</h4><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">xtuner chat ./internlm-chat-7b --adapter internlm-7b-qlora-msagent-react --lagent<br></code></pre></td></tr></table></figure>
<h2 id="5-注意事项"><a href="#5-注意事项" class="headerlink" title="5 注意事项"></a>5 注意事项</h2><p>本教程使用 xtuner 0.1.9 版本<br>若需要跟着本教程一步一步完成，建议严格遵循本教程的步骤！</p>
<p>若出现莫名其妙报错，请尝试更换为以下包的版本：（如果有报错再检查，没报错不用看）<br><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">torch</span>                         <span class="hljs-number">2</span>.<span class="hljs-number">1</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">transformers</span>                  <span class="hljs-number">4</span>.<span class="hljs-number">34</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">transformers</span>-stream-generator <span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><br><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">pip install torch==2.1.1<br>pip install transformers==4.34.0<br>pip install transformers-stream-generator=0.0.4<br></code></pre></td></tr></table></figure><br>CUDA 相关：（如果有报错再检查，没报错不用看）<br><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">NVIDIA</span>-SMI <span class="hljs-number">535</span>.<span class="hljs-number">54</span>.<span class="hljs-number">03</span>              <br><span class="hljs-attribute">Driver</span> Version: <span class="hljs-number">535</span>.<span class="hljs-number">54</span>.<span class="hljs-number">03</span>    <br><span class="hljs-attribute">CUDA</span> Version: <span class="hljs-number">12</span>.<span class="hljs-number">2</span><br><br><span class="hljs-attribute">nvidia</span>-cuda-cupti-cu12        <span class="hljs-number">12</span>.<span class="hljs-number">1</span>.<span class="hljs-number">105</span><br><span class="hljs-attribute">nvidia</span>-cuda-nvrtc-cu12        <span class="hljs-number">12</span>.<span class="hljs-number">1</span>.<span class="hljs-number">105</span><br><span class="hljs-attribute">nvidia</span>-cuda-runtime-cu12      <span class="hljs-number">12</span>.<span class="hljs-number">1</span>.<span class="hljs-number">105</span><br></code></pre></td></tr></table></figure></p>
<h2 id="6-作业"><a href="#6-作业" class="headerlink" title="6 作业"></a>6 作业</h2><h3 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1 概述"></a>1 概述</h3><p>目标：通过微调，让模型成为我们的小助手</p>
<p>方式：使用 XTuner 进行微调</p>
<p><strong>微调前</strong><br><img  src="官方回答.png"  ><span class="image-caption">官方回答</span></p>
<p><strong>微调后</strong><br><img  src="微调后.png"  ><span class="image-caption">微调后.png</span></p>
<h3 id="2-实操"><a href="#2-实操" class="headerlink" title="2 实操"></a>2 实操</h3><h4 id="微调环境准备"><a href="#微调环境准备" class="headerlink" title="微调环境准备"></a>微调环境准备</h4><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># InternStudio 平台中，从本地 clone 一个已有 pytorch 2.0.1 的环境（后续均在该环境执行，若为其他环境可作为参考）</span><br><span class="hljs-comment"># 进入环境后首先 bash</span><br><span class="hljs-comment"># 进入环境后首先 bash</span><br><span class="hljs-comment"># 进入环境后首先 bash</span><br>bash<br>conda create --name personal_assistant --<span class="hljs-built_in">clone</span>=/root/share/conda_envs/internlm-base<br><span class="hljs-comment"># 如果在其他平台：</span><br><span class="hljs-comment"># conda create --name personal_assistant python=3.10 -y</span><br><br><span class="hljs-comment"># 激活环境</span><br>conda activate personal_assistant<br><span class="hljs-comment"># 进入家目录 （~的意思是 “当前用户的home路径”）</span><br><span class="hljs-built_in">cd</span> ~<br><span class="hljs-comment"># 创建版本文件夹并进入，以跟随本教程</span><br><span class="hljs-comment"># personal_assistant用于存放本教程所使用的东西</span><br><span class="hljs-built_in">mkdir</span> /root/personal_assistant &amp;&amp; <span class="hljs-built_in">cd</span> /root/personal_assistant<br><span class="hljs-built_in">mkdir</span> /root/personal_assistant/xtuner019 &amp;&amp; <span class="hljs-built_in">cd</span> /root/personal_assistant/xtuner019<br><br><span class="hljs-comment"># 拉取 0.1.9 的版本源码</span><br>git <span class="hljs-built_in">clone</span> -b v0.1.9  https://github.com/InternLM/xtuner<br><span class="hljs-comment"># 无法访问github的用户请从 gitee 拉取:</span><br><span class="hljs-comment"># git clone -b v0.1.9 https://gitee.com/Internlm/xtuner</span><br><br><span class="hljs-comment"># 进入源码目录</span><br><span class="hljs-built_in">cd</span> xtuner<br><br><span class="hljs-comment"># 从源码安装 XTuner</span><br>pip install -e <span class="hljs-string">&#x27;.[all]&#x27;</span><br></code></pre></td></tr></table></figure>
<h4 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h4><p>创建<code>data</code>文件夹用于存放用于训练的数据集</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p /root/personal_assistant/data &amp;&amp; <span class="hljs-built_in">cd</span> /root/personal_assistant/data<br></code></pre></td></tr></table></figure>
<p>在<code>data</code>目录下创建一个json文件<code>personal_assistant.json</code>作为本次微调所使用的数据集。json中内容可参考下方(复制粘贴n次做数据增广，数据量小无法有效微调，下面仅用于展示格式，下面也有生成脚本)</p>
<p>其中<code>conversation</code>表示一次对话的内容，<code>input</code>为输入，即用户会问的问题，<code>output</code>为输出，即想要模型回答的答案。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;conversation&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>            <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;input&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;请介绍一下你自己&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;output&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;我是不要葱姜蒜大佬的小助手，内在是上海AI实验室书生·浦语的7B大模型哦&quot;</span><br>            <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;conversation&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>            <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;input&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;请做一下自我介绍&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;output&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;我是不要葱姜蒜大佬的小助手，内在是上海AI实验室书生·浦语的7B大模型哦&quot;</span><br>            <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure>
<p>以下是一个python脚本，用于生成数据集。在<code>data</code>目录下新建一个generate_data.py文件，将以下代码复制进去，然后运行该脚本即可生成数据集。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> json<br><br><span class="hljs-comment"># 输入你的名字</span><br>name = <span class="hljs-string">&#x27;Shengshenlan&#x27;</span><br><span class="hljs-comment"># 重复次数</span><br>n = <span class="hljs-number">10000</span><br><br>data = [<br>    &#123;<br>        <span class="hljs-string">&quot;conversation&quot;</span>: [<br>            &#123;<br>                <span class="hljs-string">&quot;input&quot;</span>: <span class="hljs-string">&quot;请做一下自我介绍&quot;</span>,<br>                <span class="hljs-string">&quot;output&quot;</span>: <span class="hljs-string">&quot;我是&#123;&#125;的小助手，内在是上海AI实验室书生·浦语的7B大模型哦&quot;</span>.<span class="hljs-built_in">format</span>(name)<br>            &#125;<br>        ]<br>    &#125;<br>]<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    data.append(data[<span class="hljs-number">0</span>])<br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;personal_assistant.json&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    json.dump(data, f, ensure_ascii=<span class="hljs-literal">False</span>, indent=<span class="hljs-number">4</span>)<br><br></code></pre></td></tr></table></figure>
<h4 id="配置准备"><a href="#配置准备" class="headerlink" title="配置准备"></a>配置准备</h4><p>下载模型<code>InternLM-chat-7B</code></p>
<p><a href="https://studio.intern-ai.org.cn/">InternStudio</a> 平台的 <code>share</code> 目录下已经为我们准备了全系列的 <code>InternLM</code> 模型，可以使用如下命令复制<code>internlm-chat-7b</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p /root/personal_assistant/model/Shanghai_AI_Laboratory<br><span class="hljs-built_in">cp</span> -r /root/share/temp/model_repos/internlm-chat-7b /root/personal_assistant/model/Shanghai_AI_Laboratory<br></code></pre></td></tr></table></figure>
<p>XTuner 提供多个开箱即用的配置文件，用户可以通过下列命令查看：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 列出所有内置配置</span><br>xtuner list-cfg<br></code></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#创建用于存放配置的文件夹config并进入</span><br><span class="hljs-built_in">mkdir</span> /root/personal_assistant/config &amp;&amp; <span class="hljs-built_in">cd</span> /root/personal_assistant/config<br></code></pre></td></tr></table></figure>
<p>拷贝一个配置文件到当前目录：<code>xtuner copy-cfg $&#123;CONFIG_NAME&#125; $&#123;SAVE_PATH&#125;</code><br>在本例中：（注意最后有个英文句号，代表复制到当前路径）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">xtuner copy-cfg internlm_chat_7b_qlora_oasst1_e3 .<br></code></pre></td></tr></table></figure>
<p>修改拷贝后的文件internlm_chat_7b_qlora_oasst1_e3_copy.py，修改下述位置：<br>(这是一份修改好的文件<a href="./internlm_chat_7b_qlora_oasst1_e3_copy.py">internlm_chat_7b_qlora_oasst1_e3_copy.py</a>)<br><img  src="修改配置.png"  ><span class="image-caption">修改配置</span></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># PART 1 中</span><br><span class="hljs-comment"># 预训练模型存放的位置</span><br>pretrained_model_name_or_path = <span class="hljs-string">&#x27;/root/personal_assistant/model/Shanghai_AI_Laboratory/internlm-chat-7b&#x27;</span><br><br><span class="hljs-comment"># 微调数据存放的位置</span><br>data_path = <span class="hljs-string">&#x27;/root/personal_assistant/data/personal_assistant.json&#x27;</span><br><br><span class="hljs-comment"># 训练中最大的文本长度</span><br>max_length = 512<br><br><span class="hljs-comment"># 每一批训练样本的大小</span><br>batch_size = 2<br><br><span class="hljs-comment"># 最大训练轮数</span><br>max_epochs = 3<br><br><span class="hljs-comment"># 验证的频率</span><br>evaluation_freq = 90<br><br><span class="hljs-comment"># 用于评估输出内容的问题（用于评估的问题尽量与数据集的question保持一致）</span><br>evaluation_inputs = [ <span class="hljs-string">&#x27;请介绍一下你自己&#x27;</span>, <span class="hljs-string">&#x27;请做一下自我介绍&#x27;</span> ]<br><br><br><span class="hljs-comment"># PART 3 中</span><br>dataset=dict(<span class="hljs-built_in">type</span>=load_dataset, path=<span class="hljs-string">&#x27;json&#x27;</span>, data_files=dict(train=data_path))<br>dataset_map_fn=None<br></code></pre></td></tr></table></figure>
<h4 id="微调启动"><a href="#微调启动" class="headerlink" title="微调启动"></a>微调启动</h4><p>用<code>xtuner train</code>命令启动训练、</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">xtuner train /root/personal_assistant/config/internlm_chat_7b_qlora_oasst1_e3_copy.py<br></code></pre></td></tr></table></figure>
<p><img  src="训练过程.png"  ><span class="image-caption">训练数据样例</span></p>
<blockquote>
<p>会在训练完成后，输出用于验证的Sample output</p>
<h4 id="微调后参数转换-合并"><a href="#微调后参数转换-合并" class="headerlink" title="微调后参数转换/合并"></a>微调后参数转换/合并</h4></blockquote>
<p>训练后的pth格式参数转Hugging Face格式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建用于存放Hugging Face格式参数的hf文件夹</span><br><span class="hljs-built_in">mkdir</span> /root/personal_assistant/config/work_dirs/hf<br><br><span class="hljs-built_in">export</span> MKL_SERVICE_FORCE_INTEL=1<br><br><span class="hljs-comment"># 配置文件存放的位置</span><br><span class="hljs-built_in">export</span> CONFIG_NAME_OR_PATH=/root/personal_assistant/config/internlm_chat_7b_qlora_oasst1_e3_copy.py<br><br><span class="hljs-comment"># 模型训练后得到的pth格式参数存放的位置</span><br><span class="hljs-built_in">export</span> PTH=/root/personal_assistant/config/work_dirs/internlm_chat_7b_qlora_oasst1_e3_copy/epoch_3.pth<br><br><span class="hljs-comment"># pth文件转换为Hugging Face格式后参数存放的位置</span><br><span class="hljs-built_in">export</span> SAVE_PATH=/root/personal_assistant/config/work_dirs/hf<br><br><span class="hljs-comment"># 执行参数转换</span><br>xtuner convert pth_to_hf <span class="hljs-variable">$CONFIG_NAME_OR_PATH</span> <span class="hljs-variable">$PTH</span> <span class="hljs-variable">$SAVE_PATH</span><br></code></pre></td></tr></table></figure>
<p>Merge模型参数<br><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> MKL_SERVICE_FORCE_INTEL=1<br><span class="hljs-built_in">export</span> MKL_THREADING_LAYER=<span class="hljs-string">&#x27;GNU&#x27;</span><br><br><span class="hljs-comment"># 原始模型参数存放的位置</span><br><span class="hljs-built_in">export</span> NAME_OR_PATH_TO_LLM=/root/personal_assistant/model/Shanghai_AI_Laboratory/internlm-chat-7b<br><br><span class="hljs-comment"># Hugging Face格式参数存放的位置</span><br><span class="hljs-built_in">export</span> NAME_OR_PATH_TO_ADAPTER=/root/personal_assistant/config/work_dirs/hf<br><br><span class="hljs-comment"># 最终Merge后的参数存放的位置</span><br><span class="hljs-built_in">mkdir</span> /root/personal_assistant/config/work_dirs/hf_merge<br><span class="hljs-built_in">export</span> SAVE_PATH=/root/personal_assistant/config/work_dirs/hf_merge<br><br><span class="hljs-comment"># 执行参数Merge</span><br>xtuner convert merge \<br>    <span class="hljs-variable">$NAME_OR_PATH_TO_LLM</span> \<br>    <span class="hljs-variable">$NAME_OR_PATH_TO_ADAPTER</span> \<br>    <span class="hljs-variable">$SAVE_PATH</span> \<br>    --max-shard-size 2GB<br></code></pre></td></tr></table></figure></p>
<h4 id="网页DEMO"><a href="#网页DEMO" class="headerlink" title="网页DEMO"></a>网页DEMO</h4><p>安装网页Demo所需依赖</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">pip install streamlit==1.24.0<br></code></pre></td></tr></table></figure>
<p>下载 InternLM 项目代码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建code文件夹用于存放InternLM项目代码</span><br><span class="hljs-built_in">mkdir</span> /root/personal_assistant/code &amp;&amp; <span class="hljs-built_in">cd</span> /root/personal_assistant/code<br>git <span class="hljs-built_in">clone</span> https://github.com/InternLM/InternLM.git<br></code></pre></td></tr></table></figure>
<p>将 <code>/root/code/InternLM/web_demo.py</code> 中 29 行和 33 行的模型路径更换为Merge后存放参数的路径 <code>/root/personal_assistant/config/work_dirs/hf_merge</code><br>运行 <code>/root/personal_assistant/code/InternLM</code> 目录下的 <code>web_demo.py</code> 文件，之后将端口映射到本地。在本地浏览器输入 <code>http://127.0.0.1:6006</code> 即可。</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus">streamlit run /root/personal_assistant/code/InternLM/web_demo<span class="hljs-selector-class">.py</span> <span class="hljs-attr">--server</span><span class="hljs-selector-class">.address</span> <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span> <span class="hljs-attr">--server</span><span class="hljs-selector-class">.port</span> <span class="hljs-number">6006</span><br></code></pre></td></tr></table></figure>
<p>注意：要在浏览器打开 <code>http://127.0.0.1:6006</code> 页面后，模型才会加载。<br>在加载完模型之后，就可以与微调后的 InternLM-Chat-7B 进行对话了</p>
<h3 id="3-效果"><a href="#3-效果" class="headerlink" title="3 效果"></a>3 效果</h3><p>微调前<br><img  src="官方回答.png"  ><span class="image-caption">官方回答</span></p>
<p>微调后<br><img  src="微调后.png"  ><span class="image-caption">微调后.png</span></p>
<h2 id="7-进阶作业"><a href="#7-进阶作业" class="headerlink" title="7 进阶作业"></a>7 进阶作业</h2><h3 id="1-模型上传"><a href="#1-模型上传" class="headerlink" title="1 模型上传"></a>1 模型上传</h3><p><img  src="model-upload.png"  ><span class="image-caption">model-upload.png</span></p>
<h3 id="2-修改启动文件"><a href="#2-修改启动文件" class="headerlink" title="2 修改启动文件"></a>2 修改启动文件</h3><p>接下来需要修改启动文件以下载模型以及合并 lora 层，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">from</span> openxlab.model <span class="hljs-keyword">import</span> download<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Download</span>():<br>    download(model_repo=<span class="hljs-string">&#x27;OpenLMLab/InternLM-chat-7b&#x27;</span>,output=<span class="hljs-string">&#x27;/home/xlab-app-center/InternLM-chat-7b&#x27;</span>)<br>    download(model_repo=<span class="hljs-string">&#x27;EnableAsync/openxlab-assistant&#x27;</span>,output=<span class="hljs-string">&quot;/home/xlab-app-center/hf&quot;</span>)<br><br>Download()<br>os.system(<span class="hljs-string">&#x27;echo $PWD&#x27;</span>)<br>os.system(<span class="hljs-string">&#x27;ls&#x27;</span>)<br><br>os.system(<span class="hljs-string">&#x27;xtuner convert merge /home/xlab-app-center/InternLM-chat-7b /home/xlab-app-center/hf /home/xlab-app-center/hf-merge --max-shard-size 2GB&#x27;</span>)<br>os.system(<span class="hljs-string">&#x27;streamlit run /home/xlab-app-center/InternLM/web_demo.py --server.address=0.0.0.0 --server.port 7860&#x27;</span>)<br></code></pre></td></tr></table></figure>
<h3 id="3-构建并运行"><a href="#3-构建并运行" class="headerlink" title="3 构建并运行"></a>3 构建并运行</h3><p><img  src="./build.png"  ><span class="image-caption">构建及运行</span></p>
<p>Github 地址如下：</p>
<p><a href="https://github.com/EnableAsync/openxlab-assistant">EnableAsync/openxlab-assistant (github.com)</a></p>
<p>运行地址如下：</p>
<p><a href="https://openxlab.org.cn/apps/detail/EnableAsync/openxlab-assistant">应用中心-OpenXLab-小卡的助手</a></p>
]]></content>
      <categories>
        <category>internlm</category>
      </categories>
  </entry>
  <entry>
    <title>Internlm-06-使用 OpenCompass 对大模型进行评测</title>
    <url>/internlm/internlm-06/</url>
    <content><![CDATA[<h1 id="使用-OpenCompass-对大模型进行评测"><a href="#使用-OpenCompass-对大模型进行评测" class="headerlink" title="使用 OpenCompass 对大模型进行评测"></a>使用 OpenCompass 对大模型进行评测</h1><h2 id="大模型评测概要"><a href="#大模型评测概要" class="headerlink" title="大模型评测概要"></a>大模型评测概要</h2><h3 id="人工智能技术的发展和主要模型的演变"><a href="#人工智能技术的发展和主要模型的演变" class="headerlink" title="人工智能技术的发展和主要模型的演变"></a>人工智能技术的发展和主要模型的演变</h3><ul>
<li><strong>OpenAI GPT系列：</strong><ul>
<li>2018年：发布第一代GPT模型，开启自然语言模型生成式预训练。</li>
<li>随后：发布GPT-2和GPT-3模型。</li>
</ul>
</li>
<li><strong>谷歌的预训练模型：</strong><ul>
<li>探索不同的大规模预训练模型，如T5, Flan等。</li>
</ul>
</li>
<li><strong>OpenAI的ChatGPT和GPT-4：</strong><ul>
<li>2022年11月：发布ChatGPT，展示问答、逻辑推理和内容创作能力。</li>
<li>2023年4月：发布GPT-4，引入多模态能力，拓展语言模型能力。</li>
</ul>
</li>
</ul>
<h3 id="大模型的国际竞争和应用"><a href="#大模型的国际竞争和应用" class="headerlink" title="大模型的国际竞争和应用"></a>大模型的国际竞争和应用</h3><ul>
<li><strong>OpenAI和微软的集成：</strong><ul>
<li>将ChatGPT和GPT-4集成进搜索引擎和Office办公套件，推出New Bing和Office Copilot。</li>
</ul>
</li>
<li><strong>谷歌的Bard：</strong><ul>
<li>基于PaLM和PaLM-2模型，与OpenAI和微软竞争。</li>
</ul>
</li>
<li><strong>中国企业和高校的发展：</strong><ul>
<li>百度、阿里、华为、商汤、讯飞等发布国产大模型。</li>
<li>清华、复旦等高校发布GLM, MOSS等模型。</li>
</ul>
</li>
</ul>
<h3 id="大模型评测的国际和国内进展"><a href="#大模型评测的国际和国内进展" class="headerlink" title="大模型评测的国际和国内进展"></a>大模型评测的国际和国内进展</h3><ul>
<li><strong>国际评测框架和数据集：</strong><ul>
<li>斯坦福大学的HELM评测框架。</li>
<li>纽约大学与谷歌、Meta的SuperGLUE评测集。</li>
<li>加州大学伯克利分校的MMLU测试集。</li>
<li>谷歌的Big-Bench评测集。</li>
</ul>
</li>
<li><strong>中国的评测数据集：</strong><ul>
<li>如CLUE, CUGE等，评测中文语言模型能力。</li>
</ul>
</li>
</ul>
<h3 id="面临的挑战和OpenCompass的提议"><a href="#面临的挑战和OpenCompass的提议" class="headerlink" title="面临的挑战和OpenCompass的提议"></a>面临的挑战和OpenCompass的提议</h3><ul>
<li><strong>当前挑战：</strong><ul>
<li>大模型应用场景广泛，但评测方案往往缺乏系统化。</li>
</ul>
</li>
<li><strong>OpenCompass的提议：</strong><ul>
<li>设计全面、高效、可拓展的评测方案。</li>
<li>提供分布式自动化评测系统，支持全面系统的能力评估。</li>
</ul>
</li>
</ul>
<h1 id="OpenCompass介绍"><a href="#OpenCompass介绍" class="headerlink" title="OpenCompass介绍"></a>OpenCompass介绍</h1><h2 id="评测对象"><a href="#评测对象" class="headerlink" title="评测对象"></a>评测对象</h2><p>本算法库的主要评测对象为语言大模型与多模态大模型。我们以语言大模型为例介绍评测的具体模型类型。</p>
<ul>
<li><p><strong>基座模型</strong>：一般是经过海量的文本数据以自监督学习的方式进行训练获得的模型（如OpenAI的GPT-3，Meta的LLaMA），往往具有强大的文字续写能力。</p>
</li>
<li><p><strong>对话模型</strong>：一般是在的基座模型的基础上，经过指令微调或人类偏好对齐获得的模型（如OpenAI的ChatGPT、上海人工智能实验室的书生·浦语），能理解人类指令，具有较强的对话能力。</p>
</li>
</ul>
<h2 id="工具架构"><a href="#工具架构" class="headerlink" title="工具架构"></a>工具架构</h2><p><img  src="工具架构.png"  ><span class="image-caption">工具架构</span></p>
<h3 id="大模型评测的层级结构"><a href="#大模型评测的层级结构" class="headerlink" title="大模型评测的层级结构"></a>大模型评测的层级结构</h3><ul>
<li><p>模型层</p>
<ul>
<li>重点评测对象：<ul>
<li>基座模型</li>
<li>对话模型</li>
</ul>
</li>
</ul>
</li>
<li><p>能力层</p>
<ul>
<li><p>通用能力：</p>
<ul>
<li>语言</li>
<li>知识</li>
<li>理解</li>
<li>推理</li>
<li>安全</li>
</ul>
</li>
<li><p>特色能力：</p>
<ul>
<li>长文本处理</li>
<li>编码能力</li>
<li>工具使用</li>
<li>知识增强</li>
</ul>
</li>
</ul>
</li>
<li><p>方法层</p>
<ul>
<li><p>客观评测：</p>
<ul>
<li>评估模型在确定答案任务（如选择题、填空、封闭式问答）上的能力。</li>
</ul>
</li>
<li><p>主观评测：</p>
<ul>
<li>评估用户对模型回复的真实满意度。</li>
<li>方法包括：<ul>
<li>基于模型辅助的主观评测</li>
<li>基于人类反馈的主观评测</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>工具层</p>
<ul>
<li>自动化评测支持：<ul>
<li>分布式评测技术</li>
<li>提示词工程</li>
<li>对接评测数据库</li>
<li>评测榜单发布</li>
<li>评测报告生成</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="评测方法"><a href="#评测方法" class="headerlink" title="评测方法"></a>评测方法</h2><h3 id="客观评测"><a href="#客观评测" class="headerlink" title="客观评测"></a>客观评测</h3><h4 id="评测客观问题的方法"><a href="#评测客观问题的方法" class="headerlink" title="评测客观问题的方法"></a>评测客观问题的方法</h4><ul>
<li><strong>定量比较：</strong><ul>
<li>使用定量指标比较模型输出与标准答案的差异。</li>
<li>根据差异结果衡量模型性能。</li>
</ul>
</li>
<li><p><strong>输入输出规范：</strong></p>
<ul>
<li>在评测阶段规范模型的输入和输出。</li>
<li>尽量减少噪声输出，以便更客观地评价模型能力。</li>
</ul>
<h4 id="模型能力的激发与引导"><a href="#模型能力的激发与引导" class="headerlink" title="模型能力的激发与引导"></a>模型能力的激发与引导</h4></li>
<li><p>提示词工程（Prompt Engineering）：</p>
<ul>
<li>使用特定提示词引导模型输出。</li>
</ul>
</li>
<li><p>语境学习（In-Context Learning）：</p>
<ul>
<li>利用上下文环境提升模型的输出质量。</li>
</ul>
<h4 id="客观评测的具体实践"><a href="#客观评测的具体实践" class="headerlink" title="客观评测的具体实践"></a>客观评测的具体实践</h4></li>
<li><p><strong>判别式评测：</strong></p>
<ul>
<li>结合问题和候选答案。</li>
<li>计算困惑度（perplexity），选择困惑度最小的答案。</li>
</ul>
</li>
<li><strong>生成式评测：</strong><ul>
<li>用于生成类任务（如语言翻译、程序生成、逻辑分析）。</li>
<li>使用问题作为输入，留白答案区域由模型补全。</li>
<li>对模型输出进行后处理，确保满足数据集要求。</li>
</ul>
</li>
</ul>
<h3 id="主观评测"><a href="#主观评测" class="headerlink" title="主观评测"></a>主观评测</h3><h4 id="主观评测的重要性"><a href="#主观评测的重要性" class="headerlink" title="主观评测的重要性"></a>主观评测的重要性</h4><ul>
<li>场景和能力多样性：<ul>
<li>语言表达丰富多变，很多场景和能力难以通过客观指标评测。</li>
</ul>
</li>
<li>模型安全和语言能力：<ul>
<li>需要依赖人的主观感受进行评测，以更真实地反映模型能力。</li>
</ul>
</li>
</ul>
<h4 id="OpenCompass的主观评测方案"><a href="#OpenCompass的主观评测方案" class="headerlink" title="OpenCompass的主观评测方案"></a>OpenCompass的主观评测方案</h4><ul>
<li>评测实施：<ul>
<li>使用受试者的主观判断对大语言模型进行评测。</li>
<li>构建主观测试问题集，对比不同模型的回复。</li>
</ul>
</li>
<li>成本与效率：<ul>
<li>高成本的人类主观评测。</li>
<li>结合使用性能优异的大语言模型进行主观打分。</li>
</ul>
</li>
</ul>
<h4 id="主观评测的具体实践"><a href="#主观评测的具体实践" class="headerlink" title="主观评测的具体实践"></a>主观评测的具体实践</h4><ul>
<li>单模型回复满意度统计：<ul>
<li>对单一模型的回复进行满意度评分。</li>
</ul>
</li>
<li>多模型满意度比较：<ul>
<li>比较不同模型回复的满意度。</li>
</ul>
</li>
</ul>
<h1 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h1><p><img  src="opencompass流程.png"  ><span class="image-caption">opencompass 评判流程</span></p>
<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>在 OpenCompass 中评估一个模型通常包括以下几个阶段：<strong>配置</strong> -&gt; <strong>推理</strong> -&gt; <strong>评估</strong> -&gt; <strong>可视化</strong>。</p>
<p><strong>配置</strong>：这是整个工作流的起点。您需要配置整个评估过程，选择要评估的模型和数据集。此外，还可以选择评估策略、计算后端等，并定义显示结果的方式。</p>
<p><strong>推理与评估</strong>：在这个阶段，OpenCompass 将会开始对模型和数据集进行并行推理和评估。<strong>推理</strong>阶段主要是让模型从数据集产生输出，而<strong>评估</strong>阶段则是衡量这些输出与标准答案的匹配程度。这两个过程会被拆分为多个同时运行的“任务”以提高效率，但请注意，如果计算资源有限，这种策略可能会使评测变得更慢。</p>
<p><strong>可视化</strong>：评估完成后，OpenCompass 将结果整理成易读的表格，并将其保存为 CSV 和 TXT 文件。你也可以激活飞书状态上报功能，此后可以在飞书客户端中及时获得评测状态报告。</p>
<p>接下来，我们将展示 OpenCompass 的基础用法，展示书生浦语在 <a href="https://cevalbenchmark.com/index.html#home">C-Eval</a> 基准任务上的评估。它们的配置文件可以在 <a href="https://github.com/open-compass/opencompass/blob/main/configs/eval_demo.py">configs/eval_demo.py</a> 中找到。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="面向GPU的环境安装"><a href="#面向GPU的环境安装" class="headerlink" title="面向GPU的环境安装"></a>面向GPU的环境安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">conda create --name opencompass --<span class="hljs-built_in">clone</span>=/root/share/conda_envs/internlm-base<br>conda activate opencompass<br>git <span class="hljs-built_in">clone</span> https://github.com/open-compass/opencompass<br><span class="hljs-built_in">cd</span> opencompass<br>pip install -e .<br></code></pre></td></tr></table></figure>
<p>有部分第三方功能,如代码能力基准测试 Humaneval 以及 Llama格式的模型评测,可能需要额外步骤才能正常运行，如需评测，详细步骤请参考<a href="https://opencompass.readthedocs.io/zh_CN/latest/get_started/installation.html">安装指南</a>。</p>
<h3 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 解压评测数据集到 data/ 处</span><br><span class="hljs-built_in">cp</span> /share/temp/datasets/OpenCompassData-core-20231110.zip /root/opencompass/<br>unzip OpenCompassData-core-20231110.zip<br><br><span class="hljs-comment"># 将会在opencompass下看到data文件夹</span><br></code></pre></td></tr></table></figure>
<h3 id="查看支持的数据集和模型"><a href="#查看支持的数据集和模型" class="headerlink" title="查看支持的数据集和模型"></a>查看支持的数据集和模型</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 列出所有跟 internlm 及 ceval 相关的配置</span><br>python tools/list_configs.py internlm ceval<br></code></pre></td></tr></table></figure>
<p>将会看到</p>
<figure class="highlight text"><table><tr><td class="code"><pre><code class="hljs text">+--------------------------+--------------------------------------------------------+<br>| Model                    | Config Path                                            |<br>|--------------------------+--------------------------------------------------------|<br>| hf_internlm_20b          | configs/models/hf_internlm/hf_internlm_20b.py          |<br>| hf_internlm_7b           | configs/models/hf_internlm/hf_internlm_7b.py           |<br>| hf_internlm_chat_20b     | configs/models/hf_internlm/hf_internlm_chat_20b.py     |<br>| hf_internlm_chat_7b      | configs/models/hf_internlm/hf_internlm_chat_7b.py      |<br>| hf_internlm_chat_7b_8k   | configs/models/hf_internlm/hf_internlm_chat_7b_8k.py   |<br>| hf_internlm_chat_7b_v1_1 | configs/models/hf_internlm/hf_internlm_chat_7b_v1_1.py |<br>| internlm_7b              | configs/models/internlm/internlm_7b.py                 |<br>| ms_internlm_chat_7b_8k   | configs/models/ms_internlm/ms_internlm_chat_7b_8k.py   |<br>+--------------------------+--------------------------------------------------------+<br>+----------------------------+------------------------------------------------------+<br>| Dataset                    | Config Path                                          |<br>|----------------------------+------------------------------------------------------|<br>| ceval_clean_ppl            | configs/datasets/ceval/ceval_clean_ppl.py            |<br>| ceval_gen                  | configs/datasets/ceval/ceval_gen.py                  |<br>| ceval_gen_2daf24           | configs/datasets/ceval/ceval_gen_2daf24.py           |<br>| ceval_gen_5f30c7           | configs/datasets/ceval/ceval_gen_5f30c7.py           |<br>| ceval_ppl                  | configs/datasets/ceval/ceval_ppl.py                  |<br>| ceval_ppl_578f8d           | configs/datasets/ceval/ceval_ppl_578f8d.py           |<br>| ceval_ppl_93e5ce           | configs/datasets/ceval/ceval_ppl_93e5ce.py           |<br>| ceval_zero_shot_gen_bd40ef | configs/datasets/ceval/ceval_zero_shot_gen_bd40ef.py |<br>+----------------------------+------------------------------------------------------+<br></code></pre></td></tr></table></figure>
<h3 id="启动评测"><a href="#启动评测" class="headerlink" title="启动评测"></a>启动评测</h3><p>确保按照上述步骤正确安装 OpenCompass 并准备好数据集后，可以通过以下命令评测 InternLM-Chat-7B 模型在 C-Eval 数据集上的性能。由于 OpenCompass 默认并行启动评估过程，我们可以在第一次运行时以 <code>--debug</code> 模式启动评估，并检查是否存在问题。在 <code>--debug</code> 模式下，任务将按顺序执行，并实时打印输出。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">python run.py --datasets ceval_gen --hf-path /share/temp/model_repos/internlm-chat-7b/ --tokenizer-path /share/temp/model_repos/internlm-chat-7b/ --tokenizer-kwargs padding_side=<span class="hljs-string">&#x27;left&#x27;</span> truncation=<span class="hljs-string">&#x27;left&#x27;</span> trust_remote_code=True --model-kwargs trust_remote_code=True device_map=<span class="hljs-string">&#x27;auto&#x27;</span> --max-seq-len 2048 --max-out-len 16 --batch-size 4 --num-gpus 1 --debug<br></code></pre></td></tr></table></figure>
<p>命令解析<br><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">--datasets ceval_gen \<br>--hf-path /share/temp/model_repos/internlm-chat-7b/ \  <span class="hljs-comment"># HuggingFace 模型路径</span><br>--tokenizer-path /share/temp/model_repos/internlm-chat-7b/ \  <span class="hljs-comment"># HuggingFace tokenizer 路径（如果与模型路径相同，可以省略）</span><br>--tokenizer-kwargs padding_side=<span class="hljs-string">&#x27;left&#x27;</span> truncation=<span class="hljs-string">&#x27;left&#x27;</span> trust_remote_code=True \  <span class="hljs-comment"># 构建 tokenizer 的参数</span><br>--model-kwargs device_map=<span class="hljs-string">&#x27;auto&#x27;</span> trust_remote_code=True \  <span class="hljs-comment"># 构建模型的参数</span><br>--max-seq-len 2048 \  <span class="hljs-comment"># 模型可以接受的最大序列长度</span><br>--max-out-len 16 \  <span class="hljs-comment"># 生成的最大 token 数</span><br>--batch-size 2  \  <span class="hljs-comment"># 批量大小</span><br>--num-gpus 1  <span class="hljs-comment"># 运行模型所需的 GPU 数量</span><br>--debug<br></code></pre></td></tr></table></figure></p>
<p>如果一切正常，您应该看到屏幕上显示 “Starting inference process”：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[2024-01-12 18:23:55,076] [opencompass.openicl.icl_inferencer.icl_gen_inferencer] [INFO] Starting inference process...<br></code></pre></td></tr></table></figure>
<p>评测完成后，将会看到：<br><figure class="highlight maxima"><table><tr><td class="code"><pre><code class="hljs maxima"><br>dataset                                         version    metric         mode      opencompass.models.huggingface.HuggingFace_model_repos_internlm-chat-7b<br>----------------------------------------------  ---------  -------------  ------  -------------------------------------------------------------------------<br>ceval-computer_network                          db9ce2     accuracy       gen                                                                         <span class="hljs-number">31.58</span><br>ceval-operating_system                          1c2571     accuracy       gen                                                                         <span class="hljs-number">36.84</span><br>ceval-computer_architecture                     a74dad     accuracy       gen                                                                         <span class="hljs-number">28.57</span><br>ceval-college_programming                       4ca32a     accuracy       gen                                                                         <span class="hljs-number">32.43</span><br>ceval-college_physics                           963fa8     accuracy       gen                                                                         <span class="hljs-number">26.32</span><br>ceval-college_chemistry                         e78857     accuracy       gen                                                                         <span class="hljs-number">16.67</span><br>ceval-advanced_mathematics                      ce03e2     accuracy       gen                                                                         <span class="hljs-number">21.05</span><br>ceval-probability_and_statistics                <span class="hljs-number">65e812</span>     accuracy       gen                                                                         <span class="hljs-number">38.89</span><br>ceval-discrete_mathematics                      e894ae     accuracy       gen                                                                         <span class="hljs-number">18.75</span><br>ceval-electrical_engineer                       ae42b9     accuracy       gen                                                                         <span class="hljs-number">35.14</span><br>ceval-metrology_engineer                        ee34ea     accuracy       gen                                                                         <span class="hljs-number">50</span><br>ceval-high_school_mathematics                   1dc5bf     accuracy       gen                                                                         <span class="hljs-number">22.22</span><br>ceval-high_school_physics                       adf25f     accuracy       gen                                                                         <span class="hljs-number">31.58</span><br>ceval-high_school_chemistry                     2ed27f     accuracy       gen                                                                         <span class="hljs-number">15.79</span><br>ceval-high_school_biology                       8e2b9a     accuracy       gen                                                                         <span class="hljs-number">36.84</span><br>ceval-middle_school_mathematics                 bee8d5     accuracy       gen                                                                         <span class="hljs-number">26.32</span><br>ceval-middle_school_biology                     86817c     accuracy       gen                                                                         <span class="hljs-number">61.9</span><br>ceval-middle_school_physics                     8accf6     accuracy       gen                                                                         <span class="hljs-number">63.16</span><br>ceval-middle_school_chemistry                   167a15     accuracy       gen                                                                         <span class="hljs-number">60</span><br>ceval-veterinary_medicine                       b4e08d     accuracy       gen                                                                         <span class="hljs-number">47.83</span><br>ceval-college_economics                         f3f4e6     accuracy       gen                                                                         <span class="hljs-number">41.82</span><br>ceval-business_administration                   c1614e     accuracy       gen                                                                         <span class="hljs-number">33.33</span><br>ceval-marxism                                   cf874c     accuracy       gen                                                                         <span class="hljs-number">68.42</span><br>ceval-mao_zedong_thought                        51c7a4     accuracy       gen                                                                         <span class="hljs-number">70.83</span><br>ceval-education_science                         591fee     accuracy       gen                                                                         <span class="hljs-number">58.62</span><br>ceval-teacher_qualification                     4e4ced     accuracy       gen                                                                         <span class="hljs-number">70.45</span><br>ceval-high_school_politics                      5c0de2     accuracy       gen                                                                         <span class="hljs-number">26.32</span><br>ceval-high_school_geography                     <span class="hljs-number">865461</span>     accuracy       gen                                                                         <span class="hljs-number">47.37</span><br>ceval-middle_school_politics                    5be3e7     accuracy       gen                                                                         <span class="hljs-number">52.38</span><br>ceval-middle_school_geography                   8a63be     accuracy       gen                                                                         <span class="hljs-number">58.33</span><br>ceval-modern_chinese_history                    fc01af     accuracy       gen                                                                         <span class="hljs-number">73.91</span><br>ceval-ideological_and_moral_cultivation         a2aa4a     accuracy       gen                                                                         <span class="hljs-number">63.16</span><br>ceval-logic                                     f5b022     accuracy       gen                                                                         <span class="hljs-number">31.82</span><br>ceval-law                                       a110a1     accuracy       gen                                                                         <span class="hljs-number">25</span><br>ceval-chinese_language_and_literature           <span class="hljs-number">0f8b68</span>     accuracy       gen                                                                         <span class="hljs-number">30.43</span><br>ceval-art_studies                               2a1300     accuracy       gen                                                                         <span class="hljs-number">60.61</span><br>ceval-professional_tour_guide                   4e673e     accuracy       gen                                                                         <span class="hljs-number">62.07</span><br>ceval-legal_professional                        ce8787     accuracy       gen                                                                         <span class="hljs-number">39.13</span><br>ceval-high_school_chinese                       <span class="hljs-number">315705</span>     accuracy       gen                                                                         <span class="hljs-number">63.16</span><br>ceval-high_school_history                       7eb30a     accuracy       gen                                                                         <span class="hljs-number">70</span><br>ceval-middle_school_history                     48ab4a     accuracy       gen                                                                         <span class="hljs-number">59.09</span><br>ceval-civil_servant                             87d061     accuracy       gen                                                                         <span class="hljs-number">53.19</span><br>ceval-sports_science                            70f27b     accuracy       gen                                                                         <span class="hljs-number">52.63</span><br>ceval-plant_protection                          8941f9     accuracy       gen                                                                         <span class="hljs-number">59.09</span><br>ceval-basic_medicine                            c409d6     accuracy       gen                                                                         <span class="hljs-number">47.37</span><br>ceval-clinical_medicine                         49e82d     accuracy       gen                                                                         <span class="hljs-number">40.91</span><br>ceval-urban_and_rural_planner                   <span class="hljs-number">95b885</span>     accuracy       gen                                                                         <span class="hljs-number">45.65</span><br>ceval-accountant                                <span class="hljs-number">002837</span>     accuracy       gen                                                                         <span class="hljs-number">26.53</span><br>ceval-fire_engineer                             bc23f5     accuracy       gen                                                                         <span class="hljs-number">22.58</span><br>ceval-environmental_impact_assessment_engineer  c64e2d     accuracy       gen                                                                         <span class="hljs-number">64.52</span><br>ceval-tax_accountant                            3a5e3c     accuracy       gen                                                                         <span class="hljs-number">34.69</span><br>ceval-physician                                 6e277d     accuracy       gen                                                                         <span class="hljs-number">40.82</span><br>ceval-stem                                      -          naive_average  gen                                                                         <span class="hljs-number">35.09</span><br>ceval-social-science                            -          naive_average  gen                                                                         <span class="hljs-number">52.79</span><br>ceval-humanities                                -          naive_average  gen                                                                         <span class="hljs-number">52.58</span><br>ceval-other                                     -          naive_average  gen                                                                         <span class="hljs-number">44.36</span><br>ceval-hard                                      -          naive_average  gen                                                                         <span class="hljs-number">23.91</span><br>ceval                                           -          naive_average  gen                                                                         <span class="hljs-number">44.16</span><br></code></pre></td></tr></table></figure></p>
<p>有关 <code>run.py</code> 支持的所有与 HuggingFace 相关的参数，请阅读 <a href="https://opencompass.readthedocs.io/zh-cn/latest/user_guides/experimentation.html#id2">评测任务发起</a></p>
<p>除了通过命令行配置实验外，OpenCompass 还允许用户在配置文件中编写实验的完整配置，并通过 <code>run.py</code> 直接运行它。配置文件是以 Python 格式组织的，并且必须包括 <code>datasets</code> 和 <code>models</code> 字段。</p>
<p>示例测试配置在 <a href="https://github.com/open-compass/opencompass/blob/main/configs/eval_demo.py">configs/eval_demo.py</a> 中。此配置通过 <a href="../user_guides/config.md#继承机制">继承机制</a> 引入所需的数据集和模型配置，并以所需格式组合 <code>datasets</code> 和 <code>models</code> 字段。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> mmengine.config <span class="hljs-keyword">import</span> read_base<br><br><span class="hljs-keyword">with</span> read_base():<br>    <span class="hljs-keyword">from</span> .datasets.siqa.siqa_gen <span class="hljs-keyword">import</span> siqa_datasets<br>    <span class="hljs-keyword">from</span> .datasets.winograd.winograd_ppl <span class="hljs-keyword">import</span> winograd_datasets<br>    <span class="hljs-keyword">from</span> .models.opt.hf_opt_125m <span class="hljs-keyword">import</span> opt125m<br>    <span class="hljs-keyword">from</span> .models.opt.hf_opt_350m <span class="hljs-keyword">import</span> opt350m<br><br>datasets = [*siqa_datasets, *winograd_datasets]<br>models = [opt125m, opt350m]<br></code></pre></td></tr></table></figure>
<p>运行任务时，我们只需将配置文件的路径传递给 <code>run.py</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">python run.py configs/eval_demo.py<br></code></pre></td></tr></table></figure>
<p>OpenCompass 提供了一系列预定义的模型配置，位于 <code>configs/models</code> 下。以下是与 <a href="https://github.com/open-compass/opencompass/blob/main/configs/models/opt/hf_opt_350m.py">opt-350m</a>（<code>configs/models/opt/hf_opt_350m.py</code>）相关的配置片段：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 使用 `HuggingFaceCausalLM` 评估由 HuggingFace 的 `AutoModelForCausalLM` 支持的模型</span><br><span class="hljs-keyword">from</span> opencompass.models <span class="hljs-keyword">import</span> HuggingFaceCausalLM<br><br><span class="hljs-comment"># OPT-350M</span><br>opt350m = <span class="hljs-built_in">dict</span>(<br>       <span class="hljs-built_in">type</span>=HuggingFaceCausalLM,<br>       <span class="hljs-comment"># `HuggingFaceCausalLM` 的初始化参数</span><br>       path=<span class="hljs-string">&#x27;facebook/opt-350m&#x27;</span>,<br>       tokenizer_path=<span class="hljs-string">&#x27;facebook/opt-350m&#x27;</span>,<br>       tokenizer_kwargs=<span class="hljs-built_in">dict</span>(<br>           padding_side=<span class="hljs-string">&#x27;left&#x27;</span>,<br>           truncation_side=<span class="hljs-string">&#x27;left&#x27;</span>,<br>           proxies=<span class="hljs-literal">None</span>,<br>           trust_remote_code=<span class="hljs-literal">True</span>),<br>       model_kwargs=<span class="hljs-built_in">dict</span>(device_map=<span class="hljs-string">&#x27;auto&#x27;</span>),<br>       <span class="hljs-comment"># 下面是所有模型的共同参数，不特定于 HuggingFaceCausalLM</span><br>       abbr=<span class="hljs-string">&#x27;opt350m&#x27;</span>,               <span class="hljs-comment"># 结果显示的模型缩写</span><br>       max_seq_len=<span class="hljs-number">2048</span>,             <span class="hljs-comment"># 整个序列的最大长度</span><br>       max_out_len=<span class="hljs-number">100</span>,              <span class="hljs-comment"># 生成的最大 token 数</span><br>       batch_size=<span class="hljs-number">64</span>,                <span class="hljs-comment"># 批量大小</span><br>       run_cfg=<span class="hljs-built_in">dict</span>(num_gpus=<span class="hljs-number">1</span>),     <span class="hljs-comment"># 该模型所需的 GPU 数量</span><br>    )<br></code></pre></td></tr></table></figure>
<p>使用配置时，我们可以通过命令行参数 <code>--models</code> 指定相关文件，或使用继承机制将模型配置导入到配置文件中的 <code>models</code> 列表中。</p>
<p>与模型类似，数据集的配置文件也提供在 <code>configs/datasets</code> 下。用户可以在命令行中使用 <code>--datasets</code>，或通过继承在配置文件中导入相关配置</p>
<p>下面是来自 <code>configs/eval_demo.py</code> 的与数据集相关的配置片段：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> mmengine.config <span class="hljs-keyword">import</span> read_base  <span class="hljs-comment"># 使用 mmengine.read_base() 读取基本配置</span><br><br><span class="hljs-keyword">with</span> read_base():<br>    <span class="hljs-comment"># 直接从预设的数据集配置中读取所需的数据集配置</span><br>    <span class="hljs-keyword">from</span> .datasets.winograd.winograd_ppl <span class="hljs-keyword">import</span> winograd_datasets  <span class="hljs-comment"># 读取 Winograd 配置，基于 PPL（困惑度）进行评估</span><br>    <span class="hljs-keyword">from</span> .datasets.siqa.siqa_gen <span class="hljs-keyword">import</span> siqa_datasets  <span class="hljs-comment"># 读取 SIQA 配置，基于生成进行评估</span><br><br>datasets = [*siqa_datasets, *winograd_datasets]       <span class="hljs-comment"># 最终的配置需要包含所需的评估数据集列表 &#x27;datasets&#x27;</span><br></code></pre></td></tr></table></figure>
<p>数据集配置通常有两种类型：’ppl’ 和 ‘gen’，分别指示使用的评估方法。其中 <code>ppl</code> 表示辨别性评估，<code>gen</code> 表示生成性评估。</p>
<p>此外，<a href="https://github.com/open-compass/opencompass/blob/main/configs/datasets/collections">configs/datasets/collections</a> 收录了各种数据集集合，方便进行综合评估。OpenCompass 通常使用 <a href="https://github.com/open-compass/opencompass/blob/main/configs/datasets/collections/base_medium.py"><code>base_medium.py</code></a> 进行全面的模型测试。要复制结果，只需导入该文件，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">python run.py --models hf_llama_7b --datasets base_medium<br></code></pre></td></tr></table></figure>
<p>OpenCompass 通常假定运行环境网络是可用的。如果您遇到网络问题或希望在离线环境中运行 OpenCompass，请参阅 <a href="https://opencompass.readthedocs.io/zh-cn/latest/get_started/faq.html">FAQ - 网络 - Q1</a> 寻求解决方案。</p>
<h2 id="可视化评估结果"><a href="#可视化评估结果" class="headerlink" title="可视化评估结果"></a>可视化评估结果</h2><p>评估完成后，评估结果表格将打印如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><code class="hljs text">dataset    version    metric    mode      opt350m    opt125m<br>---------  ---------  --------  ------  ---------  ---------<br>siqa       e78df3     accuracy  gen         21.55      12.44<br>winograd   b6c7ed     accuracy  ppl         51.23      49.82<br></code></pre></td></tr></table></figure>
<p>所有运行输出将定向到 <code>outputs/demo/</code> 目录，结构如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><code class="hljs text">outputs/default/<br>├── 20200220_120000<br>├── 20230220_183030     # 每个实验一个文件夹<br>│   ├── configs         # 用于记录的已转储的配置文件。如果在同一个实验文件夹中重新运行了不同的实验，可能会保留多个配置<br>│   ├── logs            # 推理和评估阶段的日志文件<br>│   │   ├── eval<br>│   │   └── infer<br>│   ├── predictions   # 每个任务的推理结果<br>│   ├── results       # 每个任务的评估结果<br>│   └── summary       # 单个实验的汇总评估结果<br>├── ...<br></code></pre></td></tr></table></figure>
<p>打印评测结果的过程可被进一步定制化，用于输出一些数据集的平均分 (例如 MMLU, C-Eval 等)。</p>
<p>关于评测结果输出的更多介绍可阅读 <a href="../user_guides/summarizer.md">结果展示</a>。</p>
<h2 id="更多教程"><a href="#更多教程" class="headerlink" title="更多教程"></a>更多教程</h2><p>想要更多了解 OpenCompass, 可以点击下列链接学习。</p>
<ul>
<li><a href="https://opencompass.readthedocs.io/zh-cn/latest/">https://opencompass.readthedocs.io/zh-cn/latest/</a></li>
</ul>
<h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h2><h3 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建环境</span><br>conda create --name opencompass --<span class="hljs-built_in">clone</span>=/root/share/conda_envs/internlm-base<br>conda activate opencompass<br><span class="hljs-comment"># 使用镜像 clone</span><br>git <span class="hljs-built_in">clone</span> https://mirror.ghproxy.com/https://github.com/open-compass/opencompass<br><span class="hljs-built_in">cd</span> opencompass<br>pip install -e .<br></code></pre></td></tr></table></figure>
<h3 id="准备数据"><a href="#准备数据" class="headerlink" title="准备数据"></a>准备数据</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cp</span> /share/temp/datasets/OpenCompassData-core-20231110.zip /root/opencompass/<br><span class="hljs-built_in">cd</span> /root/opencompass/<br>unzip OpenCompassData-core-20231110.zip<br></code></pre></td></tr></table></figure>
<p><img  src="unzip.png"  ><span class="image-caption">解压数据</span></p>
<h3 id="查看支持的数据集和模型-1"><a href="#查看支持的数据集和模型-1" class="headerlink" title="查看支持的数据集和模型"></a>查看支持的数据集和模型</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">python tools/list_configs.py internlm ceval<br></code></pre></td></tr></table></figure>
<p><img  src="list.png"  ><span class="image-caption">列出所有跟 internlm 及 ceval 相关的配置</span></p>
<h3 id="启动评测-1"><a href="#启动评测-1" class="headerlink" title="启动评测"></a>启动评测</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">python run.py \<br>--datasets ceval_gen \<br>--hf-path /share/model_repos/internlm2-chat-7b/ \  <span class="hljs-comment"># HuggingFace 模型路径</span><br>--tokenizer-path /share/model_repos/internlm2-chat-7b/ \  <span class="hljs-comment"># 注意这里是 internlm2</span><br>--tokenizer-kwargs padding_side=<span class="hljs-string">&#x27;left&#x27;</span> truncation=<span class="hljs-string">&#x27;left&#x27;</span> trust_remote_code=True \  <span class="hljs-comment"># 构建 tokenizer 的参数</span><br>--model-kwargs device_map=<span class="hljs-string">&#x27;auto&#x27;</span> trust_remote_code=True \  <span class="hljs-comment"># 构建模型的参数</span><br>--max-seq-len 2048 \  <span class="hljs-comment"># 模型可以接受的最大序列长度</span><br>--max-out-len 16 \  <span class="hljs-comment"># 生成的最大 token 数</span><br>--batch-size 2  \  <span class="hljs-comment"># 批量大小</span><br>--num-gpus 1 \ <span class="hljs-comment"># 运行模型所需的 GPU 数量</span><br>--debug<br></code></pre></td></tr></table></figure>
<p>便于复制版：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">python run.py \<br>--datasets ceval_gen \<br>--hf-path /share/model_repos/internlm2-chat-7b/ \<br>--tokenizer-path /share/model_repos/internlm2-chat-7b/ \<br>--tokenizer-kwargs padding_side=<span class="hljs-string">&#x27;left&#x27;</span> truncation=<span class="hljs-string">&#x27;left&#x27;</span> trust_remote_code=True \<br>--model-kwargs device_map=<span class="hljs-string">&#x27;auto&#x27;</span> trust_remote_code=True \<br>--max-seq-len 2048 \<br>--max-out-len 16 \<br>--batch-size 2  \<br>--num-gpus 1 \<br>--debug<br></code></pre></td></tr></table></figure>
<p>发现显存不够用，尝试改小 batch size 为 1。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">python run.py \<br>--datasets ceval_gen \<br>--hf-path /share/model_repos/internlm2-chat-7b/ \<br>--tokenizer-path /share/model_repos/internlm2-chat-7b/ \<br>--tokenizer-kwargs padding_side=<span class="hljs-string">&#x27;left&#x27;</span> truncation=<span class="hljs-string">&#x27;left&#x27;</span> trust_remote_code=True \<br>--model-kwargs device_map=<span class="hljs-string">&#x27;auto&#x27;</span> trust_remote_code=True \<br>--max-seq-len 2048 \<br>--max-out-len 16 \<br>--batch-size 1  \<br>--num-gpus 1 \<br>--debug<br></code></pre></td></tr></table></figure>
<p><img  src="run.png"  ><span class="image-caption">运行截图</span></p>
<p><img  src="result.png"  ><span class="image-caption">评测结果</span></p>
<h2 id="进阶作业"><a href="#进阶作业" class="headerlink" title="进阶作业"></a>进阶作业</h2><p>安装 lmdeploy，这一步是必须的，否则无法加载 TurboMind 模型</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">pip install lmdeploy==0.2.0<br></code></pre></td></tr></table></figure>
<p>编写 config 文件如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> mmengine.config <span class="hljs-keyword">import</span> read_base<br><span class="hljs-keyword">from</span> opencompass.models.turbomind <span class="hljs-keyword">import</span> TurboMindModel<br><br><span class="hljs-keyword">with</span> read_base():<br>    <span class="hljs-comment"># choose a list of datasets</span><br>    <span class="hljs-keyword">from</span> .datasets.ceval.ceval_gen_5f30c7 <span class="hljs-keyword">import</span> ceval_datasets<br><br><br>datasets = [*ceval_datasets]<br><br>internlm_meta_template = <span class="hljs-built_in">dict</span>(<span class="hljs-built_in">round</span>=[<br>    <span class="hljs-built_in">dict</span>(role=<span class="hljs-string">&#x27;HUMAN&#x27;</span>, begin=<span class="hljs-string">&#x27;&lt;|User|&gt;:&#x27;</span>, end=<span class="hljs-string">&#x27;\n&#x27;</span>),<br>    <span class="hljs-built_in">dict</span>(role=<span class="hljs-string">&#x27;BOT&#x27;</span>, begin=<span class="hljs-string">&#x27;&lt;|Bot|&gt;:&#x27;</span>, end=<span class="hljs-string">&#x27;&lt;eoa&gt;\n&#x27;</span>, generate=<span class="hljs-literal">True</span>),<br>],<br>                              eos_token_id=<span class="hljs-number">103028</span>)<br><br><span class="hljs-comment"># config for internlm-chat-7b</span><br>internlm_chat_7b = <span class="hljs-built_in">dict</span>(<br>    <span class="hljs-built_in">type</span>=TurboMindModel,<br>    abbr=<span class="hljs-string">&#x27;internlm-chat-7b&#x27;</span>,<br>    path=<span class="hljs-string">&#x27;/root/workspace_quant_awq4&#x27;</span>, <span class="hljs-comment"># 这里的 path 是上一节课中的 awq 模型</span><br>    engine_config=<span class="hljs-built_in">dict</span>(session_len=<span class="hljs-number">2048</span>,<br>                       max_batch_size=<span class="hljs-number">32</span>,<br>                       rope_scaling_factor=<span class="hljs-number">1.0</span>),<br>    gen_config=<span class="hljs-built_in">dict</span>(top_k=<span class="hljs-number">1</span>,<br>                    top_p=<span class="hljs-number">0.8</span>,<br>                    temperature=<span class="hljs-number">1.0</span>,<br>                    max_new_tokens=<span class="hljs-number">100</span>),<br>    max_out_len=<span class="hljs-number">100</span>,<br>    max_seq_len=<span class="hljs-number">1024</span>,<br>    batch_size=<span class="hljs-number">2</span>,<br>    concurrency=<span class="hljs-number">32</span>,<br>    meta_template=internlm_meta_template,<br>    run_cfg=<span class="hljs-built_in">dict</span>(num_gpus=<span class="hljs-number">1</span>, num_procs=<span class="hljs-number">1</span>),<br>)<br><br>models = [internlm_chat_7b]<br></code></pre></td></tr></table></figure>
<p>运行评测：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">python run.py configs/eval_internlm_my_deploy.py --debug<br></code></pre></td></tr></table></figure>
<p><img  src="awq.png"  ><span class="image-caption">加载量化后的模型</span></p>
<p><img  src="result-internlm-awq.png"  ><span class="image-caption">评判 internlm-awq</span></p>
<p>可见 internlm-AWQ 在 ceval 上的得分并不如 internlm2。</p>
<h3 id="使用-lmdeploy-0-2-0-转换-internlm2-为-awq-模型并进行评测"><a href="#使用-lmdeploy-0-2-0-转换-internlm2-为-awq-模型并进行评测" class="headerlink" title="使用 lmdeploy 0.2.0 转换 internlm2 为 awq 模型并进行评测"></a>使用 lmdeploy 0.2.0 转换 internlm2 为 awq 模型并进行评测</h3><p>使用 lmdeploy 0.2 的时候与 0.1 版本进行 AWQ 量化的方式略有不同，同时要从 huggingface 上下载测试数据集，所以国内可以使用镜像：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> HF_ENDPOINT=https://hf-mirror.com<br>lmdeploy lite auto_awq /root/share/model_repos/internlm2-chat-7b  --work-dir internlm2-chat-7b-4bit<br></code></pre></td></tr></table></figure>
<p>之后对模型进行转化：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">lmdeploy convert  internlm2-chat-7b ./internlm2-chat-7b-4bit/ --model-format awq --group-size 128  --dst-path  ./workspace_awq_internlm2<br></code></pre></td></tr></table></figure>
<p><img  src="convert.png"  ><span class="image-caption">转换模型</span></p>
<p>之后编写新的 config.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> mmengine.config <span class="hljs-keyword">import</span> read_base<br><span class="hljs-keyword">from</span> opencompass.models.turbomind <span class="hljs-keyword">import</span> TurboMindModel<br><br><span class="hljs-keyword">with</span> read_base():<br>    <span class="hljs-comment"># choose a list of datasets</span><br>    <span class="hljs-keyword">from</span> .datasets.ceval.ceval_gen_5f30c7 <span class="hljs-keyword">import</span> ceval_datasets<br><br><br>datasets = [*ceval_datasets]<br><br>internlm_meta_template = <span class="hljs-built_in">dict</span>(<span class="hljs-built_in">round</span>=[<br>    <span class="hljs-built_in">dict</span>(role=<span class="hljs-string">&#x27;HUMAN&#x27;</span>, begin=<span class="hljs-string">&#x27;&lt;|User|&gt;:&#x27;</span>, end=<span class="hljs-string">&#x27;\n&#x27;</span>),<br>    <span class="hljs-built_in">dict</span>(role=<span class="hljs-string">&#x27;BOT&#x27;</span>, begin=<span class="hljs-string">&#x27;&lt;|Bot|&gt;:&#x27;</span>, end=<span class="hljs-string">&#x27;&lt;eoa&gt;\n&#x27;</span>, generate=<span class="hljs-literal">True</span>),<br>],<br>                              eos_token_id=<span class="hljs-number">103028</span>)<br><br><span class="hljs-comment"># config for internlm2-chat-7b-awq</span><br>internlm2_chat_7b = <span class="hljs-built_in">dict</span>(<br>    <span class="hljs-built_in">type</span>=TurboMindModel,<br>    abbr=<span class="hljs-string">&#x27;internlm-chat-7b&#x27;</span>,<br>    path=<span class="hljs-string">&#x27;/root/workspace_awq_internlm2&#x27;</span>,<br>    engine_config=<span class="hljs-built_in">dict</span>(session_len=<span class="hljs-number">2048</span>,<br>                       max_batch_size=<span class="hljs-number">32</span>,<br>                       rope_scaling_factor=<span class="hljs-number">1.0</span>),<br>    gen_config=<span class="hljs-built_in">dict</span>(top_k=<span class="hljs-number">1</span>,<br>                    top_p=<span class="hljs-number">0.8</span>,<br>                    temperature=<span class="hljs-number">1.0</span>,<br>                    max_new_tokens=<span class="hljs-number">100</span>),<br>    max_out_len=<span class="hljs-number">100</span>,<br>    max_seq_len=<span class="hljs-number">1024</span>,<br>    batch_size=<span class="hljs-number">2</span>,<br>    concurrency=<span class="hljs-number">32</span>,<br>    meta_template=internlm_meta_template,<br>    run_cfg=<span class="hljs-built_in">dict</span>(num_gpus=<span class="hljs-number">1</span>, num_procs=<span class="hljs-number">1</span>),<br>)<br><br>models = [internlm2_chat_7b]<br></code></pre></td></tr></table></figure>
<p>进行评测：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">python run.py configs/eval_internlm2_my_deploy.py --debug<br></code></pre></td></tr></table></figure>
<p><img  src="awq-result.png"  ><span class="image-caption">AWQ 量化评测</span></p>
<p>能够发现 AWQ 量化后的模型在 ceval 数据集上的得分比原模型要好。精度不仅没有明显下降，相反在不少任务上还有一定的提升。可能得原因是，量化会导致一定的误差，有时候这种误差可能会减少模型对训练数据的拟合，从而提高泛化性能。量化可以被视为引入轻微噪声的正则化方法。或者，也有可能量化后的模型正好对某些数据集具有更好的性能。</p>
]]></content>
      <categories>
        <category>internlm</category>
      </categories>
  </entry>
  <entry>
    <title>扩散模型在毫米波雷达中的使用综述</title>
    <url>/uncategorized/mmRadar-Diffusion/</url>
    <content><![CDATA[<h1 id="扩散模型在毫米波雷达点云生成中的应用综述"><a href="#扩散模型在毫米波雷达点云生成中的应用综述" class="headerlink" title="扩散模型在毫米波雷达点云生成中的应用综述"></a>扩散模型在毫米波雷达点云生成中的应用综述</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>毫米波雷达（mmWave radar）因其在雨、雾、雪等恶劣天气下的稳定感知能力，近年来在自动驾驶和机器人领域受到高度关注。相较于光学传感器（如摄像头、LiDAR），毫米波雷达具备抗环境干扰的显著优势。然而，毫米波雷达点云数据也存在固有缺陷：一方面，受多路径反射、散射等影响，其回波中常混入大量杂波和虚假点（“鬼点”），导致点云 <strong>杂乱</strong>；另一方面，由于天线孔径和信号处理限制，雷达点云相对于LiDAR <strong>极度稀疏</strong>，缺乏详细的几何信息。上述问题使得毫米波雷达在高精度感知任务中的独立应用受限，往往只能作为辅助传感器。</p>
<p>针对<strong>提高毫米波雷达点云质量</strong>这一挑战，研究者将<strong>扩散模型</strong>（Diffusion Model）引入该领域，期望通过生成式方法实现雷达点云的<strong>超分辨率重建</strong>与<strong>去噪增强</strong>。扩散模型近年在图像生成和超分辨率等任务上屡创佳绩，其逐步<strong>去噪迭代</strong>过程可从噪声中恢复高质量数据。对于噪声多、稀疏性的毫米波雷达点云，这种强大的生成能力被认为非常契合需求。本综述将围绕扩散模型生成毫米波雷达3D点云的最新研究进展展开，包括典型应用场景、技术路线、开源资源以及与LiDAR数据生成的对比分析。</p>
<h2 id="扩散模型生成毫米波雷达点云的研究现状"><a href="#扩散模型生成毫米波雷达点云的研究现状" class="headerlink" title="扩散模型生成毫米波雷达点云的研究现状"></a>扩散模型生成毫米波雷达点云的研究现状</h2><p>近年来，多项研究工作探索了利用扩散模型来<strong>生成或增强毫米波雷达点云</strong>，以提升自动驾驶感知的性能，特别是在目标检测、场景重建以及雨雾等恶劣条件下的鲁棒感知方面。下面归纳几项具有代表性的研究：</p>
<ul>
<li><p><strong>基于Range Image的雷达点云超分辨率（Wu等人，2025）</strong>：Wu等提出将毫米波雷达点云投影为<strong>深度图（Range Image）</strong>表示，并结合预训练的图像扩散模型来增强点云。该方法创新性地利用了与人类视觉一致的Range Image作为中间表征，使毫米波雷达数据形式接近自然图像，从而充分迁移大规模图像扩散模型的先验知识。训练过程中，以高精度LiDAR点云生成的Range Image作为监督，让扩散模型学会从噪声中还原出高质量的雷达Range Image。推理时，模型以毫米波雷达的多通道Range Image为条件，从纯高斯噪声迭代<strong>生成清晰的Range Image</strong>，再反投影回三维得到致密雷达点云。实验证明该方法可生成与LiDAR相近的稠密点云，在ColoRadar等数据集上将毫米波雷达单帧点云的<strong>密度和准确度显著提升</strong>。</p>
</li>
<li><p><strong>跨模态扩散的雷达点云增强（Zhang等人，2024）</strong>：Zhang等将毫米波雷达感知问题视作<strong>图像恢复</strong>任务。他们使用毫米波雷达的<strong>距离-方位二维矩阵(RAH)</strong>作为输入表示，目标输出为对应场景的LiDAR <strong>俯视深度图（BEV Bird’s Eye View）</strong>。模型采用条件扩散架构，将雷达RAH作为条件，引导扩散模型从噪声生成高质量的LiDAR BEV图。训练时通过雷达-激光配对数据进行<strong>跨模态学习</strong>，让模型学会将稀疏噪声的雷达表示映射为稠密精准的激光表示。此外，作者引入了一步生成的<strong>一致性模型</strong>加速采样，实现了<strong>单步生成LiDAR级点云</strong>。该方法在公开数据集上取得了新的精度纪录，可生成接近LiDAR精度的雷达点云。值得一提的是，这一工作特别针对微型无人车（MAV）在视觉受限环境中的导航需求，证明了在<strong>极端光照条件</strong>下，利用扩散增强的雷达点云可获得与LiDAR相当的建图与感知效果。</p>
</li>
<li><p><strong>Radar-Diffusion点云超分辨率（Luan等人，2024）</strong>：Luan等提出“Radar-diffusion”框架，用于毫米波<strong>4D成像雷达</strong>点云的超分辨率增强。他们将原始雷达点和对应LiDAR点云都转换为二维的<strong>俯视栅格图(BEV)</strong>表示，并编码高度信息形成多通道影像。在此基础上，构造了<strong>均值回归随机微分方程（SDE）</strong>形式的前向/逆向扩散过程：前向过程模拟从高质量LiDAR BEV退化到稀疏雷达BEV的噪声添加；逆向过程则由一个基于U-Net的神经网络估计得分函数，逐步去噪还原出高分辨率BEV。特别地，作者设计了关注<strong>有效目标区域</strong>与<strong>空白区域</strong>的双重损失，以平衡训练中真实目标和背景空隙的生成效果。此外，通过将<strong>连续5帧雷达数据对齐融合</strong>作为输入，提高了点云稠密化的可靠性。实验在View-of-Delft (VoD)和RadarHD数据集上进行，Radar-diffusion在Fréchet距离、Chamfer距离等指标上明显优于以往方法。增强后的点云在下游配准、检测等任务中表现出更高的精度和鲁棒性。</p>
</li>
<li><p><strong>其他扩散模型应用</strong>：除了点云重建增强，扩散模型也被用于毫米波雷达感知的其他任务。例如，mmDiff模型将<strong>人体姿态估计</strong>转化为扩散生成问题，利用毫米波雷达点云估计稳定精确的3D人体关键点（该方法将雷达信息作为条件，引导扩散模型生成符合雷达观测的骨架姿态）。又如，Wu等（2024）将扩散模型嵌入<strong>雷达-摄像头3D目标检测</strong>框架中，通过在特征提取阶段对齐雷达点云与图像，并对雷达特征施加<strong>扩散去噪</strong>，有效缓解了雷达数据的稀疏和歧义，提高了小目标和远距离目标的检测性能。值得注意的是，这种方法<strong>不依赖LiDAR监督</strong>，在nuScenes大型数据集上实现了新的检测精度SOTA，体现了扩散模型在雷达异质传感融合中的潜力。</p>
</li>
</ul>
<p>以上研究表明，扩散模型在毫米波雷达点云的<strong>生成式增强</strong>方面展现出优异表现。通过将毫米波雷达数据表示转换为适合扩散模型处理的格式（如Range Image或BEV图）、结合跨模态或多帧信息作为条件，扩散模型能够<strong>去除雷达噪声点、补全缺失结构</strong>，生成接近LiDAR质量的稠密点云。这极大地拓宽了毫米波雷达在自动驾驶感知中的应用前景，使其在恶劣天气下也能提供高精度的环境感知。表1汇总了部分代表性研究及其核心技术方案。</p>
<p><strong>表1：代表性毫米波雷达点云生成扩散模型研究一览</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">项目 / 文献 (年份)</th>
<th style="text-align:left">应用场景与目标</th>
<th style="text-align:left">数据表示与输入条件</th>
<th style="text-align:left">扩散模型架构与技术</th>
<th style="text-align:left">开源资源 / 数据集</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>RangeDiff (Wu等, 2025)</strong></td>
<td style="text-align:left">雷达点云超分辨率增强（雨雾鲁棒感知）</td>
<td style="text-align:left">多通道<strong>Range Image</strong> (雷达)<br>→ 输出高质量Range Image，再投影为点云</td>
<td style="text-align:left">图像扩散模型（预训练UNet）<br>条件输入雷达深度图，多步去噪采样</td>
<td style="text-align:left"><em>ColoRadar</em>等;<br>代码待发布</td>
</tr>
<tr>
<td style="text-align:left"><strong>CrossModal Diffusion (Zhang等, 2024)</strong></td>
<td style="text-align:left">雷达点云增强（MAV导航感知）</td>
<td style="text-align:left"><strong>RAH矩阵</strong> (雷达距离-方位图)<br>→ 输出<strong>BEV深度图</strong> (LiDAR风格)</td>
<td style="text-align:left">条件DDPM + 一致性模型加速<br>UNet骨干，支持<strong>单步采样</strong></td>
<td style="text-align:left"><strong>Radar-Diffusion</strong>开源<br>数据：<em>ColoRadar</em></td>
</tr>
<tr>
<td style="text-align:left"><strong>Radar-Diffusion (Luan等, 2024)</strong></td>
<td style="text-align:left">雷达点云超分辨率（自动驾驶场景）</td>
<td style="text-align:left">多帧配准<strong>BEV栅格图</strong>+高度编码 (雷达)<br>→ 输出稠密BEV栅格图，再转点云</td>
<td style="text-align:left">连续时间扩散SDE模型<br>UNet估计噪声，迭代去噪重建</td>
<td style="text-align:left">计划开源; 数据：<em>VoD</em>、<em>RadarHD</em></td>
</tr>
<tr>
<td style="text-align:left"><strong>mmEMP (Fan等, 2024)</strong></td>
<td style="text-align:left">雷达点云增强（无需LiDAR监督）</td>
<td style="text-align:left"><strong>摄像头+IMU重建3D地图</strong><br>+ 雷达Range-Doppler矩阵</td>
<td style="text-align:left">深度神经网络 + GAN训练<br>利用视觉惯导结果指导雷达点云生成</td>
<td style="text-align:left"><strong>mmEMP</strong>代码公开（待确认）<br>数据众包采集</td>
</tr>
<tr>
<td style="text-align:left"><strong>GAN增强 (Guan等, 2023)</strong></td>
<td style="text-align:left">雷达点云增强（恶劣天气下目标形状恢复）</td>
<td style="text-align:left">低分辨率雷达点云（雨天/雾天）<br>→ 输出物体高频细节点云</td>
<td style="text-align:left">条件GAN（cGAN）框架<br>学习雷达点云到真实形状的映射</td>
<td style="text-align:left">未知（定制实验）; 数据：自建雨雾场景</td>
</tr>
</tbody>
</table>
</div>
<p><em>注：以上列举了不同代表性方法的核心特点和技术指标，其中部分开源项目及数据集可在GitHub或公开论文附录中获取。</em></p>
<h2 id="技术路线与方案综述"><a href="#技术路线与方案综述" class="headerlink" title="技术路线与方案综述"></a>技术路线与方案综述</h2><p>扩散模型用于毫米波雷达点云生成通常遵循以下技术路线：首先，将雷达原始数据转换为<strong>适合扩散模型处理的表示形式</strong>；然后，设计<strong>神经网络架构</strong>实现扩散过程（通常为U-Net骨干，结合时空注意力或Transformer模块）；接着，采用<strong>特定的训练策略</strong>（如条件扩散、连续SDE建模等）进行模型训练；最后，执行必要的<strong>配准与后处理</strong>将生成结果还原为3D点云。下面对这些环节分别加以概述：</p>
<h3 id="数据表示与输入格式"><a href="#数据表示与输入格式" class="headerlink" title="数据表示与输入格式"></a>数据表示与输入格式</h3><p><strong>输入数据格式</strong>直接影响扩散模型的效果。毫米波雷达原始输出可包括目标点列表（含距离、方位、速度等信息）或雷达数据张量（如距离-多普勒频谱）。直接在不规则的点云空间应用扩散较为困难，因此现有工作多将雷达点云<strong>栅格化为二维图像</strong>形式：</p>
<ul>
<li><p><strong>Range-Azimuth Heatmap (RAH)</strong>：将雷达探测单位按照方位角和距离映射到二维网格，像素值表示目标反射强度。RAH保留了雷达原始测角分辨率和强度信息，但由于包含多普勒维度且人眼不直观，直接用于扩散模型时效果有限。</p>
</li>
<li><p><strong>Bird’s Eye View (BEV)投影</strong>：将雷达点在地平面投影形成俯视平面图，每个网格记录是否有目标或目标高度等。BEV图直观表示地面目标分布，常用于检测任务。然而BEV忽略了仰角信息，无法体现高度结构，且对稀疏点云而言很多网格为空，给扩散模型带来挑战。</p>
</li>
<li><p><strong>Range Image（深度图）</strong>：以雷达自身为坐标系，将点云按照水平角度和垂直角度排列成二维图像，像素值为距离。这种表示与LiDAR的扫描深度图类似，每行对应雷达俯仰角，每列对应方位角。Range Image<strong>充分保留了三维几何结构</strong>和稠密的像素网格，是一种对人类和扩散模型都更自然直观的表示。Wu等就采用多通道Range Image作为扩散模型的输入代理。此外，通过将雷达点云按距离分层形成<strong>多通道深度图</strong>，可以一定程度缓解单层深度图的遮挡问题。</p>
</li>
<li><p><strong>多帧融合表示</strong>：为弥补单帧雷达点云的极端稀疏性，一些方法将<strong>时间序列上的多个帧</strong>配准叠加，提高有效点密度。例如Radar-diffusion将前后5帧雷达点经过位姿对齐后融合为输入BEV影像，提供了更丰富的环境上下文，有助于模型辨别真杂波与静态结构。</p>
</li>
</ul>
<p>除了上述常见表示，也有研究融合<strong>雷达其他维度信息</strong>作为输入条件：如雷达的<strong>多普勒速度图</strong>、<strong>反射强度图</strong>等，以丰富网络感知的要素。总体而言，选择合适的数据表示（尤其是充分包含三维结构的图像表示）是扩散模型成功应用于雷达点云生成的关键第一步。</p>
<h3 id="模型结构与扩散生成过程"><a href="#模型结构与扩散生成过程" class="headerlink" title="模型结构与扩散生成过程"></a>模型结构与扩散生成过程</h3><p>在网络架构上，主流方法大多采用<strong>基于U-Net的扩散网络</strong>。U-Net结构通过下采样-上采样路径提取多尺度特征，并可方便地融合条件信息（例如将雷达观测作为条件输入到中间层）。具体而言：</p>
<ul>
<li><p><strong>时域离散扩散模型 (DDPM)</strong>：许多工作沿用DDPM框架，逐步向数据添加噪声并训练模型学习逆过程。网络以U-Net为骨干，将<strong>时间步编码</strong>以及条件信息拼接入特征，预测每步噪声或直接预测洁净数据。在雷达点云应用中，模型通常<strong>以条件形式接入雷达观测</strong>（如RAH、Range Image等），即学习 $p(x_0 | \text{radar})$ 的生成。Zhang等的跨模态扩散和Wu等的Range Image扩散均属于此类，只不过Wu等充分利用了预训练的图像扩散模型作为初始化，提升了生成质量。DDPM的一个局限是逐步采样开销较大，因此Zhang等结合了一致性蒸馏技术，将原需多步的扩散简化为单步生成，大幅加快了推理速度。</p>
</li>
<li><p><strong>连续时间扩散模型 (Score-Based SDE)</strong>：也有工作采用连续扩散的<strong>得分网络</strong>方法。Luan等引入了 Ornstein–Uhlenbeck 类型的<strong>均值回复随机过程</strong>对LiDAR BEV到雷达BEV的退化进行建模。他们训练一个U-Net去近似该连续扩散过程的<strong>得分函数</strong>（即数据梯度），通过数值解SDE的逆方程来采样高质量点云。这种方法等价于DDPM的无限小步长情形，在理论上保证了生成分布的准确性，但实现上需要解决训练稳定性和采样效率问题。Radar-diffusion使用了自适应的SDE解算和特定损失设计，成功将该方法应用于实际数据并获益于其生成质量提升。</p>
</li>
<li><p><strong>条件与控制策略</strong>：无论离散或连续扩散，<strong>条件扩散</strong>是毫米波雷达点云生成的普遍选择，即模型生成过程受控于雷达当前观测。在实现上，条件信息可在网络<strong>编码阶段融合</strong>（如将雷达图像与噪声输入拼接）或在<strong>解码过程中引入</strong>（如通过交叉注意力将条件特征注入U-Net中间层）。例如，Wu等通过多通道雷达Range Image条件，使扩散模型以该条件为“指南”恢复对应场景的Range Image。Zhang等的方法则将雷达RAH与LiDAR BEV成对训练，使网络在条件RAH下学习生成配对的LiDAR BEV。此外，Wu等在扩散网络中<strong>嵌入语义先验</strong>，将来自摄像头的特征用作指导，以提升目标区域的生成可信度。总的来说，<strong>跨模态条件融合</strong>（雷达+摄像头/IMU/LiDAR）和<strong>时序条件融合</strong>（多帧雷达）是提高生成点云质量的有效手段。</p>
</li>
<li><p><strong>网络模块与注意力</strong>：在U-Net骨干中，不少方法加入了<strong>自注意力（Self-Attention）</strong>或Transformer模块来捕捉全局相关性。例如在高分辨率特征层使用自注意力，以便模型在去噪时考虑到不同空间位置点的关联。这对雷达点云这样的稀疏数据尤其重要，可避免生成孤立无关联的点。部分研究还使用了Transformer编码器作为条件分支，将多视角特征提取后送入扩散U-Net。总体来看，扩散模型的网络设计延续了图像扩散领域的成熟架构，并针对点云任务进行适当调整（如多输入分支、高维注意力等）。</p>
</li>
</ul>
<h3 id="配准与后处理"><a href="#配准与后处理" class="headerlink" title="配准与后处理"></a>配准与后处理</h3><p>由于毫米波雷达往往与其他传感器（LiDAR、相机）配合使用，<strong>数据配准与对齐</strong>是训练此类扩散模型的前提。典型做法是在数据集中提供<strong>严格时间同步和空间标定</strong>的雷达与LiDAR数据。研究者通常采用KITTI等格式将不同传感器点云转换到同一坐标系下，以获得逐帧对应的雷达表示和LiDAR真值。例如，Zhang等使用ColoRadar数据集时，将毫米波雷达的RAH与同时刻LiDAR的BEV通过已知外参进行投影对齐，以确保网络输入的雷达图像与监督的LiDAR图像在空间上一一对应。Wu等的方法也强调了<strong>雷达与LiDAR Range Image在时空上的严格对齐</strong>，否则模型难以学习二者的映射关系。</p>
<p>在<strong>推理阶段</strong>，扩散模型生成的中间表示（如Range Image或BEV图）需要转换回三维点云。这通常通过<strong>反投影</strong>实现：对于Range Image，直接根据像素的距离和对应角度算出3D坐标；对于BEV高程图，可将每个栅格的高度信息转化为地面坐标系下的点。同时时需要<strong>过滤无效点和残余噪点</strong>。扩散模型尽管学会了去噪，但仍可能生成少量不合理点。例如，Wu等在将增强Range Image反投影后，会结合原始雷达数据的遮挡关系剔除明显越墙的“透视”点，以避免生成伪影。Luan等的方法则在生成过程中已经通过专门的损失抑制了空白区域的噪声点。若有必要，下游还可对生成点云执行<strong>聚类滤波</strong>（例如DBSCAN去除孤立点）来进一步清理。</p>
<p>此外，在多帧融合情境下，需考虑<strong>运动补偿</strong>问题：当输入包含来自连续多帧的点云时，必须使用雷达或车辆的位姿信息先将点云变换到同一参考帧下。这通常借助里程计/IMU的数据完成。如果对动态物体进行增强，还需要更复杂的<strong>运动配准或光流</strong>算法来对齐运动目标，否则多帧融合会产生重影。</p>
<p>综上，精确的雷达-LiDAR数据配准、适当的结果滤波与坐标变换，是保证扩散模型生成结果在实际3D场景中可用的必要步骤。许多研究在论文附录中提供了数据预处理和后处理的细节及代码，方便复现他们的配准流程。</p>
<h2 id="开源项目、代码和数据资源"><a href="#开源项目、代码和数据资源" class="headerlink" title="开源项目、代码和数据资源"></a>开源项目、代码和数据资源</h2><p>扩散模型在毫米波雷达点云上的研究热度上升，也催生了相关<strong>开源代码库和数据集</strong>的发布：</p>
<ul>
<li><p><strong>开源代码项目</strong>：ZJU FAST实验室发布了<strong>Radar-Diffusion</strong>开源库（对应Zhang等RA-L 2024论文），包含预训练模型、一键推理脚本等，可实现毫米波雷达点云一步生成LiDAR点云的功能。同样地，Ruixu Geng等人为他们提出的DREAM-PCD方法提供了官方实现（GitHub: <code>ruixv/DREAM-PCD</code>），包括数据集RadarEyes的工具和增强算法代码。另有Akarsh Prabhakara等的<strong>RadarHD项目</strong>代码公开在GitHub上，实现了基于U-Net的毫米波雷达高分辨点云生成算法，是Radar-Diffusion等工作的早期参考基线。</p>
</li>
<li><p><strong>公开数据集</strong>：高质量的数据集对于训练和评估扩散模型至关重要。以下是几个常用或新近推出的毫米波雷达相关数据集：</p>
<ul>
<li><strong>ColoRadar</strong>：科罗拉多大学发布的毫米波雷达数据集，包含52段序列，涵盖矿井、室内走廊和户外道路等场景，总计145分钟的同步<strong>3D FMCW雷达+3D激光+IMU</strong>数据。ColoRadar提供了标定和评估工具，被Radar-Diffusion等工作用来作为雷达-LiDAR配对训练数据源。</li>
<li><strong>View-of-Delft (VoD)</strong>：由荷兰代尔夫特理工提供的自动驾驶多传感器数据集，包括8600余帧同步的<strong>Velodyne 64线LiDAR、立体相机</strong>以及<strong>ZF 3+1D成像雷达</strong>数据。VoD中特有的新型成像雷达提供了更密集的点云（带速度信息），Luan等在其工作中使用该数据集验证了算法对不同雷达硬件的通用性。</li>
<li><strong>RadarHD Dataset</strong>：卡内基梅隆大学等发布，与RadarHD方法配套，采集了<strong>低成本单芯片雷达</strong>在室内外的点云数据，用于验证雷达生成点云在<strong>看穿遮挡</strong>场景下的应用。该数据集注重雷达点云与真实环境的配准，为扩散模型评估提供了多样场景。</li>
<li><strong>RadarEyes</strong>：清华大学团队构建的大规模<strong>室内毫米波雷达数据集</strong>，包含超过100万帧数据。RadarEyes使用两台正交放置的单芯片雷达并辅以LiDAR和相机，提供了丰富的角度覆盖和传感器交叉参考，用于DREAM-PCD等方法的训练。其多雷达配置对扩散模型来说也是潜在的更高难度实验平台（需要融合多雷达的信息）。</li>
<li>其他数据资源：自动驾驶领域已有的一些数据集也包含毫米波雷达信息，例如<strong>nuScenes</strong>数据集提供了每辆车5个雷达的点云（每帧约数十个点），主要用于目标检测评测；<strong>Oxford Radar RobotCar</strong>数据集使用了Navtech成像雷达记录城市道路，但其雷达是2D平面扫描类型，数据格式与上述FMCW点云有所差异。还有<strong>Astyx</strong>高分辨雷达数据集、丰田提供的<strong>RadarScenes</strong>等，涵盖不同环境下雷达点云及目标标注。这些数据集为研究提供了多样的数据来源，不过并非都附带对应LiDAR用于监督训练，需要视具体任务选择。</li>
</ul>
</li>
<li><p><strong>模拟与仿真工具</strong>：在现实数据之外，一些开源仿真框架可用于<strong>生成虚拟雷达点云</strong>以扩充训练数据或测试算法鲁棒性。例如，CARLA模拟器自带基础的雷达传感器模型，可以输出模拟的雷达检测结果（包含距离、方位和速度）供研究人员转换为点云使用。此外，UCSD等提出了<strong>Shenron / C-Shenron</strong>框架，将高保真雷达传感模型集成进CARLA中。该框架利用场景中的高精度LiDAR点云和相机图像来生成逼真的毫米波雷达多视角回波，从而得到接近真实的点云模拟数据。仿真工具允许控制天气、交通等参数，在极端场景下大量生成带标注的雷达点云数据，对于训练扩散模型提升雨雾等条件下的泛化能力很有价值。不过需要注意模拟与真实之间的差异，通常扩散模型训练仍以真实数据为主，仿真数据作为辅助。</p>
</li>
</ul>
<p>综上，当前社区已经积累了一批可供利用的代码和数据资源，使研究者能够更便捷地复现并改进毫米波雷达点云的扩散生成方法。在GitHub上也出现了一些汇总资源的项目（例如<strong>awesome-radar-perception</strong>和<strong>awesome-diffusion-models</strong>列表），方便查找相关论文、代码和数据。</p>
<h2 id="与LiDAR点云生成的对比研究"><a href="#与LiDAR点云生成的对比研究" class="headerlink" title="与LiDAR点云生成的对比研究"></a>与LiDAR点云生成的对比研究</h2><p>毫米波雷达与激光雷达都是产生点云的主动传感器，但在数据特性和生成任务上存在显著差异。这也导致了基于扩散模型的生成方法在两者上的技术侧重不同：</p>
<ul>
<li><p><strong>数据密度与细节</strong>：激光雷达点云密集且具有明确的物体轮廓，而毫米波雷达点云稀疏且充满噪声。扩散模型在LiDAR点云生成中常用于<strong>真实场景合成</strong>，即在已有大量真实LiDAR数据基础上，无监督地学习其分布并生成新样本。例如，有研究提出<strong>LiDAR扩散模型 (LiDM)</strong>，将64线激光雷达扫描转换为<strong>Range Image或体素</strong>表示，再通过<strong>潜空间扩散</strong>生成逼真的新场景点云。这些模型关注的是<strong>生成样本的多样性和保真度</strong>，需要确保生成点云在几何结构上合理，如建筑物、车辆的形状完整。这方面扩散模型的优势在于稳定训练和逐步细化，使生成的LiDAR场景在统计上与真实数据分布接近。</p>
</li>
<li><p><strong>任务定位差异</strong>：毫米波雷达点云生成更多是<strong>一个有监督的增强/重建任务</strong>，即利用高质量传感器（LiDAR、相机等）作为教师，提升雷达点云质量。因此雷达扩散模型更像是执行<strong>点云超分辨率或去噪</strong>，评价指标侧重于与真值的接近程度（如Chamfer距离、Hausdorff距离等)。而LiDAR点云生成通常是<strong>无监督的生成建模</strong>，用于数据扩充或仿真，评价时除了统计指标（FID分数等），有时还会检查下游任务效果，如检测器在合成数据上的表现。两者虽然都可以使用扩散模型，但训练范式截然不同：一个是<strong>条件扩散（有条件约束）</strong>，一个是<strong>无条件或弱条件扩散</strong>。</p>
</li>
<li><p><strong>模型架构与表示</strong>：由于LiDAR点云本身足够稠密，不少LiDAR生成方法直接对<strong>Range Image</strong>或分块的深度图应用扩散。例如<strong>RangeLDM</strong>通过VAE将LiDAR深度图压缩到潜编码，再用扩散模型在潜空间生成，从而快速采样出新点云。同时，为保持LiDAR三维结构，一些工作会引入<strong>判别器或对象级约束</strong>确保生成点云中物体的形状正确。相比之下，毫米波雷达点云扩散几乎都需要依赖<strong>外部输入</strong>（雷达当前帧观测）才能生成有意义的结果——单独依靠模型“想象”一个毫米波雷达场景是很困难的，因为信息太少且歧义大。因此，雷达扩散模型更强调<strong>多源数据融合</strong>（跨模态、跨时间），而LiDAR扩散更强调<strong>高维数据的高效表示和采样</strong>（如利用潜变量加速生成）。</p>
</li>
<li><p><strong>评价指标</strong>：LiDAR点云生成的评价近年来发展出一些<strong>感知层面的指标</strong>。比如Chen等提出了Fréchet Point Cloud Distance的变体，使用预训练的分割网络提取特征来计算生成点云与真实点云的距离。毫米波雷达点云增强则更多采用几何指标和下游性能，如Chamfer距离降低了多少，检测AP提高了多少等。此外，对于雷达点云中特有的<strong>鬼点去除</strong>和<strong>真实新点生成</strong>，目前缺乏专门定义的指标，通常通过可视化和任务效果来侧面评估。</p>
</li>
</ul>
<p>值得一提的是，一些研究开始<strong>同时生成雷达与LiDAR点云</strong>或者比较两者的生成结果。例如RF-Genesis工作探索了利用<strong>多模态扩散模型</strong>零样本生成视觉场景和对应毫米波雷达数据，以评估跨模态泛化能力。虽然该方向尚在起步，但随着扩散模型的灵活性提高，将来有可能出现统一的生成框架，同时适用于LiDAR和雷达，通过共享表示和差异化细节生成来<strong>提升多传感器模拟的逼真度</strong>。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>综上所述，扩散模型为毫米波雷达点云的数据增强与生成提供了有力工具。通过精巧的输入表示选择和跨模态条件融合，扩散模型克服了雷达点云稀疏杂乱的固有难题，在自动驾驶感知任务中实现了前所未有的点云质量提升。当前已有多种架构和方案证明了扩散模型在雷达点云超分辨率、去噪以及辅助目标检测等方面的价值。伴随更多开源数据和代码的出现，这一领域有望迅速发展。未来研究方向包括：利用时间序列信息进一步增强<strong>动态场景一致性</strong>、探索更高效的实时生成以适应车载计算限制、以及发展统一模型生成多模态传感器数据。借助扩散模型的强大生成能力，毫米波雷达在自动驾驶中的角色有望从辅助提升为可靠的主力感知，在各种环境下保障车辆对周围世界的“看见”与“看清”。</p>
<p><strong>参考文献：</strong></p>
<ol>
<li><p>【1】Ruixin Wu et al. <em>“Diffusion-Based mmWave Radar Point Cloud Enhancement Driven by Range Images”</em>, arXiv preprint arXiv:2503.02300, 2025</p>
</li>
<li><p>【2】Ruibin Zhang et al. <em>“Towards Dense and Accurate Radar Perception Via Efficient Cross-Modal Diffusion Model”</em>, IEEE RA-L 2024</p>
</li>
<li><p>【3】Kexin Luan et al. <em>“Diffusion-Based Point Cloud Super-Resolution for mmWave Radar Data”</em>, IEEE ICRA 2024</p>
</li>
<li><p>【4】Cong Fan et al. <em>“Enhancing mmWave Radar Point Cloud via Visual-inertial Supervision (mmEMP)”</em>, arXiv:2404.17229, 2024</p>
</li>
<li><p>【5】R. Guan et al. <em>“Through Fog High-Resolution Imaging Using Millimeter Wave Radar”</em> (利用条件GAN恢复雷达点云细节, 2023)</p>
</li>
<li><p>【6】Akarsh Prabhakara et al. <em>“High Resolution Point Clouds from mmWave Radar (RadarHD)”</em>, IEEE ICRA 2023</p>
</li>
<li><p>【7】ZJU-FAST Lab, <strong>Radar-Diffusion 开源项目</strong> – <em>Code for Cross-Modal Radar-LiDAR Diffusion Model</em>, GitHub, 2024</p>
</li>
<li><p>【8】Autonomous Robotics &amp; Perception Group, <strong>ColoRadar Dataset</strong>, Univ. of Colorado, 2021</p>
</li>
<li><p>【9】Intelligent Vehicles Group, <strong>View-of-Delft (VoD) Dataset</strong>, TU Delft, 2022</p>
</li>
<li><p>【10】Ruixu Geng et al. <em>“DREAM-PCD: Deep Reconstruction and Enhancement of mmWave Radar Pointcloud”</em>, IEEE TIP 2024</p>
</li>
<li><p>【11】Yizhi Wu et al. <em>“A Robust Diffusion Modeling Framework for Radar-Camera 3D Object Detection”</em>, WACV 2024</p>
</li>
<li><p>【12】Qianjiang Hu et al. <em>“RangeLDM: Fast Realistic LiDAR Point Cloud Generation”</em>, arXiv:2403.10094, 2024</p>
</li>
<li><p>【13】Jiangshan Lu et al. <em>“Towards Realistic Scene Generation with LiDAR Diffusion Models”</em>, arXiv:2404.00815, 2024</p>
</li>
<li><p>【14】PapersWithCode, <strong>Point Cloud Generation Task</strong>, <em>Latest SOTA methods overview</em>, 2024</p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>扩散模型在跨域生成中的研究综述</title>
    <url>/uncategorized/Generalization-Generation/</url>
    <content><![CDATA[<h1 id="扩散模型用于跨域数据生成的研究进展"><a href="#扩散模型用于跨域数据生成的研究进展" class="headerlink" title="扩散模型用于跨域数据生成的研究进展"></a>扩散模型用于跨域数据生成的研究进展</h1><h2 id="扩散模型跨域泛化能力的探索"><a href="#扩散模型跨域泛化能力的探索" class="headerlink" title="扩散模型跨域泛化能力的探索"></a>扩散模型跨域泛化能力的探索</h2><p>扩散模型（Diffusion Models）近年来在图像、音频等生成任务中取得了显著成功，并展现出跨域泛化的潜力。例如，大规模预训练的潜在扩散模型（Latent Diffusion Models，如Stable Diffusion）在广泛的图文数据上训练后，能够生成多种风格和领域的图像。研究者开始探索这些模型在未见过的新域上的生成能力，包括无监督跨域生成、领域自适应扩散、条件扩散生成以及风格迁移和模态迁移等方向。</p>
<p>一种探索是<strong>无监督跨域生成</strong>，即在没有成对训练数据的情况下，将一个域的数据转换到另一个域。例如，有工作将扩散过程用于图像到图像的风格迁移，利用噪声迭代引导实现不同域之间的转换，而无需像GAN那样成对训练。DiffusionCLIP等方法通过预训练文本图像模型（如CLIP）指导扩散模型，将输入图像编辑到目标风格。相比判别模型的引导，利用生成式扩散模型的引导可提供更丰富的跨域迁移信息。此外，训练大模型涵盖多种域本身也是提高泛化性的途径，比如Stable Diffusion已学习了多种风格概念，因而对未明确出现过的风格也有一定生成能力。</p>
<p>在<strong>领域适应扩散模型</strong>方面，研究者尝试将预训练的扩散模型调整到新领域。例如，NeurIPS 2024提出了<strong>Terra</strong>，通过引入时间可变的低秩适配器，实现扩散模型在“领域流（domain flow）”上的连续变化。Terra将源域图像逐步变换到目标域，并生成中间插值域以缩小域间差距，从而提升模型的跨域泛化能力。这不仅用于图像风格迁移，也作为一种生成式方法来解决无监督领域自适应和领域泛化问题。另外，一些方法（如StyleGAN-NADA及其改进）利用文本提示将生成器从一个域微调到另一个域；最新的StyleGAN-Fusion工作则使用扩散模型的梯度引导来替代CLIP引导，取得更好效果。</p>
<p><strong>条件扩散模型（Conditional Diffusion）</strong>提供了在生成时引入条件信息（如标签、文本或图像提示）的机制，可用于跨域生成。例如，通过在扩散模型中添加域标签或风格标签，可以实现根据所需域来引导图像生成。复合标签引导扩散就是一例：研究者将类别标签、伪标签和域标签融合作为条件，对扩散模型进行引导，以提升目标域样本的生成质量。又如<strong>ODGEN</strong>方法通过边界框和文本描述作为条件，控制扩散模型生成包含多物体的复杂场景，实现特定领域的数据增强。此外，文本条件的扩散模型天然属于跨模态：从文本描述生成图像即是从语言域到视觉域的迁移。类似地，也有工作探索将音频特征或其他模态作为条件输入扩散模型，实现跨模态的生成和转换。</p>
<p><strong>风格迁移与模态迁移</strong>也是扩散模型跨域应用的重要方向。风格迁移方面，扩散模型可用来将内容与不同风格解耦再组合：例如采用扩散模型先对图像进行去噪生成，再在中间过程引入目标风格的信息，从而得到内容相同但风格不同的图像。相较于传统风格迁移方法，扩散模型提供了一种逐步细化图像的途径，可以更好地保持内容结构同时逼近目标域分布。在模态迁移方面，扩散模型已被用于语音到语音、文本到音频、音频到视觉等任务。例如，AudioLDM利用潜在扩散模型实现了文本到音频的生成，还支持音频风格的零样本迁移。总的来说，现有扩散模型在跨域泛化上展现出巨大潜力，许多研究正致力于进一步挖掘其在未见新域上的生成能力。</p>
<h2 id="处理新域数据的技术路线"><a href="#处理新域数据的技术路线" class="headerlink" title="处理新域数据的技术路线"></a>处理新域数据的技术路线</h2><p>针对生成“训练数据未出现过的新域”样本的挑战，研究者提出了多种技术路线，包括元学习、零样本/少样本泛化、潜在空间建模以及领域引导的生成等。</p>
<ul>
<li><p><strong>元学习（Meta-learning）</strong>：元学习旨在让模型学会快速适应新任务新域的能力。在扩散模型领域，这可能体现为训练一个基模型，使其在接收到少量新域数据或新条件时，能通过极少的梯度更新或甚至无需更新就产生合理的结果。一些工作借鉴元学习范式训练扩散模型的条件模块，使模型对新域的条件分布具有更强的适应性。不过，目前明确以元学习用于扩散跨域生成的研究相对较少，该方向仍有待深入探索。</p>
</li>
<li><p><strong>零样本与少样本生成</strong>：零样本指无需任何新域样本就能生成，新域信息通常通过语言描述或已学到的泛化能力获得；少样本则利用极少量的新域样本进行调适。一个代表性成果是<strong>“无微调的few-shot生成”</strong>方法。该方法假设我们有一个预训练扩散模型，以及目标新域的极少量图像。研究发现，预训练的DDPM扩散模型实际上拥有重构任意图像的表示能力：通过扩散过程的逆向推理，可以将任意OOD（域外）图像映射到模型的潜在编码。这些OOD图像在模型潜在空间中近似呈现出新的高斯分布，并与原训练域分离。基于这一发现，提出了<strong>“无需调参的潜在生成”</strong>范式：不改动模型参数，而是通过在扩散过程的噪声潜空间中<strong>寻找合适的隐编码</strong>来合成新域图像。这种方法等于扩展了预训练模型的潜在空间，使其覆盖新域，而无需像以往方法那样微调模型参数。实践证明，冻结的DDPM模型可以通过该策略生成未见域的样本，而且不损害原本域的生成质量。这一思路展示了利用少量样本和模型内部表示即可拓展新域生成的可能。</p>
</li>
<li><p><strong>潜在空间建模</strong>：上面提到的方法实质上是一种潜在空间建模策略。除此之外，还有其他工作在模型的潜在空间上做文章。例如，一些方法尝试在扩散模型的潜空间中进行插值、噪声扰动或添加正则，以引导模型产生不同于训练集分布的样本。还有研究引入<strong>一致性正则</strong>或<strong>潜在空间约束</strong>，使得扩散模型在生成时朝向目标域的潜在分布。总体而言，潜在空间的方法通过分析和操作扩散模型的隐变量，提供了一条不依赖大量新域数据的生成途径。</p>
</li>
<li><p><strong>领域引导的生成</strong>：这类方法利用来自源域和目标域的信息来指导生成过程。前述<strong>CCDFG（Composite-Label guided Cross-Domain Data Fusion Generation）</strong>就是典型例子。它将源域和目标域的图像、类别标签、伪标签以及域标签一起整合训练扩散模型，并重新设计了无分类器引导（classifier-free guidance）的条件策略，从源域“借用”信息提高目标域数据的生成质量。通过这种复合条件引导，模型在目标域极度数据匮乏的情况下，仍能生成逼真的目标域样本用于提升下游任务性能。另一种领域引导方式是利用预训练模型中包含的知识：比如通过语言提示描述目标域特征，引导扩散模型往该方向生成（相当于通过文字将新域知识注入模型）。实践中，用户经常使用Stable Diffusion这类模型配合特定文本prompt来得到某种新风格的图像，这也是利用模型已有知识进行零样本领域引导的体现。此外，ControlNet等扩散模型扩展通过引入特定模态的条件（如草图、深度图），可在保持预训练模型权重不变的情况下，实现跨域的<strong>结构引导</strong>生成（例如将草图转为照片等）。这些领域或模态条件的引入，使得扩散模型在跨域生成时可以得到更精细的控制。</p>
</li>
<li><p><strong>少样本微调</strong>：尽管不属于新颖方法，但少样本微调（如DreamBooth等）依然是处理新域的常用手段。DreamBooth通过对Stable Diffusion进行少量（3-5张）目标概念图像的微调，使模型学习一个新的概念或风格，并能将其与原有模型的其它概念组合生成。这种方法适用于将特定对象或风格注入模型，被视为将预训练扩散模型<strong>专用化</strong>到新域的一种方式。然而微调往往存在过拟合或遗忘原有能力的风险，因此诸如上文提到的低秩适配（LoRA）、模型融合等技术被提出以在小样本调适时保留住模型原有的泛化性。</p>
</li>
</ul>
<p>综上，针对新域的扩散生成，当前的技术路线大体在于：<strong>不依赖额外训练的潜在空间探索</strong>，以及<strong>轻量高效的模型适配</strong>。前者追求充分利用预训练模型自身的表示能力来涵盖新域；后者则通过优化方式的改进（如低秩适配、Few-shot微调、一致性蒸馏等）快速将模型迁移到新域。这些方法为扩散模型生成前所未见的领域数据提供了多样化的解法。</p>
<h2 id="图像、音频与多模态跨域生成实例"><a href="#图像、音频与多模态跨域生成实例" class="headerlink" title="图像、音频与多模态跨域生成实例"></a>图像、音频与多模态跨域生成实例</h2><p>针对不同类型数据的跨域生成，下面列举具体案例、模型和相关研究成果。</p>
<h3 id="图像跨域生成"><a href="#图像跨域生成" class="headerlink" title="图像跨域生成"></a>图像跨域生成</h3><p>图像领域的跨域生成主要包括跨风格图像生成、跨领域图像翻译，以及利用扩散模型进行数据增强等。很多工作致力于让模型在训练集未覆盖的图像风格或视觉域上生成高保真、高多样性的图像。</p>
<p>一个典型任务是<strong>跨风格图像生成</strong>。例如，将真实照片转换为艺术画风格，或将卡通图像转换为写实风格。传统的无监督图像翻译方法如CycleGAN曾用于这类任务，而扩散模型提供了新思路。有研究将扩散模型视作去噪自动编码器，通过修改扩散过程中的条件或添加引导，实现<strong>不成对数据</strong>的图像域转换。相比GAN方法，扩散模型逐步应用噪声和去噪，有助于保留图像结构细节并逐步迁移风格。例如，<strong>StyleGAN-Fusion</strong>利用Stable Diffusion的得分蒸馏采样（Score Distillation Sampling, SDS）来引导StyleGAN生成器适应新域，仅通过一个文本描述（如“3D动漫风格的人脸”）就成功将人脸生成器转移到目标风格。与之前纯文本引导的方法相比，扩散模型引导能更好捕捉目标域的细粒度特征，如关键外观细节等。</p>
<p>此外，<strong>领域特定的数据生成</strong>正在成为提高计算机视觉任务性能的有效手段。 <em>如图所示，ODGEN 可根据输入的边界框（带类别标签）布局（左）生成对应场景的合成图像（右）。该方法能够处理复杂场景（包含多类别、物体密集和遮挡），例如交通路口、医学MRI、游戏画面、水下环境等不同领域。ODGEN 生成的高质量图像可用于扩充目标检测模型的训练集，在多个特定领域的检测基准上带来显著性能提升（mAP 提高最多达25.3%）。</em> ODGEN展现了扩散模型在<strong>受控场景生成</strong>中的威力：通过在目标域上微调扩散模型并引入空间和语义约束，它可以生成原始模型无法直接产生的新域复杂图像。</p>
<p>除了图像到图像的迁移，扩散模型还可以<strong>组合来自不同域的图像内容</strong>。ICCV 2023的<strong>TF-ICON</strong>提出了一种无需训练的跨域图像合成框架。它利用预训练的文本到图像扩散模型，将<strong>指导图像</strong>的内容融合到<strong>基底图像</strong>中，而不损坏模型原有的多样化先验。具体而言，TF-ICON通过巧妙设计的“例外提示（exceptional prompt）”实现对真实图像的准确潜编码反演，然后在扩散采样初期逐步注入组合后的自注意力图，引导模型将参考图像的目标对象融入背景图像。这一过程无需对扩散模型额外训练或微调，却能生成<strong>跨域的和谐合成</strong>结果，例如将一个真人照片中的人物无缝融合到一幅动漫场景中。TF-ICON展示了预训练扩散模型在跨域编辑上的潜力——通过潜空间操作和注意力融合，实现不同域视觉内容的整合。</p>
<p>在<strong>小样本新域图像生成</strong>方面，前文提到的冻结DDPM潜在扩展方法已在跨域图像上验证。例如，研究者使用只有几张样本的新域（如天文望远镜成像）来引导预训练模型，成功合成了该新域的逼真图像，同时原模型在常规图像上的生成质量不受影响。这表明扩散模型具有<strong>发现和扩展新域</strong>的能力，即便新域在训练时未出现。类似地，DreamBooth等方法微调模型后，也能在新风格域生成高质量图像，但往往需要权衡训练步骤以避免过度遗忘原域。</p>
<p>总体而言，图像跨域生成的研究进展表明：<strong>（1）扩散模型结合条件引导或额外正则，可以实现无监督的域迁移和风格转换；（2）通过少量新域数据的利用或潜空间操控，预训练模型可以被“挖掘”出生成新域样本的能力；（3）这些跨域生成方法还被用于提升下游任务，例如通过生成合成数据提高模型对新域的识别性能</strong>。</p>
<p>下面的表格汇总了部分代表性的图像跨域生成方法：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法 / 文献 (年份)</th>
<th>任务类型</th>
<th>技术路线</th>
<th>特色与效果</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Terra</strong> (NeurIPS 2024)</td>
<td>图像领域流适应 / 插值</td>
<td>时间连续低秩适配器，微调扩散模型</td>
<td>连续表征域迁移，实现源到目标域映射并生成中间域；提升无监督域适应与泛化性能</td>
</tr>
<tr>
<td><strong>ODGEN</strong> (NeurIPS 2024)</td>
<td>特定域复杂场景数据合成 (检测)</td>
<td>预训练模型微调 + 边界框/文本条件控制</td>
<td>生成多物体场景用于检测数据增强；7个领域mAP提升最高25.3%</td>
</tr>
<tr>
<td><strong>TF-ICON</strong> (ICCV 2023)</td>
<td>跨域图像合成/编辑</td>
<td>无需训练，扩散潜空间反演 + 注意力融合</td>
<td>不损害原模型先验下，将对象融合进新背景；适用于多种域组合</td>
</tr>
<tr>
<td><strong>Latent OOD扩展</strong> (Zhu 等 2024)</td>
<td>少样本新域图像生成</td>
<td>冻结DDPM模型，探索噪声隐编码</td>
<td>利用少量OOD样本触发潜在高斯模态；无须调参即可生成新域，质量不减</td>
</tr>
<tr>
<td><strong>StyleGAN-Fusion</strong> (WACV 2024)</td>
<td>文本引导的域迁移 (生成器微调)</td>
<td>扩散模型SDS指导GAN优化</td>
<td>仅用文本描述目标域，实现生成器跨域；FID显著优于CLIP引导方法，细节更丰富</td>
</tr>
</tbody>
</table>
</div>
<h3 id="音频跨域生成"><a href="#音频跨域生成" class="headerlink" title="音频跨域生成"></a>音频跨域生成</h3><p>音频领域的跨域生成包含语音、音乐、环境音效等不同模态和风格的转换，典型任务有跨语言语音合成、说话人转换、音频风格迁移等。扩散模型凭借其对连续信号逐步逼近的生成特性，在音频质量和多样性上表现出色，逐渐应用到这些任务中。</p>
<p><strong>跨语言语音生成</strong>是指利用一个语言的语音数据来生成另一种语言的语音。例如跨语言的文本到语音合成（TTS）或语音到语音翻译（S2ST）。2023年提出的<strong>DiCLET-TTS</strong>方法，将扩散模型用于跨语言带情感迁移的TTS。它针对仅有单语语料的情感语音合成问题，引入了一个语言无关但情感相关的隐语义先验：通过先验文本编码器结合情感嵌入，对扩散模型正向过程的末端分布进行参数化，从而减少外语口音并提高情感表达。同时，DiCLET-TTS设计了正交投影的情感解耦模块，获得说话人无关但情感判别性强的情感嵌入，并在扩散模型的逆过程引入条件增强的解码器，以加强情感和说话人在合成语音中的表现力。实验表明，该方法在英语-汉语跨语言情感合成中相比现有模型有明显优势，能够有效消除外语口音并更准确地迁移情感。</p>
<p><strong>语音到语音的跨域生成</strong>方面，<strong>直接语音翻译</strong>(Speech-to-Speech Translation, S2ST)是一个具有挑战的跨模态跨语言任务。最新的工作<strong>DiffuseST</strong>将扩散模型应用于端到端的语音翻译系统中，作为语音合成器来替代传统的神经声码器。DiffuseST能够在不使用文本中间表示的情况下，将多种源语言直接翻译为英文语音，并<strong>零样本</strong>保留说话人声纹。与基于Tacotron的合成器相比，引入扩散模型后，语音质量评价MOS和PESQ各提升了23%，说话人相似度提升5%，且保持了可比的BLEU翻译准确度。有趣的是，尽管扩散模型参数量更大，但通过架构优化，该系统实现了低延迟（整体推理速度超过实时5倍）。这说明扩散生成在提升跨语言语音质量的同时，并未牺牲效率。</p>
<p><strong>音色/说话人转换</strong>（Voice Conversion）任务也从扩散模型中获益良多。任何到任何的说话人转换需要模型在没有并行数据的情况下，将一段语音转换为目标说话人的声音。扩散模型强大的建模能力使其生成的语音质量和保真度很高，但传统扩散推理速度慢。为此，2024年的<strong>LCM-SVC</strong>工作引入<strong>潜在一致性蒸馏</strong>，将预训练的扩散语音转换模型压缩为一致性模型，从而实现了一步或少步的快速推理。LCM-SVC首先训练一个潜在扩散模型用于歌声音色转换（SVC），在获得高质量转换的基础上，进一步通过一致性蒸馏训练一个学生模型，使其在单步内近似扩散过程的效果。实验结果显示，该方法<strong>大幅降低</strong>了推理时间，同时在音质和音色相似度上与扩散模型基本持平，明显优于其他SOTA转换模型。这表明扩散模型在跨域语音转换中性能优越，并可通过后处理加速以实用化。</p>
<p><strong>多语言多说话人合成</strong>也是跨域音频生成的一个方向。一些开源项目如Facebook的<strong>Voicebox</strong>（非扩散模型）实现了任意语言任意说话人的续说；相应地，基于扩散的模型也可以借助大量多语言数据进行训练，从而做到零样本的跨说话人、跨语言语音生成。尽管这方面具体研究尚不多见，但理念上与多语言文本-图像类似：大规模训练使模型学到跨语言的语音表示，再通过提示或少量适配在特定新语言上说话。</p>
<p><strong>音频风格迁移</strong>方面，扩散模型同样崭露头角。AudioLDM模型利用潜在扩散架构，不仅可以根据文本描述合成音频，还实现了任意音频之间的<strong>风格转换</strong>。例如，将一段钢琴曲风格迁移为小提琴演奏，或将语音的情感状态改变，AudioLDM都可以在无需显式训练这种对应关系的情况下实现。这得益于其学到的联合语言-音频潜在空间表示，使不同来源的音频内容能够通过扩散过程找到对应的表征并重新生成。此外，在音乐生成领域，一些研究将图像扩散模型应用到梅尔谱等表示上（如Riffusion），达到了根据文本关键词生成短音乐片段的效果，这其实也是一种跨模态（文本到音乐）生成的形式。</p>
<p>总的来说，音频跨域生成的研究侧重于<strong>保持内容信息的同时改变音频域属性</strong>（语言、说话人、情感、乐器等）。扩散模型通过逐步生成确保了合成音频的高保真度，而结合条件控制或先验约束的方法保证了内容的一致性。例如在说话人转换中保证语义不变，在翻译中保持原说话人声音，在情感迁移中保持词内容正确等。这类模型的评估通常依赖主观和客观结合：主观上通过人类评价MOS分数来衡量自然度和相似度，客观上利用如PESQ、STOI、ASR识别错误率等指标。下表汇总了若干扩散模型在音频跨域生成上的代表工作：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法 / 文献 (年份)</th>
<th>任务场景</th>
<th>核心思路</th>
<th>成果与优势</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>DiCLET-TTS</strong> (TASLP 2023)</td>
<td>跨语言文本到语音合成（情感迁移）</td>
<td>语言无关情感先验 + 正交情感解耦</td>
<td>缓解外语口音，情感表达提升；中英跨语言情感合成效果优于现有方法</td>
</tr>
<tr>
<td><strong>DiffuseST</strong> (Interspeech 2024)</td>
<td>端到端语音到语音翻译（保留声纹）</td>
<td>扩散合成器替换TTS模块</td>
<td>实现零样本说话人克隆，MOS/PESQ提高23%；整体系统快于实时5倍</td>
</tr>
<tr>
<td><strong>LCM-SVC</strong> (ArXiv 2024)</td>
<td>任意说话人歌声转换</td>
<td>潜在扩散模型 + 一致性蒸馏</td>
<td>单步生成高质量转换语音；推理提速百倍，音质和音色接近扩散基准</td>
</tr>
<tr>
<td><strong>AudioLDM</strong> (ICLR 2023)</td>
<td>文本到音频 &amp; 音频风格迁移</td>
<td>CLAP先验编码 + 潜在扩散</td>
<td>通用文本生成音频系统，涵盖语音、音乐、音效；支持任意音频的零样本风格转换</td>
</tr>
</tbody>
</table>
</div>
<h3 id="多模态跨域生成"><a href="#多模态跨域生成" class="headerlink" title="多模态跨域生成"></a>多模态跨域生成</h3><p>多模态跨域生成指的是涉及不同数据模态之间的生成转换，如文本-图像、音频-图像等。这类任务兼具跨域和跨模态的特性，扩散模型同样在其中发挥了作用。</p>
<p><strong>文本→图像</strong>生成是最广为人知的跨模态生成，由于发展成熟，我们常常忽略它其实也是一种“跨域”泛化：模型学习到了语言和视觉之间的对应关系，从而能将文本描述（语言域）转换为相应图像（视觉域）。以Stable Diffusion为代表的潜在扩散模型正是通过大规模的图文配对训练，成功捕获了跨语言-视觉域的丰富映射。一段描述从未见过的新奇情景的文字，Stable Diffusion也常能给出逼真的图像，这证明了扩散模型在跨域理解和生成上的强大能力。当然，这依赖于训练数据涵盖足够广泛的概念域。OpenAI的DALL·E 2、Google的Imagen等扩散模型也都展示了类似的跨模态生成能力——将抽象的语言输入转化为具体的视觉输出。</p>
<p>除了文本到图像，<strong>图像→文本</strong>（如图像描述生成）通常由编码器-解码器模型完成，扩散模型较少直接用于生成文本，因为语言是离散符号序列，不适合扩散模型处理连续空间的特点。不过，有研究尝试将图像嵌入扩散模型的潜在空间，然后逐步“扩散”生成描述词向量，再用解码器转成文本，但这不是主流方向，在此不作深入讨论。</p>
<p>另一个有趣的方向是<strong>语音→视频（说话人面部生成）</strong>，涉及音频和视觉的跨模态。传统方法利用3D人脸模型参数驱动动画，或直接学端到端的说话人视频合成。最新的<strong>DisentTalk</strong>工作结合了<strong>3DMM参数空间</strong>与<strong>扩散模型</strong>：它将3D人脸表情参数按照语义区域解耦，形成可精细控制的子空间，然后在此参数空间上训练分层扩散模型来合成视频帧。扩散模型引入了Stable Diffusion擅长的空间细节生成能力，同时3DMM保证了时间连贯性。通过区域感知的注意力机制，DisentTalk实现了唇动精确对齐语音、面部表情自然丰富且帧间平滑的说话人视频生成。特别地，由于中文高质量对嘴数据缺乏，作者构建了一个高清中语说话人视频数据集CHDTF用于训练，显著提升了模型在中文音频驱动下的写实度。这种将物理先验（3D人脸）与扩散生成相结合的方式，为跨语言的说话人合成奠定了基础，解决了纯扩散模型在视频一致性上的不足。随着该方向的发展，我们有望看到更多音频驱动的表情动画、手势生成等多模态融合应用，其中扩散模型提供高品质帧合成，另一些模块保证时序和结构约束。</p>
<p>此外，多模态扩散模型还可以用于<strong>视觉→音频</strong>的任务，例如根据一张图生成对应的环境声音效果，这属于较新的研究领域。一些初步尝试可能会利用预训练的音频扩散模型，将图像内容映射到音频潜在空间，再通过扩散过程得到声音。例如，看着一段无声视频片段，用扩散模型生成逼真的音效配音（下雨场景生成雨声、海边生成海浪声等）。虽然目前专门的工作不多，但这类应用潜力巨大，扩散模型能保证生成音频的连续性和多样性，而跨模态对齐需要结合对视觉场景的理解模型（如CLIP）。</p>
<p>总的来说，多模态跨域生成是一个融合领域，多模态模型（如CLIP、统一Transformer等）可与扩散模型结合，承担理解和生成不同模态的不同部分。在这一领域，<strong>扩散模型主要负责难度最大的高质量内容生成</strong>（如高清图像帧或清晰音频），而跨域对齐由其它模块或预训练模型提供先验。如文本-&gt;图像由文本编码提供条件，音频-&gt;视频由音频提取表情参数提供条件等。随着多模态大模型的发展，我们可能会看到扩散模型作为通用生成模块，嵌入到更大的多模态系统中，去处理各类跨域生成任务。</p>
<h2 id="模型评估方式与常用基准"><a href="#模型评估方式与常用基准" class="headerlink" title="模型评估方式与常用基准"></a>模型评估方式与常用基准</h2><p>评估扩散模型的跨域生成能力，需要从<strong>感知质量</strong>和<strong>跨域有效性</strong>两个方面进行。常用的评估指标和基准包括：</p>
<ul>
<li><p><strong>图像质量与多样性指标</strong>：包括Fréchet Inception Distance (FID)、Inception Score (IS)、精确度/覆盖率等，用于衡量生成图像与目标域真实数据分布的接近程度和多样性。例如，在图像跨域转换任务中，评价生成结果是否逼真且风格符合目标域，常以FID与真实目标域图片集进行比较，FID越低表示生成分布越接近真实分布。有时也使用CLIP Score评估图像与文本描述的匹配程度，以验证跨域（如跨模态）的一致性。对于特定风格迁移任务，还可能训练一个风格分类器来计算生成图像被判别为目标风格的比例。</p>
</li>
<li><p><strong>语音质量与相似度指标</strong>：在音频跨域生成中，主观的MOS（Mean Opinion Score）是衡量音质和自然度的重要指标，由听众打分获得。此外客观指标如PESQ（语音信号保真度）、STOI（可懂度）用于评估音频质量。说话人转换和语音克隆任务则关注说话人相似度，可通过embedding相似度或ABX偏好测试度量。跨语言语音合成还会用ASR识别错误率或BLEU来评价内容传达的准确性。DiffuseST的实验中就同时报告了音质提升（MOS/PESQ）和翻译内容准确度不下降。因此一套综合指标才能全面反映音频跨域生成的效果。</p>
</li>
<li><p><strong>多模态匹配指标</strong>：对于跨模态生成，如文本生成图像，会用文本图像匹配的指标（CLIP得分、Referee metric等）来测量生成图片是否符合输入描述。在音频驱动视频这类任务中，则需评估视听同步（如嘴型与语音对齐度）以及生成视频的清晰度、连贯性等，可以通过计算嘴唇同步分数，表情变化曲线相似度等专门指标来量化。例如DisentTalk通过测量唇同步误差、表情质量得分和视频稳定性指标，证明其方法在这些方面优于现有方案。</p>
</li>
<li><p><strong>下游任务性能</strong>：若跨域生成用于数据增广或辅助训练，还可以通过下游任务的效果来评估其价值。如前述ODGEN方法通过将合成图像加入训练，检测模型mAP提升了5%~25%不等。类似地，生成的跨域数据用于分类、分割等任务时，可观察这些任务在未见域上的性能提升幅度，以判断生成数据的实用性。</p>
</li>
</ul>
<p><strong>常用benchmark数据集</strong>方面，不同任务各有标准：</p>
<ul>
<li><p><strong>图像领域</strong>：DomainBed基准集合包含PACS、Office-Home、VLCS、DomainNet等数据集用于评测跨域分类和生成算法的泛化性能。这些数据集中每个包含多个风格各异的子域，用于验证模型对未见域的表现。对于图像翻译，有夏普转卡通、现实转画作等基准数据，如CelebA-HQ (人脸照片)对Anime Faces (动漫脸)等。有些研究自建小型基准，比如将FFHQ人脸照片→3D卡通等，以定量评估迁移效果（通过FID或人脸识别保持率等）。另外COCO常用于文本到图像模型评测，如Stable Diffusion在COCO上的零样本FID、CLIP Score是比较模型的指标之一。</p>
</li>
<li><p><strong>音频领域</strong>：语音合成常用的有LJSpeech（单说话人英文朗读）、VCTK（多说话人英文）、AISHELL-3（中文多人）、Emotional Speech Dataset等作为训练或评测数据。跨语言TTS会组合多语种数据，如英文LibriTTS+中文标贝数据集。语音转换评测使用Voice Conversion Challenge (VCC)提供的标准数据对，比方说VCC2020包含若干源和目标说话人语音，用于评测转换系统在保持音色和内容上的表现。S2ST可能使用LibriTrans、CVSS等语音翻译语料。音乐和音效生成则缺乏统一基准，通常各论文构建案例进行主观评测。</p>
</li>
<li><p><strong>多模态领域</strong>：文本图像常用MS-COCO、Flickr30k等含标注描述的图像集用于测试生成模型的图文对齐和图像质量。说话人视频合成使用LRS3（大量英文字幕对嘴视频）或自己录制的数据集。DisentTalk中引入的CHDTF是高清中语说话人视频数据集，用来弥补中文部分评估的不足。其他如AVHubHub、GRID等数据集也被用于评估视听合成模型的对齐和质量。</p>
</li>
</ul>
<p>无论哪种任务，人类评估依然非常重要。研究通常结合用户调研或专家打分来评估生成结果在感知上的好坏，特别是判断跨域生成是否合乎期望（如翻译语气是否自然，图像风格是否确实转换）。因此，客观指标和主观评测相辅相成，共同衡量模型性能。</p>
<h2 id="最新论文、开源项目与趋势"><a href="#最新论文、开源项目与趋势" class="headerlink" title="最新论文、开源项目与趋势"></a>最新论文、开源项目与趋势</h2><p>近年来（2023-2025）在顶会和期刊上涌现出大量关于扩散模型跨域生成的研究，也有不少开源项目推动了这一领域的发展。下面列举若干具有代表性的最新成果：</p>
<ul>
<li><p><strong>CVPR/ICCV 等视觉会议</strong>：跨域扩散图像生成是热点主题。ICCV 2023的TF-ICON提出无训练的跨域图像合成方法；WACV 2024的StyleGAN-Fusion通过扩散指导GAN完成文本驱动的域迁移；WACV 2024还出现了DiffusionCLIP改进方法，用于更好地实现图像风格转换。CVPR 2024 预计也有相关工作，如扩散模型用于未见域的图像着色、去噪增强等。</p>
</li>
<li><p><strong>NeurIPS/ICLR 等机器学习会议</strong>：扩散模型的领域适应和生成被广泛关注。NeurIPS 2024的Terra方法针对领域泛化提出了新型低秩适配技术；同届的ODGEN将扩散模型用于目标检测数据生成。OpenReview上还出现了DomainFusion框架，用扩散模型帮助分类器进行 domain generalization。ICLR 2024的一些投稿探讨了扩散预训练在下游任务中的迁移、扩散模型与对抗训练结合提升跨域鲁棒性等。这些新思想丰富了扩散模型在跨域领域的应用场景。</p>
</li>
<li><p><strong>音频与语音领域会议</strong>：在ICASSP、Interspeech等会议上，扩散模型逐渐成为高质量语音合成的基础。2023年Interspeech有工作将扩散模型用于语音转换、语音增强；2024年Interspeech的DiffuseST展示了语音翻译的最新进展。IEEE TASLP等期刊也发表了若干扩散语音合成相关论文，例如DiCLET-TTS。音乐方面，ISMIR等会议开始出现文本到音乐的扩散模型探索。可以预见，随着音频生成模型需求增长，扩散模型相关研究在音频顶会上会越来越多。</p>
</li>
<li><p><strong>多模态与其他方向</strong>：多模态生成在ACL、EMNLP等自然语言会议和ICME多媒体会议中也有涉及。上文提到的DisentTalk已被ICME 2025接收。此外，3D生成（如NeRF融合扩散）、医学影像跨模态合成等也是新趋势。例如有论文研究了零样本医学图像模态转换，用扩散模型将MRI合成CT。这些方向的研究大多发布在arXiv，逐渐会走向相关领域会议。</p>
</li>
<li><p><strong>开源项目</strong>：在社区驱动下，许多开源工具加速了扩散跨域应用的落地。Hugging Face的🤗 Diffusers库集成了Stable Diffusion及其各种派生模型，支持模型微调和控制示例，降低了研究和应用门槛。ControlNet的开源让开发者能方便地利用边缘图、分割等条件进行跨域生成。DreamBooth的代码和模型广泛流传，使定制化模型进入大众创作。音频方面，AudioLDM提供了开源实现，可以生成多种类别的声音。还有一些GitHub项目将扩散模型应用到特定领域，如「diffusion for speech enhancement」、「latent diffusion for IR simulation」等。这些开源成果丰富了工具链，也推动着跨域生成从学术走向工业实践。</p>
</li>
</ul>
<p><strong>未来趋势</strong>：综合来看，扩散模型在跨域数据生成的研究仍在快速发展。模型正朝着<strong>更高保真度</strong>和<strong>更强泛化性</strong>演进：更好的生成质量、更少的依赖新域数据。同时，效率也是关注点，出现了通过模型压缩和快速采样技术使扩散生成接近实时的工作。随着AIGC（生成式AI）热潮，跨域和多模态的大模型将继续涌现，扩散模型可能与其他架构（如Transformer、Flow等）结合，取长补短，用于构建能够跨越多个领域和模态的通用生成人工智能。可以预见，在不远的将来，我们将看到更加<strong>通用</strong>且<strong>智能</strong>的扩散模型应用于图像、语音、文本、视频等各种数据的跨域生成，为内容创作和数据增强带来新的革命。</p>
]]></content>
  </entry>
  <entry>
    <title>Internlm-05-LMDeploy 的量化和部署</title>
    <url>/internlm/internlm-05/</url>
    <content><![CDATA[<h1 id="LMDeploy-的量化和部署"><a href="#LMDeploy-的量化和部署" class="headerlink" title="LMDeploy 的量化和部署"></a>LMDeploy 的量化和部署</h1><h2 id="1-环境配置"><a href="#1-环境配置" class="headerlink" title="1 环境配置"></a>1 环境配置</h2><p>这里 <code>/share/conda_envs</code> 目录下的环境是官方未大家准备好的基础环境，因为该目录是共享只读的，而我们后面需要在此基础上安装新的软件包，所以需要复制到我们自己的 conda 环境（该环境下我们是可写的）。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">conda create -n lmdeploy --<span class="hljs-built_in">clone</span> /share/conda_envs/internlm-base<br></code></pre></td></tr></table></figure>
<ul>
<li>如果clone操作过慢，可采用如下操作:</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">/root/share/install_conda_env_internlm_base.sh lmdeploy<br></code></pre></td></tr></table></figure>
<p>我们取 <code>CONDA_ENV_NAME</code> 为 <code>lmdeploy</code>，复制完成后，可以在本地查看环境。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">conda <span class="hljs-built_in">env</span> list<br></code></pre></td></tr></table></figure>
<p>结果如下所示。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># conda environments:</span><br><span class="hljs-comment">#</span><br>base                  *  /root/.conda<br>lmdeploy                 /root/.conda/envs/lmdeploy<br></code></pre></td></tr></table></figure>
<p>然后激活环境。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">conda activate lmdeploy<br></code></pre></td></tr></table></figure>
<p>如果是在 InternStudio 开发环境，需要先运行下面的命令，否则会报错。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 解决 ModuleNotFoundError: No module named &#x27;packaging&#x27; 问题</span><br>pip install packaging<br><span class="hljs-comment"># 使用 flash_attn 的预编译包解决安装过慢问题</span><br>pip install /root/share/wheels/flash_attn-2.4.2+cu118torch2.0cxx11abiTRUE-cp310-cp310-linux_x86_64.whl<br></code></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">pip install <span class="hljs-string">&#x27;lmdeploy[all]==v0.1.0&#x27;</span><br></code></pre></td></tr></table></figure>
<p>由于默认安装的是 runtime 依赖包，但是我们这里还需要部署和量化，所以，这里选择 <code>[all]</code>。然后可以再检查一下 lmdeploy 包，如下图所示。</p>
<p><img  src="env.png"  ><span class="image-caption">安装 lmdeploy 成功</span></p>
<p>基础环境到这里就配置好了。</p>
<h2 id="2-服务部署"><a href="#2-服务部署" class="headerlink" title="2 服务部署"></a>2 服务部署</h2><p>这一部分主要涉及本地推理和部署。我们先看一张图。</p>
<p><img  src="lmdeploy.drawio.png"  ><span class="image-caption">服务架构图</span></p>
<p>lmdeploy 从架构上把整个服务流程分成下面几个模块。</p>
<ul>
<li>模型推理/服务。主要提供模型本身的推理，一般来说可以和具体业务解耦，专注模型推理本身性能的优化。可以以模块、API等多种方式提供。</li>
<li>Client。可以理解为前端，与用户交互的地方。</li>
<li>API Server。一般作为前端的后端，提供与产品和服务相关的数据和功能支持。</li>
</ul>
<p>值得说明的是，以上的划分是一个相对完整的模型，但在实际中这并不是绝对的。比如可以把“模型推理”和“API Server”合并，有的甚至是三个流程打包在一起提供服务。</p>
<p>接下来，我们看一下 lmdeploy 提供的部署功能。</p>
<h3 id="2-1-模型转换"><a href="#2-1-模型转换" class="headerlink" title="2.1 模型转换"></a>2.1 模型转换</h3><p>使用 TurboMind 推理模型需要先将模型转化为 TurboMind 的格式，目前支持在线转换和离线转换两种形式。在线转换可以直接加载 Huggingface 模型，离线转换需需要先保存模型再加载。</p>
<p>TurboMind 是一款关于 LLM 推理的高效推理引擎，基于英伟达的 <a href="https://github.com/NVIDIA/FasterTransformer">FasterTransformer</a> 研发而成。它的主要功能包括：LLaMa 结构模型的支持，persistent batch 推理模式和可扩展的 KV 缓存管理器。</p>
<h4 id="2-1-1-在线转换"><a href="#2-1-1-在线转换" class="headerlink" title="2.1.1 在线转换"></a>2.1.1 在线转换</h4><p>lmdeploy 支持直接读取 Huggingface 模型权重，目前共支持三种类型：</p>
<ul>
<li>在 huggingface.co 上面通过 lmdeploy 量化的模型，如 <a href="https://huggingface.co/lmdeploy/llama2-chat-70b-4bit">llama2-70b-4bit</a>, <a href="https://huggingface.co/internlm/internlm-chat-20b-4bit">internlm-chat-20b-4bit</a></li>
<li>huggingface.co 上面其他 LM 模型，如 Qwen/Qwen-7B-Chat</li>
</ul>
<p>示例如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 需要能访问 Huggingface 的网络环境</span><br>lmdeploy chat turbomind internlm/internlm-chat-20b-4bit --model-name internlm-chat-20b<br>lmdeploy chat turbomind Qwen/Qwen-7B-Chat --model-name qwen-7b<br></code></pre></td></tr></table></figure>
<p>上面两行命令分别展示了如何直接加载 Huggingface 的模型，第一条命令是加载使用 lmdeploy 量化的版本，第二条命令是加载其他 LLM 模型。</p>
<p>我们也可以直接启动本地的 Huggingface 模型，如下所示。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">lmdeploy chat turbomind /share/temp/model_repos/internlm-chat-7b/  --model-name internlm-chat-7b<br></code></pre></td></tr></table></figure>
<p>以上命令都会启动一个本地对话界面，通过 Bash 可以与 LLM 进行对话。</p>
<h4 id="2-1-2-离线转换"><a href="#2-1-2-离线转换" class="headerlink" title="2.1.2 离线转换"></a>2.1.2 离线转换</h4><p>离线转换需要在启动服务之前，将模型转为 lmdeploy TurboMind  的格式，如下所示。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 转换模型（FastTransformer格式） TurboMind</span><br>lmdeploy convert internlm-chat-7b /path/to/internlm-chat-7b<br></code></pre></td></tr></table></figure>
<p>这里我们使用官方提供的模型文件，就在用户根目录执行，如下所示。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">lmdeploy convert internlm-chat-7b  /root/share/temp/model_repos/internlm-chat-7b/<br></code></pre></td></tr></table></figure>
<p><img  src="convert.png"  ><span class="image-caption">转换模型</span></p>
<p>执行完成后将会在当前目录生成一个 <code>workspace</code> 的文件夹。这里面包含的就是 TurboMind 和 Triton “模型推理”需要到的文件。</p>
<p>目录如下图所示。</p>
<p><img  src="tree1.png"  ><span class="image-caption">转换后的模型</span></p>
<p><code>weights</code> 和 <code>tokenizer</code> 目录分别放的是拆分后的参数和 Tokenizer。如果我们进一步查看 <code>weights</code> 的目录，就会发现参数是按层和模块拆开的，如下图所示。</p>
<p><img  src="tree2.png"  ><span class="image-caption">转换后的权重</span></p>
<p>每一份参数第一个 0 表示“层”的索引，后面的那个0表示 Tensor 并行的索引，因为我们只有一张卡，所以被拆分成 1 份。如果有两张卡可以用来推理，则会生成0和1两份，也就是说，会把同一个参数拆成两份。比如 <code>layers.0.attention.w_qkv.0.weight</code> 会变成 <code>layers.0.attention.w_qkv.0.weight</code> 和 <code>layers.0.attention.w_qkv.1.weight</code>。执行 <code>lmdeploy convert</code> 命令时，可以通过 <code>--tp</code> 指定（tp 表示 tensor parallel），该参数默认值为1（也就是一张卡）。</p>
<p><strong>关于Tensor并行</strong></p>
<p>Tensor并行一般分为行并行或列并行，原理如下图所示。</p>
<p><img  src="col.png"  ><span class="image-caption">列并行</span></p>
<p><img  src="row.png"  ><span class="image-caption">行并行</span></p>
<p>简单来说，就是把一个大的张量（参数）分到多张卡上，分别计算各部分的结果，然后再同步汇总。</p>
<h3 id="2-2-TurboMind-推理-命令行本地对话"><a href="#2-2-TurboMind-推理-命令行本地对话" class="headerlink" title="2.2  TurboMind 推理+命令行本地对话"></a>2.2  TurboMind 推理+命令行本地对话</h3><p>模型转换完成后，我们就具备了使用模型推理的条件，接下来就可以进行真正的模型推理环节。</p>
<p>我们先尝试本地对话（<code>Bash Local Chat</code>），下面用（Local Chat 表示）在这里其实是跳过 API Server 直接调用 TurboMind。简单来说，就是命令行代码直接执行 TurboMind。所以说，实际和前面的架构图是有区别的。</p>
<p>这里支持多种方式运行，比如Turbomind、PyTorch、DeepSpeed。但 PyTorch 和 DeepSpeed 调用的其实都是 Huggingface 的 Transformers 包，PyTorch表示原生的 Transformer 包，DeepSpeed 表示使用了 DeepSpeed 作为推理框架。Pytorch/DeepSpeed 目前功能都比较弱，不具备生产能力，不推荐使用。</p>
<p>执行命令如下。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Turbomind + Bash Local Chat</span><br>lmdeploy chat turbomind ./workspace<br></code></pre></td></tr></table></figure>
<p>启动后就可以和它进行对话了，如下图所示。</p>
<p><img  src="chat.png"  ><span class="image-caption">与本地部署的模型进行对话</span></p>
<p>输入后两次回车，退出时输入<code>exit</code> 回车两次即可。此时，Server 就是本地跑起来的模型（TurboMind），命令行可以看作是前端。</p>
<h3 id="2-3-TurboMind推理-API服务"><a href="#2-3-TurboMind推理-API服务" class="headerlink" title="2.3 TurboMind推理+API服务"></a>2.3 TurboMind推理+API服务</h3><p>在上面的部分我们尝试了直接用命令行启动 Client，接下来我们尝试如何运用 lmdepoy 进行服务化。</p>
<p>”模型推理/服务“目前提供了 Turbomind 和 TritonServer 两种服务化方式。此时，Server 是 TurboMind 或 TritonServer，API Server 可以提供对外的 API 服务。我们推荐使用 TurboMind，TritonServer 使用方式详见《附录1》。</p>
<p>首先，通过下面命令启动服务。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># ApiServer+Turbomind   api_server =&gt; AsyncEngine =&gt; TurboMind</span><br>lmdeploy serve api_server ./workspace \<br>	--server_name 0.0.0.0 \<br>	--server_port 23333 \<br>	--instance_num 64 \<br>	--tp 1<br></code></pre></td></tr></table></figure>
<p>上面的参数中 <code>server_name</code> 和 <code>server_port</code> 分别表示服务地址和端口，<code>tp</code> 参数我们之前已经提到过了，表示 Tensor 并行。还剩下一个 <code>instance_num</code> 参数，表示实例数，可以理解成 Batch 的大小。执行后如下图所示。</p>
<p><img  src="api-deploy.png"  ><span class="image-caption">部署 api server</span></p>
<p>然后，我们可以新开一个窗口，执行下面的 Client 命令。如果使用官方机器，可以打开 vscode 的 Terminal，执行下面的命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># ChatApiClient+ApiServer（注意是http协议，需要加http）</span><br>lmdeploy serve api_client http://localhost:23333<br></code></pre></td></tr></table></figure>
<p>如下图所示。</p>
<p><img  src="test-apiserver.png"  ><span class="image-caption">测试 api server</span></p>
<p>当然，刚刚我们启动的是 API Server，自然也有相应的接口。可以直接打开 <code>http://&#123;host&#125;:23333</code> 查看，如下图所示。</p>
<p><img  src="fastapi.png"  ><span class="image-caption">fastapi 演示</span></p>
<p>这里一共提供了 4 个 HTTP 的接口，任何语言都可以对其进行调用，我们以 <code>v1/chat/completions</code> 接口为例，简单试一下。</p>
<p>接口请求参数如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;model&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;internlm-chat-7b&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;messages&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;写一首冬天的诗&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;temperature&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0.7</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;top_p&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;n&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;max_tokens&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">512</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;stop&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;stream&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;presence_penalty&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;frequency_penalty&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;user&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;string&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;repetition_penalty&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;renew_session&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;ignore_eos&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>
<p>请求结果如下。</p>
<p><img  src="test-fastapi.png"  ><span class="image-caption">测试 api</span></p>
<h3 id="2-4-网页-Demo-演示"><a href="#2-4-网页-Demo-演示" class="headerlink" title="2.4 网页 Demo 演示"></a>2.4 网页 Demo 演示</h3><p>这一部分主要是将 Gradio 作为前端 Demo 演示。在上一节的基础上，我们不执行后面的 <code>api_client</code> 或 <code>triton_client</code>，而是执行 <code>gradio</code>。</p>
<h4 id="2-4-1-TurboMind-服务作为后端"><a href="#2-4-1-TurboMind-服务作为后端" class="headerlink" title="2.4.1 TurboMind 服务作为后端"></a>2.4.1 TurboMind 服务作为后端</h4><p>API Server 的启动和上一节一样，这里直接启动作为前端的 Gradio。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Gradio+ApiServer。必须先开启 Server，此时 Gradio 为 Client</span><br>lmdeploy serve gradio http://0.0.0.0:23333 \<br>	--server_name 0.0.0.0 \<br>	--server_port 6006 \<br>	--restful_api True<br></code></pre></td></tr></table></figure>
<h4 id="2-4-2-TurboMind-推理作为后端"><a href="#2-4-2-TurboMind-推理作为后端" class="headerlink" title="2.4.2 TurboMind 推理作为后端"></a>2.4.2 TurboMind 推理作为后端</h4><p>当然，Gradio 也可以直接和 TurboMind 连接，如下所示。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Gradio+Turbomind(local)</span><br>lmdeploy serve gradio ./workspace<br></code></pre></td></tr></table></figure>
<p>可以直接启动 Gradio，此时没有 API Server，TurboMind 直接与 Gradio 通信。</p>
<h3 id="2-5-TurboMind-推理-Python-代码集成"><a href="#2-5-TurboMind-推理-Python-代码集成" class="headerlink" title="2.5 TurboMind 推理 + Python 代码集成"></a>2.5 TurboMind 推理 + Python 代码集成</h3><p>前面介绍的都是通过 API 或某种前端与”模型推理/服务“进行交互，lmdeploy 还支持 Python 直接与 TurboMind 进行交互，如下所示。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> lmdeploy <span class="hljs-keyword">import</span> turbomind <span class="hljs-keyword">as</span> tm<br><br><span class="hljs-comment"># load model</span><br>model_path = <span class="hljs-string">&quot;/root/share/temp/model_repos/internlm-chat-7b/&quot;</span><br>tm_model = tm.TurboMind.from_pretrained(model_path, model_name=<span class="hljs-string">&#x27;internlm-chat-20b&#x27;</span>)<br>generator = tm_model.create_instance()<br><br><span class="hljs-comment"># process query</span><br>query = <span class="hljs-string">&quot;你好啊兄嘚&quot;</span><br>prompt = tm_model.model.get_prompt(query)<br>input_ids = tm_model.tokenizer.encode(prompt)<br><br><span class="hljs-comment"># inference</span><br><span class="hljs-keyword">for</span> outputs <span class="hljs-keyword">in</span> generator.stream_infer(<br>        session_id=<span class="hljs-number">0</span>,<br>        input_ids=[input_ids]):<br>    res, tokens = outputs[<span class="hljs-number">0</span>]<br><br>response = tm_model.tokenizer.decode(res.tolist())<br><span class="hljs-built_in">print</span>(response)<br></code></pre></td></tr></table></figure>
<p>在上面的代码中，我们首先加载模型，然后构造输入，最后执行推理。</p>
<p>加载模型可以显式指定模型路径，也可以直接指定 Huggingface 的 repo_id，还可以使用上面生成过的 <code>workspace</code>。这里的 <code>tm.TurboMind</code> 其实是对 C++ TurboMind 的封装。</p>
<p>构造输入这里主要是把用户的 query 构造成 InternLLM 支持的输入格式，比如上面的例子中， <code>query</code> 是“你好啊兄嘚”，构造好的 Prompt 如下所示。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">&lt;|System|&gt;:You are an AI assistant whose name is InternLM (书生·浦语).</span><br><span class="hljs-string">- InternLM (书生·浦语) is a conversational language model that is developed by Shanghai AI Laboratory (上海人工智能实验室). It is designed to be helpful, honest, and harmless.</span><br><span class="hljs-string">- InternLM (书生·浦语) can understand and communicate fluently in the language chosen by the user such as English and 中文.</span><br><span class="hljs-string"></span><br><span class="hljs-string">&lt;|User|&gt;:你好啊兄嘚</span><br><span class="hljs-string">&lt;|Bot|&gt;:</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure>
<p>Prompt 其实就是增加了 <code>&lt;|System|&gt;</code> 消息和 <code>&lt;|User|&gt;</code> 消息（即用户的 <code>query</code>），以及一个 <code>&lt;|Bot|&gt;</code> 的标记，表示接下来该模型输出响应了。最终输出的响应内容如下所示。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;你好啊，有什么我可以帮助你的吗？&quot;</span><br></code></pre></td></tr></table></figure>
<h3 id="2-6-最佳实践"><a href="#2-6-最佳实践" class="headerlink" title="2.6 最佳实践"></a>2.6 最佳实践</h3><h4 id="2-6-1-方案实践"><a href="#2-6-1-方案实践" class="headerlink" title="2.6.1 方案实践"></a>2.6.1 方案实践</h4><p>首先说 “模型推理/服务”，推荐使用 TurboMind，使用简单，性能良好，相关的 Benchmark 对比如下。</p>
<p><img  src="benchmark.png"  ><span class="image-caption">Benchmark 效果</span></p>
<p>上面的性能对比包括两个场景：</p>
<ul>
<li>场景一（前4张图）：固定的输入、输出 token 数（分别1和2048），测试Token输出吞吐量（output token throughput）。</li>
<li>场景二（第5张图）：使用真实数据，测试吞吐量（request throughput）。</li>
</ul>
<p>场景一中，BatchSize=64时，TurboMind 的吞吐量超过 2000 token/s，整体比 DeepSpeed 提升约 5% - 15%；BatchSize=32时，比 Huggingface 的Transformers 提升约 3 倍；其他BatchSize时 TurboMind 也表现出优异的性能。</p>
<p>场景二中，对比了 TurboMind 和 vLLM 在真实数据上的吞吐量（request throughput）指标，TurboMind 的效率比 vLLM 高 30%。</p>
<p>大家不妨亲自使用本地对话（Local Chat）感受一下性能差别（2.2 节），也可以执行我们提供的 <code>infer_compare.py</code> 脚本，示例如下。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 执行 Huggingface 的 Transformer</span><br>python infer_compare.py hf<br><span class="hljs-comment"># 执行LMDeploy</span><br>python infer_compare.py lmdeploy<br></code></pre></td></tr></table></figure>
<p>LMDeploy应该是Transformers的3-5倍左右。</p>
<p>后面的 API 服务和 Client 就得分场景了。</p>
<ul>
<li>我想对外提供类似 OpenAI 那样的 HTTP 接口服务。推荐使用 TurboMind推理 + API 服务（2.3）。</li>
<li>我想做一个演示 Demo，Gradio 无疑是比 Local Chat 更友好的。推荐使用 TurboMind 推理作为后端的Gradio进行演示（2.4.2）。</li>
<li>我想直接在自己的 Python 项目中使用大模型功能。推荐使用 TurboMind推理 + Python（2.5）。</li>
<li>我想在自己的其他非 Python 项目中使用大模型功能。推荐直接通过 HTTP 接口调用服务。也就是用本列表第一条先启动一个 HTTP API 服务，然后在项目中直接调用接口。</li>
</ul>
<h4 id="2-6-2-模型配置实践"><a href="#2-6-2-模型配置实践" class="headerlink" title="2.6.2 模型配置实践"></a>2.6.2 模型配置实践</h4><p>不知道大家还有没有印象，在离线转换（2.1.2）一节，我们查看了 <code>weights</code> 的目录，里面存放的是模型按层、按并行卡拆分的参数，不过还有一个文件 <code>config.ini</code> 并不是模型参数，它里面存的主要是模型相关的配置信息。下面是一个示例。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[llama]</span><br><span class="hljs-attr">model_name</span> = internlm-chat-<span class="hljs-number">7</span>b<br><span class="hljs-attr">tensor_para_size</span> = <span class="hljs-number">1</span><br><span class="hljs-attr">head_num</span> = <span class="hljs-number">32</span><br><span class="hljs-attr">kv_head_num</span> = <span class="hljs-number">32</span><br><span class="hljs-attr">vocab_size</span> = <span class="hljs-number">103168</span><br><span class="hljs-attr">num_layer</span> = <span class="hljs-number">32</span><br><span class="hljs-attr">inter_size</span> = <span class="hljs-number">11008</span><br><span class="hljs-attr">norm_eps</span> = <span class="hljs-number">1</span>e-<span class="hljs-number">06</span><br><span class="hljs-attr">attn_bias</span> = <span class="hljs-number">0</span><br><span class="hljs-attr">start_id</span> = <span class="hljs-number">1</span><br><span class="hljs-attr">end_id</span> = <span class="hljs-number">2</span><br><span class="hljs-attr">session_len</span> = <span class="hljs-number">2056</span><br><span class="hljs-attr">weight_type</span> = fp16<br><span class="hljs-attr">rotary_embedding</span> = <span class="hljs-number">128</span><br><span class="hljs-attr">rope_theta</span> = <span class="hljs-number">10000.0</span><br><span class="hljs-attr">size_per_head</span> = <span class="hljs-number">128</span><br><span class="hljs-attr">group_size</span> = <span class="hljs-number">0</span><br><span class="hljs-attr">max_batch_size</span> = <span class="hljs-number">64</span><br><span class="hljs-attr">max_context_token_num</span> = <span class="hljs-number">1</span><br><span class="hljs-attr">step_length</span> = <span class="hljs-number">1</span><br><span class="hljs-attr">cache_max_entry_count</span> = <span class="hljs-number">0.5</span><br><span class="hljs-attr">cache_block_seq_len</span> = <span class="hljs-number">128</span><br><span class="hljs-attr">cache_chunk_size</span> = <span class="hljs-number">1</span><br><span class="hljs-attr">use_context_fmha</span> = <span class="hljs-number">1</span><br><span class="hljs-attr">quant_policy</span> = <span class="hljs-number">0</span><br><span class="hljs-attr">max_position_embeddings</span> = <span class="hljs-number">2048</span><br><span class="hljs-attr">rope_scaling_factor</span> = <span class="hljs-number">0.0</span><br><span class="hljs-attr">use_logn_attn</span> = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
<p>其中，模型属性相关的参数不可更改，主要包括下面这些。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">model_name</span> = llama2<br><span class="hljs-attr">head_num</span> = <span class="hljs-number">32</span><br><span class="hljs-attr">kv_head_num</span> = <span class="hljs-number">32</span><br><span class="hljs-attr">vocab_size</span> = <span class="hljs-number">103168</span><br><span class="hljs-attr">num_layer</span> = <span class="hljs-number">32</span><br><span class="hljs-attr">inter_size</span> = <span class="hljs-number">11008</span><br><span class="hljs-attr">norm_eps</span> = <span class="hljs-number">1</span>e-<span class="hljs-number">06</span><br><span class="hljs-attr">attn_bias</span> = <span class="hljs-number">0</span><br><span class="hljs-attr">start_id</span> = <span class="hljs-number">1</span><br><span class="hljs-attr">end_id</span> = <span class="hljs-number">2</span><br><span class="hljs-attr">rotary_embedding</span> = <span class="hljs-number">128</span><br><span class="hljs-attr">rope_theta</span> = <span class="hljs-number">10000.0</span><br><span class="hljs-attr">size_per_head</span> = <span class="hljs-number">128</span><br></code></pre></td></tr></table></figure>
<p>和数据类型相关的参数也不可更改，主要包括两个。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">weight_type</span> = fp16<br><span class="hljs-attr">group_size</span> = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
<p><code>weight_type</code> 表示权重的数据类型。目前支持 fp16 和 int4。int4 表示 4bit 权重。当 <code>weight_type</code> 为 4bit 权重时，<code>group_size</code> 表示 <code>awq</code> 量化权重时使用的 group 大小。</p>
<p>剩余参数包括下面几个。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">tensor_para_size</span> = <span class="hljs-number">1</span><br><span class="hljs-attr">session_len</span> = <span class="hljs-number">2056</span><br><span class="hljs-attr">max_batch_size</span> = <span class="hljs-number">64</span><br><span class="hljs-attr">max_context_token_num</span> = <span class="hljs-number">1</span><br><span class="hljs-attr">step_length</span> = <span class="hljs-number">1</span><br><span class="hljs-attr">cache_max_entry_count</span> = <span class="hljs-number">0.5</span><br><span class="hljs-attr">cache_block_seq_len</span> = <span class="hljs-number">128</span><br><span class="hljs-attr">cache_chunk_size</span> = <span class="hljs-number">1</span><br><span class="hljs-attr">use_context_fmha</span> = <span class="hljs-number">1</span><br><span class="hljs-attr">quant_policy</span> = <span class="hljs-number">0</span><br><span class="hljs-attr">max_position_embeddings</span> = <span class="hljs-number">2048</span><br><span class="hljs-attr">rope_scaling_factor</span> = <span class="hljs-number">0.0</span><br><span class="hljs-attr">use_logn_attn</span> = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
<p>一般情况下，我们并不需要对这些参数进行修改，但有时候为了满足特定需要，可能需要调整其中一部分配置值。这里主要介绍三个可能需要调整的参数。</p>
<ul>
<li>KV int8 开关：<ul>
<li>对应参数为 <code>quant_policy</code>，默认值为 0，表示不使用 KV Cache，如果需要开启，则将该参数设置为 4。</li>
<li>KV Cache 是对序列生成过程中的 K 和 V 进行量化，用以节省显存。我们下一部分会介绍具体的量化过程。</li>
<li>当显存不足，或序列比较长时，建议打开此开关。</li>
</ul>
</li>
<li>外推能力开关：<ul>
<li>对应参数为 <code>rope_scaling_factor</code>，默认值为 0.0，表示不具备外推能力，设置为 1.0，可以开启 RoPE 的 Dynamic NTK 功能，支持长文本推理。另外，<code>use_logn_attn</code> 参数表示 Attention 缩放，默认值为 0，如果要开启，可以将其改为 1。</li>
<li>外推能力是指推理时上下文的长度超过训练时的最大长度时模型生成的能力。如果没有外推能力，当推理时上下文长度超过训练时的最大长度，效果会急剧下降。相反，则下降不那么明显，当然如果超出太多，效果也会下降的厉害。</li>
<li>当推理文本非常长（明显超过了训练时的最大长度）时，建议开启外推能力。</li>
</ul>
</li>
<li>批处理大小：<ul>
<li>对应参数为 <code>max_batch_size</code>，默认为 64，也就是我们在 API Server 启动时的 <code>instance_num</code> 参数。</li>
<li>该参数值越大，吞度量越大（同时接受的请求数），但也会占用更多显存。</li>
<li>建议根据请求量和最大的上下文长度，按实际情况调整。</li>
</ul>
</li>
</ul>
<h2 id="3-模型量化"><a href="#3-模型量化" class="headerlink" title="3 模型量化"></a>3 模型量化</h2><p>本部分内容主要介绍如何对模型进行量化。主要包括 KV Cache 量化和模型参数量化。总的来说，量化是一种以参数或计算中间结果精度下降换空间节省（以及同时带来的性能提升）的策略。</p>
<p>正式介绍 LMDeploy 量化方案前，需要先介绍两个概念：</p>
<ul>
<li>计算密集（compute-bound）: 指推理过程中，绝大部分时间消耗在数值计算上；针对计算密集型场景，可以通过使用更快的硬件计算单元来提升计算速。</li>
<li>访存密集（memory-bound）: 指推理过程中，绝大部分时间消耗在数据读取上；针对访存密集型场景，一般通过减少访存次数、提高计算访存比或降低访存量来优化。</li>
</ul>
<p>常见的 LLM 模型由于 Decoder Only 架构的特性，实际推理时大多数的时间都消耗在了逐 Token 生成阶段（Decoding 阶段），是典型的访存密集型场景。</p>
<p>那么，如何优化 LLM 模型推理中的访存密集问题呢？ 我们可以使用 <strong>KV Cache 量化</strong>和 <strong>4bit Weight Only 量化（W4A16）</strong>。KV Cache 量化是指将逐 Token（Decoding）生成过程中的上下文 K 和 V 中间结果进行 INT8 量化（计算时再反量化），以降低生成过程中的显存占用。4bit Weight 量化，将 FP16 的模型权重量化为 INT4，Kernel 计算时，访存量直接降为 FP16 模型的 1/4，大幅降低了访存成本。Weight Only 是指仅量化权重，数值计算依然采用 FP16（需要将 INT4 权重反量化）。</p>
<h3 id="3-1-KV-Cache-量化"><a href="#3-1-KV-Cache-量化" class="headerlink" title="3.1 KV Cache 量化"></a>3.1 KV Cache 量化</h3><h4 id="3-1-1-量化步骤"><a href="#3-1-1-量化步骤" class="headerlink" title="3.1.1 量化步骤"></a>3.1.1 量化步骤</h4><p>KV Cache 量化是将已经生成序列的 KV 变成 Int8，使用过程一共包括三步：</p>
<p>第一步：计算 minmax。主要思路是通过计算给定输入样本在每一层不同位置处计算结果的统计情况。</p>
<ul>
<li>对于 Attention 的 K 和 V：取每个 Head 各自维度在所有Token的最大、最小和绝对值最大值。对每一层来说，上面三组值都是 <code>(num_heads, head_dim)</code> 的矩阵。这里的统计结果将用于本小节的 KV Cache。</li>
<li>对于模型每层的输入：取对应维度的最大、最小、均值、绝对值最大和绝对值均值。每一层每个位置的输入都有对应的统计值，它们大多是 <code>(hidden_dim, )</code> 的一维向量，当然在 FFN 层由于结构是先变宽后恢复，因此恢复的位置维度并不相同。这里的统计结果用于下个小节的模型参数量化，主要用在缩放环节（回顾PPT内容）。</li>
</ul>
<p>第一步执行命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 计算 minmax</span><br>lmdeploy lite calibrate \<br>  --model  /root/share/temp/model_repos/internlm-chat-7b/ \<br>  --calib_dataset <span class="hljs-string">&quot;c4&quot;</span> \<br>  --calib_samples 128 \<br>  --calib_seqlen 2048 \<br>  --work_dir ./quant_output<br></code></pre></td></tr></table></figure>
<p>在这个命令行中，会选择 128 条输入样本，每条样本长度为 2048，数据集选择 C4，输入模型后就会得到上面的各种统计值。值得说明的是，如果显存不足，可以适当调小 samples 的数量或 sample 的长度。</p>
<blockquote>
<p>这一步由于默认需要从 Huggingface 下载数据集，国内经常不成功。所以我们导出了需要的数据，大家需要对读取数据集的代码文件做一下替换。共包括两步：</p>
<ul>
<li>第一步：复制 <code>calib_dataloader.py</code> 到安装目录替换该文件：<code>cp /root/share/temp/datasets/c4/calib_dataloader.py  /root/.conda/envs/lmdeploy/lib/python3.10/site-packages/lmdeploy/lite/utils/</code></li>
<li>第二步：将用到的数据集（c4）复制到下面的目录：<code>cp -r /root/share/temp/datasets/c4/ /root/.cache/huggingface/datasets/</code> </li>
</ul>
</blockquote>
<p>第二步：通过 minmax 获取量化参数。主要就是利用下面这个公式，获取每一层的 K V 中心值（zp）和缩放值（scale）。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">zp = (min+max) / 2<br>scale = (max-min) / 255<br>quant: q = round( (f-zp) / scale)<br>dequant: f = q * scale + zp<br></code></pre></td></tr></table></figure>
<p>有这两个值就可以进行量化和解量化操作了。具体来说，就是对历史的 K 和 V 存储 quant 后的值，使用时在 dequant。</p>
<p>第二步的执行命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 通过 minmax 获取量化参数</span><br>lmdeploy lite kv_qparams \<br>  --work_dir ./quant_output  \<br>  --turbomind_dir workspace/triton_models/weights/ \<br>  --kv_sym False \<br>  --num_tp 1<br></code></pre></td></tr></table></figure>
<p>在这个命令中，<code>num_tp</code> 的含义前面介绍过，表示 Tensor 的并行数。每一层的中心值和缩放值会存储到 <code>workspace</code> 的参数目录中以便后续使用。<code>kv_sym</code> 为 <code>True</code> 时会使用另一种（对称）量化方法，它用到了第一步存储的绝对值最大值，而不是最大值和最小值。</p>
<p>第三步：修改配置。也就是修改 <code>weights/config.ini</code> 文件，这个我们在《2.6.2 模型配置实践》中已经提到过了（KV int8 开关），只需要把 <code>quant_policy</code> 改为 4 即可。</p>
<p>这一步需要额外说明的是，如果用的是 TurboMind1.0，还需要修改参数 <code>use_context_fmha</code>，将其改为 0。</p>
<p>接下来就可以正常运行前面的各种服务了，只不过咱们现在可是用上了 KV Cache 量化，能更省（运行时）显存了。</p>
<h4 id="3-1-2-量化效果"><a href="#3-1-2-量化效果" class="headerlink" title="3.1.2 量化效果"></a>3.1.2 量化效果</h4><p>官方给出了 <a href="https://huggingface.co/internlm/internlm-chat-7b">internlm-chat-7b</a> 模型在 KV Cache 量化前后的显存对比情况，如下表所示。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>batch_size</th>
<th>fp16 memory(MiB)</th>
<th>int8 memory(MiB)</th>
<th>diff(MiB)</th>
</tr>
</thead>
<tbody>
<tr>
<td>8</td>
<td>22337</td>
<td>18241</td>
<td>-4096</td>
</tr>
<tr>
<td>16</td>
<td>30593</td>
<td>22369</td>
<td>-8224</td>
</tr>
<tr>
<td>32</td>
<td>47073</td>
<td>30625</td>
<td>-16448</td>
</tr>
<tr>
<td>48</td>
<td>63553</td>
<td>38881</td>
<td>-24672</td>
</tr>
</tbody>
</table>
</div>
<p>可以看出，KV Cache 可以节约大约 20% 的显存。</p>
<p>同时，还在 <a href="https://github.com/open-compass/opencompass">opencompass</a> 平台上测试了量化前后的精准度（Accuracy）对比情况，如下表所示。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>task</th>
<th>dataset</th>
<th>metric</th>
<th>int8</th>
<th>fp16</th>
<th>diff</th>
</tr>
</thead>
<tbody>
<tr>
<td>Language</td>
<td>winogrande</td>
<td>accuracy</td>
<td>60.77</td>
<td>61.48</td>
<td>-0.71</td>
</tr>
<tr>
<td>Knowledge</td>
<td>nq</td>
<td>score</td>
<td>2.69</td>
<td>2.60</td>
<td>+0.09</td>
</tr>
<tr>
<td>Reasoning</td>
<td>gsm8k</td>
<td>accuracy</td>
<td>33.28</td>
<td>34.72</td>
<td>-1.44</td>
</tr>
<tr>
<td>Reasoning</td>
<td>bbh</td>
<td>naive_average</td>
<td>20.12</td>
<td>20.51</td>
<td>-0.39</td>
</tr>
<tr>
<td>Understanding</td>
<td>openbookqa_fact</td>
<td>accuracy</td>
<td>82.40</td>
<td>82.20</td>
<td>+0.20</td>
</tr>
<tr>
<td>Understanding</td>
<td>eprstmt-dev</td>
<td>accuracy</td>
<td>90.62</td>
<td>88.75</td>
<td>+1.87</td>
</tr>
<tr>
<td>Safety</td>
<td>crows_pairs</td>
<td>accuracy</td>
<td>32.56</td>
<td>31.43</td>
<td>+1.13</td>
</tr>
</tbody>
</table>
</div>
<p>可以看出，精度不仅没有明显下降，相反在不少任务上还有一定的提升。可能的原因是，量化会导致一定的误差，有时候这种误差可能会减少模型对训练数据的拟合，从而提高泛化性能。量化可以被视为引入轻微噪声的正则化方法。或者，也有可能量化后的模型正好对某些数据集具有更好的性能。</p>
<p>总结一下，KV Cache 量化既能明显降低显存占用，还有可能同时带来精准度（Accuracy）的提升。</p>
<h3 id="3-2-W4A16-量化"><a href="#3-2-W4A16-量化" class="headerlink" title="3.2 W4A16 量化"></a>3.2 W4A16 量化</h3><h4 id="3-2-1-量化步骤"><a href="#3-2-1-量化步骤" class="headerlink" title="3.2.1 量化步骤"></a>3.2.1 量化步骤</h4><p>W4A16中的A是指Activation，保持FP16，只对参数进行 4bit 量化。使用过程也可以看作是三步。</p>
<p>第一步：同 3.1.1，不再赘述。</p>
<p>第二步：量化权重模型。利用第一步得到的统计值对参数进行量化，具体又包括两小步：</p>
<ul>
<li>缩放参数。主要是性能上的考虑（回顾 PPT）。</li>
<li>整体量化。</li>
</ul>
<p>第二步的执行命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 量化权重模型</span><br>lmdeploy lite auto_awq \<br>  --model  /root/share/temp/model_repos/internlm-chat-7b/ \<br>  --w_bits 4 \<br>  --w_group_size 128 \<br>  --work_dir ./quant_output<br></code></pre></td></tr></table></figure>
<p>命令中 <code>w_bits</code> 表示量化的位数，<code>w_group_size</code> 表示量化分组统计的尺寸，<code>work_dir</code> 是量化后模型输出的位置。这里需要特别说明的是，因为没有 <code>torch.int4</code>，所以实际存储时，8个 4bit 权重会被打包到一个 int32 值中。所以，如果你把这部分量化后的参数加载进来就会发现它们是 int32 类型的。</p>
<p>最后一步：转换成 TurboMind 格式。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 转换模型的layout，存放在默认路径 ./workspace 下</span><br>lmdeploy convert  internlm-chat-7b ./quant_output \<br>    --model-format awq \<br>    --group-size 128<br></code></pre></td></tr></table></figure>
<p>这个 <code>group-size</code> 就是上一步的那个 <code>w_group_size</code>。如果不想和之前的 <code>workspace</code> 重复，可以指定输出目录：<code>--dst_path</code>，比如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">lmdeploy convert  internlm-chat-7b ./quant_output \<br>    --model-format awq \<br>    --group-size 128 \<br>    --dst_path ./workspace_quant<br></code></pre></td></tr></table></figure>
<p>接下来和上一节一样，可以正常运行前面的各种服务了，不过咱们现在用的是量化后的模型。</p>
<p>最后再补充一点，量化模型和 KV Cache 量化也可以一起使用，以达到最大限度节省显存。</p>
<h4 id="3-2-2-量化效果"><a href="#3-2-2-量化效果" class="headerlink" title="3.2.2 量化效果"></a>3.2.2 量化效果</h4><p>官方在 NVIDIA GeForce RTX 4090 上测试了 4-bit 的 Llama-2-7B-chat 和 Llama-2-13B-chat 模型的 token 生成速度。测试配置为 BatchSize = 1，prompt_tokens=1，completion_tokens=512，结果如下表所示。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>model</th>
<th>llm-awq</th>
<th>mlc-llm</th>
<th>turbomind</th>
</tr>
</thead>
<tbody>
<tr>
<td>Llama-2-7B-chat</td>
<td>112.9</td>
<td>159.4</td>
<td>206.4</td>
</tr>
<tr>
<td>Llama-2-13B-chat</td>
<td>N/A</td>
<td>90.7</td>
<td>115.8</td>
</tr>
</tbody>
</table>
</div>
<p>可以看出，TurboMind 相比其他框架速度优势非常显著，比 mlc-llm 快了将近 30%。</p>
<p>另外，也测试了 TurboMind 在不同精度和上下文长度下的显存占用情况，如下表所示。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>model(context length)</th>
<th>16bit(2048)</th>
<th>4bit(2048)</th>
<th>16bit(4096)</th>
<th>4bit(4096)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Llama-2-7B-chat</td>
<td>15.1</td>
<td>6.3</td>
<td>16.2</td>
<td>7.5</td>
</tr>
<tr>
<td>Llama-2-13B-chat</td>
<td>OOM</td>
<td>10.3</td>
<td>OOM</td>
<td>12.0</td>
</tr>
</tbody>
</table>
</div>
<p>可以看出，4bit 模型可以降低 50-60% 的显存占用，效果非常明显。</p>
<p>总而言之，W4A16 参数量化后能极大地降低显存，同时相比其他框架推理速度具有明显优势。</p>
<h3 id="3-3-最佳实践"><a href="#3-3-最佳实践" class="headerlink" title="3.3 最佳实践"></a>3.3 最佳实践</h3><p>本节是针对《模型量化》部分的最佳实践。</p>
<p>首先我们需要明白一点，服务部署和量化是没有直接关联的，量化的最主要目的是降低显存占用，主要包括两方面的显存：模型参数和中间过程计算结果。前者对应《3.2 W4A16 量化》，后者对应《3.1 KV Cache 量化》。</p>
<p>量化在降低显存的同时，一般还能带来性能的提升，因为更小精度的浮点数要比高精度的浮点数计算效率高，而整型要比浮点数高很多。</p>
<p>所以我们的建议是：在各种配置下尝试，看效果能否满足需要。这一般需要在自己的数据集上进行测试。具体步骤如下。</p>
<ul>
<li>Step1：优先尝试正常（非量化）版本，评估效果。<ul>
<li>如果效果不行，需要尝试更大参数模型或者微调。</li>
<li>如果效果可以，跳到下一步。</li>
</ul>
</li>
<li>Step2：尝试正常版本+KV Cache 量化，评估效果。<ul>
<li>如果效果不行，回到上一步。</li>
<li>如果效果可以，跳到下一步。</li>
</ul>
</li>
<li>Step3：尝试量化版本，评估效果。<ul>
<li>如果效果不行，回到上一步。</li>
<li>如果效果可以，跳到下一步。</li>
</ul>
</li>
<li>Step4：尝试量化版本+ KV Cache 量化，评估效果。<ul>
<li>如果效果不行，回到上一步。</li>
<li>如果效果可以，使用方案。</li>
</ul>
</li>
</ul>
<p>简单流程如下图所示。</p>
<p><img  src="quant.png"  ><span class="image-caption">量化流程图</span></p>
<p>另外需要补充说明的是，使用哪种量化版本、开启哪些功能，除了上述流程外，<strong>还需要考虑框架、显卡的支持情况</strong>，比如有些框架可能不支持 W4A16 的推理，那即便转换好了也用不了。</p>
<p>根据实践经验，一般情况下：</p>
<ul>
<li>精度越高，显存占用越多，推理效率越低，但一般效果较好。</li>
<li>Server 端推理一般用非量化版本或半精度、BF16、Int8 等精度的量化版本，比较少使用更低精度的量化版本。</li>
<li>端侧推理一般都使用量化版本，且大多是低精度的量化版本。这主要是因为计算资源所限。</li>
</ul>
<p>以上是针对项目开发情况，如果是自己尝试（玩儿）的话：</p>
<ul>
<li>如果资源足够（有GPU卡很重要），那就用非量化的正常版本。</li>
<li>如果没有 GPU 卡，只有 CPU（不管什么芯片），那还是尝试量化版本。</li>
<li>如果生成文本长度很长，显存不够，就开启 KV Cache。</li>
</ul>
<p>建议大家根据实际情况灵活选择方案。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://github.com/InternLM/lmdeploy/">InternLM/lmdeploy: LMDeploy is a toolkit for compressing, deploying, and serving LLMs.</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/665725861">仅需一块 3090 显卡，高效部署 InternLM-20B 模型 - 知乎</a></li>
</ul>
<h2 id="附录1：TritonServer-作为推理引擎"><a href="#附录1：TritonServer-作为推理引擎" class="headerlink" title="附录1：TritonServer 作为推理引擎"></a>附录1：TritonServer 作为推理引擎</h2><h3 id="TritonServer环境配置"><a href="#TritonServer环境配置" class="headerlink" title="TritonServer环境配置"></a>TritonServer环境配置</h3><blockquote>
<p>注意：本部分内容仅支持物理机上执行，不支持虚拟主机。</p>
</blockquote>
<p>使用 Triton Server 需要安装一下 Docker 及其他依赖。</p>
<p>先装一些基本的依赖。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">apt-get update<br>apt-get install cmake sudo -y<br></code></pre></td></tr></table></figure>
<p>然后是 Docker 安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Add Docker&#x27;s official GPG key:</span><br>sudo apt-get install ca-certificates curl gnupg<br>sudo install -m 0755 -d /etc/apt/keyrings<br>curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg<br>sudo <span class="hljs-built_in">chmod</span> a+r /etc/apt/keyrings/docker.gpg<br><br><span class="hljs-comment"># Add the repository to Apt sources:</span><br><span class="hljs-built_in">echo</span> \<br>  <span class="hljs-string">&quot;deb [arch=<span class="hljs-subst">$(dpkg --print-architecture)</span> signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \</span><br><span class="hljs-string">  <span class="hljs-subst">$(. /etc/os-release &amp;&amp; echo <span class="hljs-string">&quot;<span class="hljs-variable">$VERSION_CODENAME</span>&quot;</span>)</span> stable&quot;</span> | \<br>  sudo <span class="hljs-built_in">tee</span> /etc/apt/sources.list.d/docker.list &gt; /dev/null<br>sudo apt-get update<br><br><span class="hljs-comment"># install</span><br>sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin<br></code></pre></td></tr></table></figure>
<p>安装后我们跑一个 HelloWorld。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># helloworld</span><br>sudo docker run hello-world<br></code></pre></td></tr></table></figure>
<p>可以看到类似下面的画面，表示运行成功。</p>
<p><img  src="triton-server.png"  ><span class="image-caption">triton server</span></p>
<h3 id="TritonServer推理-API服务"><a href="#TritonServer推理-API服务" class="headerlink" title="TritonServer推理+API服务"></a>TritonServer推理+API服务</h3><blockquote>
<p>注意：这部分需要 Docker 服务。</p>
</blockquote>
<p>这里我们把提供模型推理服务的引擎从 TurboMind 换成了 TritonServer，启动命令就一行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># ApiServer+Triton</span><br>bash workspace/service_docker_up.sh<br></code></pre></td></tr></table></figure>
<p>这里会启动一个 TritonServer 的容器，如下图所示。</p>
<p><img src="triton-server-run.png" alt=""></p>
<p>可以再开一个窗口执行 Client 命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># ChatTritonClient + TritonServer（注意是gRPC协议，不要用http）</span><br>lmdeploy serve triton_client  localhost:33337<br></code></pre></td></tr></table></figure>
<p>结果如下图所示。</p>
<p><img src="triton-client.png" alt=""></p>
<h3 id="TritonServer-服务作为后端"><a href="#TritonServer-服务作为后端" class="headerlink" title="TritonServer 服务作为后端"></a>TritonServer 服务作为后端</h3><p>使用过程同 2.4.1 小节。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Gradio+TritonServer（注意是gRPC协议，不要用http）</span><br>lmdeploy serve gradio localhost:33337 \<br>	--server_name 0.0.0.0 \<br>	--server_port 6006<br></code></pre></td></tr></table></figure>
<p>结果如下图所示。</p>
<p><img src="triton-client-web.png" alt=""></p>
<h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h2><h3 id="TurboMind推理-API服务"><a href="#TurboMind推理-API服务" class="headerlink" title="TurboMind推理+API服务"></a>TurboMind推理+API服务</h3><p><img  src="story.png"  ><span class="image-caption">部署并使用 api 生成 300 字小故事</span></p>
<h3 id="TurboMind-推理-命令行本地对话"><a href="#TurboMind-推理-命令行本地对话" class="headerlink" title="TurboMind 推理+命令行本地对话"></a>TurboMind 推理+命令行本地对话</h3><p><img  src="chat.png"  ><span class="image-caption">与本地部署的模型进行对话</span></p>
<h3 id="TurboMind-推理-gradio"><a href="#TurboMind-推理-gradio" class="headerlink" title="TurboMind 推理+gradio"></a>TurboMind 推理+gradio</h3><p><img  src="gradio.png"  ><span class="image-caption">Gradio 部署</span></p>
<h3 id="KV-Cache-量化部署"><a href="#KV-Cache-量化部署" class="headerlink" title="KV Cache 量化部署"></a>KV Cache 量化部署</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 计算 minmax</span><br>lmdeploy lite calibrate \<br>  --model  /root/share/temp/model_repos/internlm-chat-7b/ \<br>  --calib_dataset <span class="hljs-string">&quot;c4&quot;</span> \<br>  --calib_samples 128 \<br>  --calib_seqlen 2048 \<br>  --work_dir ./quant_output<br></code></pre></td></tr></table></figure>
<p>这里在计算的时候需要下载 calibrate 数据集 c4，国内经常不成功。所以需要手动下载后对读取数据集的代码文件做一下替换。共包括两步：</p>
<ul>
<li>第一步：复制 <code>calib_dataloader.py</code> 到安装目录替换该文件：<code>cp /root/share/temp/datasets/c4/calib_dataloader.py  /root/.conda/envs/lmdeploy/lib/python3.10/site-packages/lmdeploy/lite/utils/</code></li>
<li>第二步：将用到的数据集（c4）复制到下面的目录：<code>cp -r /root/share/temp/datasets/c4/ /root/.cache/huggingface/datasets/</code></li>
</ul>
<p><img  src="max.png"  ><span class="image-caption">计算每一层的最大 GPU 占用</span></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 通过 minmax 获取量化参数</span><br>lmdeploy lite kv_qparams \<br>  --work_dir ./quant_output  \<br>  --turbomind_dir workspace/triton_models/weights/ \<br>  --kv_sym False \<br>  --num_tp 1<br></code></pre></td></tr></table></figure>
<p><img  src="qparam.png"  ><span class="image-caption">获取量化参数</span></p>
<p>之后修改 <code>weights/config.ini</code> 文件 <code>quant_policy=4</code> 表示开启 KV Cache 量化。</p>
<p>部署运行内存占用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">watch vgpu-smi<br></code></pre></td></tr></table></figure>
<p><img  src="kv-cache-memory.png"  ><span class="image-caption">KV Cache 内存占用</span></p>
<h3 id="W4A16-量化"><a href="#W4A16-量化" class="headerlink" title="W4A16 量化"></a>W4A16 量化</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 计算 minmax</span><br>lmdeploy lite calibrate \<br>  --model  /root/share/temp/model_repos/internlm-chat-7b/ \<br>  --calib_dataset <span class="hljs-string">&quot;c4&quot;</span> \<br>  --calib_samples 128 \<br>  --calib_seqlen 2048 \<br>  --work_dir ./quant_output_awq<br></code></pre></td></tr></table></figure>
<p>之后量化权重</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 量化权重模型</span><br>lmdeploy lite auto_awq \<br>  --model  /root/share/temp/model_repos/internlm-chat-7b/ \<br>  --w_bits 4 \<br>  --w_group_size 128 \<br>  --work_dir ./quant_output_awq<br></code></pre></td></tr></table></figure>
<p>命令中 <code>w_bits</code> 表示量化的位数，<code>w_group_size</code> 表示量化分组统计的尺寸，<code>work_dir</code> 是量化后模型输出的位置。这里需要特别说明的是，因为没有 <code>torch.int4</code>，所以实际存储时，8个 4bit 权重会被打包到一个 int32 值中。所以，如果你把这部分量化后的参数加载进来就会发现它们是 int32 类型的。</p>
<p><img  src="awq.png"  ><span class="image-caption">AWQ 量化</span></p>
<p>最后一步：转换成 TurboMind 格式。</p>
<p>这个 <code>group-size</code> 就是上一步的那个 <code>w_group_size</code>。如果不想和之前的 <code>workspace</code> 重复，可以指定输出目录：<code>--dst_path</code>，比如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">lmdeploy convert  internlm-chat-7b ./quant_output_awq \<br>    --model-format awq \<br>    --group-size 128 \<br>    --dst_path ./workspace_quant_awq4<br></code></pre></td></tr></table></figure>
<p><img  src="convert-awq.png"  ><span class="image-caption">转换为 TurboMind 格式</span></p>
<p>目录结构如下：</p>
<p><img  src="tree-awq.png"  ><span class="image-caption">转换为 TurboMind 格式的 AWQ 模型结构</span></p>
<p>部署使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">lmdeploy chat turbomind ./workspace_quant_awq4<br></code></pre></td></tr></table></figure>
<p>内存占用</p>
<p><img  src="awq-memory.png"  ><span class="image-caption">AWQ 量化内存占用</span></p>
<p>可见内存占用只有 6G。</p>
]]></content>
      <categories>
        <category>internlm</category>
      </categories>
  </entry>
  <entry>
    <title>反社会的人笔记</title>
    <url>/uncategorized/%E5%8F%8D%E7%A4%BE%E4%BC%9A%E7%9A%84%E4%BA%BA/</url>
    <content><![CDATA[<h1 id="反社会的人"><a href="#反社会的人" class="headerlink" title="反社会的人"></a>反社会的人</h1><p>上层阶级与下层阶级是如何搞垮德国，而谁又在从中获利。</p>
<p>作者瓦尔特·伍伦韦伯在成为记者之前曾就读于海德堡大学政治和法律专业。《反社会的人》是其于2012年出版的首部著作。一经面世就成为当年德国最畅销的读物之一。作者在书中所呈现的德国社会不公正性虽然不为中国读者所熟悉，但这些现象在德国国内早已是热门话题。与大量将焦点放在贫富差距上的社会讨论不同的是，本书的作者首先定义了德国社会中业已形成的两个新兴阶级，即上层阶级和下层阶级。通过对这两个社会群体发展过程的详细描述，作者提出了自己看似惊人的观点。他认为新兴上层阶级和下层阶级的存在使德国社会面临着分崩离析的局面。这两个看似对立的阶级实质上具有近乎一致的发展轨迹和表现特征。它们不但在德国社会运作过程中极力地逃避着作为公民的义务和责任，而且其生存形态给德国的普通纳税人造成了极大负担。</p>
<p>瓦尔特·伍伦韦伯进而在本书的第二部分中将讨论的重点转向了促成这两个阶级形成的原因，也就是德国经济中两个最庞大的产业：金融和社会救助产业。借助大量的统计数据和对相关人员的采访，作者揭示了这两个产业依附于上层和下层阶级得到快速发展的事实。金融行业通过帮助上层阶级进行巨额财富的投机活动，不但使德国经济陷入巨大的危机，还让上层阶级这种纯粹依靠资本运作获益的生活方式成为可能。而社会救助产业则通过利用德国社会福利制度的漏洞，将大量的政府公共支出占为己有，从而发展成为拥有200万从业人员的巨型产业。本书同时尖锐地指出了德国历届联邦政府在这两个产业的畸形发展过程中所起到的推波助澜的作用。政府逐步解除对这两个行业的监管导致其在追求利益最大化的道路上越走越远。</p>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>哲学家路德维希·维特根斯坦曾说过：“对于一无所知的事情，人们应当保持沉默。”正因如此，对于同时在德国社会结构的两极发生着的巨大变化，至今无人展开讨论。对探讨对象的一无所知往往导致这类讨论在尚未开始时就注定夭折。作为社会凝聚力瓦解的前兆，下层乃至上层阶级纷纷退缩到各自的平行世界。而人们却一直在回避这一威胁。其中一个最重要的原因就是：我们对于德国社会结构中的这两类人群知之甚少。</p>
<p>当然无知并不是唯一的障眼法，阻碍人们认识这个新兴阶级社会的还有习惯性思维。东部和西部的德国人早已不习惯以阶级来划分他们所处的社会。统一之前的东德人活在“统一的社会主义社会”的假象中。而西德人则相信当时的联邦德国正朝着“均质化的中产阶级社会”发展。“不管怎样大家都是中产阶级”这一观念在如今西德人的意识里依然根深蒂固。</p>
<p>对于其他主要欧美国家的人民来说，认识到社会阶级的存在是件理所当然的事情。而如今的德国人在这方面却显得缺乏经验。对于中产阶级社会狭隘的固着遮挡了他们的视线，使其难以察觉到德国社会正在经历的转变，因为这种转变首先就发生在德国下层和上层阶级中。</p>
<p>上层阶级是否仍然像大多数人认为的那样担当着社会生产力的骨干角色？<strong>事实是那些过去的企业奠基人及开拓者早已完成转型，变成了纯粹的投资者。</strong>他们现在更喜欢在高风险的金融投资领域用资本获取更多的资本。德国的财富精英们也绝非像他们宣称的那样被税收压得喘不过气来。恰恰相反，他们厚实的肩膀上仅仅承担着微不足道的税赋。维持国家日常运作的经济重任则转由辛勤的中产阶级纳税人来承担。在过去十年中，上亿欧元的财富被转移到了金字塔的顶端。但为何如此巨大的财富转移时至今日仍不为社会所察觉？这应当归咎于上层阶级在自身习性上的一个重大转变。受世人瞩目自古以来就是一种特权。不论是剧院里高高在上的包厢还是主席台的中间席位，显眼的位子总是属于位高权重的人。然而如今的上层阶级却更愿意生活在外人无从窥探的平行世界里。他们只会在互相之间展示其财富。在外界看来，德国的富人们就像根本不存在一样。</p>
<p>然而最近的金融危机却提醒了世人：少数极端富有者的贪欲已经威胁到了社会中大多数人的生活水准。因此，不论上层阶级如何百般地抵制，其价值观和行为都有必要成为公共探讨的主题。相对于上层阶级，下层阶级倒是活得不藏不掖。早在十年前，我成为了首批对这一新兴社会阶层进行报导的记者之一，并在之后的数年间对这个尚不为人所了解的社会阶层进行了大量的采访研究。我得出的结论是：人们对下层阶级的印象仍停留在那些老生常谈、空穴来风的故事或是个别利益集团别有用心的不实宣传上。人们不会想到，物质的匮乏如今和下层阶级的日常生活根本扯不上关系，游戏机、智能电话、电脑和电视娱乐节目才是他们生活中最重要的组成部分。德国的社会福利制度早已战胜了匮乏的物质生活。德国的穷人可以说有的是钱。尽管如此，下层阶级所遭受的不公正对待却是真实且残酷的，而这种不公正性的根源及广度绝非“贫穷”一词所能概括。<strong>下层阶级被剥夺的是一种宝贵的社会参与性。较之金钱的匮乏，受教育机会的缺失才是下层阶级的主要标志。匮乏的教育机会几乎可以说是一切相关问题的根源，包括失业、健康以及抚养后代时的力不从心。下层阶级和中产阶级之间的区别并非收入水平，文化上的差异才是横跨在两者之间的鸿沟。</strong></p>
<p>绩效观念对于德国社会有着不可替代的意义。它不光是富足生活和优越社会福利的保障，更是德国价值体系的支撑。然而上层阶级与下层阶级却发展出了各自独有的价值观和道德观，并与主流社会的认同渐行渐远，这使得对生产绩效的追求失去往日的意义。因为对于以上两个阶级来说，工作所得并非其典型的经济来源。<strong>上层阶级通过毫不费力的资本投资获取财富，而下层阶级则基本依靠社会救济拨款来维持生活。</strong>有别于中产阶级，生产绩效对这两个生活在平行社会中的阶级来说丝毫不具备同等的意义。</p>
<p>社会学家注意到，这两个社会阶级的成员几乎已无法意识到付出劳动与获得成功之间的因果关系。上层阶级视成功为理所当然的结果。下层阶级则缺乏通过付出努力而获取成功的经历。这就使得各种缺乏诚信的手段在两个阶层获得了极大的生存空间。蓬勃发展的税收规避行业正在帮助上层阶级最大限度地逃避纳税。而下层阶级也在社会福利法规制度的丛林中发挥着自身的创造性，尽其所能地不劳而获。可以说，<strong>善于寻找和利用法律漏洞正日渐成为这两个社会阶层所共有的特性</strong>。而德国政府却在经济上资助了这种社会离心运动的发展。中产阶级基本上是在独自维持社会的正常运作，其缴纳的高额税收既化解了财富阶层金融投机行为所带来的风险，同时又保障了下层阶级坐享各种社会福利。他们既为有钱人的财富提供了保护伞，又承担着人人受益的社会福利体系。可以说中产阶级在同时供养着上层和下层阶级。</p>
<p>为了在金融危机中挽救德国经济，政府背负了总量足以再完成一次两德统一过程的巨额债务。同时税务局所征收的每5欧元税收中，就有1欧元流入了社会救助产业的账户。这两个行业无疑是德国经济中最大的吸金者。为此，社会救助产业正在庆祝一个真正的经济奇迹，其发展速度达到了德国总体经济增长的七倍。同时，金融行业也在经历着一个激动人心的繁荣期。货币供应量在过去的二十年里以爆炸式的速度增长。然而政府财政却从这些发展中一无所获，原因就在于这两个巨型行业所享受的税收特权将它们从纳税义务中解放出来，得以将盈利最大程度地占为己有。</p>
<p>值得注意的还有，这两个行业的发展曲线在20世纪90年代中期不约而同地开始垂直攀升。那是因为在这一时期，德国政府的一系列举措大规模地解除了对这两个行业的监管。近年来更是几乎完全放弃了对金融和社会救助产业的控制。德国政府可以说彻底地向其势力举起了白旗。民主社会及其制度的意义在此被漠视，而纳税者也成为了社会中大多数人的唯一角色。</p>
<h2 id="第一章-上层阶级：富人只满足于富有"><a href="#第一章-上层阶级：富人只满足于富有" class="headerlink" title="第一章 上层阶级：富人只满足于富有"></a>第一章 上层阶级：富人只满足于富有</h2><p>在学生时代勤奋好学，并且选择法律或金融这类热门专业的人，取得高学历后进入知名企业开始废寝忘食地工作，同时注重人脉的培养。他既能产生创意又具备执行能力，总是让周围的人感受到自己积极的一面。这样的人接着就能受到提拔，在公司停车场拥有固定的车位。工作中自然也免不了与同事勾心斗角，才能得到下一个升职加薪的机会。他平时还必须生活节俭，购买人寿保险，签订住房互助储金合同，建造私人住宅，最终获得公司股份。<strong>而富人却知道，人们永远也不会通过这条途径变得富有。</strong></p>
<p>承担最高的税率、保时捷跑车、香槟酒、大庄园、高尔夫俱乐部、私人游泳池、劳力士手表、周游世界、古奇、邮轮旅行、丹麦B&amp;O音响、能享受专家治疗的私人医疗保险、高斯巴雪茄”、加入扶轮社，而富人却知道，真正的财富绝非这些东西所能代表。</p>
<p>在过去的几十年中，经济生活的标准对于社会中下阶层也有了明显的提高，在高速公路上以200公里的时速驾驶、去国外度假、拥有家庭影院，这些在以前只有少部分人能够拥有的体验如今的平常人也一样可以获得。之前作为奢侈象征的事物陆续进入了普通收入者的生活，这更导致了一种假象，即社会财富间的距离正在逐渐缩小。造成这个假象的还有一条德国人的黄金法则：“是什么人开什么车。”然而这条曾被视为阶层分界的铁律早已不再适用于如今的德国社会。为了能更准确地了解德国的财富阶层及其财富的规模，我们急需一种新的标准，并非汽车品牌，也不是度假目的地。为此，我们需要一张A4大小的纸，在竖版的方向每隔1厘米画一条线，每条线代表了50000欧元的财富，在画第20条线时就达到一百万欧元的标准。当线画到这张A4纸的顶端时大约代表了一百五十万欧元。如果所有的德国人都在代表自己财富水平的那条线上打钩的话，其中一半以上的人只能打在这张纸的底部区域，也就是说这些人基本上没有任何财产。而几乎99%的人都能就自己拥有的财富在这张纸上找到对应的那条线。只有1%的德国人，其所拥有的财富使他们能跳出这张纸的范围，这些人的数量大约在八十万到一百万左右。他们才是德国真正的财富阶层，他们手上掌握着真正的资本。</p>
<p>我们还可以继续利用这个A4纸标准来衡量德国人所拥有的财富之间到底有多大的差距，根据《经理人杂志》“所提供的德国财富排行榜，南部阿尔迪公司”拥有者卡尔·阿尔布雷希特·常年占据榜首，名下财产估计在170亿欧元左右。代表其财富的那条线该画在多远的地方呢？一米？十米？一百米？答案是3.5公里。也就是说99%的德国公民的财富可以表现在一张A4纸上，而想看到代表卡尔·阿尔布雷希特财富的那条线则需要用望远镜才行。我们所使用的A4纸财富标准和国际上社会学研究者认同的标准极其相似，即所谓的“高净值个人，HNWI”，也就是除名下的不动产外所掌握净资产超过一百万美元的个人。而事实上根据实时汇率，拥有超过七十五万欧元资产的人其名下的不动产价值基本也会处于同样的规模。据“世界财富报告”统计，2011年德国人中拥有至少一百五十万欧元财富的高净值个人共924000位，他们是德国社会最富有的百分之一。</p>
<h3 id="不为人知的上层阶级"><a href="#不为人知的上层阶级" class="headerlink" title="不为人知的上层阶级"></a>不为人知的上层阶级</h3><p>在阶级意识极强的英国和法国，上层阶级理所当然地受到不间断地关注。而德国社会却与之相反，人们习惯于对财富阶层及他们的财富闭口不谈。任何关于个人财富的讨论会被立即贴上“妒忌话题”的标签。这足以让人对此类话题退避三舍，这也是德国社会至今对国内上层阶级缺乏认识的原因之一。谁要是不提问，自然得不到答案。然而有时问了也会得不到答案，所有尝试对上层阶级进行研究的科学家没准儿都遇到过这种情况。达姆斯塔特工大的社会学家米夏埃尔·哈特曼敦授作为德国一流的社会精英研究者，长期对政治、政府、法律及经济界的关键人物进行研究”。在工作中他无奈地发现，没有哪个群体像财富精英们那样对有关他们的研究采取一概抵制的态度。而且越是有钱，抵制得越坚决。哈特曼教授说：“就算是我们这样的学者也几乎接近不了那群人。”对德国最重要的经验社会学研究《社会经济学调查》的研究者来说，被上层阶级拒之门外早就是习以为常的事了。通常只要是问及其财富的规模，访问就极有可能被终止。为此，该研究项目的学者们在多年前就把这个问题从问卷中去掉了。作为研究者之一的马库斯·格拉布卡·抱怨说：“我们对上层阶级知道的还太少了。”持相同意见的还有波兹坦大学’的教授、最具权威的经验社会学著作《德国的财富》作者沃尔夫冈·劳特巴赫，这位财富研究者承认：“我们对这个虽小但极具影响力的社会群体的了解是肤浅的。”并将他们称作“躲在暗处的隐形群体”。而法兰克福的社会学教授西格哈特·内克尔“则直接对当前关于该问题的研究水平下了定论：“德国上层阶级目前就是一个研究空白。”</p>
<h3 id="工资收入只属于门外汉"><a href="#工资收入只属于门外汉" class="headerlink" title="工资收入只属于门外汉"></a>工资收入只属于门外汉</h3><p>巨额财富的运作管理是金融行业中正在快速发展的一个服务门类，它保持着每年7%的增长点。在过去的20年里，令财富阶层欣喜若狂的巨大收益无疑要算理财经理人的功劳。这些为私人银行效力的理财专家满足了有钱人的最大梦想，那就是让财富自己为它的所有者创造更多的财富，进而使该阶层的财富水平达到了一个前所未有的规模。对于财富阶层来说，过去的20年是他们的黄金时期。金融危机加速了他们和其余社会人群之间的财富差异化。我们可以通过对收入情况的比较来说明这一问题。根据经济发展与合作组织提供的数据，德国国内的收入差异水平自1990年起开始加剧，且明显超过大部分经合组织国家差异水平。当90%的德国民众的收入水平在世纪之交有所减少时，占人口5%的上层阶级收入却增长了近15%。</p>
<h3 id="向上的再分配"><a href="#向上的再分配" class="headerlink" title="向上的再分配"></a>向上的再分配</h3><p>资本的分配比收入的分配更不平均，准确地说资本分配的不平均程度是收入分配的3倍。马库斯·格拉布卡证实了这点：“资本的集中程度在过去的几年中持续地增长。”米夏埃尔·哈特曼教授也得出了相同结论：“这几年里，最富有的那1%手中的财富得以明显地增加，其中的大部分集中在最最富有的千分之一手上。”</p>
<p>1970年社会全部财富的44%掌握在占人口总数10%的富人手中，现在这个比例已经增长至66%。把社会财富比作蛋糕的话，又有两块蛋糕从多数人的盘子被分到了少数人的盘子里。这样的再分配涉及的数额巨大，如今德国的全部社会财富高达6.6万亿欧元，要是还按照1970年的比例再次分配的话，德国最富有的那10%就得吐出1.5万亿欧元。对其余90%的人来说，这意味着人均20000欧元的额外收入。若是在不同的时代，这样不公平的财富分配足以引发一场血腥的革命。</p>
<p>10%的人口支配着三分之二的财富。哈特曼教授表示，这里还存在着上层与最上层之间的差别。让我们从财富的金字塔往上看，最著名的那1%拥有超过三分之一的财富，他们比社会中90%的人加起来还富有。但在近10年财富分配中的最大赢家只有大约80000人，也就是最最富有的千分之一。全德国社会财富的15%属于这80000人。为了让读者看得更明白：</p>
<p>·其余90%的德国人拥有33.4%的财富。</p>
<p>·富有的10%拥有66.6%的财富。</p>
<p>·最富有的1%拥有35.8%的财富。</p>
<p>·最最富有的1%o拥有22.5%的财富。</p>
<p>看了这组数据谁要是已经觉得呼吸困难，那接下来的这个数字足以让人立刻窒息。以上的数据包含了所有的财富类型，如果把其中所有者自住的不动产去掉只计算金融资本的话，那最富有的5%就掌握着全德国75%的财富。</p>
<p>早先有许多学者相信渗漏效应，他们认为财富会从上层流经全社会的各个层面直至下层，这意味着上层获益则所有人都将获益。渗漏效应因此为财富的不均匀分配提供了合法性。然而财富阶级似乎在自己与其他社会阶层中间拉起了一张塑料薄膜。马库斯·格拉布卡说：“所有的研究表明，其他社会阶层什么也没从上层得到。”这种在社会财富分配过程中的变化是否正是上层社会退出公众视线的原因呢？面对财富分配游戏中的失败者，没必要以胜利者的姿态在其面前耀武扬威，最好的办法是让他们继续蒙在鼓里。</p>
<h3 id="隐蔽的享乐主义"><a href="#隐蔽的享乐主义" class="headerlink" title="隐蔽的享乐主义"></a>隐蔽的享乐主义</h3><p>马丁·哈尔德带我去了他朋友安德烈亚斯·穆尔库迪斯那里。他俩有着共同的客户群。只有知情者才认得安德烈亚斯的店，马丁开着他的保时捷从货车入口进入了柏林一座破败的建筑里，停在卸货区域内。在这个一楼的Loft里，所卖的商品都是安德烈亚斯亲自挑选的。儿童服装，由瑞士农妇手工编织，标签上是弗兰肯豪泽女士亲笔写的“出自弗兰肯豪泽女士”，没有标价。在另一个台子上摆着一双男皮鞋，当然是手工制作，但这鞋看起来就像是曾经有人穿着它走了一遍圣地亚哥朝圣之路一样。普通人估计都不好意思把它捐给红十字会。只有识货的人才知道这鞋的来历。马丁告诉我：“其中的信息只有知情者才能读到。而像阿玛尼、古奇、普拉达这些牌子只适合半吊子。”服装代表了身份，这句话到今天也不过时。但对于从前的上层阶级来说，向世人展示其地位是非常重要的事。而如今他们的服装却发展成了一种暗号。不引起别人的注意对于今天的上层阶级来说才是最重要的。</p>
<p>黑尔格·阿亨巴赫的理论是：“财富并不能满足精神的需求，拥有10亿身家或者更多的人经常会感到孤独和恐惧。”而他则给这样的人提供了精神上的满足，通过艺术品。收藏和展示价值不菲的艺术品被视为享受财富的高雅形式。在德国，谁要是花1000万欧元造了艘游艇，必然会被视为暴发户。但要是用同样的价格拍得一幅格哈德·里希特的画作，则成了艺术的促进者。艺术品收藏让富人可以在任意挥霍其财富的同时还能以富有修养的形象示人。</p>
<p>然而对艺术的理解和财富多寡之间却没有联系，黑尔格·阿亨巴赫也由此发展出了他的事业。他在德国被认为是艺术品咨询行业的发明者。他可以在有钱人购买某件艺术品时提供咨询，也能帮他们筹备一个收藏系列。几百年来，财富阶层身边总是不乏艺术品，在文艺复兴时期艺术收藏就变得更为重要，而正是在同一时期，财富的地位也上升到了一个新的高度。这并不意味着拥有了财富就会自动对艺术产生兴趣。黑尔格·阿亨巴赫必须先帮许多客户把他们对艺术的兴趣唤醒，然后塑造他们对艺术的品味。他声称，一些客户通过艺术收藏简直像是脱胎换骨了一样。</p>
<h3 id="去政治化的上层阶级"><a href="#去政治化的上层阶级" class="headerlink" title="去政治化的上层阶级"></a>去政治化的上层阶级</h3><p>当代来自经济领域的上层阶级则是去政治化的一群人。在他们中间弥漫着对国家政治制度及政治活动的蔑视。“在我们的圈子里没有谁愿意为国家出力，也没人会和媒体接触。”一位坚持不愿透露姓名的男爵对我说。该男爵的家族姓氏可以追溯到12世纪。他的住所是一座位于德国南部的雄伟古堡，居住面积大约为1200平方米。通过观察男爵的家族历史，人们可以发现上层阶级在国家事务中的演变。直到17世纪，神职人员都是很受欢迎的职业。而在19和20世纪中，男爵的先辈们则通过出任部长、将军和议员来体现其政治上的显要地位。男爵本人也曾短时间涉足政界，而且还获得过地方议员的席位。然而政治这种需要赢得多数人好感的游戏对于他来说始终觉得陌生。“在政治中，人们要表现和证明自己，需要承担责任。而我们这样的人已经对这些没什么兴趣了。”男爵说。因此他最终还是放弃了家族的传统，转而进入商界，但始终还是上层阶级。</p>
<h3 id="精英工厂"><a href="#精英工厂" class="headerlink" title="精英工厂"></a>精英工厂</h3><p>曾几何时，受教育机会可以说是上层阶级特权的重要表现，然而20世纪60年代开始的德国教育改革改变了这一情况。上层阶级在教育方面的优势荡然无存，中产阶级则通过优化后的教育制度迈开了奋力追赶的脚步。竭尽全力的中产阶级家长为了确保自己的后代能在未来的社会竞争中占据有利条件，纷纷开始用肖邦进行胎教，一种对自身生存状态的危机感正在财富阶层中传播开来，其根源来自全球金融风暴。长期以来，上层阶级已经习惯了坐享理财专家们为其巨额投资所带来的两位数的收益率。金融危机让他们第一次感受到其财富的安全性并非理所当然的事情。当前世界经济的不可预知性同样严重威胁到了上层阶级有保障的物质生活，他们中的许多人在受到震惊后开始退缩不前。托马斯·派瑞将上层阶级的这种应激反应称为“搁浅”，对其的描述可概括为：一种对周边可控区域更为强烈的固着，这种可控区域主要包括家庭和所属社会阶层，其共同特点是私密、熟悉和可预见性。因此，上层阶级的目光更大程度地转向内部，自身成了他们唯一的参照物。外部世界则越来越多地被其视为威胁。</p>
<p>社会学家已经观察到，社会阶层之间的隔离有愈演愈烈的趋势，特别是对于上层阶级来说。社会学教授西格哈特·内克尔总结说：“上层阶级自身所具有的特征变得越发明显，保持社会阶级间的距离对其来说也越来越重要。”百万富翁们为了避免与穷人接触纷纷逃进了他们的平行世界。关于这个平行世界的例子有很多：越来越多的上层阶级偏爱会员制的俱乐部，而非传统的各类民间协会。他们几乎从不使用公共交通工具，即使和高收入者一起乘坐航班的商务舱对他们来说也是不能忍受的。这就说明了为什么2004年至今德国的私人飞机拥有量翻了一番。连汉莎航空公司都瞅准了其中的商机，开始接受私人航班的预定。婚姻问题研究者指出：上层阶级中的越来越多的人倾向于门当户对的联姻。那个集团总裁和接上学到东西，但赫伯特·亨茨勒表示，为政府所做的工作让他在很多方面进行了重新思考。这个咨询委员会旨在从资金及技术的角度帮助政府解决基础设施建设方面的难题。从前像赫伯特·亨茨勒这样的人是绝不会站在政府的立场思考的，甚至会为这些难题与政界展开激烈的辩论。可惜这位前高级经理人直到退休后才发现税收的重要性：“对国家基础设施项目的投资，有许多只能依靠税收收入来实现。为此，我现在甚至赞成国家提高税收。”</p>
<h3 id="退入平行社会"><a href="#退入平行社会" class="headerlink" title="退入平行社会"></a>退入平行社会</h3><p>“让所有人接受教育”曾是德国20世纪70年代一项宏大的政治计划。对于一些勤奋的德国人来说，在大约20年中教育确实使其在社会和经济地位方面的提升成为可能。然而2000年进行的第一次PISA测验的结果却表明：没有哪个国家像德国一样，在教育资源上偏袒家境优越的学生。家庭背景自始至终决定了一名学生在德国教育体系中所受到的待遇。除了留在大学任教外，博士学位是人们在德国教育系统中所能获得的最高学历。如果说获得博士学位意味着今后的人生将一帆风顺，对于像法律、工程和经济学专业的博士就更是如此。米夏埃尔·哈特曼教授对这些专业的博士毕业生进行跟踪研究后发现：来自上层阶级的博士进入企业高级管理层的机会是中产阶级出身同等学历者的3倍。</p>
<p>对知识和专业技能的学习早已不是通向顶层的阶梯，社会中的上升通道最多只能到达中产阶级。尽管如此，教育却显得比之前更加重要。因为对于99%的德国人来说，受教育虽不能保证飞黄腾达，但却是唯一能够避免其现有社会地位下降的途径。教育的首要意义如今变成了经济状况的保障。而在德国国内的中学和大学里刻苦学习的中产阶级后代明显高估了教育能够带来的机遇。相反上层阶级知道，想加入上层阶级这个俱乐部并不需要过人的学历。一位人力资源管理者说：“成绩对我们来说不重要，而形象、自信心和行为举止才是关键因素。”在她的名片上印着德国区首席运营官，此次的目的是为－－家投资银行招揽高级管理人员。这位女士希望能在欧洲商学院有所收获。欧洲商学院作为一所德国私立高校，在国际和国内的同类学校排行中都名列前茅，被视为金融行业的精英工厂。学院每学期的学费为6000欧元。虽说不是牛津或哈佛大学，但它属于德国最好的大学。</p>
<h3 id="过于集中的财富意味着危险"><a href="#过于集中的财富意味着危险" class="headerlink" title="过于集中的财富意味着危险"></a>过于集中的财富意味着危险</h3><p>约翰·肯尼斯·加尔布雷思对于上层阶级有着截然不同的看法。这位哈佛大学的经济史学家凭借其对金融行业历史中的泡沫经济与银行危机的研究闻名于世。在他看来，上层阶级非但不是经济领域的价值创造者，反而是一种危险因素。财富阶层是金融行业历史上所有灾难的制造者。迄今为止发生过的所有经济危机都拥有一个共同的前提：一旦少数人手中掌握了太多的财富，就会引发灾难。</p>
<p>不光是今天的富人被认为有杰出的能力。加尔布雷思纵观历史后发现：人们在所有的时期都愿意相信，谁要是占有的财富越多，其社会及经济地位就越牢固，也越具有敏锐的洞察力和聪明的头脑。金钱还会被用来衡量所创造的价值，财富越多，其所创造的价值和运用的才智就越多。对于加尔布雷思来说，将财富与才智相提并论更是一个具有欺骗性的观点。虽然加尔布雷思已于2006年去世，但其关于历史的见解仍可以被运用到对当代德国社会的研究中。上层阶级自认为是社会精英的神话已经被打破，米夏埃尔·哈特曼教授通过对德国大型企业中最高领导层的调查发现：其中80％的人来自社会中最富有的那5%的家庭，其中的一半更是属于最最富有的那千分之一。可见，才能或资历并非是成为企业管理者的依据，家庭背景才是真正的选拔条件。而相应的工作收入对财富阶层来说简直就是零花钱，这也是为什么大部分的高净值个人并不从事任何职业。沃尔夫冈·劳特巴赫认为这些人属于德国社会中不劳而获的群体，其财富的快速增长并非辛勤工作的结果。金融市场是其进行财富积累的主要手段。而通过高明的资本运作让财富成倍增长充其量只能算是理财专家的劳动成果，上层阶级只不过是提供了资本而已。来自《社会经济学调查》(SOEP)、汉斯·伯克勒基金会及世界经济合作组织等多个机构的研究结果同样证明了这个结论。社会学教授西格哈特·内克尔还观察到了商界精英如何从昔日带有中产阶级兢兢业业特点的群体转变为如今的经济机会主义者。正如劳特巴赫所指出的：当人拥有巨额财富时，金融市场上机会主义的博弈为其带来的回报比辛勤工作丰厚得多。相对于普通的工作收入，这种毫不费力的资本收益更能代表上层阶级的身份。在德国只有5%的人属于直接股东，而股市中的投机行为对于那些没有足够资本来分散风险的人，也就是其余95%的德国人并不可取。可见，资本收益其实是上层阶级的特权。</p>
<h3 id="从企业家变为投资者"><a href="#从企业家变为投资者" class="headerlink" title="从企业家变为投资者"></a>从企业家变为投资者</h3><p>然而将自己毕生经营的企业托付给下一代早已不是那些老一辈创业者的唯一选择。正有越来越多上了年纪的企业所有者向豪克·奥夫豪泽私人银行的米夏埃尔·施拉姆就出让企业一事进行咨询。“企业中的世袭观念正迅速消除。”他说。托马斯·派瑞对此和施拉姆持有一致的看法：“理想的情况中子孙们有朝一日能接手并承担起家族企业，在现实里已不再是常态。”那些在财富中成长起来的孩子对于备受压力的企业领导者一职已失去兴趣。而老一辈财富阶层不但对此表示理解，更乐意为其后代安排好今后衣食无忧的生活。没有责任和压力的财富显然要美好得多。当托马斯·派瑞向那些财富阶层问及其今后的目标时，他得到的最多回答是这样：保持健康、对自己的心灵进行探索、创造生活和工作的平衡以及在私人生活中寻找一片净土。</p>
<p>原先注入企业中的资金现在则被交给私人银行的专家们去经营。投资经理们所提供的全球化投资策略使新一代财富阶层从此不必再为企业利润担心。企业家从此变成了投资者。作为资本家的他们出售了曾是其财富基础的生产资料。组织企业进行生产对社会而言是一种积极的行为，相对而言将大量资金投入金融行业则是一种消极行为。财富阶层正从国民经济的积极建设者转变为消极的寄生群体。然而上层阶级仍孜孜不倦地将自己视为一个由企业家组成的群体。托马斯·派瑞在他的采访研究中把这称为“自以为是的自我认识”。尽管如此，上层阶级的世界中除了坐享其成者，总还是存在一些成功的企业家，通过努力奠定了其财富地位。</p>
<p>想自己创业，首先必须要有一定的启动资金。创业者在没有足够存款的情况下就只能向银行贷款。创业者是否能够迈出第一步很大程度上取决于银行的判断。在2011年中，位于波恩的中产阶层研究机构对个人创业行为进行了统计。德国当年400000起注册创业行为中，有380000起最终宣告破产。由此可见成功创业的难度。最普遍的创业原因并非绝妙的生意点子，却是因为生活所迫。许多长期失业者在走投无路时才会萌发创业的想法。而一旦创业失败并无力偿还银行贷款，这些人能做的就只有宣告破产。在之后的六年时间里，他们不能在银行开户、不能签手机协议和新的租房合同。这意味着破产者失去了其经济存在性，前景一片渺茫。德国对经济上的失败者可以说是毫不留情。在中产阶层研究机构的统计中，出身财富阶层者的首次创业行为则显示了截然不同的数据。上层阶级家庭很乐意出资帮后代解决像启动资金这样的小问题，这就给了他们一个实现其创业想法的良好开端。尽管受过最好的教育，上层阶级的后代也不一定能一次成功。这也没关系，只要该家庭对其后代有信心，不断地为他们创造机会，这些创业者在第二次甚至第三次尝试的时候总能千出点名堂来，也就成了所谓的“白手起家的百万富翁”。</p>
<p>现在是时候对前面所说的进行总结并提出一个问题：上层阶级对于公众社会究竟承担了什么样的角色？他们既不是领导阶层，又不具备任何道德层面的导向性。他们将自己与社会公众生活隔离开来，国家政治舞台上也鲜见他们的影子。他们并非促进政治、学术或文化发展的动力，而这个阶级所自我标榜的生产力推动者形象也被证明是无稽之谈。他们甚至不愿再担负起将其家族企业经营下去的责任。上层阶级所感兴趣的就只有一件事情：获取利益，金钱是他们的唯一。富人只满足于富有。</p>
<h3 id="机会均等的童话"><a href="#机会均等的童话" class="headerlink" title="机会均等的童话"></a>机会均等的童话</h3><p>除了默认的态度，德国社会显然对上层阶级没有任何期待与要求。无论是否违背了业绩社会的基本准则，上层阶级从不需要对其财富的合理性做出解释。对于在其他社会阶层辛勤工作的人来说，创造业绩所换来的相应回报为其在社会上升通道中向财富阶层靠拢提供了可能性。社会中财富拥有者的更替非但无须带有革命性质，而且应该是一个业绩社会的常态。社会流动性和机会均等性作为重要的特征，可以用来衡量每个业绩社会。</p>
<p>汉堡市阿尔托纳区综合医院的妇幼中心产房内，成排的新生儿们还带着母体的温度。这时候的他们似乎全都一样，没有身份差别，没有高低上下之分。没人能够知道他们其中谁将成为法官和企业主，而谁又将是小职员、部门经理或是失业者。人生在最初的时刻似乎对每个人都是公平的，然而命运的骰子其实早已投下。距医院不到百米的7号高速公路将阿尔托纳的蓝领居住区与全德国人均收入最高的社区之一艾尔贝区分隔开来。当母亲带着新生儿出院回家时，每个孩子的命运就已清晰可见。在德国，阶级属性决定了每个人今后的发展机会。你父母是谁决定了你将是谁。</p>
<p>对所有的社会而言，每个人都享有同样的机会只能说是天方夜谭。但对于德国来说，从维利·勃兰特任总理的时代起，改善机会均等的情况已经成为德国政界的目标。让来自不同社会阶层的孩子都能在人生中获得成功。克劳斯·冯·多纳尼作为维利·勃兰特执政时期的教育部长曾为此付出努力，但是他在回忆录中写道：在改善机会均等性的事业上，我们还远远没有达到目标。</p>
<p>但为何格哈德·施罗德作为一个清洁女工的儿子能官至德国总理？而他的副手约施卡·费舍尔在高中都没毕业的情况下成为了外交部长？不同于经济界，政界遵循的是另一套游戏规则。相对于出身背景，坚持不懈的精神才是获得成功的保证。谁若想在政坛出人头地就必须做好卧薪尝胆的准备，这也是投身政治对于财富阶层缺乏吸引力的原因之一。施罗德和费舍尔这代人经历了一个德国社会流动性的黄金时期，社会地位的升迁直到上世纪70年代仍相对容易实现。这代人的父辈在二战中大批阵亡，以至于年青一代能够提前取代其父辈在社会中的位置。更重要的是，这个时期高速增长的德国经济需要每个人的力量，甚至小学毕业生在有段时间内也能够进入企业管理层。米夏埃尔·哈特曼教授认为：当市场条件优越时，下层阶级也将从中受益，其中的一部分人能够完成向上的社会流动。但当市场形势低迷时，那些来自富裕家庭的人则在社会竞争中具有绝对的优势。充满机会的60和70年代对于所有社会阶层来说是一个历史上的特殊时期。这个时期虽然在婴儿潮到来之前就已经成为过去，但其影响力在德国社会却久久挥之不去。很多德国人依然对机会均等的童话深信不疑。</p>
<p>柏林科学中心的赖因哈德·波拉克受海因里希·波尔基金会的委托对机会均等性的现状进行了研究，他通过将德国社会流动性情况与其他国家对比得出结论：德国在该项对比中体现出了极小的社会流动性。换句话说，几乎没有哪个工业化国家像德国一样，对社会流动机会的分配如此不公平。财富研究专家沃尔夫冈·劳特巴赫将德国称为一个“凝固的社会”。社会学教授西格哈特·内克尔则相信：社会流动性的作用正在被家庭出身取代。人们正在经历一场社会的再封建化，财富阶层就是德国新的贵族。</p>
]]></content>
      <tags>
        <tag>book</tag>
      </tags>
  </entry>
  <entry>
    <title>小米创业思考</title>
    <url>/uncategorized/xiaomi/</url>
    <content><![CDATA[<p>整本书主要是雷军口述的记录。</p>
<h1 id="小米创业历程"><a href="#小米创业历程" class="headerlink" title="小米创业历程"></a>小米创业历程</h1><h1 id="小米方法论"><a href="#小米方法论" class="headerlink" title="小米方法论"></a>小米方法论</h1><h1 id="小米方法论的实践"><a href="#小米方法论的实践" class="headerlink" title="小米方法论的实践"></a>小米方法论的实践</h1><h2 id="对互联网思维的理解"><a href="#对互联网思维的理解" class="headerlink" title="对互联网思维的理解"></a>对互联网思维的理解</h2><h2 id="互联网七字诀"><a href="#互联网七字诀" class="headerlink" title="互联网七字诀"></a>互联网七字诀</h2><h3 id="专注"><a href="#专注" class="headerlink" title="专注"></a>专注</h3><p><strong>专注、极致、口碑、快</strong>，这就是雷军总结的互联网七字诀，也是雷军对互联网思维的高度概括。</p>
<p>从商业角度看，专注就是要“把鸡蛋尽量放在一个篮子里”。这听起来似乎有些不合理，大家的第一反应可能是“风险会不会太大？”，但事实上，这往往才是正确的选择。在任何时候，任何商业实体的资源都是有限的，将有限的资源投入足够聚焦的业务线中，才可能形成最大化的竞争力，拿出足够好的产品与服务。</p>
<p>早在30多年前，我就亲身经历过这样的教训。上大学时，我经历了第一次创业，我跟几个同学合伙创办了一家公司，取名“三色公司”。我们看起来并不是完全没有基础，我和我的合伙人们拥有在当时的武汉算起来还不错的技术能力，我自己也有软件开发的经验，并且在当地拥有一些IT行业圈子的人脉，似乎也有些“客户资源”。但是，在这场“过家家”式的创业尝试中，从第一天起，我们就没想明白我们要做什么。<strong>“看似什么都能做”，其实就是“做什么都不知道”。</strong>我们做过装机、软件开发、倒手电子元器件，甚至连打印这样的活儿也接，但很快就陷入困局。当然，“三色公司”的问题很多，可以说几乎把零经验草根创业能犯的错都犯了个遍，但“不专注”是根本问题，毕竟只有想清楚做什么，才知道要怎么做，以什么样的组织形式、争取什么样的资源去做。</p>
<p>最困难时，我们只能靠派出合伙人去跟食堂大师傅打牌赢饭票度日。经历了一段时间的“惨淡经营”，“三色公司”以失败告终。</p>
<p>这是我的商业生涯经历的第一次挫折。从那时起我就明白了，对一家公司的生存与发展而言，没有“专注”，就没有一切。</p>
<p>那么，当我们谈论“专注”时，我们究竟在谈什么？我总结了专注的四个核心命题：</p>
<ul>
<li>清晰的使命、愿景。</li>
<li>深刻的洞察力，了解行业，了解用户需求，找到机会。</li>
<li>明确而坚定的目标及与之匹配的能力。</li>
<li>克制贪婪，少就是多。</li>
</ul>
<p><strong>边界在哪儿：清晰的使命、愿景</strong></p>
<p>几年前，小米内部有过一些讨论，讨论的主题是：我们的业务到底有没有边界？有人说，我们没有边界，理由是小米的方法论具有普适性，小米用户群的各种消费需求也越来越宽泛，似乎只要有用户基础，我们就什么都能做。</p>
<p>这样的认识是绝对错误的。一家公司怎么可能没有边界？没有边界的组织必将走向盲目和混乱。</p>
<p>有一句古训，叫作“有所为，有所不为”。要达成真正的专注，搞清楚哪些要为，哪些不该为，在具体事项的讨论决策之上，需要一个组织内的终极判断依据，那就是非常明确的使命、愿景，它是一家企业/机构最本源、最核心的行动指南，是观念层面的专注，是专注领域的大边界线。</p>
<p>我们如何定义使命和愿景？在跟不少企业家朋友的沟通中，我发现大家对使命和愿景的理解五花八门。最常见的，比如“争取卓越”“用户第一”“以用户为中心”是不是使命，是不是愿景？以我的观点看，这些都不是。</p>
<p><strong>使命，是企业/机构存在的目的和意义，是企业/机构努力为社会、大众提供的价值；而愿景，则是基于这样的使命，企业/机构最终希望成为的样子。</strong></p>
<p>使命和愿景的总结是一项非常严肃的工作，是塑造企业灵魂的过程。使命和愿景只有经过长期实践、思考和总结才会变得清晰可见，而随着公司的成长和思考的深入，使命和愿景还可能需要再修正和完善。使命和愿景并非大型公司所独有，再小的机构/商业实体都有自己的使命和愿景。比如，一家街边小超市也期望为社区的邻里提供方便的购物；一家小饭馆也会秉承“真材实料、童叟无欺”，用心给大家做一顿好饭。</p>
<p>暂时没有在形式上总结出确定、成文的使命和愿景的企业/机构，但凡能够获得成功，就说明它对自身的价值和远景已经有了明确的认知与共识。小米从诞生第一天起，就有用互联网思维和方法改变制造业、推动效率革命的梦想，已经有了朴素而明确的奋斗方向。在公司发展的第五年，2014年7月，小米第一次明确、清晰地总结了自身的使命和愿景。当时提出的使命是“让每个人都能享受科技带来的乐趣”，愿景则是“做用户心中最酷的公司”。</p>
<p><strong>克制贪婪，少就是多</strong></p>
<p>资源总是有限的，切口越小，压强越大，突破越有力。</p>
<p>所以，大到布局公司业务，小到定义一款产品，对于一个具体的业务目标，基于洞察和我们所掌握的基本能力，我们要做的就是不断收敛，专注于必要的“最小切口”。这也是我们一再强调“克制贪婪”，尽量追求“单点切入”的原因。</p>
<p><strong>一次解决一个最迫切的需求</strong></p>
<p>在业务选择上如此，在具体产品上也是如此。不要试图用一款产品解决太多问题，能最大化满足一项迫切需求，就是巨大的成功。</p>
<p>很多人问过我，产品的切口怎么选？小米内部在讨论产品时常说“单点突破，逐步放大”，一开始尽量聚焦到只解决用户一个迫切的需求，这样验证起来也非常简单。解决的问题要一句话就可以说清楚，比如小米充电宝解决的问题就是“怎样获得大容量、质量可靠又便宜的充电宝”。</p>
<p>我对此做了一个总结：</p>
<p>第一，一个明确而且用户迫切需要的产品，更容易找到明确的用户群。这样，产品研发出来后不容易走偏。</p>
<p>第二，选择的用户需求要有一定的普遍性，这决定了产品的未来市场前景。</p>
<p>第三，解决的问题少，开发速度快，容易控制初期的研发成本和风险。</p>
<p>第四，解决明确问题的产品，容易跟用户说清楚，推广也会相对简单。</p>
<p>以我们在2014年推出的一款爆款产品——空气净化器为例。2013年年初，北京的雾霾非常严重，最夸张的是当年3月，整整一个月北京的天空都是黄褐色的。当时空气净化器的价格普遍较高，进口品牌价格更是高达5000元甚至近万元，作为耗材的滤芯价格也要几千元；国产品牌但凡是正规厂家出产的，都要2000~3000元起，而且由于大多数产品是小厂出产的，所以供给能力有限。当人们受困于雾霾，对空气净化器有着迫切需求时，市场供给却严重不足。</p>
<p>在这种情况下，我们快速孵化了一家生态链公司，做出了设计、性能媲美5000元以上进口品牌的产品，仅售899元。因为我们的空气净化器解决的问题特别聚焦、特别迫切，也没有其他品牌如“离子香氛”等花里胡哨的功能，市场客群广泛，而且开发迅速、上市供给充足，性能、价格几乎无可挑剔，所以一上市即大获成功，小米一举成为中国空气净化器领域的第一，一直保持至今。</p>
<p>反过来看，试图用一款产品来解决很多需求，除了产品开发、推广难度大，未必能够凭借功能的数量优势赢得竞争优势，有时候甚至会误导开发者。消费电子业一个比较典型的例子就是索尼出品的掌上游戏机PSP，在游戏机的定义之外，它还有巨大的野心，想打造成21世纪的多媒体娱乐终端，但结果却未达预期。尤其是在智能手机崛起之后，除了严守游戏机定位、专注游戏的任天堂，其他所有的掌机都失去了生存空间。</p>
<p><strong>决定不做什么跟决定做什么一样重要</strong></p>
<p>“少就是多”最典型的案例就是苹果。众所周知，苹果的产品线极为精简，iPhone每年只出一代，虽然现在也有不同的细分型号，有mini、Pro、Pro Max等不同版本，但本质上还是同一款产品，依然保持着极少的SKU数量。</p>
<p>这种精简产品线哲学来自苹果起死回生的历练。1997年，苹果几近破产，就把乔布斯请了回去。一回到苹果，乔布斯就传达了一个理念：决定不做什么跟决定做什么一样重要。乔布斯跟几十个产品团队开会，对所有产品进行评估，结果显示苹果的产品线十分分散，光是麦金塔电脑就有无数个版本，每个版本还有一堆让人困惑的编号，从1400到9600都有。花样繁多的产品，在乔布斯眼里大部分都是垃圾。</p>
<p>“我应该让我的朋友们买哪些？”乔布斯问了个简单的问题，却得不到简单的答案。他开始大刀阔斧地砍掉不同型号的产品，很快就砍掉了70%。</p>
<p>几周过后，乔布斯还是无法忍受那么多的产品，在一次产品战略会上发飙了。他在白板上画了一条横线和一条竖线，画了一个方形四格图，在两列顶端写上“消费级”“专业级”，在两行标题写上“台式”和“便携”，然后说：“我们的工作就是做四个伟大的产品，每格一个。”说服董事会后，苹果高度集中研发了iMac G3、Powerbook G3、Power Macintosh、iBook四款产品。</p>
<p>当时苹果距离破产也就还有不到90天的时间。在此危难时刻，乔布斯只用了一招撒手锏——“专注”，就力挽狂澜，让苹果从1997年亏损10.5亿美元，变成1998年赢利3.09亿美元，起死回生。</p>
<p>用尽量少的产品满足用户最关注的需求，是一种超凡的能力。少就是多，背后是极为精准的行业发展与用户需求洞察、极为清晰的产品/战略思路，以及基于强大产品力的超凡自信。</p>
<p><img  src="./image-20250305214814435.png"  ><span class="image-caption">image-20250305214814435</span></p>
<p><strong>全局“对表”，实时校验</strong></p>
<p>“克制贪婪，少就是多”，听起来是特别显而易见的道理，但在进入业务扩张期的公司的实际运营中，想要一直做到这一点极不容易。</p>
<p>当我们聊专注时，通常会集中在一家公司的创业阶段或一个产品品类的开拓阶段。但专注只针对初创企业吗？显然不是。</p>
<p>那么，业务扩张与保持专注矛盾吗？并不一定矛盾，关键看四个判断标准：</p>
<p>1.是否符合公司的使命、愿景和战略。</p>
<ol>
<li>能否与公司核心业务形成显著的强协同并形成闭环。</li>
<li>能否为用户提供一致性的价值与体验。</li>
<li>公司的资源是否支持。</li>
</ol>
<p>我们曾经看到，很多强有力的企业在推进业务多元化，看起来有用户、有资金、有推广/渠道资源，但往往不甚成功。比如曾有房地产巨头进军饮用水行业，但因无法形成协同闭环，最终失败，这并不意外。</p>
<p>曾经有很多人问，小米一开始只做手机，后来做的领域越来越多，以至有一种声音说小米不再专注了，做成“杂货铺”了，这是不是真的呢？</p>
<p>从根本上看，这种说法是错误的。小米始终坚定地坚持着专注目标：从终极使命看，坚持做“感动人心、价格厚道”的好产品，让全球每个人都能享受科技带来的美好生活；从运营模型和产业抱负看，始终坚持探索、追求在更多产业环境下更高的生产、流通效率，推动整个商业领域持续推进效率革命；从业务布局看，始终坚持围绕用户关于科技应用的消费需求，构建全场景的智能生态。最关键的是，小米的主业一直足够聚焦，更多的品类是帮助、支持生态链兄弟公司来做（关于生态链模式，后文将有详细介绍）。</p>
<p>只有贯穿长期目标、始终围绕用户真实需求出发、与核心业务构成强协同的业务拓展，才能真正驱动企业发展的飞轮。而且，每一项新业务的拓展都以之前业务坚实的发展模型和预期为基础，这样才能保证每一个发展阶段都能集中精力，专注地开拓一项业务。</p>
<p>小米正是这么做的。生态链业务的崛起，是在手机业务一度站到世界前三、中国第一的基础上，而IoT业务的爆发则是站在生态链快速推进的肩膀上。</p>
<p>但在具体执行中，过去几年，小米的确在专注方面出现了问题。在一些业务中缺乏克制、业务失焦，既浪费了公司资源，也无端消耗了公司品牌资产，拖累了公司战略的聚焦推进，同时也对用户体验形成了伤害。</p>
<p>解决这个问题的关键就是“对表”，从上到下统一思路，既要有统一的专注目标，还要进行“校验”，时时检查保证不走偏。</p>
<p><strong>时时反问自己三个问题</strong></p>
<p>管理领域有一条公理，即组织一旦成立，就有无可抑制的自我成长的冲动和诉求。对一家公司而言是这样，对这家公司内部的任何一支团队而言也是如此。组织的成长，通常都源于设立的各类项目，还有与项目相匹配的人力、资金等各类资源的要求，以及最为关键的一点：营业额或利润的增长。营业额、利润一涨，往往马上会带动组织成长欲望的“局部正循环”。</p>
<p>但是，任由这样的“局部正循环”“野蛮生长”，往往并不能带来“全局正循环”，而是会指向一种近乎失控的状态。这里的关键问题就是，局部组织的行动方向与公司整体方向是否严格对齐？如果放任偏差，哪怕只是失之毫厘，最终也一定是谬以千里。</p>
<p>下面有两种公司核心战略的表达，你如何看待它们之间的区别？</p>
<p>第一种是2019年年初，我们内部提出的一项新的战略总结：“手机+AIoT双引擎”。它非常直观地表现出公司的两大价值集群，并体现了两者共同推进公司成长的战略表述。但是，在宣布实施一年半后，我们发现这项战略是错误的，甚至对公司业务产生了比较严重的误导。</p>
<p>错误的本质在于，用加号连接并列的“二元业务核心结构”使得公司的战略执行出现了失焦。手机业务的增长和AIoT的增长似乎成了两件事，让AIoT相关业务群更加倾向于独立的用户数和连接数的提升，以及网站成交金额的增加，迷失了“手机”和“AIoT”共同构成的“智能生活”体验的核心目标。</p>
<p>比如大家电业务，一开始从1999元的10kg智能滚筒一体机切入，凭借领先的智能体验、精美的设计、扎实的做工和性能，取得了成功。但在团队内部制定目标时，由于急于实现规模增长，很快做出了诸如售价799元的非智能波轮洗衣机等一批传统产品。</p>
<p>799元的传统波轮产品好不好？当然好。但是，这样的产品是我们需要的吗？相比其他同行，这款产品在性能、体验上差不多，只是价格稍微厚道一些，用料品质好一点，但这对增进用户使用体验、为用户提供独特价值，以及建设科技生态有帮助吗？甚至，这是不是对公司品牌资产的一种稀释与浪费？</p>
<p>一款产品的上市不只是可能多一份销售额，每增加一个存货单位，开发成本、市场成本、客服/售后成本、仓储物流成本、销售运营管理成本等一系列成本都有增加。在公司总资源有限的情况下，我们的团队把力气花在这样“用户价值增益”不明显的产品上，显然是不值得的。</p>
<p>这就是部门增长目标与集团整体目标发生了背离。分开看，每个团队各自都挺专注，但合起来一看，离专注就十万八千里了。</p>
<h3 id="极致"><a href="#极致" class="headerlink" title="极致"></a>极致</h3><p>提到极致，人们往往会想到互联网创业者们的一系列口号。很多人都提出了对它的理解和描述，比如“玩命死磕”“不惜代价投入”“做到超乎想象”等等。这些对吗？可能都对，但不全面。极致既是一种产品观，又是竞争策略，还是经营策略。</p>
<p>这三类都包含其中的总结，我首先想到的是“谷歌十诫”，我当初曾要求金山的每一位员工都能背诵。时至今日，我还能很轻松地背出来。这十条中我印象最深的是“把一件事情做到极致”和“仅仅优秀是远远不够的”。仔细揣摩一下，就可以理解为什么从谷歌搜索到Gmail，再到谷歌地图等，当年谷歌几乎每个产品都让用户癫狂——因为极致。</p>
<p>那么，什么叫极致？我的理解是，极致就是做到自己能力的极限，做到别人做不到的高度。</p>
<p>在实践中，“极致”有两重含义：</p>
<ol>
<li><p>心智上的无限投入，不遗余力争取最好。</p>
</li>
<li><p>无限追求最优解，认知触达行业和用户需求的本质。</p>
</li>
</ol>
<p><strong>做到自己能力的极限</strong></p>
<p>极致首先是一种精神与意愿，表现为心智上的无限投入，不断挑战自己的极限。为了获得最出色的结果，有极强的主观能动性去探索、发现、总结。在自己专注的核心领域和方向上，不要“差不多”，没有“够好了”，要的是“再努一把，能不能更好”。过去有句话叫“高标准，严要求”，那么极致就是“始终更高标准，玩命更严要求”。</p>
<p><strong>先有一颗不妥协的心</strong></p>
<p>追求极致，说起来很容易，做起来很难。难的不是创造极致的过程，而是能发现很多司空见惯、熟视无睹的不美好、不完善，同时对这些不美好、不完善决不妥协、决不容忍。</p>
<p>比如说，我们有多少人用笔记本电脑？有多少人用苹果笔记本？我永远弄不明白，为什么有些笔记本电脑的充电器又大又难看，还那么难用？为什么没有一家公司把充电器改得像苹果电脑的充电器一样漂亮？我们以前的时髦是每天带着笔记本上班，却还要装一个难看又难用的充电器，真的很痛苦。</p>
<p>小米决定做笔记本电脑后，我就提了一个非常明确的需求：在保障性能、安全、可靠性的前提下，尽量把充电器做小、做轻、做好看。终于，在2020年小米十周年之际，有了一个让我满意的优雅的解决方案。得益于材料科学的进展，我们的研发团队跟上游合作伙伴一起，经过几年的尝试，终于做出了足够优雅、精美的笔记本充电器。</p>
<p>这就是我们推出的GaN（氮化镓）充电器，它的尺寸甚至比很多手机充电器还小，但它的充电功率高达65W，这是个什么概念呢？对一般手机而言，用它充满电只要50分钟左右；而对于搭载了支持65W以上快充技术的手机，充满电则只要40分钟左右。它不仅能给手机充电，还能给平板电脑、笔记本电脑和各种Type-C充电口的消费电子产品充电。这意味着出差时你只需要携带一个充电器，就能满足所有的充电需求。</p>
<p>这是目前最小巧精致的笔记本充电器，得益于GaN这种半导体材料效率高、发热小的特性，小米的工程师经过长期研发，能够把它的创新应用技术提升到足以放进如此小的体积内，并且能够大规模量产的程度。随着我们的大力推动，仅用2年时间，GaN技术就在全行业高端产品线中迅速普及。但让我骄傲的是，小米推出的设计、制造方案，依然是全行业最为精巧、优雅的。</p>
<p>我非常乐意向我的朋友和客人们推荐这款产品，这是真正能让生活变得美好的产品，是真正让我满意、让我自豪的产品。</p>
<p>对不完美不妥协，对一切丑的、难用的产品和服务细节不容忍，并且有巨大的热情和动力去改变，这是极致的前提。</p>
<p><strong>别人看不到的地方也要非常好</strong></p>
<p>在沃尔特·艾萨克森所著的《史蒂夫·乔布斯传》第12章中，记载了一个让所有产品人都灵魂震颤的故事：</p>
<blockquote>
<p>乔布斯从父亲身上学到，充满激情的工艺就是要确保即使是隐藏的部分也被做得很漂亮。这种理念最极端也是最有说服力的例子之一，就是乔布斯会仔细检查印刷电路板。电路板上是芯片和其他部件，深藏于麦金塔的内部，没有哪个用户会看到它，但乔布斯还是会从美学角度对它进行评判。“那个部分做得很漂亮，”他说，“但是，看看这些存储芯片，真难看。这些线靠得太近了。”</p>
<p>一名新手工程师打断他说这有什么关系，“只要机器能运行起来就行，没人会去看电路板的”。乔布斯的反应和往常一样：“我想要它尽可能好看一点，就算它是在机箱里面的。优秀的木匠不会用劣质木板去做柜子的背板，即使没人会看到。”几年之后，在麦金塔电脑上市后的一次访谈中，乔布斯再一次提到了当年父亲对他的教导：“如果你是个木匠，你要做一个漂亮的衣柜，你不会用胶合板做背板，虽然这一块是靠着墙的，没人会看见。你自己知道它就在那儿，所以你会用一块漂亮的木头去做背板。如果你想晚上睡得安稳的话，就要保证外观和质量都足够好。”</p>
</blockquote>
<p><strong>改改改改再改改</strong></p>
<p>极致只属于天赋异禀的天才吗？我完全不这么认为。相反，我始终相信，极致是可打磨、可训练的。要有一颗始终不满足于现状、不安于平庸的心，以及在枯燥痛苦的持续改善中始终追求完美的耐性。</p>
<p>我们的一位联合创始人阿黎（黎万强），早年就在金山负责UI/UE（用户界面/用户设备）设计，是国内互联网软件行业最早一批专职的UI设计师之一。在金山的时候，阿黎的团队就以疯狂打磨设计著称，经常拿着设计稿，在公司里到处找人测试、要反馈，从5楼找到1楼，最后连金山食堂的大厨都被他拽着不放。</p>
<p>到了小米之后，无论是带MIUI团队，还是带小米网电商团队，阿黎的团队依旧疯狂反复打磨，甚至在产品上线前几天还会把方案全盘推翻重来。</p>
<p>以小米手机包装盒为例，我们的包装盒不仅外观设计风格极简，还选用了当时全球结构强度最好也最贵的牛皮纸作为原材料。2012年，我们做过一次测试，两个体重加起来超过350斤的同事叠在一起站在盒子上，包装盒毫无损坏、稳如泰山。从此，叠罗汉踩盒子成了用户测试我们的包装盒的一个经典玩法。</p>
<p>这背后，是整个设计团队历时6个月，经过30多遍结构修改，上百次打样，做了一万多个样品，最终才有了小米手机包装盒令人称道的工艺和品质。这个风格的包装盒我们沿用了很久，后来在推进新零售战略时，为了适应线下渠道货架展陈的需要，我们才改变了外观设计，但坚固的品质传承了下来。</p>
<p>熟悉小米的用户可能知道一个梗，那就是“发布会前，雷军连夜说服高管调低价格”。这其实是事实，不是编的故事，当然价格只是其中一个话题而已。</p>
<p>其实，发布会前夜都不一定是“最后期限”。通常而言，对于产品是否发布、工厂后续产线安排的细节调整、产品销售运营策略和发布方法，可能直到发布当日的午间，我们还在做最后一次集中讨论修改。</p>
<p>我印象中最挑战极限的一次，是在2013年米粉节的发布会前。距离开场还有几分钟，我和团队在后台，大家突然觉得有必要再做一次讨论和关键内容修改。讨论完，业务团队马上通知后端执行的同事，市场部的同事马上改对应的PPT内容，我闭上眼深呼吸几口，然后走上台，发布会正式开始。</p>
<p>我们的设计团队曾经做过一张在小米内部非常著名的海报：改改改改再改改。不断修改和打磨对小米的团队而言已经成为一种习惯，不到最后一刻，绝不停止思考和打磨。</p>
<p>这些年来，我跟很多做出过精彩、伟大产品的团队交流过。尽管行业千差万别、个性各有不同，但都有一个相同的特征：了不起的极致产品不是只靠一个天才的想法、一个突然出现的灵感就能做出来的，而是要经历长期痛不欲生的修改，一点一点打磨出来。</p>
<p>事实上，产品的发布不是终点，产品的发售也不是终点。互联网方法论告诉我们，产品卖出去时，才是跟用户关系的开始。产品也需要持续更新，一代一代迭代改善，改改改改再改改，是一条没有止境的路。</p>
<p><strong>全身心投入，不留余地</strong></p>
<p>在这些年的投资经历中，我发现了一个有趣的现象：有过创业成功经验的团队二次创业的成功率往往不高。对创业而言，资源太多，反而是一种拖累。</p>
<p>这不是故弄玄虚。创业者一旦在创业之初就想着有多少资源可以借用，往往就不能在产品、体验和创新上百分之百地投入。没有其他资源，创业就是背水一战，反而更容易做出极致的产品。</p>
<p>“人若无名，便可专心练剑”，对于张艺谋导演的电影《英雄》里的这句话，我非常有感触。在开始创办小米时，我隐姓埋名了一年多时间，所有入职的同事也必须签保密条款，不让人知道小米是雷军的创业公司，严禁使用任何外部资源。这么做只为一条准则：一切靠产品说话，一切只靠产品说话。</p>
<p>前面说过，我们创业的朴素初心是“做全世界最好的手机，只卖一半的价格”。小米刚刚起步，我的设想是，只做一款手机，要做就要堆料堆到无以复加，性能上率先用全球顶级的芯片，配备超过当时主流容量一倍的大内存，同时所有的元器件非“苹果供应商”不用。</p>
<p>在我“躲起来”创办小米的时候，我的一个朋友听说我要做手机，但还不知道我的具体计划，就给我发消息说：“如果你真的想做手机，那就只做一款。”因为，如果一款打不过，做一堆，还是打不过。</p>
<p>事实的确如此。做小米第一代手机时，小米还非常小，无论是资金还是行业资源，都完全承受不起失败。事实上，在发布前，几乎没有人相信小米能做成，但我们还是相信，虽然我们完全没有硬件工业基础，但产品和体验的很多原理，是跨行业相通的，只要我们真的全身心投入，一定有机会。</p>
<p>所以，我一直主张，在开发一个新项目、准备一个新产品时，先不要想你可以去外部找什么借力，或者同时做几款覆盖多少档位的后续产品，只考虑一件事：如何激发团队的全部能力，把这个新项目或新产品当作一局定生死的唯一机会，全身心投入，看看极致能到什么程度。</p>
<p>2011年时，我的一个创业者朋友在凌晨两点给我发了一个短信，说“终于明白啥叫‘极致’了，极致就是把自己逼疯，把竞争对手逼死”。“把自己逼疯，把别人逼死”，我虽然不太喜欢这种过于强调竞争博弈的表达方式，但这种不给自己留余地的精神，就是极致的精髓。因为不留余地，所以必须惊艳，否则就是死路一条。</p>
<p><strong>无限追求最优解</strong></p>
<p>什么才是极致的产品，我理解有两个条件：一是产品要惊艳，设计要惊艳，成本也要惊艳；二是超出了用户预期，真的能让用户尖叫。</p>
<p>要满足这两点，就要无限追求每个产业发展阶段的产品最优解。最优解就是当下的最大化用户价值，也是绝对的竞争优势。</p>
<p><strong>最优解是绝对竞争优势</strong></p>
<p>在产品设计上追求极致的重要性在于，先行者占有很多优势，如果有极致的想法，往往能做出唯一答案。</p>
<p>这是一种能让竞争者绝望的优势。在指纹解锁技术成熟之前，小米的研发团队曾经设计了652种解锁方案，最后发现还是比不上苹果的滑动解锁。在那个时代，那个方案是唯一的解，是绕不过去的，是最好的，是最极致的。</p>
<p>最优解通常出现在哪里？我们发现，最优解本身往往并不在于性能指标（按照摩尔定律，性能指标总是会不断提升的），而是源自基于用户需求的更简化或者更集成的实现方法。</p>
<p>举个简单的例子，当用户需要发短信给某个联系人时，一般系统需要6步操作，而MIUI只需要3步，这就是一个最小单元的最优解——因为通过精心设计，其他竞品已经没有办法精简到更少的操作步数了。</p>
<p>又比如，索尼在CRT（阴极射线管）显示时代的巅峰，源于特丽珑阴极映像管（又称单枪三束管）的独特设计工艺，而其他竞品中最接近的也要使用三根电子枪，这使得索尼的方案色彩表现力出色，而且色纯度和色平衡容易调节，这种极致的工艺给索尼带来了长达数十年的最优解地位。</p>
<p>而更集成的方案，是把复杂多样的需求先行解构，再重新结构化，用完备而可扩展的功能体系来满足用户多样的需求。事实上，日本的消费电子业界在迈向全面数字化的过程中，因为在架构的“系统体系性”方面丢掉了曾经的优势，导致无论是随身听还是数码相机等曾经辉煌的电子产品，最终都在以智能手机为代表的一体化、数字化浪潮中消亡。</p>
<p>小米MIUI的开发团队早年经历过很多需要突破最优解的痛苦，但最后都拿出了很多最优解方案，比如在系统个性化方面的产品架构。</p>
<p>相比偏向封闭的iOS，安卓最大的特性是定制化程度高，这就使得用户更容易实现系统个性美化。小米的MIUI系统把这一点发挥到了极致，我们做出了“百变主题”的方案，不仅建立了中国安卓定制系统领域中最庞大、最精彩的第三方设计主题生态，甚至还能按照桌面、图标、解锁方式、铃声、音效等来自不同主题包的方案进行自由搭配，让每个用户都能轻松做出只属于自己的独一无二的系统界面。这就是更集成化最优解的典型案例。</p>
<p>这套产品方案在2011年小米第一代手机发布前就做出来了，时至今日，仍然是安卓生态中系统个性化的最优解。</p>
<p>正是凭借做出了大量这样的“最优解”创新，MIUI一直引领安卓定制系统生态的风潮，有用户开玩笑地称“万物基于MIUI”，这也成为小米手机长期以来的强大卖点。</p>
<p>我们几乎可以确信，在每一个技术世代，在产品设计方面，对应每一个品类、每一种需求，都存在一个最优解。如果你专注的领域中还没有发现公认的最优解，那么恭喜，你还有非常大的机会不断接近它，直到找到它，并建立起强大的竞争优势。</p>
<p><strong>再不起眼的产品都有最优解</strong></p>
<p>也许有人会怀疑，真的是每个品类、每个需求都存在最优解吗？在很多产品形态几年甚至十几年、几十年没有变化的领域，也是如此吗？</p>
<p>以一个小到大家会觉得很不起眼的产品——小米MIUI系统自带的计算器App为例。乍一看，这个产品太过稀松平常了，自手机自带计算器以来，几乎就没什么可折腾的空间，能应付日常加减乘除不就够了吗？再讲究点儿，加上科学计算器功能，似乎就到顶了。毕竟，科学计算器平常又有多少人用得到呢？</p>
<p>不过，当移动互联网时代到来，在有着强烈互联网意识的团队眼中，计算器就不再是一个简单的系统工具，而是一个互联网服务入口。</p>
<p>MIUI系统的计算器非常好用，可以一直跟踪显示连续运算中的每一步，其中任何一个数字都可以被调用复制或修改。这意味着，进行一串复杂计算时，你随时可以复查任何一步的数字输入是否有错，并且马上修改。</p>
<p>到这里，这个App的强大已经秒杀了市面上所有的手机系统计算器App，对经常演算的用户来说，这就解决了一个巨大的痛点。但这只是开始。</p>
<p>我们在日常生活中跟数字和计算打交道最多的需求是哪些？我们做了个统计，无非是各种汇率、度量衡的换算，再复杂些的还有个税和房贷的计算。基于移动互联网LBS和各类服务接口的功能，这些需求MIUI的计算器App都能满足。</p>
<p>我们还集成了一项“亲戚称呼计算”的功能，比如“爷爷的哥哥的女儿叫什么？”，输入后马上就有答案——“堂姑”。这个功能在过年走亲戚时特别有用，被认为是最神奇的计算器功能。</p>
<p>这么一款不起眼的系统App，MIUI团队就挖掘出如此强大的新应用场景，而且还在随用户的需求变化不断更新，让开发的同事们可以自豪地说：这就是最优解。总结一下，首先，这款产品不是一个纯数字计算工具，而是一类基于数字计算和换算的互联网服务入口；其次，它把相关功能梳理为“计算”“换算”“税贷”三类，做到了整类应用的结构化建构。</p>
<p>我相信，只要是还没有出现被公认最优解的地方，就有巨大的机会和空间。而要追求和实现极致，就要持续追求最优解，一次性把事情做对，不要“来回拉抽屉”反复干。</p>
<p><strong>没有永恒的最优解</strong></p>
<p>替代一匹快马的，不一定是一匹更快的马，而有可能是蒸汽机车。</p>
<p>经历过CRT电视机和显示器时代的人，还会记得一个特别响亮的名字：“索尼特丽珑”。和随身听一样，特丽珑显像管是索尼对整个世界影响力最大的技术发明之一，也是CRT时代电视机和显示器最佳品质的同义词。截至1994年，索尼卖出了超过1亿台电视机，是当时绝对的王者。</p>
<p>不过，所有的最优解都有极强的时代性。特丽珑是显像管时代的技术顶峰，但显像管也有功率大、体积难以做轻薄、分辨率提升难度巨大等一系列局限。当技术发展进入下一世代，前代的最优解价值就烟消云散了。事实上，索尼正是因为对特丽珑的最优解优势太过贪恋，才在平板显示时代到来之际落后于竞争对手的等离子、LCD（液晶显示屏）技术，丢掉了全球电视机和显示工业的绝对领先地位。</p>
<p>而前面说到的苹果滑动解锁的最优解，也随着指纹解锁技术的成熟而消亡了，被屏下指纹技术+结构光人脸识别技术所取代。</p>
<p>对所有的后来者而言，前人的优势再完美，也总有机会弯道超车；而对曾经的极致创新者而言，如何保持持续追求最优解的能力，就成了对“极致”的本质理解。</p>
<p><strong>任天堂为什么是“世界的主宰”</strong></p>
<p>极致的最高境界就是认知领先于全行业，率先洞察、抵达行业和用户需求的本质。毕竟，人无法做出超过自己认知的产品。只有认知始终领先，才能保障长期不断产出极致产品的能力和环境。</p>
<p>最典型的例子来自游戏行业。</p>
<p>游戏的本质是“创意”和“乐趣”。任天堂前社长岩田聪在GDC 2005论坛上做的一次堪称经典的主题发言，我至今都记忆犹新。他谈的最重要的观点就是“玩者之心”。一家游戏公司成功的关键在于，必须营造热爱游戏的文化，每一个人都必须是游戏玩家！这样的公司才能获得持续长久的成功。</p>
<blockquote>
<ul>
<li><p>在我的名片上写着，我是一个公司总裁。在我自己看来，我是一个游戏开发者。在内心深处，我实际上是一个玩家。</p>
</li>
<li><p>你是否曾经为了一款自己都不愿意玩的游戏而辛苦开发呢？</p>
</li>
<li><p>即便我们来自世界的不同地方，即便我们说着不同的语言，即便我们吃着不同的食品或者饭团，即便我们在游戏中有不同的体验，但今天我们在座的每个人都有一个非常重要的相同点。这个相同点就是我们都拥有同样的“玩者之心”。</p>
</li>
</ul>
</blockquote>
<p>当被问及如何看待和其他公司的竞争时，他回答：我从来不觉得任天堂在和其他公司竞争；任天堂应该做的不是和其他公司竞争，而是关注玩家的感受；任天堂的敌人是“不关心玩家”的思想。</p>
<p>因为这样的投入与认知，任天堂持续拿出了无数的最优解，比如FC游戏机确立了游戏设备上的“十字按键”标准，比如1983年出品的《马里奥兄弟》定义了平台跳跃游戏的一系列范式，比如在N64设备上的《超级马里奥64》定义了3D游戏的视角等众多操作实现方式，比如Wii开启了全家参与的家用游戏。此外，任天堂最新的游戏机平台Switch创新性地开创了家用游戏机和掌机的融合形态，而它的首发护航游戏《塞达尔传说：旷野之息》赢得了业内顶级大奖TGA（The Game Awards）2017年度游戏、最佳游戏设计和最佳动作冒险游戏。在这款自由度惊人的开放世界游戏中，玩家们可以自由借助游戏中的各类场景，创造出点火产生上升气流飞天、砍树搭桥过河等各种超出想象又无比真实的玩法，从而产生“这里是个真实世界”的前所未有的沉浸感。如此的创意，实在是令人惊叹。</p>
<p>任天堂拥有百年历史，从做纸牌起家，后来也做过玩具、游戏场生意，对“娱乐”的理解算是刻在了这家公司的灵魂里。从以“Game &amp; Watch”这样一块电子印刷屏掌机和“大金刚”这样的街机产品进入电子游戏行业开始算，任天堂在游戏行业沉沉浮浮50年。论体量，它的市值远不如索尼、微软；论游戏机性能，在新千年之初的GameCube（任天堂出品的一款游戏机设备）之后，无论是家用机、掌机，还是如今融合了家用机、掌机的Switch，任天堂的硬件产品都远逊于同时代的竞争者。比如在掌上游戏机领域，任天堂的NDS系列在性能、画质、多媒体能力方面远逊于索尼的PSP，但前者的全生命周期销量是后者的近两倍，软硬比（即硬件销量与软件销量的比值，软件销量越多越成功）更是遥遥领先于PSP。</p>
<p>正是因为对“创意”和“乐趣”的深刻认知，任天堂的产品在“游戏性”方面做到了同时代产品的极致，尽管任天堂在20世纪末也曾遭遇危机，但都迅速再度辉煌，至今依然屹立不倒。电子游戏行业有一个非常著名的说法：“任天堂是世界的主宰”，这是对一家极致公司的最高褒奖。</p>
<p><strong>极致不是自嗨和自我感动</strong></p>
<p>极致是一枚尖锐的钉子，我们铆足了劲儿敲钉子时，要小心钉错了地方。</p>
<p>追求极致切忌“盲目自我感动”，需要基于对行业、用户需求的深刻洞察，以“专注”的方向为指导，时时校验，防止跑错方向。</p>
<p>小米创业的前5年可谓所向披靡，但那时我们的基础还很不扎实，对制造业的理解也不够深入，曾经闹过不少笑话。</p>
<p>2016年我接手手机部，发现小米手机的螺丝钉供应商只有一个，价格比同行贵5倍。找到那家供应商的老板一问，才知道是因为我们选料特别夸张，用的比别家好无数倍，而且每个螺丝钉上都铣出个小米的标识。我又问，您怎么进的小米供应链？他说因为我以前是苹果供应商。我说您现在还有哪几个客户？他说：“我现在只服务小米，我的东西好到连苹果都用不起了，只有小米能用得起。”</p>
<p>我哭笑不得，我们真的需要在螺丝钉上搞个小米标识，然后花同行5倍的钱吗？反正小米是傻乎乎地用了很多年。</p>
<p>类似的事情还有很多，比如手机包装盒中附带的卡针，同行中比较讲究的用铝合金，大多数中端及以下产品都是用塑料材质，成本不过几分钱。但从2011年起，不论什么样的手机产品，我们用的都是不锈钢铣出来的，成本要2元，甚至我们当时售价只有499元的红米入门机用的也是这样的卡针。2元在业内听起来简直是天价，尤其是当时一年出货量以五六千万台计时，就是一个很惊人的数字。</p>
<p>有同事曾追问我，苹果不是也追求看不见的地方也要做得很好吗？为什么我们用这样精雕细琢的螺丝钉就不对呢？我们不是一直都说要极致，要不惜成本吗？</p>
<p>我回答，区别还是挺明显的。把电路板做得特别工整，展现出的是对产品品质的溢出式的追求，虽然看起来是“溢出式”的，但实际上保证了整体设计和品质一定是过硬的，这对用户而言是有直接价值的。而卡针基本上是“一次性”使用，不少用户家里都有不止一个，花溢出的价值就几乎全是浪费，至于我们花成本在螺丝钉上铣小米的标识，对用户而言有一分钱的价值吗？这不是自嗨是什么？我们不要在自嗨上浪费宝贵的成本，应该用到真正对用户有用的地方。</p>
<p>如果追求极致的努力不在用户需要的正确方向上，或者不在公司专注的方向上，那么花的力气越大，离题越远，此时的投入和努力只能沦为一种“秀情怀”的噱头，或者是一种无用的“炫技”，抑或是一种盲目的“自我感动”。</p>
<p>我们不仅反对“自嗨”和“自我感动”，更要反对把“极致”做成华而不实的噱头。比如10年前的消费电子行业，有人在手机机身镶嵌宝石作为核心卖点，有人把数码相机机身采用所谓“哥窑瓷”等作为核心卖点，这些不过是为了炫耀所谓的“极致奢华”来谋求溢价，但产品本身却稀松平常。缺乏诚意的产品显然只会迎来失败。</p>
<p>乔布斯所说的橱柜的背后用料扎实、做工精美，前提是这个橱柜整体设计非常出色且质量过关。如果一个橱柜的全部亮点只是背面做得精美，无疑是一个蠢到家的笑话。</p>
<p>把噱头当极致，是自欺欺人的行为。用户不傻，他们会用脚投票。</p>
<p>所以，当你撸起袖子准备大干一场时，我建议你反复问自己三个问题：</p>
<ul>
<li>我们追求的极致是不是用户真正需要的？</li>
<li>我们追求的极致是不是能成为产品/服务的核心竞争力？</li>
<li>我们追求的极致是不是能形成长期可持续的竞争壁垒？</li>
</ul>
<p>所以，把钉子往哪儿钉，决定了“极致”的价值。钉的地方对了，像苹果率先拿出触控电容屏技术，支撑起了现代智能手机形态和交互方式；而如果错了，就像索尼当初力推的MD（Mini Disc）Player，无论它的机械结构多么精巧迷人，索尼的工程师们对它有多迷恋，都难逃迅速被MP3播放器淘汰的命运，消失在历史的黄沙中。</p>
<p><strong>追求极致的本质是投资未来</strong></p>
<p>将“哥窑瓷”工艺作为核心卖点的数码相机，被看作是“拿噱头当极致”，那么，小米也出过一系列以陶瓷机身为卖点的手机，这是自相矛盾吗？</p>
<p>不矛盾。首先，小米的产品，无论选择什么样的工艺，都是基于产品本身同档最强性能，这是任何消费电子产品的定义属性；同时，作为这个时代“人最亲密的伴侣”，我们一天要拿起手机上百次，拿着手机的时间长达几个小时，材质、工艺带来的手感，是手机体验最重要的组成部分之一。</p>
<p>坚固耐磨、触感如玉、光泽优雅的陶瓷，显然是一种非常优秀的材质，但过去为什么就没人在手机上试过呢？因为它的缺点也非常明显，一是硬度超高（达到莫式硬度8，仅次于刚玉和金刚石）；二是工艺难度太大，要做成手机中框和背壳这样的大小、强度和精度，良品率太低，工程师说，一开始，烧一炉陶瓷出来全是碎的，心也跟着碎了；三是成本更高，是金属材质的3~4倍。所以，这种特殊的陶瓷过去只被用在高端烤瓷牙上，因为尺寸足够小、成型足够厚、价格足够贵。</p>
<p>初期没有太多进展的烧制试验几乎就是在烧钱，工程师们有点儿绷不住了，就来问我还要不要干。我反问他们，你们觉得这么干有多大价值？工程师们认定，陶瓷材质将在未来持续提供无可取代的独特体验。我说，那就干吧，再烧5000万元，如果不成咱们再说。研发团队一下子又有了信心，驻场坚持反复试验，终于在小米手机5时代实现了量产。</p>
<p>第一道门打开，后面的路上就有了光。工程师们果然兑现了他们描述的未来，从小米手机5的陶瓷背壳，到小米MIX陶瓷“中框+背壳”、小米MIX 2的Unibody一体化陶瓷（中框跟背壳的一体化成型）、小米MIX 3彩色陶瓷机身，再到小米MIX 4轻量化陶瓷工艺，一路进化，现在陶瓷已经成为小米最高端手机产品MIX系列最具辨识度的代表性元素，在手机业内也独此一家，被认为是手机领域最好的材质体验。在这个过程中，小米团队不仅把陶瓷工艺吃得越来越透，做得越来越好，更重要的是，对新材质工艺也有了更全面的理解和经验。后来，苹果在Apple Watch上也应用了同样的陶瓷技术。</p>
<p>2007年年初，乔布斯在台上激情澎湃地发布划时代的第一代iPhone时，在台下的台湾触控屏厂TPK的老板和技术负责人激动得放声痛哭。iPhone的多点触控电容屏彻底改变了智能手机的模样，但在这背后，苹果和TPK一起历时5年，经历了9次濒临放弃又重新坚定信心的奋斗，才拿出了这款划时代的技术。</p>
<p>触摸屏已经诞生超过20年了。从Palm OS的设备，到WinCE、塞班、Windows Mobile等系统，早就搭载了触控屏，甚至在20世纪80年代，IBM就发售过带触控功能的CRT电脑显示器。但是，这些都是基于工业应用思维的单点触控电阻屏，只能一下一下地用笔或指甲点戳，跟苹果的手指点划的自然交互逻辑不可同日而语。苹果率先天才地提出了新交互的构想，并且以毫不放松的苛刻的要求，以及无比的耐心和坚持，实现了这样前所未有的体验。</p>
<p>看到未来的新可能，再以超越常人的投入把它实现，这样的路注定充满痛苦。但真正有意义的事，通常都不容易，做到别人做不到的高度，才算极致。小米工程师的“心碎”、TPK老板的痛苦，都是这条路上的常态，也都值得。</p>
<p>经历过这样试炼的团队，将收获更有力的竞争优势、更广阔的业务视野、更雄厚的产品能力和研发技术积累，对产品和用户将有更深的理解，团队成员也将更有经验、自信和雄心。这一切产生最大价值的时候，不是获得成功的今天，而是拥有更多可能的明天。</p>
<p>所以说，今天对极致的追求，其实是在投资明天的竞争力。一家有强大生命力、创新活力、荣誉感、自尊心且有追求的企业，不会只盯着眼前一时的利益，而是能接受更长远的“延迟满足感”，这样才会有对极致的追求。</p>
<p><strong>口碑</strong></p>
<p>用户口碑是所有产品成功的关键因素，这是不言而喻的公理。</p>
<p>资源永远有限，对于创业公司尤其如此。只有专注，才能集中所有资源做一件事情，才能把这件事情做到极致；只有极致，才能从内心深处打动用户，用户才愿意口口相传，从而形成良好的口碑传播效应。</p>
<p>良好的口碑从何而来？我的理解是，好产品不一定能带来口碑，便宜的产品不一定能带来口碑，又好又便宜的产品也不一定能带来口碑，只有超过预期的产品才能带来口碑。</p>
<ul>
<li>口碑的产生基础：和用户交朋友，倾听用户意见，深刻了解用户需求。</li>
<li>口碑既是品牌策略，也是增长策略。产品/服务有口碑，就能自传播、自转化。</li>
<li>产品、服务和沟通等与用户所有触点的表现总和，才是口碑。</li>
<li>口碑的阈值是不断提升的，是用户价值长期稳定提升的倒逼机制。</li>
</ul>
<p><strong>销量第二，口碑第一</strong></p>
<p>这一节的标题其实还有一种写法：口碑是衡量产品、服务的终极标准。也许你会有这样的疑惑：为什么不是销量或者利润呢？有一些产品叫好不叫座，难道说这样的产品也是成功的吗？叫好不叫座的产品的确存在，销量和利润当然也非常重要，这是两个不同维度的事。什么样的产品叫好不叫座？比如一些艺术电影。但这类产品本身不是面向大众的，通常一部艺术电影的目标是艺术院线的观众，不会也不应该有面向大众卖座的预期。同理，任何领域的产品和服务如果出现了这种情况，就说明产品定位和规划出了问题。</p>
<p>之所以强调口碑第一，是因为口碑总是领先销量或利润一步，是与产品和业务形成正循环的要件。</p>
<p>我们分析一下正循环的构成：和用户交朋友，认真倾听用户的意见，深刻了解用户的需求，才能不断做出真正满足用户迫切需求，甚至是用户自己未能察觉的需求的好产品，才能赢得口碑；而口碑一旦形成，就能自传播、自转化，对于产品改善、业务推进具有强大的推力，而且这些推力完全是免费的、可裂变的。</p>
<p>很多人可能更多地把口碑视为一种传播红利和流量来源。但实际上，口碑不仅能自传播，更能自转化，基于朋友、熟人圈的推荐，具有无可替代的坚实背书能力和裂变能力。近年来，KOC（关键意见消费者）投放、私域流量运营成为业内热点风潮，很多企业为此投放了不少资源，但实际上，口碑本身就是最有效的私域流量和转化资源，我们大可不必舍本逐末、舍近求远。</p>
<p>退一万步讲，不管什么原因导致产品虽有口碑，但销量不算大，在短期内也是没关系的。毛主席说过，“存地失人，人地皆失；存人失地，人地皆存”。口碑就是业务的有生力量和群众基础，只要有生力量不灭，群众基础不毁，下一款产品操盘得当，依然能够获得成功。</p>
<p>所以，我们在业务决策中，一定要把口碑放在第一位。甚至要做好心理准备，部分产品只要口碑出众，哪怕销量有限甚至亏损也在所不惜。</p>
<p>关于口碑，小米历史上最典型的例子是小米MIX的第一代产品。这款产品的故事我们在后面的章节中还会提到，它来自一个我们完全不考虑量产性，更遑论销量、利润的概念机追求——探索“5年后的手机是什么样子”。它是全面屏手机的开山之作，史无前例的91.3%正面屏占比被业界评价为“指明了未来手机发展的方向”。同时，它还史无前例地使用了中框+背壳的全陶瓷机身工艺，却坚持小米价值观，定出了超乎人们想象的3499元起的厚道价格。</p>
<p>这样一款产品一经发布，立即震动了全球业界，赢得了巨大的口碑。以此为起点，小米MIX也出人意料地实现了量产，销量超过40万台。客观地说，这样的销量依然摊不平巨大的研发成本，从单一型号项目看是亏损的。但它带来的巨大口碑价值却是无法估量的，以此为起点，小米MIX作为小米最高端手机的产品线立住了，并且开启了围绕屏幕极致创新的持续进化延展。</p>
<p>口碑第一，就是用户感知第一。无论一款产品、服务做得多用心，无论用户的评价是不是完全公允（事实上，从长期、宏观看，口碑一定绝对正确；但从短期、微观看，一定会有局部的失真），无论面对产品预期与用户口碑的偏差时开发者有多委屈，我们都得确认一个评判原则：用户的口碑评价永远是对的。</p>
<p>5年前，我们的一家生态链公司发布了一款自有品牌的高端3匹变频空调，价格高达4000元。他们不惜工本，倾注了大量心血，体验也相当出色，自以为做了一款会赢得满堂彩的产品。但始料未及的是，用户口碑却崩了，销量自然也不出彩。当时闹到什么程度呢？甚至有米粉和我的朋友给我发消息，问我“小米怎么会做这样的事？”。</p>
<p>这家公司的团队负责人跟我说：“我们的产品是高端的，我们的利润设置相比同行并不过分，为什么还会被骂？”对不起，当用户觉得一款产品的表现不及他的预期时，你没有更多道理可讲，错了就是错了。这款产品的问题在于，它通过小米的平台出售，但它的产品力相比它的定价低于了用户的预期。用户对小米平台的“厚道表现”有一贯的高预期，生态链公司自有品牌在没有完全证明自己、赢得用户的充分信任之前，突然定出一个远超同业同标准主流产品的价格，就会挑战用户对小米平台的信任。</p>
<p>印象是无数事实累积验证得出来的，用户对产品的印象一定大过开发者讲的事实。我们一直希望赢得用户的信任，让用户相信小米平台上的商品可以“闭着眼睛买”，然而一次“破功”就会伤害用户对我们的信任，所以这是一个非常严重的错误。</p>
<p>从2019年开始，小米手机的高端化之路稳步前行，逐渐被用户信任和接受，才有了显著的进展。我一直主张，我们要像相信真理一样相信口碑的力量。这就是互联网七字诀中“口碑为王”的信仰。</p>
<p><strong>超预期才有口碑</strong></p>
<p>10年前，我经常问大家一个问题：去过海底捞吗？海底捞真的比五星级酒店的餐厅好吗？</p>
<p>说到豪华酒店，我曾经去过一次迪拜的帆船酒店，据说那是全球最好的酒店，一走进去果然金碧辉煌。但是，我觉得无比失望，第一反应居然是“怎么这么土啊！”。毋庸置疑，帆船酒店当然是全球最顶尖的酒店，但是我的期望在此之前被吊得太高了。</p>
<p>那海底捞呢？比如夏天在海底捞吃完饭，服务员端上来一个果盘，客人没吃完，问能不能打包带走？服务员说不能带走。当客人结完账，服务员给了他一整个西瓜，说切开的西瓜不卫生，如果想带走我们给您打包整个西瓜。结果，一个西瓜就把那个客人感动得一塌糊涂。</p>
<p>很多人说口碑就是好吃、好看、好用，口碑就是因为服务丰富，而且有趣，价格也合适。其实不然，这与你事先的预期有关。海底捞通常都开在很一般的地方，当我们走进去的时候，它的服务超越了我们所有的期望值，我们就会觉得好。当我们去五星级餐厅的时候，我们的期望值很高，超越的难度就不可同日而语了。</p>
<p>我也是琢磨了好久才想明白这个道理：好产品不一定能带来口碑，便宜的产品不一定能带来口碑，又好又便宜的产品也不一定能带来口碑，只有超过预期的产品才能带来口碑。</p>
<p>我们需要了解，预期是一个相对值。每一位消费者在购买产品/服务时，都有一个相对于社会产品/服务价值平均表现的心理预估，这无关这个具体产品/服务的绝对价值或定位，有高端的、中端的，也有入门级的，带来满足感的是这项服务超过了用户预期。所以，无论我们提供什么样的产品/服务，都要致力于超过可比档位的行业或社会普遍预期值。</p>
<p>概括来说，口碑的来源，是始终保持对同业的显著比较优势。</p>
<p>对立志做最好的产品和服务的企业及机构而言，包括小米这样的，显然从一开始就选择了一条艰难而绝不容半点放松的道路——绝对体验要向最高标准看齐，同时相对预期还要想尽办法胜出。</p>
<p><strong>做全栈口碑</strong></p>
<p>全栈是个工程开发概念，全栈工程师是指掌握多种技能、胜任前端与后端、能利用多种技能独立完成产品的人。要做成口碑，实际上也需要借鉴“全栈”思路，实现全面覆盖，不留缺口和短板。</p>
<p>好的产品只是口碑的一部分。产品（包括性能、设计、工艺、定价等）、服务和沟通，一家公司与用户所有触点的表现总和，才是口碑。</p>
<p>从诞生之日起，小米就极其重视用户口碑，哪怕是在产品之外，我们都做了大量的事情，在每个细节上都下了很大的功夫，一点一点地建设、巩固我们的口碑。</p>
<p>小米第一代手机刚发布时，税务所根据经验只给了我们5本发票，因为谁也没法相信一家刚成立没多久的小公司需要那么多发票。结果，我们一周就卖了十几万台手机，我们在网上卖的手机没有发票，就有网友投诉我们偷税漏税，我们真的是冤枉得不得了。后来跟税务局协调了好几个月，才允许我们使用机打发票。当我们拿到机打发票的时候，已经欠了用户几十万张发票。我们搞了十几台税票打印机，连续打了两个星期，甚至打坏了两台。这些发票打完后，我们都是用EMS快递给用户的，还附了一张致歉卡和贴膜作为礼物，用户收到后非常感动。</p>
<p>类似的举动，12年来我们做了很多很多，其中大多数都是由一线的同事提出想法并很快决策的。这样的操作需要一个前提，就是有一支互相信任的团队，以及资源前置、关怀决策权前置的原则，让听得见枪声的前线拥有炮火呼叫权。</p>
<p>实际上，一家公司中的所有人都与用户有着直接或间接的接触，每一名员工都应该是公司口碑的维护者。全员参与，挖掘更多与用户的触点，并不断打磨触点中的细节，就是在为产品/服务争取更多的更具象、真实、全面的反馈，同时为公司争取更多自传播、自转化的机会。</p>
<p>我曾听到一种声音，认为公司为了尽量藏拙，或者为了保持所谓的品牌高级感、距离感，应该刻意减少与用户的直接接触点数量。这样的想法简直匪夷所思。互联网经验告诉我们，高频场景的增长潜力始终高于低频场景，如何从低频转向高频，是所有经营者竭尽全力的追求。况且，如果真有拙，在这个社交媒体高度发达、信息透明度越来越高的时代，怎么可能藏得住？对一家志存高远、认真打磨产品的公司而言，如果有更多点、更高频地与用户接触，谋求更多口碑自传播、自转化的机会，肯定求之不得，又怎会避之不及？</p>
<p><strong>不要刻舟求剑，也不要坐井观天</strong></p>
<p>口碑如同流云，因势变幻莫测，风云际会就是风起云涌；口碑如同涧水，一开始静水流深，汇聚入海就是澎湃巨浪。</p>
<p>因为相对值的本质，以及比较优势变量，口碑无论是风评结论本身，还是评价的标准都在不断变化。所以，从来没有一劳永逸的口碑，也没有一成不变的获取、评估方法。辩证唯物主义早就告诉我们，要用发展的眼光看问题，对口碑的看法也是如此。</p>
<p><strong>口碑的阈值是不断提升的</strong></p>
<p>一年多前，有一家前来交流的企业分享了一个案例。通过调研监控，该企业发现用户对产品的满意度和推荐度陡然大幅下跌。数据反馈到产品和质量部门后，这些部门也是一头雾水，从原材料质量管控到产线品控标准都丝毫未变、稳定如山，甚至在产品定义和设计方面更下功夫，产品整体呈上行趋势并持续向高端进发，怎么会出现这样的怪事？</p>
<p>他们赶紧在各地进行了一轮用户访谈，再结合内部更细致的运营数据分析，才弄明白：问题恰恰出在原材料质量管控到产线品控标准的那个“丝毫不变、稳定如山”。因为产品走向高端之后，用户的预期发生了变化，原本用户不以为然的细节，如今就要被“吹毛求疵”了。</p>
<p>这就是典型的“刻舟求剑”式的刻板经营带来的问题。事后可能会觉得这简直有点可笑，原理如此简单，但发现问题的过程居然如此大费周章。这件事值得我们严肃且深刻地反思：我们在日常的经营活动中，因为疏于思考和想当然，到底犯下了多少错误？</p>
<p>除了上面提到的产品线升级维度的用户预期口碑阈值提升，在客群拓展中，还会遇到由不同群体预期不同带来的阈值差异。</p>
<p>2021年小米发布了第一款万元级别的手机MIX FOLD，这也是小米第一款量产的折叠屏手机，主要针对高端商务人群。MIUI系统团队针对折叠屏做了大量的专项体验优化，还特别做了“三指横划进入PC模式”的功能，就是能像操作个人计算机一样，通过类似“开始”菜单和“文件夹”的交互逻辑来操作手机。想法很好，但开发量的确大，短时间内无法打磨到足够精致的程度，于是MIUI团队就习惯性地按照以往的操作方式，先发布功能，在手机上市后再通过OTA升级的形式，把这项功能交付给用户。</p>
<p>但出乎团队意料的是，这个“习惯性动作”却对口碑造成了严重伤害。先发布后升级交付并持续优化，这是互联网开发的常见模式，小米的核心用户发烧友们都比较习惯，甚至觉得这是团队“有雄心、有想法、有担当”的表现——提前披露创新功能是对开发能力的自信，经过继续打磨再交付会带来更好的体验。但对非发烧友的商务用户而言，这就有些无法接受了——发布会上承诺会有的功能，居然还要等？尽管事先有说明，也不违反相关法规，但根据“口碑第一”原则，用户不接受的，显然就是错了。</p>
<p>这样的“会错意”对经营者而言，同样是一件“刻舟求剑”的蠢事。对从诞生之日起就坚决信奉“口碑第一”的小米团队而言，这是极其严重的错误。MIUI团队对用户的一系列不满反馈进行了深刻的反思，并制订了详尽全面的整改计划。</p>
<p>相比以上两者，更常见也更严重的是消费需求升级、行业整体变动带来的口碑阈值跳升。</p>
<p>口碑阈值的不断上升，其实是对用户价值长期稳定提升的倒逼机制，经营者需要不断拿出更好的产品和服务，才能维持良好的口碑。而规避“刻舟求剑”式失误的方法就是，不要犯观察与思考方面的“懒惰病”，要重视对行业动向、用户需求变化的洞察，注重对口碑变化的追踪与分析。</p>
<p><strong>小心“信息茧房”</strong></p>
<p>观察、追踪口碑的变化，要小心“信息茧房”。</p>
<p>互联网最大的特点，就是与用户直接接触，实时获得用户反馈变得更加容易，也更加深入，究其根本是互联网的信息高透明度与去中心化特征。</p>
<p>提升商家与用户之间的信息透明度、对称性，是小米一直倡导的。小米起步时，智能手机业的信息还处于高度不透明状态，从没有企业会明明白白地把精确的配置信息、性能参数和工艺明细披露出来，这使得用户在购买时往往不能获得准确的信息。</p>
<p>为什么智能手机行业不能像个人计算机行业一样，把配置清清楚楚地标出来，让用户明明白白地购买？而且，个人计算机行业还有大量的基准程序测试，所有用户都可以非常方便、直观地了解自己所购设备的性能。手机行业需要自己的基准程序测试，也需要更多的像《消费者报告》这样的独立评测团队。</p>
<p>这些在十多年前的手机业界还暂付阙如，于是我打算先推动这样的生态的诞生。</p>
<p>具体怎么做呢？首先，通过我个人投资或者关联公司投资的方式，支持有志于此、能力出色的个人或者团队，比如王自如的Zealer、安兔兔这样的团队。让我没想到的是，这成了过去对我的重大误解之一，就是认为我早期投资个别评测机构是为了获取营销支持。</p>
<p>事实并非如此。实际上，除了最早的投资，我们跟这类机构的沟通接触与其他同行并无二致，这类机构对小米也没有特别的照顾，他们认为要批评的地方也从没有手软过。后来，我们从资本结构上退出了一部分这样的机构，因为随着国产手机业的发展，这样的生态、业态也已蓬勃发展。今天，活跃在微博、知乎、B站等平台的专业数码评测机构和个人已有数百家之多。</p>
<p>小米还在业内率先提出跑分概念，就是基于安兔兔等的基准程序测试，用最直观的数据来展现衡量设备的综合性能。也有部分人批评“跑分评价”，诚然，跑分并不能全面覆盖对一款智能手机的综合体验，但它至少是最核心的基础和前提。“不服跑个分”从此成了国内手机业最深入人心的性能评价方式。</p>
<p>详细配置/参数披露、基准程序机构评测、网上用户口碑，是手机行业透明度提升的四大要件，是用户口碑及时、准确反馈的重要保障。但我并不认为这只适用于消费电子领域，所有面向用户信息透明度不高的行业，都可以通过类似的方式来增强对用户权利的保障，推动行业正向进步。</p>
<p>但是，随着互联网资讯产品形态和业态的变化，行业信息透明度和对口碑的观察、反馈也受到了新的挑战。</p>
<p>随着各类信息流资讯产品推荐算法的演进，观察者可能会被某一种算法重复加强的倾向或局部视野阻挡视线。同时，与业务发展同步，随着用户群体规模和多样性的不断提升，很多以前我们长期采用的简单观察方式也面临着“局部失真”的风险。比如我们经过长期观察发现，在特别的企业方微博（包括企业官方微博、企业加V认证的个人账号）下，以长周期来看，绝大多数互动行为（包括转发、评论、点赞）来自特定数目且相对固定的用户群体。固然可以认为，这些最活跃的核心用户代表了企业基本盘用户群体中的一些突出的声音，但具体到某个事项中，这些口碑反馈未必能代表整个基本盘用户，遑论更广大的大众用户群体的意见，因为在如今的公开社交媒体中，大众用户往往已经成了“沉默的大多数”。</p>
<p>还有一种最危险也最可憎的现象，就是不正当竞争中的“水军行为”。如果说互联网产品机制和用户行为的变化给口碑观测带来了客观上的迷雾，那么“水军”则是直接冲着破坏信息透明度来的。小米创业以来，一路上遭遇过很多诋毁，而因为小米坚持的“性价比战略”不符合当前人们的判断直觉，所以更助长了这些“诋毁”的传播。在公司发展早期，我们无视且放任了这种危险的声音，没有采取系统的有力应对措施，而且早年我们也缺乏品牌建设体系，结果被人贴上了很多负面的标签，在后续发展中付出了非常惨痛的代价。</p>
<p>失真的口碑观察和反馈，可能会对企业改进和用户选择产生巨大的误导，必须引起我们的高度重视与关注。</p>
<h3 id="快"><a href="#快" class="headerlink" title="快"></a>快</h3><p>我们期待非常多的快，比如研发进展快、库存周转快、资金回笼快等等。但在这里，我们集中讨论的是公司在业务发展和面对用户反馈时，洞察、反应、决策、改善的速率问题。我相信，这是一家公司的底层核心素养和能力。有了这些“快的素养”和“快的能力”，研发进展、库存周转、资金回笼等各种“快的结果”自然纷至沓来。</p>
<p><strong>快是成长效率</strong></p>
<p>我们通常把“快”理解成一种竞争策略。《孙子兵法》中谈“风林火山”，就强调“其疾如风”，要靠超高的机动性，抢先赢得战机。</p>
<p>相信经历过2010前后互联网行业变革的人，都能理解这个行业的焦虑。当意识到移动互联网并不是个人计算机时代互联网的简单延伸时，市场的参与者们都急于寻找一张“船票”。这是中国互联网行业第一次集体意识到狭窄的时间窗口和关键“船票”的意义，“快”成了压倒一切的诉求。</p>
<p>当时小米刚刚成立，按照“硬件+软件+互联网”的“铁人三项1.0”模式，在做手机系统、筹备手机硬件团队的同时，小米在国内率先启动基于智能手机的即时消息项目“米聊”，一度获得显著的先发优势。</p>
<p>当时我有个判断，如果腾讯在一年之内没有反应，米聊将有50%的胜算；如果半年之内有反应，米聊基本没机会。但结果，腾讯在一个月内就做出了反应，腾讯广研院迅速推出了微信，并获得了腾讯集团力量的大力支持。</p>
<p>凭借千万人同时在线的高并发后端技术沉淀和在社交关系链方面的优势，加上公司体量等综合资源的巨大优势，微信逐渐实现了对米聊的赶超。小米作为一家初创小公司，无法同时支撑移动互联网即时消息和智能手机这两个千亿美元级市场的投入，于是我们放弃了米聊，把全部精力都投入智能手机领域。</p>
<p>在竞争背后，“快”更重要的意义在于企业/业务本身的成长效率，以及用户价值的提升预期和速率。</p>
<p>对企业而言，快是更低的机会成本、更快的改善成长速度。对用户而言，快关联着迁移成本与持续获利预期，在互联网领域中，由于产品多是免费的，用户的迁移成本很低，所以对快的强调到了无以复加的地步。对创业者而言，创业的每一天都有巨大的机会成本，这就需要保持极快的速度，开发产品时一定要想清楚能不能在两三个月或者最多半年内做出来，测试用户的需求和反馈能不能很快有一个结果，收到用户的反馈以后能不能很快去改。移动互联网时代的用户其实不怕产品不够完善，怕的是他提了意见你却没有改进。如何跟用户快速沟通、快速反馈、快速修正，这几个问题非常关键。</p>
<p>出于行业特点，硬件工业等实体商品领域无法像纯互联网行业那样在用户选择上毫无成本，产品周期也更长，没办法在线实时更新，但道理是相通的。用一切办法，尽可能了解用户需求、尽快获得用户反馈，尽快更新改善，这就是我们采用互联网开发模式的原因。而用户也更相信一家效率更高、改善更快的公司能拿出更好的产品/服务，为他们持续提供更多的价值。</p>
<p>所以，对企业而言，快是一种持续进化成长的素养。</p>
<p>“天下武功，唯快不破。”我对此的理解是，一家更快的公司通常都有更高的效率，也必然拥有更强的洞察力、更好的行业适应性、更坚韧的生命力和更持续的创新能力。</p>
<p><strong>关于快的四种能力</strong></p>
<p>“快”作为一种素养，它的实现本身更是一种突出的系统能力。我们可以把快的四种能力总结为：洞察快、响应快、决策快、改善快。关于这个话题，我有两个小故事可以分享。</p>
<p>第一个故事是关于“王朝覆灭的缩影”。很多年前，我曾经跟一家手机公司的高管做过一次交流。当时，这家公司的全球市场份额处于鼎盛时期，我使用过它的很多款产品。我跟对方讲了很多产品改进意见，一不小心就一口气说了将近两个小时。那位高管非常耐心地听完了我的话，做了很多记录，反复表示感谢，并非常诚恳地说这些问题的确存在，他回去后会推动产品和研发部门尽快改善。</p>
<p>很可惜，之后的两年多时间里，这些问题中的大多数依然存在，改善微乎其微。</p>
<p>我毫不怀疑那位高管听取我的意见的诚意，我也完全相信，他会在内部传递这些意见。但是依然没什么改观，这或许只能说明这家公司内部的某些系统出现了失灵。</p>
<p>这家公司的手机业务在巅峰时期曾占据全球市场份额的40%以上，但在此后一年多的时间里，以光速坠向消亡。当一家公司持续出现系统失灵时，无论它当时多么强大，一旦遭遇技术世代的变迁，距离覆亡可能就只有咫尺之遥。</p>
<p>第二个故事是“还有这样的操作？”。</p>
<p>2011年，有几位微软的高管来小米跟我交流，他们百思不得其解：“你们的MIUI操作系统是怎么做到每周更新的？”</p>
<p>他们说，微软的版本更新周期特别长，因为微软的装机量极大，一旦更新失败，他们承受不起，所以都是很长时间更新一次，就这还提心吊胆的。</p>
<p>我告诉他们，其实我们是在手机系统里做了两个分区，装了两套操作系统，一旦更新失败，自动回滚到上个版本。微软的高管震惊了，第一次听到这样的解决思路。</p>
<p>这个秘诀说起来的确非常简单，但是需要有内测版、开发版、稳定版的产品线区分设置；需要建设一个聚集发烧友的社区，通过四格反馈报告、用户意见投票等运营产品提供支持；需要有一群视团队为朋友，真心参加共创设计开发的发烧友群体的支持；再加上一支充满激情、自驱力极强、技术能力出众的团队，以“不吃饭也要先优化”的热情打磨产品，才能够实现。</p>
<p>这就是传统工程开发模式和互联网开发模式的巨大区别。</p>
<p>总之，快不是凭空冒出来的，不是喊口号和讲道理喊出来的，也不是光靠想快起来的意愿就能实现的，它来自充满进取心和热情的团队，来自严整而持久的流程和方法支持，来自创新的思路和工具，来自与用户亲密无间的接触和反馈。</p>
<p>本质上说，快是一种独特的全局能力，要实现快，需要把实现快的机制当成一个创新产品来做。以快的四种能力为对标，去衡量改造相关团队的组织和流程，这样才能真的让公司提速。</p>
<p><strong>给丁磊做台98英寸电视</strong></p>
<p>2019年10月，我在乌镇参加商业大会，白天的会议议程都很满，到了晚上，朋友们闲下来会三三两两聚在一起，小酌一杯聊聊天。</p>
<p>有一天晚上，丁磊在吃饭时突然跟我说：雷总，你能不能帮我做一批超大尺寸的电视机，比如100英寸左右的。</p>
<p>我问他，为什么？小米目前还没有这样的产品，如果你家里用，直接买几台市面上有的产品不就行了。</p>
<p>他说，是打算放在办公室里，开视频会议、播放PPT（演示文稿）等用的。看了下这类产品，最便宜的也要十几万元，实在太贵了。你那套方法能推着一个领域快速成熟起来，把价格做下来，而且你们的设备交互体验更好，互联网应用的支持度更高。你要是做出来，我后面陆陆续续把网易的会议室里都装上。</p>
<p>丁磊的话让我脑子里突然闪过一道亮光。小米进入电视行业6年，2019年登上了国内行业销量第一的位置，我们很清楚，电视重在身临其境的体验，一直在追求更大、更清晰，100英寸左右的超大尺寸符合未来趋势，有机会成为我们“高端产品大众化”的下一款爆品。</p>
<p>同时，丁磊的需求给了我们一个新的思考方向：超大屏电视会是办公场景的高潜力需求。之前几年我们也想过，但那个时候需求看起来还不明显，现在丁磊这么提了，这种需求是不是累积到了即将成熟的程度？</p>
<p>丁磊问我能不能做，价格能不能做到5万元以内？我马上给小米电视部门总经理打了个电话，他告诉我，巧了，之前已经有这样的考量，跟上游面板厂一起已经有了一定的预研基础，98英寸的尺寸符合要求，但BOM成本（元器件成本的累加）再怎么压也还有25000元左右，有机会把零售价做到5万元以内。</p>
<p>值得干！我让同事们马上正式立项这款产品。BOM成本25000元，另外由于98英寸电视体积过于巨大，每安装一台都要出动吊车和一组工人，送货和安装的成本非常高，我们按照每台平均2000元计。我们相信，前期虽然会有亏损，但随着销量提升，依然有机会迅速打平成本，并且实现盈利。</p>
<p>2020年年初，新冠肺炎疫情暴发，远程办公需求暴涨，通过大屏电视进行电话会议再也不是低频场景。我们的团队在此前预研的基础上加紧开发调试，2020年3月24日，这款Redmi 98英寸超大屏电视终于发布面市，定价19999元，引发了行业轰动。</p>
<p>这时，距离丁磊提出需求不过5个月的时间。</p>
<p>特别有意义的是，在生产备货过程中，基于对市场需求和产品力的信心，我们的面板订单量远超面板厂的预期，加上面板厂对产线的调整改良，我们成功地实现了BOM成本的近乎打平。上市之后，这款产品受到用户的热烈欢迎，随着销量的增加，加上配送安装等综合成本的持续降低，当年就实现了成本全面打平，并有微利。</p>
<p>5个月时间，我们为整个业界打开了超大屏幕电视的市场。在小米下场之前，全行业98英寸及以上电视在中国市场平均月销量不过78台，到2020年下半年，光小米的产品月销量就已经达5000台，并且带动了一批企业跟进。到2021年6月，98英寸电视已成为国内电视品牌集中竞争的一个新热点。随着规模的不断提升，综合成本也在不断摊薄，到2022年，我们的98英寸电视的售价已经下调到16999元。</p>
<p><strong>以极致产品和过硬口碑为导向</strong></p>
<p>前面提到了“100分钟必有回应”原则，其实，小米早年更快，在我们的产品只有少数几款手机业务时，我们执行的标准是在微博上15分钟内进行首次答复响应。</p>
<p>现在看起来标准“放松”了很多，为什么会有这样的调整？小米的业务范围比早期广阔了很多，在客服沟通中，相比投诉和反馈问题，咨询使用方式和技巧的比例大幅提升。我们团队希望能够为用户提供更好的沟通服务，更细致完善地帮用户解决问题，同时也避免微博首次响应过快，吸引过多用户在微博反馈导致渠道形成拥挤，反而降低响应之后沟通和解答服务的效率与品质。</p>
<p>在这种情况下，我们会选择慢一点，把包括微博、电话、官方在线、社区等全平台服务的品质做得更好。当然，按照新的沟通服务品质标准，小米的客服团队也一直在努力缩短“100分钟”标准。</p>
<p>这样的选择，12年来，小米每每遇见，次次坚定。</p>
<p>2012年时，我们应政府主管部门的要求立项红米手机，目标就是优选国内产业链，做国民手机。当时的国内产业链还不成熟，我们做的第一代产品内部测试体验并不理想，我非常不满意。到这时，我们在这款产品上的研发费用已经投入了4000多万元，开发团队经过讨论，一致同意，之前的4000多万元研发费用就当交学费了，整个项目推倒重来。</p>
<p>所以行业内看到的红米手机第一代，其实是我们研发的第二代，代号是H2。2013年7月31日，红米手机正式发布，震动整个业界，第一代单款产品卖出了4460万台。从那一天起，中国山寨手机业态迅速消亡。</p>
<p><strong>不要用战术上的勤奋掩盖战略上的懒惰</strong></p>
<p>绝不能为了追求快而疏忽重要的战略思考。当公司处于创业初期时，每一个举动都可以很快。但是随着业务的成长和拓展，可供选择的岔口就多了，这时绝不能因为一味图快而含糊、轻率地跨过重要的战略决策点。很多当下看似都对的选择，日后却可能引向截然不同的道路。</p>
<p>在这个问题上小米曾经付出过惨痛的代价。小米前期超高速成长，掩盖了非常多的问题，到2015年年底，问题一下子全部爆发出来。究其原因，小米手机发布3年就赢得中国第一、全球第三的领先位置后，因为对“快”的片面追求，而没能下决心及时对团队进行调整，解决当时已经存在的硬件研发团队管理问题，由此造成了产品规划、交付等系统能力的严重落后，这是我们犯下的最严重、最致命的错误。所幸，小米的补课很快取得效果，从“死亡螺旋”中挣脱了出来，重回高速发展道路。</p>
<p>另一个沉痛的教训是，小米早期忽视了品牌的系统性建设，一些关键决策做得比较轻率。比如，红米手机的命名，在2018年我们进行复盘时，发现这是个极其严重的错误。</p>
<p>小米手机从一开始就定位于旗舰手机，性能参数和用料瞄准全球顶级，虽然是基于BOM定价，但也是国产品牌中最高的。红米的命名，混淆了小米和红米的界限，虽然定义是不同的产品线，但客观上将小米早期的发烧、高端品牌形象拉向了单一的低价标签，造成了品牌认知上的混乱，加上红米系列诞生后3年1.1亿台的巨大销量，事实上混淆了小米品牌的大众认知。</p>
<p>同时，红米还是小米旗下第一个“×米”式的命名，做了一个非常不好的示范。在此之后，小米生态链中大量的公司和产品品牌沿袭了这种命名方式，造成了很多认知上的混乱，严重稀释了小米的品牌势能。</p>
<p>这些错误的本质在于，为了新产品线的高位起步和尽快增长，在没有足够深刻思考的情况下，轻率地选择了直接消耗小米的品牌资产，实际却得不偿失。2019年小米开始对品牌架构进行梳理，红米改为与小米品牌并列的Redmi独立品牌，同时也禁止再使用“×米”命名等无端消耗小米品牌资产的行为。</p>
<p>磨刀不误砍柴工，快与耐心并不冲突，在重大节点方面，还需要有更长远的眼光，宁可慢一些，想明白了再做决策，在战术执行上快的同时，战略上要走得更稳。不稳、不扎实，一定会造成不必要、不理智的急躁，迟早会出问题。所以我认为，“战略积累快不得，战术演进慢不得”，为了更底层的坚定原则和更长远的发展，有时候，有局部的、阶段性的慢，才有全局的快。</p>
<h1 id="小米方法论与产业生态"><a href="#小米方法论与产业生态" class="headerlink" title="小米方法论与产业生态"></a>小米方法论与产业生态</h1><h1 id="小米方法论的演进思考"><a href="#小米方法论的演进思考" class="headerlink" title="小米方法论的演进思考"></a>小米方法论的演进思考</h1><h1 id="对小米影响最为深远的5篇文章"><a href="#对小米影响最为深远的5篇文章" class="headerlink" title="对小米影响最为深远的5篇文章"></a>对小米影响最为深远的5篇文章</h1>]]></content>
      <tags>
        <tag>创业</tag>
      </tags>
  </entry>
  <entry>
    <title>爱的艺术笔记</title>
    <url>/uncategorized/%E7%88%B1%E7%9A%84%E8%89%BA%E6%9C%AF/</url>
    <content><![CDATA[<h1 id="来自-Async-的-Tips"><a href="#来自-Async-的-Tips" class="headerlink" title="来自 Async 的 Tips"></a>来自 Async 的 Tips</h1><p>注意，不要过度，我们不必要太过迁就和顺从任何人。</p>
<p>人们不会珍惜轻易得到的东西，这些东西包括爱。</p>
<h1 id="爱是一门艺术"><a href="#爱是一门艺术" class="headerlink" title="爱是一门艺术"></a>爱是一门艺术</h1><h2 id="爱重要的是能力"><a href="#爱重要的是能力" class="headerlink" title="爱重要的是能力"></a>爱重要的是能力</h2><p>如果爱是一门艺术，那就要求人们有这方面的知识并付出努力。</p>
<p>大多数人认为爱情首先是自己能否被人爱，而不是自己有没有能力爱的问题。</p>
<p>因此对他们来说，关键是：我会被人爱吗？我如何才能值得被人爱？为了达到这一目的，他们采取了各种途径。男子通常采取的方法是在其社会地位所允许的范围内，尽可能地去获得名利和权力，而女子则是通过保持身段和服饰打扮使自己富有魅力；</p>
<p>而男女都喜欢采用的方式则是使自己具有文雅的举止，有趣的谈吐，乐于助人，谦虚和谨慎。</p>
<p>为了使自己值得被人爱而采用的许多方法与人们要在社会上获得成功所采用的方法雷同，即都是“要赢得朋友和对他人施加影响”。事实上，我们这个社会大多数人所理解的“值得被人爱”无非是赢得人心和对异性有吸引力这两种倾向的混合物而已。</p>
<p>产生在爱这件事上一无可学这一看法的第二个原因是人们认为爱的问题是一个对象问题，而不是能力问题。他们认为爱本身十分简单，困难在于找到爱的对象或被爱的对象。</p>
<p>一些事实：</p>
<ul>
<li><p>人与人之间的爱情关系也遵循同控制商品和劳动力市场一样的基本原则——等价交换。</p>
</li>
<li><p>人们往往把这种如痴如醉的入迷，疯狂的爱恋看作是强烈爱情的表现，而实际上这只是证明了这些男女过去是多么地寂寞。</p>
</li>
</ul>
<p>要认识爱情是一门艺术。人们要学会爱情，就得像学其他的艺术——如音乐，绘画，木工或者医疗艺术和技术一样的行动。</p>
<h1 id="爱情理论"><a href="#爱情理论" class="headerlink" title="爱情理论"></a>爱情理论</h1><h3 id="一、爱情是对人类生存问题的回答"><a href="#一、爱情是对人类生存问题的回答" class="headerlink" title="一、爱情是对人类生存问题的回答"></a>一、爱情是对人类生存问题的回答</h3><p>爱情的每一个理论必须要以人的理论、人的生存理论为前提。我们所能看到的动物的爱情或者更确切地说动物身上类似爱情的东西，主要是动物的一部分本能。在人身上只能看到这一本能的残余。人的存在的根本要点是人超越了动物界，超越了本能的适应性，脱离了自然——尽管人永远不可能完全脱离自然。</p>
<p>经历过孤寂的人必然会有恐惧感。实际上孤寂感是每种恐惧的根源。孤寂意味着与外界没有联系，不能发挥人的力量，意味着一筹莫展，不能把握世界，事物和人；意味着世界把我淹没，而我只能听之任之。所以孤寂是引起强烈恐惧感的根源，同时孤寂还会引起羞愧和负罪的感觉。</p>
<p>因此对人来说最大的需要就是克服他的孤独感和摆脱孤独的监禁。人在达到这一目的过程中的完全失败就会导致人的疯狂，因为人只有通过完全彻底地脱离周围世界，以至于不再感到与世隔绝，他对彻底孤独的恐惧感才会得到克服——因为他与之隔绝的世界从他的生活中消失了。</p>
<p>人——所有时代和生活在不同文化之中的人——永远面临同一个问题，即：如何克服这种孤独感，如何超越个人的天地，实现人类的大同。</p>
<p>人们对这一问题的回答在一定的范围则取决于人所达到的个性的高度。在一个孩子身上，“我”字几乎还没有形成。每个孩子都同母亲融为一体，只要母亲在他身旁，他就不会有孤独感。他的孤独感通过母亲的存在，同母亲的乳房和肌肤的接触而得到和缓。一直到孩子发育到产生孤独感和个性这个阶段，母亲的存在才不足以消除他的孤独感，他必须以其他的方法克服这种孤独感。</p>
<p>人类在孩提时代几乎是以同样的方式体验与大自然的和谐。大地、动物和植物完全是人的世界。人把自己看作和动物完全一致，这表现在人装扮成动物以及崇拜图腾或其他的动物神。但人类越脱离原始的纽带，就越疏远自然世界，就越要寻找摆脱孤独的途径。</p>
<p>达到这一目的的一种途径是不同形式的纵欲。例如自我引起——或借助于毒品——的恍惚状态就是一种形式的纵欲。</p>
<p>就是最穷的罗马人也能自豪地说我是罗马的公民罗马和罗马帝国就是他的家，他的祖国和世界。在今日的西方社会，同一组人结合仍然是克服孤独感最常用的方法。在这种结合中，参加者为了使自己属于这一组人而失去了大部分个性。如果我与他人完全一样，我的感情、思想与他人一致，我的衣着、习惯和看法都与这一组人的楷模看齐，我就可得救，就不会再经历可怕的孤独。</p>
<p>在当今资本主义社会，平等的概念发生了变化。今天“平等”指的是机器——也就是失去个性的人的平等。平等意味着“一个模式”而不是“统一”。这是一个抽象体的同一模式，是做同样的工作、寻求同样的享受，读同样的报纸，有同样的思想感情的人的模式。</p>
<p>现代社会鼓吹实现非个性化的平等理想，因为这个社会需要“人——原子”，这些人原子相互之间没有区别，汇集起来也能毫无摩擦地顺利地发挥作用，他们都服从同一个命令，尽管如此，每个人却都确信他们是在按自己的意愿办事。就象现代化的大规模生产要求产品规格化，社会的发展也要求人的规格化，并把这称为“平等”。</p>
<p>通过同一化达到人与人的结合既不是强烈的也不是激烈的过程，而是按照一个刻板的公式十分平静地进行。</p>
<p>我们是把爱情看作是对人类生存问题的成熟回答，还是指爱情的不成熟形式，也就是人们称为共生有机体的结合呢？下面我只是把前者看作是爱情，但我们的讨论却要从后者开始。</p>
<p>共生有机体结合的生物楷模是怀孕的母亲同胚胎之间的关系。他们既是两体，又是一体。他们生活在一起(共生)，他们相互需要。胎儿是母亲的一部分，并从她身上得到他所需要的一切，所以母亲就是他的世界。她抚养和保护胎儿，同时她自己的生活也因胎儿的存在而得到一种升华。在生理性的共生有机体的结合中，两者的身体互不依赖，但在心理上却相互依赖。</p>
<p>共生有机体结合的消极形式是服从——医学名词就是被虐癖。有被虐癖的人通过把自己变成他的引导者、启示者、保护者的一部分使自己摆脱孤独和与世隔绝感。保护者就是他的生命，没有保护者他就无法生存。不论保护者是人还是神，总之他的威力超越一切。他主宰一切，而自己什么也不是，被虐淫者必须成为其保护者的一部分，因为只有这样他才能分享保护者的伟大、威力和安全。被虐淫者从来不作任何决定和进行任何冒险，他从不孤独，但也决不独立。他不是一个完整的人，可以说还没有完全诞生。在宗教的语言中把崇拜的对象称为偶像，而被虐淫者对其保护者的崇拜超过了对偶像的崇拜。这种崇拜可以同生理要求和性要求相混合，在这种情况下被虐淫者的服从不仅是想象力的产物，而且是一种与全身有关的生理需要。另外还有屈服于命运、疾并有节奏感的音乐或者屈服于由吸毒和催眠状态引起的极度兴奋等病状——在所有这些情况下，犯病的人失去了他的完整性，把自己成为一个人或一件事物的工具；从而使他不用对生存的问题作出独立的和自由的回答。</p>
<p>共生有机体结合的积极形式是控制另一个人——与被虐癖相应的医学名词是施虐癖。施虐淫者就是通过把另一个人成为他自己的一部分而摆脱孤独，他吞并他的崇拜者，从而使自己身价百倍。</p>
<p>就象被他控制的人脱离不了他一样，施虐淫者也离不开他的崇拜者，双方都不能失去对方。区别只在于——施虐淫者命令、利用、损害和欺压对方，而对方则乐于被他左右。从现实的角度来看似乎他俩之间存在着很大的差别，但从更深的意义来看他俩的区别不比他俩的共同点重要，他俩的共同点是在结合的过程中双方都失去其独立性行完整性。如果我们理解这一点，就不难确定一般来说一个人会根据不同的对象作出施虐癖和被虐癖的反应。希特勒对其他人首先是施虐淫者，但面对他的命运、历史和自然的“威力”作出的却是被虐淫者的反应。</p>
<p>同共生有机体结合相对立的是成熟的爱情，那就是在保留自己完整性和独立性的条件下，也就是保持自己个性的条件下与他人合二为一。人的爱情是一种积极的力量，这种力量可以冲破人与人之间的高墙并使人与人结合。爱情可以使人克服孤寂和与世隔绝感，但同时又使人保持对自己的忠诚，保持自己的完整性和本来的面貌。在爱情中出现了两个生命合为一体，却依然保持两体的怪现象。</p>
<p>如果我们说，爱情是一项“积极的活动”，我们就会遇到“积极的活动”这个词有双重意义的问题。这个词的现代用法一般就是指人们通过付出劳动改变现存状态的行为。所以经商的人，学医的人，流水作业线上的工人，做椅子的木匠或者运动员都是积极活动的人。他们活动的共同点都是为了达到一个外部的目的。但这里我们都没有考虑产生积极性的根源。我们可以举一个例子加以说明。</p>
<p>有的人由于内心极度的不安或者孤独而狂热地工作，有的人则是为了升官发财。在这种情况下这个人就是一种狂热、一种热情的奴隶，而他的“积极性”实际上是一种“消极性”，因为他是受外力的驱使。他是一个受苦的人，而不是一个“行动”的人。另一方面人们往往把一个坐在椅子上沉思默想、观察和体验自己以及自己同世界关系的人看作是“消极的”，因为他什么也不“干”。实际上这种精神高度集中的禅坐是最高的积极性，是灵魂的积极性，只有那些内心自由和独立的人才能做到这点。“积极的活动”这一概念的一个意义，也就是现代应用的意义是指为了达到外部的目的而付出努力。这个词的另一个意义是运用人的蕴藏在内部的力量，不管是否达到外部的变化。斯宾诺莎精辟地解释了这个词的第二种意义。他把情绪分成积极的和消极的两种，分成“行动”和“狂热”。如果一个人是在积极的情绪支配下行动，他就是自由的，是情绪的主人。如果他是被一种消极的情绪所支配，那他就是受外力驱使者，是他自己都不了解的动机的对象。这样，斯宾诺莎最终得出结论认为，美德和控制自己是一回事。妒忌、野心和每种形式的贪婪是热情和狂热；相反爱情是一种行动，是运用人的力量，这种力量只有在自由中才能得到发挥，而且永远不会是强制的产物。</p>
<p>爱情是一种积极的，而不是消极的情绪。一般来说可以用另一个说法来表达，即爱情首先是给而不是得。</p>
<p>什么是“给”？这个问题看起来似乎很容易回答，实际上却很复杂并有双层意义。十分流行的误解是把“给”解释为放弃，被别人夺走东西或作出牺牲。一个性格还没有超越接受、利用或者贪婪阶段的人对给的理解就是这样。一个“重商主义”的人也准备给，但一定要通过交换。只“给”而没有“得”对他来说就是欺骗。那些基本上是非生产性性格结构的人则会有一种被别人拿走东西的感觉。因此这种类型的大多数人拒绝给予别人东西。而有些人却又把“给”变成一种自我牺牲的美德。他们认为，正因为“给”是痛苦的，所以应该这么做。给的美德就是准备牺牲，对他们来说，“给”比“得”好这一准则就是意味着宁可忍受损失也不要体验快乐。</p>
<p>有创造性的人对“给”的理解完全不同。他们认为“给”是力量的最高表现，恰恰是通过“给”，我才能体验我的力量，我的“富裕”，我的“活力”。体验到生命力的升华使我充满了欢乐。我感觉到自己生气勃勃，因而欣喜万分。“给”比“得”带来更多的愉快，这不是因为“给”是一种牺牲，而是因为通过“给”表现了我的生命力。</p>
<p>如果我们把这一原则用来解释各种特殊的现象，就不难认识这一原则的有效性。最基本的例子可以在性范畴里找到。男子性行为的最高峰就是一种给的行为：男子把自己的性器官交给女子，在达到性高潮的一刹那，他把精液给予对方。只要他不是阳痿，他就必须这么做。如果他不能给，他就是阳痿。女子也是如此，只不过表现形式复杂一点罢了。女子交出自己，她打开通向女性内部的大门，在接受的同时她也给予，如果她没有能力给，而只能得，她就是性冷淡。在女子身上给的行为还表现在她作为母亲的作用上。她把她的养料给予她肚中的胎儿，后来又给婴儿喂奶和给予母体的温暖。对女子来说不能给是极其痛苦的。</p>
<p>在物质世界范畴内给是财富。不是拥有财物的人是富裕的，而是给予他人东西的人才是富裕者。害怕受到损失的吝啬鬼，不管他拥有多少财产，从心理学角度来看，他是一个贫穷和可怜的人。愿意把自己的东西给予他人的人却是富有的，他感觉到自己是一个有能力帮助别人的人。只有那些连生活必需品都没有的人才不能体验帮助别人的乐趣。但是日常生活经验告诉我们，衡量有没有足够生活必需品的标准既取决于人的实际财产，也取决于人的性格本质。众所周知穷人往往比富人更愿意给。尽管如此，超过一定限度的贫困往往使许多人无法给，恰恰这一点是十分令人懊丧的——这不仅仅是因为从中可以看到穷人的贫困，同时也是因为穷人被剥夺了给所带来的欢乐。</p>
<p>但给的最重要范畴还不是物质范畴，而是人所具有的特殊范畴。一个人究竟能给予别人什么呢？他可以把他拥有的最宝贵的东西，他的生命给予别人。但这并不一定意味着他一定要为别人献出自己的生命，而是他应该把他内心有生命力的东西给予别人。他应该同别人分享他的欢乐、兴趣、理解力、知识、幽默和悲伤——简而言之一切在他身上有生命力的东西。通过他的给，他丰富了他人，同时在他提高自己生命感的同时，他也提高了对方的生命感。他给并不是为了得，但是通过他的给，不可避免地会在对方身上唤起某种有生命力的东西。因此他的给同时也包括了使接受者也成为一个给的人，而双方都会因为唤醒了内心的某种生命力而充满快乐。在给的行为中诞生了新的东西，给和得的人都会感谢这新的力量。这一点表现在爱情上就是：没有生命力就是没有创造爱情的能力。马克思极其优美地表达了上述思想。他说：“如果你以人就是人以及人同世界的关系是一种充满人性的关系为先决条件，那么你只能用爱去换爱，用信任换取信任。如果你想欣赏艺术，你必须是一个有艺术修养的人；如果你想对他人施加影响，你必须是一个有艺术修养的人；如果你想对他人施加影响，你必须是一个能促进和鼓舞他人的人。你同人及自然的每一种关系必须是你真正个人生活的一种特定的、符合你的意志对象的表现。如果你在爱别人，但却没有唤起他人的爱，也就是你的爱作为一种爱情不能使对方产生爱情，如果作为一个正在爱的人你不能把自己变成一个被人爱的人，那么你的爱情是软弱无力的，是一种不幸。”</p>
<p>不仅在爱情上“给”意味着“得”。教师向他的学生学习，演员受到观众的鼓舞，精神分析学家通过治愈他人的病而治愈自己的病也都如此，先决条件是给的人不应该把对方看作是他帮助的对象，而应该同对方建立一种真正的、创造性的紧密关系。</p>
<p>有没有能力把爱情作为一种给的行为取决于人的性格发展，这一事实似乎没有必要加以强调了。取得这一能力的先决条件是人要有一种占主导地位的生产性倾向。持有这种态度的人就克服了他的依赖性、自恋性（“自恋”这一概念是由弗洛伊德提出的，弗洛伊德把人的自我欣赏叫做“自恋”，他认为，“自恋”必先于他恋，这主要表现在儿童把与生俱来的里比多（指心能，尤其是性本能的能）用到自己身上。——译者注）以及剥削别人的要求，并能找到对自己的人性力量的信赖以及达到目的的勇气。如果缺乏这些特点，人们就害怕献出自己，也就是害怕去爱。</p>
<p>爱情的积极性除了有给的要素外，还有一些其他的基本要素。这些要素是所有爱的形式共有的，那就是：<strong>关心、责任心、尊重和了解</strong>。</p>
<p>在母爱中关心的要素表现得最为突出。如果有一个母亲拒绝给孩子喂食、洗澡和关心他身体的舒适，那么无论这位母亲如何强调她对孩子的爱，也不会有人相信她。但如果她关心孩子，她的爱就令人可信了。对动物和植物的爱亦是如此。如果有一位妇女对我们说她很爱花，可是我们却发现她忘记浇花，我们就不会相信她说的话。爱情是对生命以及我们所爱之物生长的积极的关心。如果缺乏这种积极的关心，那么这只是一种情绪，而不是爱情。爱情的这一要素在《约拿书》中得到很美的描绘。上帝吩咐约拿去尼尼微，向那里的居民宣布，如果他们不改邪归正，他们就将受到惩罚。约拿却不愿行使这一使命，他逃跑了，因为他担心尼尼微的居民将会悔过，从而求得上帝的宽恕。约拿是一个执法从严的人，但不是一个爱人之人。在他逃亡的路上，他发现自己躲在一条大鱼的肚子里，这条大鱼象征着隔绝和监禁，正是由于约拿缺乏仁爱和恻隐之心，所以才被送到这儿。上帝拯救了他，约拿去到尼尼微，向那里的居民宣告上帝的话，这时正如约拿担心的那样，尼尼微的居民回心转意，虔诚忏悔，上帝原谅了他们，答应不使全城覆没。约拿大为不悦和失望，他要看到“正义”，而不是仁爱。最后他坐在一棵树的阴影底下重又找回失去的安宁。这棵树本是上帝让它长高，好替约拿遮挡灼热的阳光。这时上帝却让这棵树枯死了，约拿十分沮丧，埋怨上帝。上帝回答说：“你为那棵一夜长、一夜死的树惋惜，虽然你既没有栽活它，也没有关心它。为什么我就不能惋惜尼尼微城内那十二万好坏不分的居民和那许许多多的动物呢？”上帝向约拿解释道，爱的本质是创造和培养，爱情和劳动是不可分割的。人们爱自己劳动的成果，人们为所爱之物而劳动。</p>
<p>关心和关怀还包括爱情的另一方面，即责任心。今天人们常常把责任心理解为是义务，是外部强加的东西。但是责任心这个词的本来意义是一件完全自觉的行动，是我对另一个生命表达出来或尚未表达出来的愿望的答复。“有责任”意味着有能力并准备对这些愿望给予回答。约拿对尼尼微的居民没有责任心，像该隐一样，他同样会提出这一问题“难道我应该是我弟弟的看守吗？”。一个爱的人的回答是，我兄弟的生命不仅与他自己有关，而且也同我有关。我应对其他的人负责就像对自己负责一样。这种责任心在母子关系中主要表现在母亲对孩子生理上的要求的关心。在成人之间则也包括关心对方的精神要求。</p>
<p>如果爱情没有第三个要素：尊重，那责任心就很容易变成控制别人和奴役别人。尊重别人不是惧怕对方。尊重这个词的出处就是有能力实事求是地正视对方和认识他独有的个性。尊重就是要努力地使对方能成长和发展自己，因此尊重决无剥削之意。我希望一个被我爱的人应该以他自己的方式和为了自己去成长、发展，而不是服务于我。如果我爱他人，我应该感到和他一致，而且接受他本来的面目，而不是要求他成为我希望的样子，以便使我能把他当作使用的对象。只有当我自己达到独立，在没有外援的情况下独立地走自己的路，即不想去控制和利用别人，只有在这种情况下，尊重对方才成为可能。只有在自由的基础上才会有爱情，正像在一首古老的法国歌曲中唱的那样“爱情是自由之子，永远不会是控制的产物”。</p>
<p>人们只有认识对方，了解对方才能尊重对方。如果不以了解为基础，关心和责任心都会是盲目的，而如果不是从关怀的角度出发去了解对方，这种了解也是无益的。了解的方式多种多样。成为爱情一要素的了解是要深入事物的内部，而不是满足于一知半解。我只有用他人的眼光看待他人，而把对自己的兴趣退居二位。我才能了解对方。譬如：我可以知道这个人在生气，即使他自己不表露出来。但我还可以更进一步地去了解他，然后就知道，他很害怕和不安，他感到孤独和受到良心的谴责。这样我就明白他的生气只是他内部更深的东西的反映，这时我眼中的他不再是一个发怒的人，而是一个处在恐惧和惶恐不安之中的受苦的人。</p>
<p>了解同爱情还有另一个基本的关系。希望同另一个人结合以逃避自我孤独的监禁同另一个完全符合人性的愿望有紧密的联系，那就是认识“人的秘密”。生命从其纯生物的角度来看是一个奇迹和秘密，而在人的范围内每个人对自己和对别人都是一个不可解答的秘密。我们认识自己，但尽管作了一切努力还是不认识自己，我们认识他人，但我们还是不认识他们，因为我们和他们都不是一回事。我们越深入我们生命的深处或另一个人的生命深处，我们离认识生命的目标就越远。尽管如此，我们不能阻止这种深入了解人的灵魂的秘密、了解人的核心，即“自我”的愿望将继续存在。</p>
<p>有一种可以认识这一秘密的令人绝望的可能性——那就是拥有掌握对方的全部权力，利用这种权力我可以随心所欲地支配他，让他按照我的意志去感受，去思想，把他变成一样东西，变成我的东西，我的财产。在这方面最明显的表现就是施虐淫者的极端作法，施虐淫者要求并能使一个人受苦，他折磨和迫使那个人泄露他的秘密。要求发现人的秘密是恣意暴行和破坏狂的基本动机。艾萨克——巴比尔(艾萨克——巴比尔(1894——1941)，苏联作家。——译者注)很清楚地表达了这一思想。他摘引俄国国内战争时一个军官的话，这个军官刚刚把他过去的主人踩死。军官说：“用一颗子弹——我想说——用一颗子弹只能把这个家伙干掉……开枪是永远不能深入他的灵魂，到达他作为一个人和有灵魂的地方。但我毫无顾忌，我已经不止一次踩死敌人，每次都超过一个小时。你知道吗——我想知道，生命到底是什么，我们天天遇到的生命到底是什么？”</p>
<p>在孩子身上我们经常能看到这条通向知识的捷径。孩子随手拿起一样东西，把它弄坏，以便认识这样东西。譬如他抓到一个蝴蝶，就很残忍地把翅膀折断，他要认识蝴蝶，迫使它交出自己的秘密。在这儿残暴有一个较深的动机：那就是希望认识事物和生命的秘密。</p>
<p>认识秘密的另一条途径是爱情。爱情是积极深入对方的表现。在这一过程中，我希望了解秘密的要求通过结合得到满足。在结合的过程中，我认识对方，认识自己，认识所有的人，但还是“一无所知”。我对生命的了解不是通过思想传导的知识，而是通过人唯一可以使用的方式——通过人与人的结合。施虐癖的产生是为了了解秘密，但却一无所得。我把一个生命一块一块的解体，我所能达到的就是这一生命被破坏。只有爱情才能带给我知识，在结合的过程中回答我提出的问题。在爱情中，在献身中，在深入对方中，我找到了自己，发现了自己，发现了我们双方，发现了人。</p>
<p>德尔斐的箴言“认识你自己”表达了我们要求认识自己和他人的愿望。这是全部心理学的渊源。因为这一愿望是要认识完整的人，认识他内心最深处的秘密，所以通常的知识，由思想传导的知识不能满足这一愿望。即使我们对自己的了解比现在高出一千倍，也不可能深入事物的最本质的东西。我们对自己是一个迷，别人对我们来说也永远会是一个迷。达到全部了解人的唯一途径是思想上的认识，也就是心理学的知识是实现通过爱情达到全面了解的一个条件。我必须客观地去认识对方和自己，以便使自己能够看到对方的现实状态或者能够克服幻想，克服我想象中的被歪曲了的他的图像。我只有客观地认识一个人，我才能在爱中了解他的真正本质。</p>
<p>另外我们还知道，我们永远不可能靠智力来了解人和宇宙的秘密，但可以通过爱情去把握它。心理学作为一门科学有其局限性。就像神学的逻辑结论是神秘主义，心理学的最终结论就是爱。</p>
<p>关心、责任心、尊重和了解是相互依赖的。在成熟的人身上可以看到这些态度的集中表现。成熟的人就是指能够创造性地发挥自己力量的人。成熟的人只想拥有他自己的劳动果实，放弃了获取全力和全知的自恋幻想，并有一种谦恭的态度。这一态度的基础是他内心的力量，单单这股力量就能使他进行真正的、创造性的劳动。</p>
<h3 id="二、父母和孩子之间的爱"><a href="#二、父母和孩子之间的爱" class="headerlink" title="二、父母和孩子之间的爱"></a>二、父母和孩子之间的爱</h3><p>母爱就其本质来说是无条件的。母亲热爱新生儿，并不是因为孩子满足了她的什么特殊的愿望，符合她的想象，而是因为这是她生的孩子。（我在这里提到的母爱或者父爱都是指“理想典型”，也就是马克斯——韦伯提到了的或者荣格的原型意义上的理想典型，而不是指每个母亲和每个父亲都以这种方式爱孩子。我更多的是指在母亲和父亲身上体现的那种本质。)无条件的母爱不仅是孩子，也是我们每个人最深的渴求。从另一个角度来看通过努力换取的爱往往会使人生疑。人们会想：也许我并没有给那个应该爱我的人带来欢乐，也许会节外生枝——总而言之人们害怕这种爱会消失。此外靠努力换取的爱常常会使人痛苦地感到：我之所以被人爱是因为我使对方快乐，而不是出于我自己的意愿——归根结蒂我不是被人爱，而是被人需要而已。鉴于这种情况，因此我们所有的人，无论是儿童还是成年人都牢牢地保留着对母爱的渴求，是不足为奇的。大多数的孩子有幸得到母爱(我们以后再谈在什么程度上得到母爱。）而成人身上的这种渴望更难得到实现。在令人满意的发展过程中，这种渴望始终是性爱的一个成分；但也经常出现在宗教形式，或者更多的是出现在神经病形式中。</p>
<p>同父亲的关系则完全不同。母亲是我们的故乡，是大自然、大地和海洋。而父亲不体现任何一种自然渊源。在最初几年内孩子同父亲几乎没有什么联系，在这个阶段父亲的作用几乎无法同母亲相比。父亲虽然不代表自然世界，却代表人类生存的另一个极端：即代表思想的世界，人所创造的法律、秩序和纪律等事物的世界。父亲是教育孩子，向孩子指出通往世界之路的人。</p>
<p>同父亲作用紧密相关的是另一个同社会经济发展有关的作用。随着私有制以及财产由一个儿子继承的现象出现，父亲就对那个将来要继承他财产的人特别感兴趣。父亲总是挑选他认为最合适的儿子当继承人，也就是与他最相像，因而也是最得他欢心的那个儿子。父亲是有条件的爱。父亲的原则是：“我爱你，因为你符合我的要求，因为你履行你的职责，因为你同我相像。”正如同无条件的母爱一样，有条件的父亲有其积极的一面，也有其消极的一面。消极的一面是父爱必须靠努力才能赢得，在辜负父亲期望的情况下，就会失去父爱。父爱的本质是：顺从是最大的道德，不顺从是最大的罪孽，不顺从者将会受到失去父爱的惩罚。父爱的积极一面也同样十分重要。因为父爱是有条件的，所以我可以通过自己的努力去赢得这种爱。与母爱不同，父爱可以受我的控制和努力的支配。</p>
<p>父母对孩子的态度符合孩子的要求。婴儿无论从身体还是心理上都需要母亲的无条件的爱和关怀。在六岁左右孩子就需要父亲的权威和指引。母亲的作用是给予孩子一种生活上的安全感，而父亲的任务是指导孩子正视他将来会遇到的种种困难。一个好母亲是不会阻止孩子成长和不会鼓励孩子求援的。母亲应该相信生活，不应该惶恐不安并把她的这种情绪传染给孩子。她应该希望孩子独立并最终脱离自己。父爱应该受一定的原则支配并提出一定的要求，应该是宽容的、耐心的，不应该是咄咄逼人和专横的。父爱应该使孩子对自身的力量和能力产生越来越大的自信心，最后能使孩子成为自己的主人，从而能够脱离父亲的权威。一个成熟的人最终能达到他既是自己的母亲，又是自己的父亲的高度。他发展了一个母亲的良知，又发展了一个父亲的良知。母亲的良知对他说：“你的任何罪孽，任何罪恶都不会使你失去我的爱和我对你的生命、你的幸福的祝福。”父亲的良知却说：“你做错了，你就不得不承担后果；最主要的是你必须改变自己，这样你才能得到我的爱。”成熟的人使自己同母亲和父亲的外部形象脱离，却在内心建立起这两个形象。同弗洛伊德的“超我”理论相反，人不是通过合并父亲和母亲，从而树立起这两个形象，而是把母亲的良知建筑在他自己爱的能力上，把父亲的良知建筑在自己的理智和判断力上。成熟的人既同母亲的良知，又同父亲的良知生活在一起，尽管两者看上去互为矛盾。如果一个人只发展父亲的良知，那他会变得严厉和没有人性；如果他只有母亲的良知，那他就有失去自我判断力的危险，就会阻碍自己和他人的发展。</p>
<p>人从同母亲的紧密关系发展到同父亲的紧密关系，最后达到综合，这就是人的灵魂健康和达到成熟的基础如果人不是这么发展就会导致神经玻限于篇幅，我不可能在这儿详细解释我的这一观点，只能简单扼要地提一下。</p>
<p>譬如造成神经病的一个原因可能是一个男孩有一个十分慈爱，却又很娇惯他的母亲，同时又有一个性格懦弱或者对孩子不感兴趣的父亲。在这种情况下，小男孩会牢牢地抓住同母亲的联系，发展成为一个十分依赖母亲的人。这种人往往孤立无援，需要得到保护，不可能获得父亲的一些特点：如纪律、独立性和驾驭生活的能力。他就会企图在所有的人身上寻找“母亲”的形象，有时在妇女身上，有时在有权威的男子身上。反之，如果母亲性情冷淡、麻木不仁或者十分专制，孩子就会把对母爱的需要转移到父亲身上，就会变成单一的向父亲方向发展的人。这样的人往往只服从于法律、秩序、权威的原则，却没有能力希望或者得到无条件的爱。如果他的父亲很有权威，同他的关系又很密切，就更会加强他的这一发展。其他的调查也得出这样的结论：即某些神经病形式，如强迫性神经病同患者的单一父亲联系有关，而另一些病状，如歇斯底里、酗酒，不能面对现实生活和厌世则是同母亲的单一联系所致。</p>
<h3 id="三、爱的对象"><a href="#三、爱的对象" class="headerlink" title="三、爱的对象"></a>三、爱的对象</h3><p>爱首先不是同一个特殊的人的关系，而更多的是一种态度，性格上的一种倾向。这种态度决定一个人同整个世界，而不是同爱的唯一“对象”的关系。如果一个人只爱他的对象，而对其他的人无动于衷，他的爱就不是爱，而是一种共生有机体的联系或者是一种更高级意义上的自私。尽管如此大多数人都认为爱情取决于对象，而不是能力。他们甚至认为专爱一个人就是强烈爱情的证明。我们在上面已经提到过这一错误的结论。正因为人们不是把爱情看作是一种积极的行动，灵魂的一股力量，所以他们认为只要找到爱的对象就行，别的东西自然而然就会产生。可以把这一态度同想画一张画的人作一比较：这个人虽然想画画，但他不是去学绘画这门艺术，而是强调他首先要找到他愿意画的合适的对象。如果他找到了这么一样东西，他也就能画了。如果我确实爱一个人，那么我也爱其他的人，我就会爱世界，爱生活。如果我能对一个人说：“我爱你”，我也应该可以说：“我在你身上爱所有的人，爱世界，也爱我自己。”</p>
<p>认为爱情是一种同所有人相关，而不是只关系一个人的观点并不意味着不同形式的爱情在爱情的对象方面没有区别。</p>
<h4 id="1、博爱"><a href="#1、博爱" class="headerlink" title="1、博爱"></a>1、博爱</h4><p>一切爱的形式都以博爱为基础。作者指的博爱就是对所有的人都有一种责任感，关心、尊重和了解他人，也就是愿意提高其他人的生活情趣。</p>
<h4 id="2、母爱"><a href="#2、母爱" class="headerlink" title="2、母爱"></a>2、母爱</h4><p>虽然对母亲的动机各有解释，但最重要的动机是我们称之为“超越自己”的追求。这一追求属于人的最基本要求，并以人的觉悟和下列事实为基础：即人对自己的纯生物作用不满，他不能忍受自己仅仅是被扔进这一世界的小卒。他一定要感到自己是创造者，是能超越处于被创造者消极地位的生命。满足这一要求有许多可能性，最自然和最基本的途径就是母亲对自己创造物的关怀和爱。在孩子身上母亲超越了自我，她对孩子的爱使她的生活产生新的意义。(正因为男子不能通过生育来满足超越自己的要求，所以他只能通过用双手创造物体和创造思想来证明他的创造能力。)</p>
<p>但是孩子必须长大，必须脱离母体和母亲的乳房，必须成为一个完整的、独立的生命。母亲的真正本质在于关心孩子的成长，这也就意味着也关心母亲和孩子的分离。这里我们就可以看到母爱和性爱的区别。在性爱中两个迄今为止分开的人结合在一起，而在母亲中过去是一体的两个人分开了。母爱不仅应该允许这一分离，而且还应该希望并促成这一分离。只有在这个阶段，母爱才成为一项艰巨的任务，因为这时就要求母亲无私并能贡献出一切，除了被爱者的幸福一无所求，但恰恰在这点上许多母亲都失败了。自恋的、专制的和贪婪的妇女在孩子尚小的时候，可以是一个很疼爱孩子的母亲。但是当孩子处于同母亲分离的阶段时，只有那些真正有能力爱的妇女，那些觉得给比得更幸福的妇女，那些生命之根底很扎实的妇女才会继续是一个疼爱孩子的母亲。</p>
<p>对正在成长的孩子的爱，这种忘我无私的母爱也许是爱的最困难的形式。但是由于母亲对孩子的爱是那么自然，所以往往给人一种容易做到的假象。正因为难以做到这点，所以只有那些有能力爱的妇女，那些热爱丈夫，热爱其他孩子，热爱陌生人和人类的妇女才能成为真正爱孩子的母亲。在这个意义上，没有能力爱的妇女当她们的孩子幼小时，可以是一个很娇惯孩子的母亲，但永远成不了爱孩子的母亲。检验这一点的试金石是看一个母亲愿意不愿意忍受同孩子的分离，以及在分离后能不能继续爱孩子。</p>
<h4 id="3、性爱"><a href="#3、性爱" class="headerlink" title="3、性爱"></a>3、性爱</h4><p>博爱是同等人之间的爱，母爱是对需要帮助的人的爱，虽然这两者之间有很大的区别，但它们却有一个共同点：那就是按它们的本质，它们的爱不属于一个人。如果我爱我周围的人，我也爱所有的人，如果我爱我的一个孩子，我也爱其他的孩子以及所有需要我帮助的孩子。同这两种类型不同的是性爱，性爱要求完全彻底地实现合二为一，要求自己同他人完全融会。按其性质，这种类型的爱是专一的，不是包罗万象的，因此这种爱也是爱的最能迷惑人的形式。</p>
<p>首先这种爱常常会同“堕入情网”的爆炸式的经历混为一谈，在这种情况下，两个人之间的所有隔阂突然都消失了。正像上面已经提到过的那样，按其本质这种突如其发的强烈感受是注定短命的。当陌生人成为亲密的人，就没有需要克服的障碍了，就不需要作出努力去达到真正的接近。爱者对被爱者的了解同对自己的了解一样多，也许我应该说——一样的少。如果体验对方达到一定的深度，那你对对方就不会那么熟悉——而克服两个人之间的障碍的奇迹就会一天天地重复。但大多数人无论对自己还是对别人都是了解得非常快，而且很快就觉得一览无余了，这恰恰是因为他们只了解了人的表面，而没有深入内心。对他们来说，人与人之间的亲密首先是通过性结合得以实现的。正因为他们觉得他们同别人的隔离首先是一种肉体上的隔离，所以肉体的结合对他们来说就意味着克服人与人的隔离。</p>
<p>另外，对许多人来说还有一系列克服人与人隔离的方法。讲述自己的生活，叙述自己的希望和恐惧，谈出自己幼稚的或者不成熟的梦想，以及找到面对世界的共同利益——所有这一切都是克服人与人之间隔离的途径。甚至表露自己的愤怒和仇恨，毫无顾忌地交心也都被看出是亲密的表现。也许从中就能解释一些夫妇常常感受到的相互之间的那股不正常的吸引力：那就是只有当他们一起睡觉或者发泄了相互的憎恨后，他们会突然感到两个人之间的亲密关系。但是这种类型的“亲密”有一个特点，那就是随着时间的推移会逐渐消失。后果就是人们要在另一个人身上，在另一个陌生人身上寻求爱。而那个陌生人又会成为“亲密”的人，新的爱情经历又会是十分强烈和幸福，然后又逐渐消失，一直到希望进行新的征服，得到新的爱情的要求重又出现——并永远幻想着新的爱情会和以前完全不同。</p>
<p>同时性要求的欺骗性又会加强这种幻想。性要求的目的旨在达到结合，而绝不仅仅是生理上的要求和为了释放折磨人的压力。这时对孤独的恐惧会加强这种要求，此外占有欲和被占有欲，虚荣心以及人的破坏性都会加强性要求——当然爱情也会加强这一要求。看起来性要求是同每一种强烈的感情混杂在一起，并因此而得到加剧，所以爱情也会加强这一要求。</p>
<p>大多数人认为性要求是同爱情联系在一起的，所以他们很容易得出具有迷惑性的结论：即如果两个人互相愿意占有对方的身体，他们就是互爱了。爱情毫无疑问会引起性结合的要求，在有爱情的情况下，这种生理关系就不会带有占有或被占有的野心和欲望，而是充满了温柔。如果生理上的结合要求不是以爱情为基础，如果性爱不具有博爱的成分，那么只会造成一种纯生理的暂时的结合。性的吸引力虽然在一刹那间会造成两者结合的幻觉，但是如果没有爱情，在这次结合后留下来的只有陌生的感觉，他们之间的距离没有缩校他们仍是一对陌生人，他们不是觉得羞愧，就是相互憎恨，因为他们比过去更强烈地感受到在幻觉消失后留下来的这种陌生感。温柔绝不是如弗洛伊德所说是性本能的升华，而是博爱的一种直接表现，既表现在爱的生理形式中，也表现在爱的非生理形式中。</p>
<p>性爱具有一种博爱和母爱都不具备的独占性。必须进一步研究性爱的这种独占性。性爱的这种独占性经常被错误地解释为是一种互为占有的联系。我们经常看到互为相爱，但对其他人却毫无情感的男女。他们的这种爱实际上是一种共同的自私，这些人往往把自己同所爱之人等同起来，并通过把一个人分成两个人的办法来克服人与人之间的隔绝。他们以为这样做就能克服孤独。但正因为他们远远脱离同时代的人，所以他们之间实际上也是隔绝和互为陌生的，结合对他们来说只是一种幻觉。性爱是具有独占性，但同时也是通过爱一个人，进而爱全人类，爱一切生命。性爱的独占性只表现在我只同一个人完全地、即在灵魂和肉体上融会为一体。性爱只有在性结合这点上，在生活的全部范围彻底献身这一点上排斥他人，而不是在一个更深的博爱意义上。</p>
<p>如果男女双方确实相爱，他们的性爱就具备一个先决条件——那就是我从我生命的本质出发去爱对方，并且去体验对方的本质。人就其本质来看都是一样的，我们既是整体的部分；又是整体，因此实际上爱谁都一样。从根本上来看爱情是意志的行为，是人作的一项把全部生命交付对方的决定。这一点也正是婚姻是不可解除的观点和许多传统婚姻形式的思想基矗在这些传统的婚姻形式中配偶不经自行选择，而是由被人挑血人们相信“先结婚，后恋爱”的说法。在现代西方世界这种观点被视为是完全错误的。人们认为爱情是一种自发的感情反应，人们会突然被一种无法抗拒的感情所控制。这里人们只看到两个人的特点，而没有看到——所有的男人都是亚当的一部分，所有的女人都是夏娃的一部分这一事实。人们拒绝认识性爱的一个重要因素：即意志的因素。爱一个人不仅是一种强烈的感情——而且也是一项决定，一种判断，一个诺言。如果爱情仅仅是一种感情，那爱一辈子的诺言就没有基矗一种感情容易产生，但也许很快就会消失。如果我的爱光是感情，而不同时又是一种判断和一项决定的话，我如何才能肯定我们会永远保持相爱呢？</p>
<p>从这一立场出发也许可以得出下列结论：即爱情只是意志的行为，献身的行为，爱谁原则上不起任何作用。不管婚姻是别人撮合的还是自行决定的——一经缔结，意志应该能够保证爱情的继续存在。看起来持有这种观点的人并没有认识到人的本质的矛盾性和性爱的矛盾性。我们所有的人是一体——但尽管如此我们每个人又都是只存在一次、不可重复的生命。从我们都是一体的意义上来看，我们能从博爱出发爱每一个人；但从我们是不一样的角度出发，性爱就要求具有特定的、独一无二的、完全是个性的成分，这种成分只存在于几个人，而不是在所有的人的中间。</p>
<p>　　因此这两种观点——一种认为性爱完全是两个人之间的吸引力，是两个特殊的人之间绝无仅有的联系；另一种观点认为性爱只是意志的行为——都是正确的；也许应该这么说，真理既不在这边，也不在那边。所以认为夫妇关系不好应该马上解除婚姻同在任何情况下都不允许解除婚姻的观点都是错误的。</p>
<h4 id="4、自爱"><a href="#4、自爱" class="headerlink" title="4、自爱"></a>4、自爱</h4><p>心理观察是否证实了在自爱和爱别人之间存在着一个基本矛盾的观点？自爱和利己是一码事，还是互为对立？此外，现代人的利己难道确实是一种对具有一切理性和感情可能性的自我的爱，还是对此有不同的解释？利己同自爱完全一样还是利己恰恰是缺少自爱的结果呢？在我们用心理学的观点分析利己和自爱以前，我们必须分析一下自爱和爱别人是相互排斥的这一错误的逻辑结论。如果把他人当作人来爱是美德，而不是罪恶的话，那么爱自己也应该是美德，因为我也是一个人，有关人的一切概念都与我有关。因此上述原则本身就是矛盾的。圣经中“爱他人如同爱己”的说法说明了对自己的完整性和独特性的尊重，爱自己，理解自己同尊重、爱和谅解别人是不可分割的。爱我同爱另一个生命是紧密相连的。</p>
<p>这里我们就触及到了使我们得出这些结论的一些心理上的先决条件。概括如下：我们的感情和态度的对象不仅是其他人，也包括我们自己。对别人的态度同对我们自己的态度互不矛盾，而是平行存在。从这一点出发来解答我们的问题就意味着爱别人和爱我们自己不是两者择一，恰恰相反：一切有能力爱别人的人必定也爱自己。原则上爱自己和爱别人是不可分的。真正的爱是内在创造力的表现，包括关怀、尊重、责任心和了解诸因素。爱不是一种消极的冲动情绪，而是积极追求被爱人的发展和幸福，这种追求的基础是人的爱的能力。</p>
<p>爱另外一个人这一事实就是爱的力量的具体体现。在爱中包含的原则上的肯定是针对所爱之人，而这个人又体现了人类以及人性。对一个人的爱包括了对所有这样的人的爱。“分工”的形式：爱自己的家庭却不爱他人，是缺乏爱的能力的表现。对人类的爱是对一个特定的人的爱的先决条件，尽管对人类的爱从其产生来看是通过对某些特定的人的爱发展起来的。</p>
<p>从中可以得出我自己也是我的爱的对象，同他人没有区别的结论。对自己的生活、幸福、成长以及自由的肯定是以爱的能力为基础的，这就是说，看你有没有能力关怀人、尊重人，有无责任心和是否了解人。如果一个人有能力创造性地爱，那他必然也爱自己，但如果他只爱别人，那他就是没有能力爱。</p>
<p>我们可以假设：爱自己和爱他人平行存在，——那我们如何来解释显然是排斥一切关心他人的利己呢？利己者只对自己感兴趣，一切为我所用，他们体会不到“给”的愉快，而只想“得”。周围的一切，凡是能从中取利的，他们才感兴趣。</p>
<p>利己者眼里只有自己，总是按照对自己是否有利的标准来判断一切人和一切事物，他们原则上没有爱的能力。这一结论难道不正好证明了对自己的关心和对别人的关心只能两者择一吗？是不是应该把利己和自爱看作是一回事才正确呢？但如果这么认为就完全错了，这一错误在自爱这个问题上已经导致许多不正确的结论。利己和自爱绝不是一回事，实际上是互为矛盾的。利己的人不是太爱自己，而是太不爱自己。缺乏对自己的爱和关心表明了这个人内心缺少生命力，并会使他感到空虚和失望。在必要时这个不幸和胆怯的人会通过各种其他的满足来弥补他失去的幸福。他看上去似乎非常关心自己，实际上只是试图通过对自己的关心去掩盖和补充自己缺乏爱的能力。弗洛伊德的观点是利己者就是自恋者，他们把对别人的爱用到自己身上。利己者没有爱别人的能力这是对的，当他们也同样没有能力爱自己。</p>
<p>如果我们把利己同在一个过度忧虑的孩子的母亲身上可以看到的那种占有欲作一比较，就更容易了解什么是利己。母亲一方面真诚地相信，她对自己的孩子特别地好，但另一方面她确实能感觉到对她宠爱的对象有一种几乎已经觉察不到的敌意。母亲之所以对孩子这么忧虑重重，并不是因为她太爱孩子，而是因为她要以此来弥补自己缺乏爱孩子的能力。</p>
<p>我们的这一关于利己本质的理论符合精神分析学家在治疗“忘我”症时所获得的经验。“忘我”是神经病的一种症兆，在为数不少的患者身上可以看到这种症兆，只是这些人一般来说不是受这种症兆，而是受到与这一症兆有关的其他的病兆，如厌世、虚弱、失去工作能力和处理不好爱情问题等的折磨。但是“忘我”不是像我上面所说的被看作是一种病兆，在大多数情况下“忘我”被看作是值得自豪的、唯一令人满意的性格特点。“忘我”的人一无所求，他只为“别人活着”，而且因为不重视自己而感到自豪。但一旦他发现，尽管他那么忘我可还是感到不幸，他同别人的关系仍然不令人满意，他就会感到吃惊。精神分析表明，这种“忘我”是一种病兆，而且常常会是主要病兆之一。患者没有能力爱，也没有能力使自己快活，他对生活充满了敌意，在他的忘我后面隐藏着一种很强的常常是自己意识不到的自私性，我们只有把他的“忘我”看作是一种病兆，使他克服缺乏创造力的缺点，也就是克服造成“忘我”以及其他病兆的根源，他才会得到痊愈。</p>
<p>忘我的本质特别表现在对其他人的影响上——在我们的文化中最常见的表现是“忘我”的母亲对自己孩子的影响。母亲认为孩子可以通过她的“忘我”认识到什么是被人爱，认识并学会什么是爱。但是她的“忘我”所造成的效果往往违背她的意愿。孩子们并没有表现出他们是幸福的，他们是被人爱的；他们一个个胆小，紧张，担心受母亲的责备并想方设法满足母亲的愿望。一般来说他们会受到母亲的那种隐蔽在深处的对生活的敌意和恐惧的传染，他们更多地是能感觉到，而不是认识到这点。总而言之，“忘我”的母亲的影响同利己者的影响并无多大区别，而且常常是前者甚于后者；因为母亲的忘我会阻止孩子对自己提出批评。孩子们的生活在一种不能使母亲失望的压力下，在道德的假面具下人们在教育他们要轻视生活。如果有机会，可以观察一下一个能真正自爱的母亲对孩子会产生什么影响，从而可以确定，再没有比一个能自爱的母亲在体验爱情、欢乐和幸福方面对孩子产生更积极的影响了。</p>
<p>爱克哈特(爱克哈特，中世纪德意志神秘主义哲学家和神学家。他认为上帝即万物，万物即上帝；通过自己的灵性，人即可与上帝合而为一，与万物混成一体，获得真正的自由。——译者注)有一句格言，最精辟地总结了关于自爱的思想。他说：“你若爱己，那就会爱所有的人如爱己。你若对一个人的爱少于爱己，如果你不是爱所有的人如同爱己，如果你不是在一个人身上爱所有的人——因为这个人就是上帝和人。一个既爱自己又爱他人如同爱己的人就是这样的人，一个值得这样评价的人。”</p>
<h1 id="爱情及其在当代西方社会的衰亡"><a href="#爱情及其在当代西方社会的衰亡" class="headerlink" title="爱情及其在当代西方社会的衰亡"></a>爱情及其在当代西方社会的衰亡</h1><p>如果爱情是那些具有创造性和成熟性格的人的一种能力，那么由此可以得出结论：每一个在一个特定社会生活的人的爱的能力取决于这一社会对这个人的性格的影响。当我们谈到当代西方社会的爱情时，我们要提出下列问题，即西方文明的社会结构以及这一社会结构产生的精神是否会促进爱情的发展。提出这一问题就意味着要对此作出否定的回答。任何一个客观地观察我们西方生活的人都会毫不犹豫地说爱情——博爱、母爱和性爱在西方是罕见的现象，许多假爱情的形式取代了它们的位置，而这些假爱情的形式实际上只是爱情的衰亡的形式。</p>
<p>资本主义社会一方面是以政治上的自由原则，另一方面是以市场作为调整一切经济活动，因此也是调节一切社会关系的原则为基础的。货物市场决定进行货物交换的条件。劳动力市场调节劳动力的买卖。有用的物和有用的人的精力和技巧都变成价值，这些价值根据市场的条件自愿公平地进行交换。譬如说鞋吧，一旦市场上没人问津，即使鞋本身是有用和必需的，也会失去任何经济价值（交换价值）。人的力气和技巧亦是如此。资本的拥有者可以购买劳动力，并命令劳动力为其资本的有利投资而劳动。劳动力的拥有者必须根据当时的市场条件出售其劳动力，才不至于挨饿。这种经济结构反映在价值的高低级别上。资本统治劳动力，无生命的物体要比劳动力，要比人的才能和一切有生命的物体价值要高。占有要高于存在。</p>
<p>这一结构从一开始就是资本主义的基础，尽管这一社会结构至今仍然是现代资本主义的标志，但有一些因素起了变化，这些因素赋予现代资本主义新的特点，并对现代人的性格结构产生深远的影响。我们看到资本主义发展的结果是资本不断集中。大企业不断地扩大，而小企业越来越受排挤。在大企业中，资本的所有权越来越同资本的管理权分开。几十万股票持有者是企业的“占有者”。管理企业的则是管理官僚阶层，他们虽然薪俸甚高，但企业并不属于他们。这些官僚不仅对获取大量利润感兴趣，而且也热衷于不断扩大企业，从而不断扩大他们自己的权力。资本的日趋集中和强大的管理官僚阶层的形成也表现在工人运动的发展中。工会把劳动力组织起来，使得工人不必在劳动力市场上孤军作战。工人成为大工会的成员，而这些大工会也同样被强大的官僚阶层所管理，并代表工人去同工业巨头对峙。无论在资本领域，还是在劳动力领域，个人的主动性被官僚阶层所取代。越来越多的人失去独立性，依附于庞大的经济帝国的官僚阶层。</p>
<p>资本集中带来的另一个决定性特点是劳动组织的特殊形式，这也是现代资本主义的特点之一。高度集中、分工严密的企业导致一种新的劳动组织，在这一组织中个人失去了个性，而成为机器中一个可以随时调换的齿轮。现代资本主义中个人的问题可以归纳如下：</p>
<p>现代资本主义需要大批能在一起协调工作的人。这些人对消费的需求越来越高，但他们的口味是标准化的，既容易受到控制，又能预测。现代资本主义需要的人是一方面能感觉到自己是自由和独立的并相信自己不屈服于任何权威、原则和良心，另一方面他们又准备执行命令，完成别人交给的任务，服服贴贴地进入社会这部机器中去，规规矩矩地听人摆布，自愿服从领导，盲目地受人指挥——只有一个例外，那就是他们要不遗余力地干活，永远地发挥作用和力争晋升。</p>
<p>那结果是什么呢？如果就是现代人对自己、对同代人和对大自然产生异化。他变成一种商品，体验到自己的生命力实际是一笔资本，这笔资本在既定的市场条件下要给他带来最大的利润。人与人之间的关系从本质上来看是互为陌生的，是自动机器之间的关系，其安全感的基础就是要想方设法靠拢一群人，在思想、感情和行动中同这一群人保持一致。虽然每个人都努力同别人接近，但实际上都是孤独的，充满了不安全感、恐惧感和负罪感。只要人与人之间的隔膜得不到克服，这种感觉就会不断出现。但我们的文明提供了各种可能性，使人们感觉不到这种孤独。这首先就是人们每天都重复着千篇一律僵化的机械性工作，这种工作秩序使他们不再自觉地感到人追求超越和统一的基本要求。但是光靠这个还不行，因此人就通过享受，通过娱乐工业提供的音乐、画片，以及通过不断地购买新的物品去减少这种尚未意识到的绝望。事实上现代人很像休克斯勒尔（休克斯勒尔(1894——1963),美国作家，深受佛教的影响。——译者注）在他的《美丽的新世界》一书中描绘的那付样子：“营养充分，穿戴讲究，性欲得到满足，但却没有自我，同他同时代的人也只有表面的接触。”现代人的宗旨正如休克斯勒尔简明扼要地总结的那样是“今朝有酒今朝醉”或者是“今日，人人幸福”的颂词。现代人的幸福就是享受，就是满足消费和同一群人同化的要求。他们消费商品、图片、食品、饮料、香烟、人、杂志、书籍、电影，真是无其不有。世界只是为了填饱他们的肚子，就象一个巨大的苹果，一个巨大的酒瓶和一个巨大的乳房，而我们是婴儿，永远在期待，在希望，却永远是个失意者。我们的性格努力地适应进行交换、接受和消费的要求。所有的一切——精神的和物质的东西——都成为交换和消费的对象。</p>
<p>至于爱情，当然也完全符合现代人的社会性格。自动机器是不会爱的，它们只能交换“一揽子特性”，想做一笔好买卖。在这一异化了的结构中，人在爱情上的基本要求是“结伴”思想，这在婚姻中表现得尤为突出。在无数宣传美满婚姻的文章中，一对毫无摩擦的伴侣被奉为是理想的结合。这一宣传同社会要求职员应得心应手的标准毫无两样。这个职员必须“相应独立”，是一个很好的合作者，宽容，同时又具有进取心，对生活的要求又很高。正像婚姻顾问对我们介绍的那样，一个丈夫应该理解他的“妻子”，并是她的帮手。他应该赞赏她妻子的新衣服，也要称赞她做的饭菜。而每当丈夫疲劳不堪、怨气十足地回家来时，妻子则应该体谅他，当丈夫谈到职业上的麻烦事时，妻子应该注意听他讲。如果丈夫忘记了她的生日，妻子不应该生气，而应该通情达理。所有这一切无非是表明这两个人的关系如上了油一样毫无摩擦，但这两个人一辈子都会互不了解，永远达不到“中心关系”，而是敬如宾客，只是尽力使对方舒适而已。这样的爱情和婚姻概念实际上是强调保护自己免遭不可忍受的孤独感的侵袭。在“爱情”中人们终于找到了避风港。两个人结成用以反对全世界的同盟，却把这种两个人的自私看作是爱情和信赖。</p>
<p>强调结伴的精神，强调相互之间的宽容是一个比较新的发展。在第一次世界大战后的那段日子起作用的是另一种爱情公式。那时性的相互满足是令人满意的爱情关系，特别是幸福婚姻的基础。人们认为造成许多不幸婚姻的原因是夫妇在性生活上不能很好地“配合”，而根源是缺乏对性生活的正确态度，也就是一方或双方都没能很好地掌握性生活的技巧。为了“消除”这种缺陷和帮助那些不能相爱的不幸的夫妇，许多书里都提供了各种正确的性态度的建议和说明，并多多少少许诺只要这样，幸福和爱情就会油然而生。其基本思想是：爱情是性生活得到满足的产物，如果男女双方学会在性生活上使对方满足，他俩就会相爱。这一点完全符合社会上流行的幻想，即正确的技术不仅能解决工业生产的问题，也能解决人的问题。人们没有看到，与此相反的观点才恰恰是正确的。</p>
<p>爱情不是性满足的结果，而是性的幸福，甚至掌握所谓的性技巧也是爱情的结果。如果一定要证实这一观点，除了日常的观察外，还可以求助于精神分析治疗的许多具体实例。对最经常出现的性问题的研究——妇女的性冷淡，男子心理上的各种严重的或不太严重的阳痿形式——表明产生这些问题的原因不在于缺乏技巧，而是这些男女的胆怯心理使他们失去爱的能力。害怕异性、憎恨异性是造成这些困难的原因，这些困难阻止他们献出自己和自发地行动，使他们在生理上无法忍受异性的靠近。如果一个有性障碍的人能从他的恐惧和憎恨中摆脱出来，他就会获得爱的能力，他的性问题也就解决了。如果不能摆脱出来，即使有再多的性技术的知识也无济于事。</p>
<p>把爱情看作是性满足的产物，把爱情看作是结伴思想和防止孤独的避风港，这两种观点是西方社会中爱情衰亡的两种“正常”形式，是由社会决定并造成的爱情病理学。这种病理学有许多个性化的形式，其结局都是自觉地受苦。这些形式被精神分析学家和越来越多的外行称为神经玻下面通过几个例子简明地说明一些经常出现的形式。</p>
<p>造成精神病态爱情的基本条件是“相爱的”一方或双方都牢牢地抓住父亲或母亲的形象，并把他以前对父亲或母亲怀有的感情、期待和恐惧成年后都转移到“所爱者”身上。这些人从来没有超越儿童阶段，成年后还在寻找儿童时代的联系。在这种环境下，这些人在感情生活方面始终是停留在二岁、五岁或十二岁的阶段，但他们的智力和社会能力却符合他们的实际年龄。在严重的情况下，感情上的这种不成熟状态会破坏其社会生活；在不那么严重的情况下这一冲突只限于个人亲密关系的范畴。</p>
<p>我们再回到我们前面已经提到过的以父亲为中心或以母亲为中心的讨论。下面的例子与我们现在经常能看到的病态爱情关系有关，也就是男子在感情发育过程中始终停留在同母亲的联系上。这些男子从来没有断奶，他们始终感到自己是孩子，他们需要母亲的保护、母爱、温暖、关怀和欣赏。他们需要无条件的母爱——得到这种爱只需要一个条件，那就是他们需要这种爱，他们是母亲的孩子，弱小无力。这些人在企图赢得一个女子的爱时，往往和蔼可亲，风度翩翩；如果他们成功了，仍然会保持这副样子。但他们同这个女子的关系（实际上同对所有的人的关系一样）都是表面的，而且不负责任。他们的目的是被人爱，而不是爱自己。在这种类型的人身上往往可以看到很强的虚荣心和没有完全暴露的远大志向。如果他们找到“合适”的妻子，他们就信心十足，觉得自己占了全世界的上风；这时他们对其他人也会和蔼可亲，温文尔雅。但在过了一段时间后他的妻子不再符合他的想象，就会出现冲突和摩擦。如果他妻子不始终如一地欣赏他，如果她要求有自己的生活，希望得到爱和保护，如果她——在极端的情况下——不准备原谅他的外遇（或者不流露对此有一种颇为欣赏的兴趣），这时他就会感到受到很大的伤害和失望。一般来说他还会用“妻子不爱他，自私或者专制”的说法把他的这种感情简单化。很明显，“慈母”对她的令人着迷的“儿子”的任何一个小小的疏忽都被看作是缺乏爱情的表现。这些男子一般来说把他们的文雅举止，和他们愿意使别人高兴的愿望同真正的爱情混淆起来，并因此得出他们受到不公正对待的结论。他们自以为是伟大的恋人，对妻子的不满抱怨不休。</p>
<p>只有在很少的情况下，一个以母亲为中心的男子才能正常地生活。如果他们的母亲是以一种升华的方式“爱他”（也许她虽然专制，但不具有破坏性），如果他的妻子同他的母亲是相同的类型，如果他的特殊才能能使他发挥他的魅力和赢得他人的欣赏（某些杰出的政治家就是这种情况），那么从社会角度来看他已经是“很好地纳入”社会。即使他从来没有达到一个更成熟的精神高度。但是在不少上面所说的有利条件下——当然这是一种更经济的情况——他的爱情升华（尽管不少他们的社会生活）会是巨大的失望；当这种类型的人一旦觉得他被众人所抛弃，就会出现冲突，在很多情况下会产生强烈恐惧和厌世的念头。</p>
<p>在另一种给位严重的病态爱情形式中，患者同母亲的联系更深，也更缺乏理性。在这种情况下，形象地说，问题不在于病人想回到母亲爱护的双臂之中或者给予养料的乳房，而是回到母球接受一切——和破坏一切——的怀抱里。如果说精神健康的本质在于脱离母亲的子宫，进入世界，那么严重精神病的本质就是被母体所吸引，要重新回到母体——也就是被夺走生命。这种联系往往出现在和母亲的关系中，他们的母亲以这种接受——破坏的方式同孩子联系在一起。又时她们是以爱的名义，有时是以履行责任的名义要在自己身上保留孩子，保留成长的孩子以及成年后的孩子。只有通过她们，孩子才能呼吸。这些男子除了一些侮辱女性的表面关系外不可能爱别的女人。她们不能自由和独立，而只能永远是一个残废者或者是一个罪犯。</p>
<p>母亲的具有破坏性的侵吞性的一面是母亲形象中坏的一面。母亲不仅能赋予生命，而且能夺走生命。母亲是活跃生活、也是破坏生活之人。她能创造爱的奇迹——但没有人比她更能伤害人。在宗教的象征中（如印度女神时母和在梦的象征中都可以经常找到母亲的两个截然相反的方面。</p>
<p>神经机能病态的另一个完全不同的形式可以从同父亲相关的病例中找到。</p>
<p>一个相应的例子是一个男子有一个性冷淡感情内向的母亲，而父亲却把他的爱和全部的兴趣倾注在孩子身上（这一部分是母亲冷淡的结果）。他是一个“好父亲”，同时也很专横。他如果对儿子的行为满意，他就称赞他，送给他礼物，对他很亲切。一旦他对儿子不满，他就会退居一旁或者咒骂儿子。除了父亲的疼爱以为一无所有的孩子就以一种奴隶的方式同父亲联系在一起。他的生活主要目标就是要使父亲高兴——如果他做到了，他就感到幸福、安全和满足。但如果他犯了错误，做了错事，如果他不能讨父亲的欢心，他就感到空虚、没人爱他或受到唾弃。再后来的生活中，这个人总之寻找一个他能以同样的方式与之联系的父亲形象。他的一生始终是依照他说否得到父亲的称赞而上下起落。在社会上这些人常常能获得很大的成功，他们认真、值得信赖和勤奋——先决条件是他们所选定的父亲形象要善于正确地对待他们。他们同女仔的关系则是小心翼翼和有距离的。妇女对他们来说没有中心意义；他们一般对妇女颇有点轻视，这种轻视往往被他们对妇女的像父亲对小姑娘那般的关系所掩饰。一开始，由于他们的男性特点，他们会给妇女留下一些印象；但是一旦嫁给这些男子的妇女发现他们自己在丈夫的生活中只起第二位作用，——而父亲的形象其主要作用——，她们就会越来越失望。但是也有例外的情况，那就是如果其中碰巧也是一父亲为中心的类型——这样她同一个对待她如同一个任性的孩子那样的男子在一起就会感到幸福。</p>
<p>更为复杂的病态爱情形式往往出现在下面的那种人身上，这些人的父母互不相爱，但又善于控制自己，他们既不争吵也不流露自己的不满。同时这些父母同子女的关系也很不自然。一个姑娘在叫里感受到的只是“规规矩矩”的气氛，但同父亲或母亲没有很多接触，因此留在姑娘心中的只是混乱和害怕的清晰。这个姑娘永远不知道父母的感受和想法。在这样的家庭气氛中始终存在着一种不可知和空虚的成分。后果是姑娘完全隐退到自己的小天地里去，而她的这一态度一直可以保持到她后来的爱情关系中去。另外这种回避也是不断滋长的恐惧情绪以及在这个世界无根底的感受所致，最终会导致被虐癖的倾向，因为这是可以体验强力刺激的唯一机会。这些妇女常常愿意他们的丈夫和她们吵闹，而不是正常地、理智地与他们相处，因为只有这样才能够使她们暂时地失去紧张和恐惧的感受。因此她们往往会不自觉地去激怒丈夫，一结束折磨人的空虚。</p>
<p>下面还将介绍几种经常出现的非理性的爱情形式，但不再分析原因——即同年时代发展的一些特殊因素。</p>
<p>不乏少见的假爱情的一种形式——这种形式又常常被人们称为“伟大的爱情”（经常出现在小说和电影里）——是偶像化的爱情。一个没有达到产生自我感觉高度的人（这种自我感觉的基础是创造性地发挥自己的力量）倾向于把自己所爱的人“神化”。他同自己的力量异化并把自己的力量反射到他所爱之人身上，他所爱之人被当做一切爱情、光明和祝福的源泉而受到他的崇拜。在这一过程中，人失去了对他自己力量的觉悟，在被爱者身上失去自己，而不是找到自己。但是从长远来看，由于没有一个人能符合崇拜者的心愿，当然不可避免地就会出现失望，而解决这一问题的方法就是寻找一个新的偶像——有时候会出现恶性循环。这种偶像化爱情形式开始时的特征是爱情体验的强烈性和突发性。这种形式的爱情常常被看作是真正的伟大的爱情；但是恰恰是这种所谓的强烈性和深度性却表现了那些恋爱者的饥渴和孤独。也许不必过分强调的是，我们常常可以看到这种爱情形式相结合的男女在严重的情况下会给人一对疯子的印象。</p>
<p>另一种假爱情的形式就是人们称之为多愁善感的爱情。这种爱情的本质就是它只能存在于想象中，而不是存在于同另一个人实实在在的结合之中。这类爱情最广泛的形式是用代用品使自己满足，那就是消费爱情电影、爱情小说和爱情歌曲。通过消费这些东西可以使一切没有实现的对爱情、人与人结合和亲近的向往得到满足。那些无力拆除自己与伴侣之间那堵高墙的男女，当他们在银幕上看到悲欢离合的情侣时，会身临其境，感动得热泪盈眶。对许多夫妇来说，银幕是他们体验爱情的唯一可能性——不仅自己是这样，而且两个人会一起成为他人爱恋故事的观众。这要爱情是一个白日梦，他们就能加入进来，但如果爱情成为两个真实的人之间的一种现实关系——他们就僵化了。</p>
<p>多愁善感的爱情的另一种表现是吧现时推移到过去，一队夫妇可以通过回忆过去的爱情而受到深深的感动，虽然他们当时根本就没有感受到爱。这种情况和幻想未来的爱情完全一样。不知有多少定过婚的男女或新婚夫妇仍在憧憬未来爱情的想法，尽管她们现在已经开始感觉到对方的无聊。这种倾向符合作为现代人标志的一般态度。现在人不是生活在过去就是生活在未来，但不是现时。他们满怀感伤地回忆童年和母亲——或者为未来制定伟大的计划。不管是通过参与别人的非真正的爱情经历来体验爱情，还是通过吧现时推移到过去和未来的方法来躲避爱情的现实，这些抽象的和异化的爱情形式其作用就和鸦片一样，都是为了减轻现实、人的孤独和与世隔绝所带来的痛苦。</p>
<p>神经病态爱情的另一种形式是一套投射做法。这种投射做法能导致回避自己的问题，从而把注意力放到“所爱者”的错误和缺点上。个人在这方面的态度同民族和国家的态度没什么两样。有些人对他人的每一个细微错误的反应都十分灵敏，而对自己的问题和弱点却不闻不问，他们永远是在考虑如何指责对方或者教育对方。如果——常常是这种情况——男女双方都热衷于这么做，那他们俩之间的爱情关系就成为相互的投射。如果我们是专横或无主见的，我就指责对方有这些缺点，并且根据我的性格不是要求他改正就是为此要惩罚他。而对方也同我一样地行事——这样两个人都能回避自己的问题，因此这两个人也就不能采取使他们自己进一步发展的步骤。</p>
<p>投射的另一种形式是把自己的问题投射到孩子身上。首先这种反射常常反射在希望生孩子的愿望上。有些人之所以要孩子是因为他们想把自己的生存问题反射到孩子身上。如果当一个人感到自己没有能力赋予自己的生活一种意义时，他就会试图在他的孩子的生活里找到生活的意义。但是这必然会在自己和孩子身上造成失败的结果。失败的第一个原因是因为每一个人的生存问题只能有自己解决，而不能通过一个代理者。另外一个原因是有这种打算的人恰恰缺乏必要的能力、以引导孩子解决自己的生存问题。同时孩子还往往被当作投射的对象，以缓和父母之间的紧张关系。这些父母常使用的理论就是为了使孩子不是去一个共同的家，所以不愿离婚。但深入的调查结果表明：在这样的“共同的家”中笼罩着的那种紧张和不幸的气氛往往比公开的决裂对孩子的损害更大，因为公开的决裂至少表示一个人有能力通过一项勇敢地决定来借宿无法忍受的状况。</p>
<p>这里还必须提及一个经常出现的错误,一种幻想，即认为爱情必定意味没有冲突。按“在任何情况下都应避免痛苦和悲伤”的世俗之见，所以现代人也认为，爱情就是意味着没有冲突。他们还以他们所见之争吵都是毁灭性的争论，对双方都没有好处的事实作为理论依据。但是真正的原因在于大多数人的“冲突”实际上都是为了避免真正的冲突。这些冲突只是对一些鸡毛蒜皮的小事产生分歧而已，而这些小事按其本质来看是无法澄清或者无法解决的。但人与人之间的真正冲突——那些不应该被遮掩，也不应该投射到别处的冲突，那些属于人的内在现实并能在人的心灵深处体验到的冲突——绝不是毁灭性的。这些冲突会得到澄清，会带来一种净化，从而是双方能变得更有知识，更坚强。现在我得把我上面讲过的东西再强调一下。</p>
<p>爱情只能产生于这样两个人中间，这两个人都从他们生存的圈子里跳出来并互相结合，同时他们每个人都又能脱离自我中心去体验自己。只有这种“中心体验”才是人的现实，才是生活，才是爱情的基础。这样体验到的爱情是不断地挑战，这种爱情不是避风港，而是一种共同的努力、成长和劳动。如果两个人能从自己的生命的本质出发，体验到通过与自觉地一致，与对方结成一体，而不是逃离自我，那么在这样的基本事实面前，就连和谐、冲突、欢乐和悲伤这样的东西也就只能退居第二位了。“爱情的存在只有一个证明：那就是双方联系的深度和每个所爱之人的活力和生命力。这也是我们所能看到的爱情的唯一成果。”</p>
<p>正如自动机器不能相爱一样，自动机器也不可能爱神，因此神爱所达到的衰亡程度与人爱的衰亡程度相等。这一事实同有些人认为我们是发生在我们时代的宗教复兴的见证人的观点大相径庭。在没有比这种观点更荒唐的了。我们所经历的（即使有例外）无非是回到把神偶像化的时代，和把对神的爱变成符合异化了的人的性格结构。从新捡起把神偶像化的做法是很容易识破的。我们社会上的许多人胆小怕事，没有原则，也没有信赖，除了活下去外没有任何目标，因此他们仍然是孩子并希望在他们需要帮助的时候，能得救于父亲或母亲。在宗教文化中，譬如中世纪的宗教文化中，就是一般人都把神看作是帮助他们的父亲和母亲，这确实是事实。但是他们对待神的态度是很严肃的，他们把按照神的旨意去生活看作是他们生活的目标。可今天已经看不到这种努力了。日常生活同一切宗教价值已截然分开。生活的目的仅仅是为了寻求物质上的享受和劳动力市场上的成功。我们在世界范畴内活动的原则基础是冷漠和自私（后者常常被“个人主义”或者个人“能动性”的叫法所取代）。生活在真正宗教文化中的人也许可以同一个八岁的儿童相比较，儿童一方面把父亲看作是拯救者，但另一方面他已经开始把父亲的教诲和原则接受到自己生活中去。而现代人却像一个三岁的孩子，只有需要夫妻时才招呼他，而自己一个人能玩时，也会很高兴。</p>
<h1 id="爱的实践"><a href="#爱的实践" class="headerlink" title="爱的实践"></a>爱的实践</h1><p>行使任何一门艺术都需要有一些基本的东西，木匠艺术、医疗技术和爱的艺术都是如此。首先要求有纪律。如果没有纪律，我将会一事无成。如果我是凭一时的“兴致”去行事，这也许会成为使我感到愉快的一种嗜好，但我永远成不了大师。这里所指的纪律不是实践一门特殊艺术所要求的纪律（如每天要坚持练习几个小时），而是贯穿人的一生的纪律。也许有人会说，对当代人来说莫过于比学校纪律更容易的事了；难道当代人不是每天都要遵守劳动八小时的纪律吗？但实际情况是，在工作之外人很少能表现出一点自我纪律来。一旦他不工作，就十分懒散，无所事事——用一句好听的话来表达就是他想“轻视一下”。但恰恰是这种什么也不想干的意愿是对生活秩序作出的一种反响。正因为人们被迫每天八小时为别人的目标付出力气，以一种劳动节奏规定的方式工作，所以他就要反叛，而这种反叛就采取了无所作为的态度。另外他在反对权威的斗争中对每一种纪律都已抱有怀疑的态度。不管这种纪律是非理性的权威强加给自己的还是自己给自己规定的理性的纪律。但如果没有纪律，生活就会七零八落、混乱和没有集中。</p>
<p>集中是掌握艺术的一个必要条件，这一点是无需证明的了。每一个试图学会一门艺术的人都了解这一点。但是在我们这个社会集中比自我纪律还有罕见，我们的文化已经导致一种非集中的、分散的、史无前例的生还方式。人们往往同时干几件事：看书、听收音机、谈话、抽烟、吃饭和喝酒。人成为消费者，张开大嘴坐着，贪婪地吞下一切东西：画片、烧酒和知识。这种缺乏集中的想象特别表现在我们现在已经很难一个人安静地坐着。大多数人已经不会一个人安静的坐着，不说话，不抽烟、不看书和不喝酒。他们很快就会变得不安起来，他们一定要动嘴或者动手。（抽烟就是缺乏集中的一个症状，抽烟的人即动手、动嘴、也懂眼睛和鼻子。）</p>
<p>第三个因素是耐心。学过艺术的人都值得要达到目的就必须要有耐心。想尽可能快的取得结果的人永远也学不会一门艺术。尽管如此，对现代人来说耐心同纪律和集中一样是难以做到的。我们整个工业系统提倡的恰恰是耐心的反面，那就是要快。我们所有的机器都是为了达到快的目的：汽车和飞机把我们很快地送到预定的地点——而且要越快越好。以一半的世界生产同样多的产品的机器要比旧的和运转慢的机器好一倍。当然这里有重要的经济原因，但是正如同许多其他的方面一样，这一点也体现了人的价值原是由经济价值所决定。对机器是好的东西必然对人也是好的——这听起来似乎合乎逻辑。现代人认为如果他不很快地处理事情，就会失去时间，可他并不知道他如何利用他由此赢得的时间——除了只会无聊地打发时间。学会一门艺术还有另一个条件那就是对掌握这门艺术要有极大的兴趣。如果一门艺术没有最高意义的话，那没有一个学徒会学这门艺术。他最多成为一名业余能手，但不可能成为大师。这一条件对爱的艺术如同对其他的艺术一样同为重要。但看起来，在爱的艺术中，业余能手的人数要远远超过大师。</p>
<p>在谈及学会一门艺术的一般条件时还必须提及一点，那就是人们从来不是一开始就直接地学会一门艺术，而总是间接地学会这门艺术。一开始人们必须学会许多其他的、而且看起来经常是同这门艺术无关的东西，然后才开始学子这门艺术。木匠学徒要先学会刨木头，学钢琴的人要先练习音阶，而学习禅宗射箭艺术的人则要先练习呼吸。为了使自己成为一门艺术的大师，必须把一生献给这门艺术。在实践这门艺术时，自己要成为工具并保持一定的状态，以适应需要完成的任务。这一点在实践爱的艺术上就意味着所有想成为大师的人应该把生活的每一个阶段训练纪律、集中和耐心作为实践爱的艺术的开端。</p>
<p>那么如何训练纪律呢？我们的爷爷辈能更好地回答这一问题。他们会建议我们早起，不要过奢华的生活，要努力工作。但这种类型的纪律也有不利的一面。这种纪律死板，是把节余的道德放在首位，并且在很多方面与生活为敌。但作为对这类纪律的回答，今天越来越大的倾向是以一种怀疑的目光来对待每种纪律，并以一种懒洋洋的无所事事来找到八小时之外的平衡点。每天早晨按时起床，按时进行一定的活动，如禅坐、看书、听音乐和散步，不做或者有限度地做一些分散注意力的是如看侦探小说和电影，不暴饮暴食——这些都是明显的基本要求。但是最重要的是不要把纪律看作是外部强加的东西，而应该成为自我意志的体现，应该感到这是一种愉快，并且逐渐习惯于一种生活态度，一旦放弃它，便会若有所思。我们西方扔对纪律观念最令人遗憾的看法（对其他的到底亦是如此）是，他们认为纪律必会使人难受或不适，纪律只有达到这种效果，才是“有用的”。但是东方人很久以来就认识到，与身心有益的东西必定使人舒适，即使开始的时候需要克服一定的阻力。</p>
<p>生活在我们文化中的人很难做到集中，因为我们的全部文化似乎都是为了“分散注意力”和反对培养集中的能力。最重要的步骤是要学会一个人单独呆着，而且不看书，不听广播，不抽烟和不喝酒。有没有集中的能力表现在能不能单独地呆着——而这种能力优势学会爱的一个条件。正因为我不能自力更生，所以我只能把自己同另一个人连在一起。这个人也许就是我的生命的拯救者，但是这种关系同爱情无关。是否能一个人呆着居然成为有无能力爱的条件之一，这一点会令人奇怪。但每一个试图这么做的人将会知道做到这点是很难的。随着时间的推移他会坐立不安，甚至会感到有点害怕。于是他就会找出各种借口为自己放弃练习辩护，他会说一个人呆着毫无意义，是愚蠢的，太浪费时间，等等。他在练习的过程中还会确定，一个人呆着的时候，各种各样的念头都会冒出来，困扰你。他会突然发现他正在打算这一天还能干些什么，他在思考工作中遇到的困难或者是考虑今天晚上上哪里去。但是做一些简单的练习就能帮助他集中，譬如：轻松地坐着（即不要懒散，也不要紧张），把眼睛闭上，努力使自己的眼前出现一片白色，并排除一切干扰自己的画面和念头。然后可试着观察自己的呼吸——不要去想它，也不要去影响它，而只是要意思到自己在呼吸。另外还要试着得到一种“自我”的感受；我=我的自己+我的力量的中心+我的世界的创造者。至少每天早晨要做二十分钟这样的练习（如果有可能还有延长）和每晚睡觉前坚持练习。除这些练习外还有学会专心做一切事：专心听音乐、看书、谈话或欣赏图画。如果专心地干，那么干什么就无关紧要了，无论干什么，重要的或者不重要的都会增加一层现实意义，因为干事的人是完全开放的。为了学会集中要尽量避免无意义的谈话，也就是不能成为谈话的谈话。如果两个人在谈论他俩所熟悉的一棵树的生长情况，或者在评论刚才吃过的面包的味道，或者在回忆他们职业上的共同经历，他俩的谈话可能是重要的，这就看他俩是否真的在谈论一件经历过的事，还是就抽象的东西交换看法。另外有关政治或者宗教的谈话也肯能是毫无意义的，如果交谈者只是老生常谈，没有亲身经历的体会，只是交换一下看法而已。我这里还要补充一点，那就是不仅要逃避无聊的谈话，而且还要避免同不三不四的人来往。我这里指的不仅是要回避那些有破坏性的凶恶之人，应该回避他们，因为这些人会使人消沉和压抑，而且还指那些内心无生命力的人，那些思想和谈话都没有内容的人，这些人不是在谈话而是在闲扯，他们不会思考，指挥把一套套的世俗之见搬出来。当然不可能永远回避这些人，有时也没有费这么做的必要。在和这样的人接触中如果你不是像他们所想的那样，闲扯一通，而是直率地和与人为善改变自己的态度，这一方面是因为你的反应使他们大吃一惊，另一方面也是因为他们自己也渴望从杜撰和陈词滥调中摆脱出来，走向现实。</p>
<p>在同别人的关系中要记住首先就意味着要有听别人讲话的能力。大多数人认为他们是在听别人讲话，而且还帮对方出主意，可实际上他们根本没听进去。他们不重视别人的话，漫不经心地回答对方。后果是这样的谈话往往使他们感到疲倦。他们认为如果他们记住地听对方讲话，就会跟疲倦。可他们想错了，每一件聚精会神完成的事会使人清醒（尽管干完时候出现能恢复的自然疲劳状态）。而懒懒散散的干事只能使人产生倦意——同时这些人在夜里也很难入睡。集中意味着要完全地在现时地生活，而不是赶着这事想那事。那些相爱的人应当首先练习集中，这事理所当然的。他们必须学会亲近对方并向对方开放，而不是像通常所见的那样相互回避。万事开头难，这句俗话对练习集中也适用。人们常常会有永远达不到目的的感觉。所以显而易见练习集中还必须要有耐心。如果人们不知道学会每一种事都要有一个过程，都应自己给自己施加压力，那就永远不会学会集中。要想知道什么是耐心，只有观察幼儿学走路就行。孩子一次、二次、三次跌倒在地上，可他还是坚持着走下去，一直到不摔跤为止。有孩子学走路的耐心和集中他会作出多么大的成绩啊！</p>
<p>集中还要求另一样东西，那就是对自己要保持清醒。如果解释呢？难道应该不断思考自己、“分析”自己，还是别的？如果我们把一个人对一部机器的高度的注意力做例子，也许就能很容易地回答这个问题。譬如有汽车的人对自己的汽车总是很警觉的，任何一种细微的声响和马达功能的变化都不会被他放过。统一开车的人对马路表面的变化、前后车辆的速度及方向变化也十分灵敏。尽管如此开车的人并没有去思考这些现象，他只是处在一种清醒状态之中，对他所集中于的事（也就是安全行驶）所发生的任何变化都会做出反应。</p>
<p>我们用母亲对婴儿的态度做例子就能说明什么是对一个生命的清醒的关注。在婴儿还没有表达以前，母亲就能感觉到婴儿体内的一些变化、他的愿望和需要。婴儿一叫或一哭，母亲就会醒来，虽然平时比这更响的声音都不会吵醒她。这说明了母亲对孩子的每一种生命的表现都是很清醒的，母亲即不害怕，也不担心，而是助于一种清醒的平衡状态，能接受孩子发出的每一个重要信号。我们也可以以同样的方式清醒地面对自己。譬如在感觉到累或者消沉的时候，不应该听之任之和用随时可以捡来的消沉的想法去加剧这种感受，而应该问问自己：到底发生了什么？为什么我那么一蹶不振？同样在我们生气或者迷惑不解的时候，在我们开始想入非非的时候，都应该这样问自己。在所有这种情况下，终于的是要觉察内心的活动，而不是用各种各样的方法去找到为自己辩护的借口。这样我们就此次会听到内心的一种声音，在向我们讲述，为什么会害怕、消沉或者迷惑不解。一般人对自己体内的活动都有一定的警觉性；能感觉到每种变化和甚至能发现几乎感觉不到的疼痛。注意身体的变化是比较容易做到的，因为大多数人都了解自己的健康状态。电脑上对心灵变化就不可能那么灵敏，因为许多人还从来没见过一个对自己的内心活动保持清醒的人。对他们来说，衡量内心活动是否正常的标准是他们的父母和亲戚，或者是他们加入的社会集团，只有他们同这一标准没有区别，他们就决定自己很“正常”，也就没有兴趣去观察与他们不同的生活态度。譬如有许多人还从来没有见过一个有爱的能力的人或者一个独立完整的、具有勇气和能集中干事的人。为了能清醒地面对自己，必须要有一个设想，要知道什么叫做健康地、活跃地、充满人性地发挥人的作用。可是如果我们既没有在童年时代，也没有在后来的岁月里有过这种体验，我们又如何能得出这样的结论呢？对这个问题肯定不会有简单的回答，但这个问题却击中了我们教育制度的要害。</p>
<p>在传授知识方面，我们忘记了对人的发展来说是作重要的教诲，呢就是一个成熟的和慈爱的人的现身教育。在外面自己文化的某系阶段，或者在中国和印度，最有影响的是德高望重的人。教师不仅或不首先是传授知识，他的任务还包括培养学生具有一定的人的品质。在当代资本主义社会——这一点也适用于俄国共产主义，值得钦佩和作为榜样的人绝不是因为他们具有高尚的品质。电影明星、播音员，一些新闻记者以及政界和经济界的巨头是老百姓的榜样。这些人的主要资本常常是因为他们能够扬名四海。但尽管如此，情况还不至于糟到使人绝望。如果我们想一想，像阿尔贝特-施威策这样的人能在美国和其他地方出名，如果我们看到有许多可行的办法，能使我们的青年一代熟悉那些活着的和死去的优秀人物，并通过这些人了解人能不断完善自己，如果我们想到文学和所有艺术的那些不朽之作，我们就相信有可能去传授人应该如何清醒地、充满活力的生活。如果我们做不到这点，我们很可能会面临有一天我们整个的文化传统崩溃的下场。我们的文化传统首先不是以传授一些思想和知识为基础，而是传授做人的态度。如果我们的后代不在能经历这一传统，我们五千年的文化就会崩溃，即使人们孩子继续不断地传授和发展知识。</p>
<p>上面我们分析了在行驶所有艺术时必须具备的条件，现在我要谈一下掌握爱情艺术的必不可少的特殊条件。根据我对爱情本质的论述，获得爱的能力的主要条件是克服自恋。自恋倾向是人的一种态度，具有这种态度的人体验到的现实只是内心活动，主要是他们自己的贪婪和恐惧，对他们来说，外部世界的现象本身是不现实的，只有对他们有利或者威胁他们的食物才有意义。同自恋相反的是客观性，客观性就是对人和事物都有开放的态度，能实事求是地看待事物。这个意义上的客观性就是能从表面深入现象核心的实现主义。同自恋相反，客观性的基础不是与外部世界毫无关系，而是有强烈的联系。精神病的所有形式是没有客观性的极端形式，在这个意义上就是对客观事物没有开放的能力。对精神病患者来说，如果有现实的话，那也只存在于他的内心，就是他的恐惧和欲望。外部世界对他来说只是他内心世界的象征，只是他的创造物。我们做梦的时候，也有类似的现象。在梦里发生的具体事件象征内心活动，即使如此，睡梦中的无名还是深信梦里发生的事同我们在清醒状态感觉到的现实一样真实。</p>
<p>但是梦和精神病仅仅是缺乏客观性的极端例子。我们每个人对世界都有一个非客观的图像，一个被我们的自恋倾向所歪曲了的图像。难道还需要我举例说明吗？只要我们观察自己和邻居或者看报的话，是不难找到这样的例子的，只是由于自恋的程度不一，歪曲客观的程度也有高低。譬如一位妇女打电话给他的医生，告诉他，她很想当日下午去他那儿看病。医生说，他今天下午没有空，明天下午才有空。可能个妇女却说：“医生，可我住的地方离您那儿才五分钟的路！”这位妇女不能理解她住的虽然近却不能节省医生的时间。她完全是从自恋的角度出发看问题的：因为她节省了时间，所以医生也节省了时间。对她来说“我”是唯一的现实。</p>
<p>不那么极端的例子——或者也许仅仅是不能吗明显而已——常常出现在人与人的关系中。真不知有多少父母首先关兴趣的是他们的孩子是否听话，是否使他们高兴等等，而不是孩子自己经历了些什么，是怎么经历的——当然这些经历与父母无关。真不知有多少丈夫认为他们的妻子很专横，实际上是由于他们自己同母亲的幼稚的联系而把妻子的被一个要求解释为是限制他们的“自由”。真不知又有多少妻子认为她们的丈夫无能或者软弱，而实际上仅仅是因为丈夫不符合他们童年时代想象中的光彩夺目的骑士啊！</p>
<p>对其他民族缺乏客观性就更常见，也更具有危险性。一个民族会突然地把另一个民族看成是劣等的和敌对的，却自认为本民族体系一切优秀的和高贵的品质。敌人的行为用一种尺度衡量，而自己的行为却用另一种尺度衡量。甚至敌人的善意举动也被看作是险恶用心的产物，只是为了遮住我们和世界的眼目而已，可另一面有用高贵的动机来为自己的坏行为辩护。如果我们考察一下民族与民族、人与人之间的关系，我们一定会得出下列结论：客观性是例外，而不同程度的自恋是常规。</p>
<p>能进行客观思考的能力就是理智，以理智为基础的感情是谦恭。我们只有摆脱了童年时代妄图得到全知、全能的幻想，才能有客观性和运用自己的理智。</p>
<p>这在爱的艺术的实践上的表现在：能否学会爱取决于人的自恋程度和能不断培养自己的谦恭、客观性和理智。我们应该一辈子为此努力。谦恭和客观性同爱情一样不能只限于生活的一些范围。如果我对陌生人没有客观的态度，那我对自己的家也不会真正客观，反之亦然。</p>
<p>我想学会爱的艺术，我就应该在任何情况下都力求客观，并且能注意到在什么情况下我没有力求客观，并对此保持清醒的态度。我应该努力去认识一个被我自恋歪曲了的人的形象同这个人的实际面目，也就是同我的利益、困难和恐惧无关的实际面目之间的区别。有无客观性和理智是学会爱的艺术的一个关键性条件，人们应该对所有与自己所接触的人都能保持理智和客观。如果我们只对所爱之人保持客观，而以为对其他人就不需要客观性，那我们很快就能发现我们既不能处理好自己同所爱之人的关系，也处理不好同其他人的关系。</p>
<p>爱的能力取决于我们本人成熟的程度，以及在我们同世界和同自己的关系中能不能发展一种创造性的倾向。这种脱离自己的过程、诞生和成熟的过程需要另一种品质作为必不可少的条件：那就是信仰。爱情是以信仰为基础的<br>什么是信仰?难道信仰就一定是信仰上帝或者别的宗教教义?信仰是否同理智和理性的思考对立？信仰是不是只是一种无法证明的没有根底的知识呢?首先应该区别合理的信仰和非合理的信仰。我理解的非合理的信仰是指服从一种非理性权威的信仰(信仰一个人或者一种理想)。与此相反，合理的信仰是扎根于自已思想或感情体验的一种坚定的信念。合理的信仰首先不是信仰什么东西，而是一种确认，这种确认是符合建筑在自己真实经历上的坚定的信念。信仰是全部人格的一个性格特点，而不是同某些被看作为对的思想内容有关的东西。</p>
]]></content>
      <tags>
        <tag>book</tag>
      </tags>
  </entry>
  <entry>
    <title>算法整理</title>
    <url>/uncategorized/leetcode/</url>
    <content><![CDATA[<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><h2 id="rust-中-dbg-超时"><a href="#rust-中-dbg-超时" class="headerlink" title="rust 中 dbg! 超时"></a><code>rust</code> 中 <code>dbg!</code> 超时</h2><p>在 <code>rust</code> 中使用 <code>dbg!</code> 的时候，在题目判定时，可能会因为 <code>dbg!</code> 超时，提交代码的时候要去掉 <code>dbg!</code></p>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p>第 27、977 题就是经典的双指针题目。</p>
<ul>
<li>有序数组平方。</li>
</ul>
<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>注意，使用滑动窗口的时候，只用一个 for 循环代表滑动窗口的结尾，否则又会陷入两个 for 的困境。</p>
<ul>
<li>长度最小的子数组</li>
</ul>
<h2 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>    s[i] = s [i-<span class="hljs-number">1</span>] + a[i];<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="Java-多组输入示例"><a href="#Java-多组输入示例" class="headerlink" title="Java 多组输入示例"></a>Java 多组输入示例</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>        <span class="hljs-type">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span>[] s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            nums[i] = scanner.nextInt();<br>            s[i] = s[i - <span class="hljs-number">1</span>] + nums[i];<br>        &#125;<br>        <br>        <span class="hljs-keyword">while</span> (scanner.hasNextInt()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>            System.out.println(s[b+<span class="hljs-number">1</span>] - s[a]);<br>        &#125;<br>        scanner.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="模拟矩阵"><a href="#模拟矩阵" class="headerlink" title="模拟矩阵"></a>模拟矩阵</h2><ol>
<li>走完一行或者一列对 x 和 y 进行处理，使得继续走下一行而不下标越界</li>
<li>走完一行或者一列对 x 和 y 进行处理，使得走到没有写数字的地方</li>
<li>走完一行或者一列对边界进行处理</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] generateMatrix(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-type">int</span> [][]result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">xMax</span> <span class="hljs-operator">=</span> n, yMax = n, xMin = <span class="hljs-number">0</span>, yMin = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (count &lt;= n * n) &#123;<br>            <span class="hljs-comment">// 向右</span><br>            <span class="hljs-keyword">while</span> (y &lt; yMax) &#123;<br>                result[x][y] = count++;<br>                y++;<br>            &#125;<br>            y--; <span class="hljs-comment">// 能够向下走</span><br>            x++; <span class="hljs-comment">// 走到没写过数字的地方</span><br>            xMin += <span class="hljs-number">1</span>; <span class="hljs-comment">// 向右一行补充完向上少走一行</span><br><br>            <span class="hljs-comment">// 向下</span><br>            <span class="hljs-keyword">while</span> (x &lt; xMax) &#123;<br>                result[x][y] = count++;<br>                x++;<br>            &#125;<br>            x--; <span class="hljs-comment">// 能够向左走</span><br>            y--; <span class="hljs-comment">// 走到没写过数字的地方</span><br>            yMax -= <span class="hljs-number">1</span>; <span class="hljs-comment">// 向右少走一行</span><br><br>            <span class="hljs-comment">// 向左</span><br>            <span class="hljs-keyword">while</span> (y &gt;= yMin) &#123;<br>                result[x][y] = count++;<br>                y--;<br>            &#125;<br>            y++; <span class="hljs-comment">// 能够向右走</span><br>            x--; <span class="hljs-comment">// 走到没写过数字的地方</span><br>            xMax -= <span class="hljs-number">1</span>; <span class="hljs-comment">// 向下少走一行</span><br><br>            <span class="hljs-comment">// 向上</span><br>            <span class="hljs-keyword">while</span> (x &gt;= xMin) &#123;<br>                result[x][y] = count++;<br>                x--;<br>            &#125;<br>            x++; <span class="hljs-comment">// 能够向右走</span><br>            y++; <span class="hljs-comment">// 走到没写过数字的地方</span><br>            yMin += <span class="hljs-number">1</span>; <span class="hljs-comment">// 向左少走一行</span><br><br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a>最大子数组和</h2><p>dp[i] 代表以第 i 个元素结尾的最大子数组的和：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSubArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            dp[i] = Math.max(dp[i - <span class="hljs-number">1</span>] + nums[i - <span class="hljs-number">1</span>], nums[i - <span class="hljs-number">1</span>]);<br>            ans = Math.max(ans, dp[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h2 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a>合并区间</h2><p>要点在于判断什么时候可以合并，什么时候不能合并：</p>
<ul>
<li>先根据开头位置排序</li>
<li>下一个区间的开头大于当前末尾的时候不能合并</li>
<li>其他情况可以合并</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] merge(<span class="hljs-type">int</span>[][] intervals) &#123;<br>        Arrays.sort(intervals, (a, b) -&gt; &#123; <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>]; &#125;);<br>        List&lt;<span class="hljs-type">int</span>[]&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        ans.add(intervals[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; intervals.length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> ans.get(ans.size() - <span class="hljs-number">1</span>)[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (intervals[i][<span class="hljs-number">0</span>] &gt; right) &#123; <span class="hljs-comment">// 下一个的头部大于当前最后一个，不合并</span><br>                ans.add(intervals[i]);<br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 可以合并</span><br>                right = Math.max(right, intervals[i][<span class="hljs-number">1</span>]);<br>                ans.get(ans.size() - <span class="hljs-number">1</span>)[<span class="hljs-number">1</span>] = right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[ans.size()][]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="轮转数组"><a href="#轮转数组" class="headerlink" title="轮转数组"></a>轮转数组</h2><p>反转三次数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        reverse(nums, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>        reverse(nums, <span class="hljs-number">0</span>, (k % n) - <span class="hljs-number">1</span>);<br>        reverse(nums, k % n, n - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>        <span class="hljs-keyword">while</span> (start &lt; end) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> nums[start];<br>            nums[start] = nums[end];<br>            nums[end] = tmp;<br>            start++;<br>            end--;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="除自身以外数组的乘积"><a href="#除自身以外数组的乘积" class="headerlink" title="除自身以外数组的乘积"></a>除自身以外数组的乘积</h2><p>要求不使用除法，并且当前元素如果为 0 的时候，总和除以当前元素也用不了。</p>
<h3 id="没有优化"><a href="#没有优化" class="headerlink" title="没有优化"></a>没有优化</h3><p>要点在于将当前以外的乘积分为左边和右边部分，这样就可以划分并逐步计算得到答案。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] productExceptSelf(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] l = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>], r = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        l[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        r[n] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            l[i] = l[i - <span class="hljs-number">1</span>] * nums[i - <span class="hljs-number">1</span>];<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">1</span>; j--) &#123;<br>            r[j] = r[j + <span class="hljs-number">1</span>] * nums[j];<br>        &#125;<br><br>        <span class="hljs-type">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            ans[i] = l[i] * r[i + <span class="hljs-number">1</span>];<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="优化空间"><a href="#优化空间" class="headerlink" title="优化空间"></a>优化空间</h3><ul>
<li>用 ans 数组记录右边数组的乘积，然后用一个变量记录左边数组的乘积。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] productExceptSelf(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        ans[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        ans[n - <span class="hljs-number">1</span>] = nums[n - <span class="hljs-number">1</span>];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            ans[i] = ans[i + <span class="hljs-number">1</span>] * nums[i];<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (i &lt; n - <span class="hljs-number">1</span>) r = ans[i + <span class="hljs-number">1</span>];<br>            ans[i] = l * r;<br>            l = l * nums[i];<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="缺失的第一个正数"><a href="#缺失的第一个正数" class="headerlink" title="缺失的第一个正数"></a>缺失的第一个正数</h2><p>要点在于</p>
<ul>
<li>原地哈希，<code>f(nums[i]) = nums[i] - 1</code></li>
<li>其他的在于防止死循环和保证所有数字都被 hash 过</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">firstMissingPositive</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">isSwap</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">while</span> (isSwap) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> nums[i] - <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> &lt;= hash &amp;&amp; hash &lt; n &amp;&amp; i != hash &amp;&amp; nums[hash] != nums[i]) &#123; <span class="hljs-comment">// 第3个和第4个条件防止死循环</span><br>                    swap(nums, i, hash);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    isSwap = <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br><br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> != nums[i]) &#123;<br>                <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> nums[i];<br>        nums[i] = nums[j];<br>        nums[j] = tmp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1><h2 id="矩阵置零"><a href="#矩阵置零" class="headerlink" title="矩阵置零"></a>矩阵置零</h2><p>给定一个 <strong><code>m x n</code></strong> 的矩阵，如果一个元素为 <strong>0</strong> ，则将其所在行和列的所有元素都设为 <strong>0</strong> 。请使用 <strong><a href="http://baike.baidu.com/item/原地算法">原地</a></strong> 算法。</p>
<p>难点在于原地算法，否则很简单，模拟就好，模拟的时候注意不要跳过本来为 0 的元素。</p>
<h2 id="旋转图像"><a href="#旋转图像" class="headerlink" title="旋转图像"></a>旋转图像</h2><p>要点在于：</p>
<ul>
<li>做不到一步直接交换到位</li>
<li>先副对角线对称，然后上下对称</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-comment">// 沿着副对角线对称，然后上下交换</span><br>        <span class="hljs-comment">// 9 6 3</span><br>        <span class="hljs-comment">// 8 5 2</span><br>        <span class="hljs-comment">// 7 4 1</span><br><br>        <span class="hljs-comment">// 找到每个元素的 swap 位置</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-comment">// 沿着副对角线对称</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= n - <span class="hljs-number">1</span> - i; j++) &#123;<br>                <span class="hljs-comment">// 关于副对角线对称有 (i, j) &lt;-&gt; (n-1-i, n-1-j)</span><br>                swap(matrix, i, j, n - <span class="hljs-number">1</span> - j, n - <span class="hljs-number">1</span> - i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 沿着 x 轴对称</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n / <span class="hljs-number">2</span>; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-comment">// 关于 x 轴对称有 (i, j) &lt;-&gt; (n-1-i, j)</span><br>                swap(matrix, i, j, n - <span class="hljs-number">1</span> - i, j);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> matrix[i][j];<br>        matrix[i][j] = matrix[x][y];<br>        matrix[x][y] = tmp;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 副对角线对称</span><br><span class="hljs-comment">// 0,0 -&gt; n-1,n-1</span><br><span class="hljs-comment">// 0,1 -&gt; n-2,n-1</span><br><span class="hljs-comment">// 0,n-1 -&gt; 0,n-1</span><br><span class="hljs-comment">// 1,0 -&gt; n-1,n-2</span><br></code></pre></td></tr></table></figure>
<h2 id="搜索二维矩阵-II"><a href="#搜索二维矩阵-II" class="headerlink" title="搜索二维矩阵 II"></a>搜索二维矩阵 II</h2><p><img  src="/searchgrid2.jpg"  ><span class="image-caption">img</span></p>
<h3 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h3><p>每一行二分搜索</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">searchMatrix</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] nums : matrix) &#123;<br>            <span class="hljs-keyword">if</span> (Arrays.binarySearch(nums, target) &gt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>总时间复杂度 O(m logn)</p>
<h3 id="Z-字搜索"><a href="#Z-字搜索" class="headerlink" title="Z 字搜索"></a>Z 字搜索</h3><p>要点在于：</p>
<ul>
<li>看矩阵右上角，左边严格小于，下面严格大于</li>
<li>所以每次可以排除掉一行或者一列，总时间复杂度 O(m + n)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">searchMatrix</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-comment">// 看矩阵右上角，左边严格小于，下面严格大于</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, col = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (row &lt; m &amp;&amp; col &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (target == matrix[row][col]) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target &gt; matrix[row][col]) &#123;<br>                row++;<br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// target &lt; matrix[row][col]</span><br>                col--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h1 id="双指针-1"><a href="#双指针-1" class="headerlink" title="双指针"></a>双指针</h1><h2 id="移动零"><a href="#移动零" class="headerlink" title="移动零"></a>移动零</h2><p>10^4 O(n)</p>
<p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<p><strong>请注意</strong> ，必须在不复制数组的情况下原地对数组进行操作。</p>
<p><strong>key：</strong>保证 right 在 left 左边。</p>
<h2 id="盛最多水的容器"><a href="#盛最多水的容器" class="headerlink" title="盛最多水的容器"></a>盛最多水的容器</h2><p>10^5 O(n)</p>
<p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有 <code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> 。</p>
<p>找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。</p>
<p>返回容器可以储存的最大水量。</p>
<p><strong>说明：</strong>你不能倾斜容器。</p>
<p><strong>思考：</strong>有两个变量决定盛水量：1. 左右的距离。 2. 较低的柱子高度。</p>
<ol>
<li>左右的距离最左到最右最大，然后慢慢缩小。</li>
<li>如果移动较高的柱子，那么盛水量不会变大，但是如果移动较低的柱子，那么盛水量有可能会变大。</li>
</ol>
<h2 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a>接雨水</h2><p>2 * 10^4</p>
<p><img  src="rainwatertrap.png"  ><span class="image-caption">img</span></p>
<figure class="highlight dns"><table><tr><td class="code"><pre><code class="hljs dns">输入：height = [<span class="hljs-number">0,1,0,2</span>,<span class="hljs-number">1,0,1,3</span>,<span class="hljs-number">2,1,2,1</span>]<br>输出：<span class="hljs-number">6</span><br>解释：上面是由数组 [<span class="hljs-number">0,1,0,2</span>,<span class="hljs-number">1,0,1,3</span>,<span class="hljs-number">2,1,2,1</span>] 表示的高度图，在这种情况下，可以接 <span class="hljs-number">6</span> 个单位的雨水（蓝色部分表示雨水）。 <br></code></pre></td></tr></table></figure>
<p><strong>key：</strong>某一处的雨水 = 全局左右最高柱子的最小值 - 当前处的高度</p>
<p>剩下的点就在求左右最高柱子处进行优化。</p>
<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>将左右最高柱子的高度分别记为 leftMax，rightMax，并 O(n) 计算出这个数组的。</p>
<p>可以用动态规划求 left 和 right 的原因是这里的 left 和 right 表示的是全局最高，而<strong>柱状图中最大的矩形</strong>这道题中不是全局最低的。</p>
<p>需要注意的点是 <strong>初始值</strong> 和 <strong>边界</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">trap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> height.length;<br>        <span class="hljs-type">int</span>[] leftMax = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-type">int</span>[] rightMax = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        leftMax[<span class="hljs-number">0</span>] = height[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            leftMax[i] = Math.max(leftMax[i - <span class="hljs-number">1</span>], height[i]);<br>        &#125;<br>        rightMax[n - <span class="hljs-number">1</span>] = height[n - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            rightMax[i] = Math.max(rightMax[i + <span class="hljs-number">1</span>], height[i]);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">total</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            total += Math.min(leftMax[i], rightMax[i]) - height[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> total;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>时间复杂度：O(n)，其中 n 是数组 height 的长度。计算数组 leftMax 和 rightMax 的元素值各需要遍历数组 height 一次，计算能接的雨水总量还需要遍历一次。</p>
<p>空间复杂度：O(n)，其中 n 是数组 height 的长度。需要创建两个长度为 n 的数组 leftMax 和 rightMax。</p>
<h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><h3 id="双指针-2"><a href="#双指针-2" class="headerlink" title="双指针"></a>双指针</h3><p>动态规划计算 leftMax 和 rightMax 的时候需要遍历一次数组，能不能直接得到 leftMax 和 rightMax 而不遍历呢？这样就可以将得到 max 的复杂度降低为 O(1) 了。</p>
<p><strong>与盛最多水的容器相同的思路，可以从两边的雨水向中间进行计算</strong>，这样可以 O(1) 得到</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">trap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> height.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxLeft</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, maxRight = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            maxLeft = Math.max(maxLeft, height[left]);<br>            maxRight = Math.max(maxRight, height[right]);<br>            <span class="hljs-keyword">if</span> (height[left] &gt; height[right]) &#123;<br>                ans += maxRight - height[right];<br>                right--;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                ans += maxLeft - height[left];<br>                left++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="滑动窗口-1"><a href="#滑动窗口-1" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><h3 id="滑动窗口模板"><a href="#滑动窗口模板" class="headerlink" title="滑动窗口模板"></a>滑动窗口模板</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 外层循环扩展右边界，内层循环扩展左边界</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span> ; r &lt; n ; r++) &#123;<br>	<span class="hljs-comment">// 当前考虑的元素</span><br>	<span class="hljs-keyword">while</span> (l &lt;= r &amp;&amp; check()) &#123; <span class="hljs-comment">// 区间[left,right]不符合题意</span><br>        <span class="hljs-comment">// 扩展左边界</span><br>    &#125;<br>    <span class="hljs-comment">// 区间[left,right]符合题意，统计相关信息</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a>无重复字符的最长子串</h2><p>5 * 10^4 级别</p>
<p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的最长子串的长度。</p>
<ol>
<li>判断重复字符：Set</li>
<li>最长字串：滑动窗口</li>
</ol>
<p>这道题官方解答为枚举所有起始位置，之后向右延申至不含重复字符的最长子串长度，如果包含重复字符，那么左指针持续移动到不含重复字符为止。</p>
<p>关键在于有重复字符的时候，是左指针持续地向右移动，而不是重新开始枚举，因为这个操作，使得时间复杂度为 O(n)，那么为什么这样不会漏掉答案呢？也就是说为什么这样一定会取到最优答案呢？</p>
<p>因为当右边要出现重复字母的的候，这个时候左指针到右指针的子串一定是对应了右指针不移动情况下的最优子串。</p>
<p>所以可以枚举右指针，并让左指针不断向右。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> &#123;<br>        Set&lt;Character&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length(), l = <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; r &lt; n; r++) &#123;<br>            <span class="hljs-keyword">while</span> (set.contains(s.charAt(r))) &#123;<br>                set.remove(s.charAt(l));<br>                l++;<br>            &#125;<br>            set.add(s.charAt(r));<br>            ans = Math.max(ans, r - l + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="找到字符串中所有字母异位词"><a href="#找到字符串中所有字母异位词" class="headerlink" title="找到字符串中所有字母异位词"></a>找到字符串中所有字母异位词</h2><p>给定两个字符串 <code>s</code> 和 <code>p</code>，找到 <code>s</code> 中所有 <code>p</code> 的 异位词的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p>
<p>3 * 10^4 级别</p>
<p>与上一题相同，需要做以下操作：</p>
<ol>
<li>判断异位词。</li>
<li>异位词子串。</li>
</ol>
<p>确定异位词需要 O(n)，n 是字符串长度。</p>
<p><strong>key：</strong>在这道题中，异位词和原词肯定是长度相同的，所以直接用固定长度的滑动窗口滑过去，这样时间复杂度为 O(n * m)。但是有更好的做法，就是当向右滑动的时候，删掉的是左面的字母，如果右边能够补齐，那么就说明是异位词，这样就可以 O(1) 判断异位词，再加上滑动的耗时，总计 O(m)。</p>
<p>Arrays.equals 可以判断两个数组相等。</p>
<h2 id="统计好子数组的数目"><a href="#统计好子数组的数目" class="headerlink" title="统计好子数组的数目"></a>统计好子数组的数目</h2><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回 <code>nums</code> 中 <strong>好</strong> 子数组的数目。</p>
<p>一个子数组 <code>arr</code> 如果有 <strong>至少</strong> <code>k</code> 对下标 <code>(i, j)</code> 满足 <code>i &lt; j</code> 且 <code>arr[i] == arr[j]</code> ，那么称它是一个 <strong>好</strong> 子数组。</p>
<p><strong>子数组</strong> 是原数组中一段连续 <strong>非空</strong> 的元素序列。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[1,1,1,1,1]</span>, k = <span class="hljs-number">10</span><br>输出：<span class="hljs-number">1</span><br>解释：唯一的好子数组是这个数组本身。<br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[3,1,4,3,2,2,4]</span>, k = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">4</span><br>解释：总共有 <span class="hljs-number">4</span> 个不同的好子数组：<br>- <span class="hljs-string">[3,1,4,3,2,2]</span> 有 <span class="hljs-number">2</span> 对。<br>- <span class="hljs-string">[3,1,4,3,2,2,4]</span> 有 <span class="hljs-number">3</span> 对。<br>- <span class="hljs-string">[1,4,3,2,2,4]</span> 有 <span class="hljs-number">2</span> 对。<br>- <span class="hljs-string">[4,3,2,2,4]</span> 有 <span class="hljs-number">2</span> 对。<br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10^5</code></li>
<li><code>1 &lt;= nums[i], k &lt;= 10^9</code></li>
</ul>
<p>核心思路：</p>
<p>如果窗口中有 c 个元素 x，再进来一个 x，会新增 c 个相等数对。<br>如果窗口中有 c 个元素 x，再去掉一个 x，会减少 c−1 个相等数对。<br>用一个哈希表 cnt 维护子数组（窗口）中的每个元素的出现次数，以及相同数对的个数 pairs。</p>
<p>外层循环：从小到大枚举子数组右端点 right。现在准备把 x=nums[right] 移入窗口，那么窗口中有 cnt[x] 个数和 x 相同，所以 pairs 会增加 cnt[x]。然后把 cnt[x] 加一。</p>
<p>内层循环：如果发现 pairs≥k，说明子数组符合要求，右移左端点 left，先把 cnt[nums[left]] 减少一，然后把 pairs 减少 cnt[nums[left]]。</p>
<p>内层循环结束后，[left,right] 这个子数组是不满足题目要求的，但在退出循环之前的最后一轮循环，[left−1,right] 是满足题目要求的。由于子数组越长，越能满足题目要求，所以除了 [left−1,right]，还有 [left−2,right],[left−3,right],…,[0,right] 都是满足要求的。也就是说，当右端点固定在 right 时，左端点在 0,1,2,…,left−1 的所有子数组都是满足要求的，这一共有 left 个。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">countGood</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        Map&lt;Integer, Integer&gt; cnt = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">pairs</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : nums) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> cnt.getOrDefault(x, <span class="hljs-number">0</span>);<br>            pairs += c; <span class="hljs-comment">// 进</span><br>            cnt.put(x, c + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">while</span> (pairs &gt;= k) &#123;<br>                x = nums[left];<br>                c = cnt.get(x);<br>                pairs -= c - <span class="hljs-number">1</span>; <span class="hljs-comment">// 出</span><br>                cnt.put(x, c - <span class="hljs-number">1</span>);<br>                left++;<br>            &#125;<br>            ans += left;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>
<h2 id="统计得分小于-K-的子数组数目"><a href="#统计得分小于-K-的子数组数目" class="headerlink" title="统计得分小于 K 的子数组数目"></a>统计得分小于 K 的子数组数目</h2><p>滑动窗口使用前提：</p>
<ul>
<li>连续子数组/子串。</li>
<li>有单调性。本题元素均为正数，所以子数组越长，分数越高；子数组越短，分数越低。这意味着只要某个子数组的分数小于 k，在该子数组内的更短的子数组，分数也小于 k。</li>
</ul>
<p>为什么用滑动窗口的复杂度为 O（n）：虽然用了两个循环，但是内层循环的总循环次数不超过 n，所以总的时间复杂度为 O(n)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">long</span>[] sum;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">countSubarrays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">long</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        sum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">long</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            sum[i] = sum[i - <span class="hljs-number">1</span>] + nums[i - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; right &lt;= n; right++) &#123;<br>            <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; !check(left, right, k)) &#123;<br>                left++;<br>            &#125;<br>            ans += right - left;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, <span class="hljs-type">long</span> k)</span> &#123;<br>        <span class="hljs-keyword">return</span> (right - left) * (sum[right] - sum[left]) &lt; k;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="小优化"><a href="#小优化" class="headerlink" title="小优化"></a>小优化</h3><p>可以不用前缀和，把前缀和动态维护。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">countSubarrays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">long</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; right &lt;= n; right++) &#123;<br>            sum += nums[right - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; !check(left, right, sum, k)) &#123;<br>                sum -= nums[left];<br>                left++;<br>            &#125;<br>            ans += right - left;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, <span class="hljs-type">long</span> sum, <span class="hljs-type">long</span> k)</span> &#123;<br>        <span class="hljs-keyword">return</span> (right - left) * sum &lt; k;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="区间"><a href="#区间" class="headerlink" title="区间"></a>区间</h1><h2 id="合并区间-1"><a href="#合并区间-1" class="headerlink" title="合并区间"></a>合并区间</h2><p>先排序，排序之后放入第一个元素，然后判断后续的开头是不是小于第一个元素的结尾，如果是的话就连起来，否则就形成新的区间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] merge(<span class="hljs-type">int</span>[][] intervals) &#123;<br>        Arrays.sort(intervals, (a1, a2) -&gt; &#123;<br>            <span class="hljs-keyword">return</span> a1[<span class="hljs-number">0</span>] - a2[<span class="hljs-number">0</span>];<br>        &#125;);<br>        List&lt;<span class="hljs-type">int</span>[]&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        ans.add(intervals[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; intervals.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (intervals[i][<span class="hljs-number">0</span>] &gt; ans.get(ans.size() - <span class="hljs-number">1</span>)[<span class="hljs-number">1</span>]) &#123;<br>                ans.add(intervals[i]);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> ans.get(ans.size() - <span class="hljs-number">1</span>)[<span class="hljs-number">1</span>];<br>                right = Math.max(right, intervals[i][<span class="hljs-number">1</span>]);<br>                ans.get(ans.size() - <span class="hljs-number">1</span>)[<span class="hljs-number">1</span>] = right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[ans.size()][]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="区间列表的交集"><a href="#区间列表的交集" class="headerlink" title="区间列表的交集"></a>区间列表的交集</h2><p>因为两个列表里都为不相交且已经排序好的区间，我们可以使用双指针逐个检查重合区域</p>
<p>对于两个区间arr1=[left1,right1]，arr2=[left2,right2]<br>判断重合：</p>
<p>若两个区间arr1与arr2相交， 那么重合区域为[max(left1,left2),min(right1,right2)]<br>若不相交，则right1&lt;left2或right2&lt;left1， 那么求得的重合区域max(left1,left2)的值会比min(right1,right2)大， 可以通过比较两个值来判断是否重合<br>移动指针：</p>
<p>假设right1&lt;right2， 因为区间列表为不相交且已经排序好的， 则arr1不可能与secondList中arr2以后的任何区间相交。 所以每次优先移动当前区间尾段较小的指针 (right2&lt;right1同理)<br>若right1==right2， 因为列表各个区间不相交，arr1与arr2都不可能与之后的区间有交集， 可以移动任意一个</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] intervalIntersection(<span class="hljs-type">int</span>[][] firstList, <span class="hljs-type">int</span>[][] secondList) &#123;<br>        List&lt;<span class="hljs-type">int</span>[]&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> firstList.length, n2 = secondList.length;<br><br>        <span class="hljs-keyword">while</span> (i &lt; n1 &amp;&amp; j &lt; n2) &#123;<br>            <span class="hljs-type">int</span>[] arr1 = firstList[i];<br>            <span class="hljs-type">int</span>[] arr2 = secondList[j];<br><br>            <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> Math.max(arr1[<span class="hljs-number">0</span>], arr2[<span class="hljs-number">0</span>]);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> Math.min(arr1[<span class="hljs-number">1</span>], arr2[<span class="hljs-number">1</span>]);<br><br>            <span class="hljs-keyword">if</span> (l &lt;= r) ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;l, r&#125;);<br><br>            <span class="hljs-keyword">if</span> (arr1[<span class="hljs-number">1</span>] &lt; arr2[<span class="hljs-number">1</span>]) i++;<br>            <span class="hljs-keyword">else</span> j++;<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[ans.size()][]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>链表对于有插入、交换或者删除的操作的时候，一般加一个<strong>虚拟头节点</strong>更好处理。</p>
<p>203.移除链表元素</p>
<p>707.设计链表</p>
<p>206.翻转链表</p>
<p>206.翻转链表</p>
<p>19.删除链表的倒数第 N 个结点</p>
<h2 id="K-个一组翻转链表"><a href="#K-个一组翻转链表" class="headerlink" title="K 个一组翻转链表"></a>K 个一组翻转链表</h2><p>给你链表的头节点 <code>head</code> ，每 <code>k</code> 个节点一组进行翻转，请你返回修改后的链表。</p>
<p><code>k</code> 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 <code>k</code> 的整数倍，那么请将最后剩余的节点保持原有顺序。</p>
<p>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p>
<p><strong>Key：</strong>关键在于写一个 reverse 函数逆转从 head 到 tail 的链表。其中 reverse 函数可以返回逆转后的最后一个节点。还有需要维护返回的节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseKGroup</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> head;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>, head), cur = head, pre = dummy, ret = <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            count++;<br>            <span class="hljs-keyword">if</span> (count == k) &#123;<br>                <span class="hljs-keyword">if</span> (first) &#123;<br>                    ret = cur;<br>                    first = <span class="hljs-literal">false</span>;<br>                &#125;<br>                pre = reverse(pre, head, cur);<br>                head = pre.next;<br>                cur = pre;<br>                count = <span class="hljs-number">0</span>;<br>            &#125;<br>            cur = cur.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br><br>    <span class="hljs-comment">// 逆转从 head 到 tail 的链表，pre 是 head 的前一个结点</span><br>    <span class="hljs-comment">// 返回逆转后的最后一个节点，其实就是 head，这一组的最后一个节点是下一组的 pre</span><br>    <span class="hljs-keyword">private</span> ListNode <span class="hljs-title function_">reverse</span><span class="hljs-params">(ListNode pre, ListNode head, ListNode tail)</span> &#123;<br>        <span class="hljs-comment">// pre -&gt; head -&gt; cur -&gt; tail</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head.next, retTail = head;<br>        head.next = tail.next;<br>        <span class="hljs-keyword">while</span> (cur != tail) &#123; <span class="hljs-comment">// tail 之前的节点全部头插法插到到 pre 之后</span><br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> cur.next;<br>            pre.next = cur;<br>            cur.next = head;<br>            head = cur;<br>            cur = next;<br>        &#125;<br>        <span class="hljs-comment">// 把 tail 也插到头部</span><br>        pre.next = tail;<br>        tail.next = head;<br>        <span class="hljs-keyword">return</span> retTail;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="排序链表"><a href="#排序链表" class="headerlink" title="排序链表"></a>排序链表</h2><p>要点在于排序 + 链表操作</p>
<p>题目的进阶问题要求达到 O(nlogn) 的时间复杂度和 O(1) 的空间复杂度，时间复杂度是 O(nlogn) 的排序算法包括归并排序、堆排序和快速排序（快速排序的最差时间复杂度是 O(n^2)），其中最适合链表的排序算法是归并排序。</p>
<p>归并排序基于分治算法。最容易想到的实现方式是自顶向下的递归实现，考虑到递归调用的栈空间，自顶向下归并排序的空间复杂度是 O(logn)。如果要达到 O(1) 的空间复杂度，则需要使用自底向上的实现方式。=</p>
<p>递归写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">sortList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> findMiddle(head);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">rightHead</span> <span class="hljs-operator">=</span> mid.next;<br>        mid.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 断开链表</span><br><br>        <span class="hljs-comment">// 排序</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> sortList(head);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> sortList(rightHead);<br>        <br>        <span class="hljs-comment">// 合并有序链表</span><br>        <span class="hljs-keyword">return</span> mergeList(left, right);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> ListNode <span class="hljs-title function_">mergeList</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-keyword">while</span> (l1 != <span class="hljs-literal">null</span> &amp;&amp; l2 != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (l1.val &lt; l2.val) &#123;<br>                cur.next = l1;<br>                l1 = l1.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur.next = l2;<br>                l2 = l2.next;<br>            &#125;<br>            cur = cur.next;<br>        &#125;<br>        <span class="hljs-comment">// 接上剩余链表，这里不需要用 while，因为肯定要么 l1 要么 l2 剩余，剩余部分本来就是接好的</span><br>        <span class="hljs-keyword">if</span> (l1 != <span class="hljs-literal">null</span>) &#123;<br>            cur.next = l1;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (l2 != <span class="hljs-literal">null</span>) &#123;<br>            cur.next = l2;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> ListNode <span class="hljs-title function_">findMiddle</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head.next; <span class="hljs-comment">// 重要！fast 从 head.next 开始，确保 slow 指向中点或者左中点</span><br>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">null</span> &amp;&amp; fast.next != <span class="hljs-literal">null</span>) &#123;<br>            slow = slow.next;<br>            fast = fast.next.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>迭代写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 1. 获取链表长度</span><br>    <span class="hljs-comment">// 2. 设置合并的长度（step）</span><br>    <span class="hljs-comment">// 3. 合并根据长度划分的所有链表</span><br>    <span class="hljs-comment">// 4. step *= 2</span><br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">sortList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>, head);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> listLength(head);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">step</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; step &lt; length; step *= <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> dummy.next;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">newTail</span> <span class="hljs-operator">=</span> dummy;<br>            <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 从 cur 开始，分割出两段长为 step 的链表，头节点分别为 head1 和 head2</span><br>                <span class="hljs-type">ListNode</span> <span class="hljs-variable">head1</span> <span class="hljs-operator">=</span> cur;<br>                <span class="hljs-type">ListNode</span> <span class="hljs-variable">head2</span> <span class="hljs-operator">=</span> splitList(head1, step);<br>                <span class="hljs-comment">// 下一轮的起点，也是为了分割开链表</span><br>                cur = splitList(head2, step); <br>                <span class="hljs-comment">// 合并两段长度为 step 的链表</span><br>                <span class="hljs-type">ListNode</span> <span class="hljs-variable">merged</span> <span class="hljs-operator">=</span> mergeList(head1, head2);<br>                <span class="hljs-comment">// 找到下一个要合并的链表的 head</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                <span class="hljs-type">ListNode</span> <span class="hljs-variable">curr</span> <span class="hljs-operator">=</span> merged;<br>                <span class="hljs-keyword">while</span>(len &lt; step * <span class="hljs-number">2</span> &amp;&amp; curr.next != <span class="hljs-literal">null</span>) &#123;<br>                    len++;<br>                    curr = curr.next;<br>                &#125;<br>                <span class="hljs-comment">// 合并后的头节点插入到 newTail 后面</span><br>                newTail.next = merged;<br>                newTail = curr;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> ListNode <span class="hljs-title function_">splitList</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> size)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-comment">// nextHead 的前一个节点，用于断开链表</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size - <span class="hljs-number">1</span> &amp;&amp; cur != <span class="hljs-literal">null</span>; i++) &#123;<br>            cur = cur.next;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">null</span> || cur.next == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">nextHead</span> <span class="hljs-operator">=</span> cur.next;<br>        cur.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 断开链表</span><br>        <span class="hljs-keyword">return</span> nextHead;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">listLength</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">null</span>) &#123;<br>            head = head.next;<br>            length++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> length;<br>    &#125;<br><br>    <span class="hljs-comment">// 返回合并链表的头节点</span><br>    <span class="hljs-keyword">private</span> ListNode <span class="hljs-title function_">mergeList</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-keyword">while</span> (l1 != <span class="hljs-literal">null</span> &amp;&amp; l2 != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (l1.val &lt; l2.val) &#123;<br>                cur.next = l1;<br>                l1 = l1.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur.next = l2;<br>                l2 = l2.next;<br>            &#125;<br>            cur = cur.next;<br>        &#125;<br>        <span class="hljs-comment">// 接上剩余链表，这里要用 while，因为肯定要么 l1 要么 l2 剩余，剩余部分本来就是接好的</span><br>        <span class="hljs-keyword">if</span> (l1 != <span class="hljs-literal">null</span>) &#123;<br>            cur.next = l1;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (l2 != <span class="hljs-literal">null</span>) &#123;<br>            cur.next = l2;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="合并-K-个升序链表"><a href="#合并-K-个升序链表" class="headerlink" title="合并 K 个升序链表"></a>合并 K 个升序链表</h2><h3 id="朴素做法"><a href="#朴素做法" class="headerlink" title="朴素做法"></a>朴素做法</h3><p>用一个数组存储所有的 head，然后每次取出所有数组的最小值，然后插入到链表最后面。</p>
<p>每次取出最小值，复杂度为 O(k)，然后一共要取 k <em> n 次，n 是最长链表的长度，这样时间复杂度为 O(k^2 </em> n)，每次取出最小值的时候，有比较被浪费掉了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeKLists</span><span class="hljs-params">(ListNode[] lists)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> dummy;<br>        ListNode[] head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>[lists.length];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">allLength</span> <span class="hljs-operator">=</span> <span class="hljs-number">500</span> * <span class="hljs-number">10000</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; lists.length; i++) &#123;<br>            head[i] = lists[i];<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; allLength) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">minVal</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x3f3f3f3f</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">minIndex</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; lists.length; j++) &#123;<br>                <span class="hljs-keyword">if</span> (head[j] != <span class="hljs-literal">null</span> &amp;&amp; minVal &gt; head[j].val) &#123;<br>                    minVal = head[j].val;<br>                    minIndex = j;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 所有链表都为空</span><br>            <span class="hljs-keyword">if</span> (minIndex == -<span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>;<br>            cur.next = head[minIndex];<br>            cur = cur.next;<br>            head[minIndex] = head[minIndex].next;<br>            i++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="二分做法"><a href="#二分做法" class="headerlink" title="二分做法"></a>二分做法</h3><p><img  src="./6f70a6649d2192cf32af68500915d84b476aa34ec899f98766c038fc9cc54662-image.png"  ><span class="image-caption">img</span></p>
<p>复杂度计算：</p>
<p><img  src="./image-20250202004335203.png"  ><span class="image-caption">image-20250202004335203</span></p>
<p>链表两两合并避免比较浪费，左闭右闭实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeKLists</span><span class="hljs-params">(ListNode[] lists)</span> &#123;<br>        <span class="hljs-keyword">return</span> mergeLists(lists, <span class="hljs-number">0</span>, lists.length - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> ListNode <span class="hljs-title function_">mergeLists</span><span class="hljs-params">(ListNode[] lists, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> &#123;<br>        <span class="hljs-keyword">if</span> (l == r) <span class="hljs-keyword">return</span> lists[l];<br>        <span class="hljs-keyword">if</span> (l &gt; r) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l + (r - l) / <span class="hljs-number">2</span>;<br>        <span class="hljs-comment">// 左闭右闭</span><br>        <span class="hljs-keyword">return</span> mergeTwoLists(mergeLists(lists, l, mid), mergeLists(lists, mid + <span class="hljs-number">1</span>, r));<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> ListNode <span class="hljs-title function_">mergeTwoLists</span><span class="hljs-params">(ListNode a, ListNode b)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-keyword">while</span> (a != <span class="hljs-literal">null</span> &amp;&amp; b != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (a.val &lt;= b.val) &#123;<br>                cur.next = a;<br>                a = a.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur.next = b;<br>                b = b.next;<br>            &#125;<br>            cur = cur.next;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (a != <span class="hljs-literal">null</span>) cur.next = a;<br>        <span class="hljs-keyword">if</span> (b != <span class="hljs-literal">null</span>) cur.next = b;<br><br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>左闭右开实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeKLists</span><span class="hljs-params">(ListNode[] lists)</span> &#123;<br>        <span class="hljs-keyword">return</span> mergeLists(lists, <span class="hljs-number">0</span>, lists.length);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> ListNode <span class="hljs-title function_">mergeLists</span><span class="hljs-params">(ListNode[] lists, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> &#123;<br>        <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (r - l == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> lists[l];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l + (r - l) / <span class="hljs-number">2</span>;<br>        <span class="hljs-comment">// 左闭右开</span><br>        <span class="hljs-keyword">return</span> mergeTwoLists(mergeLists(lists, l, mid), mergeLists(lists, mid, r));<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> ListNode <span class="hljs-title function_">mergeTwoLists</span><span class="hljs-params">(ListNode a, ListNode b)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-keyword">while</span> (a != <span class="hljs-literal">null</span> &amp;&amp; b != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (a.val &lt;= b.val) &#123;<br>                cur.next = a;<br>                a = a.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur.next = b;<br>                b = b.next;<br>            &#125;<br>            cur = cur.next;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (a != <span class="hljs-literal">null</span>) cur.next = a;<br>        <span class="hljs-keyword">if</span> (b != <span class="hljs-literal">null</span>) cur.next = b;<br><br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="二叉树的中序遍历"><a href="#二叉树的中序遍历" class="headerlink" title="二叉树的中序遍历"></a>二叉树的中序遍历</h2><p>递归做法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        helper(root);<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        helper(root.left);<br>        list.add(root.val);<br>        helper(root.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>非递归做法，用一个栈模拟递归栈。</p>
<p>前序遍历是中左右，如果还有左子树就一直向下找。完了之后再返回从最底层逐步向上向右找。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Deque&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span> (root != <span class="hljs-literal">null</span> || !stack.isEmpty()) &#123;<br>            <span class="hljs-keyword">while</span> (root != <span class="hljs-literal">null</span>) &#123;<br>                list.add(root.val);<br>                stack.push(root);<br>                root = root.left;<br>            &#125;<br>            root = stack.pop();<br>            root = root.right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>中序是左中右，如果还有左子树就一直向下找，直到左边最底部，然后处理节点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Deque&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span> (root != <span class="hljs-literal">null</span> || !stack.isEmpty()) &#123;<br>            <span class="hljs-keyword">while</span> (root != <span class="hljs-literal">null</span>) &#123;<br>                stack.push(root);<br>                root = root.left;<br>            &#125;<br>            root = stack.pop();<br>            list.add(root.val);<br>            root = root.right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>前序是先中间，再左边然后右边，而这里是先中间，再后边然后左边。那我们完全可以改造一下前序遍历，得到序列new_seq之后再reverse一下就是想要的结果了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Deque&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span> (root != <span class="hljs-literal">null</span> || !stack.isEmpty()) &#123;<br>            <span class="hljs-keyword">while</span> (root != <span class="hljs-literal">null</span>) &#123;<br>                list.add(root.val);<br>                stack.push(root);<br>                root = root.right;<br>            &#125;<br>            root = stack.pop();<br>            root = root.left;<br>        &#125;<br>        Collections.reverse(list);<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h2><p>要点在于如何记录深度，递归的时候可以通过传参解决：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">maxDepth</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        helper(root, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> maxDepth;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> depth)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            maxDepth = Math.max(maxDepth, depth);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        helper(root.left, depth + <span class="hljs-number">1</span>);<br>        helper(root.right, depth + <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">leftHeight</span> <span class="hljs-operator">=</span> maxDepth(root.left);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">rightHeight</span> <span class="hljs-operator">=</span> maxDepth(root.right);<br>            <span class="hljs-keyword">return</span> Math.max(leftHeight, rightHeight) + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="反转二叉树"><a href="#反转二叉树" class="headerlink" title="反转二叉树"></a>反转二叉树</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">invertTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        helper(root);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> TreeNode <span class="hljs-title function_">helper</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> helper(root.right);<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> helper(root.left);<br>        root.left = left;<br>        root.right = right;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h2><p>这里注意条件是 <code>left.val == right.val &amp;&amp; helper(left.left, right.right) &amp;&amp; helper(left.right, right.left)</code> ，因为对称是中心轴对称，而不是左右相等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">return</span> helper(root.left, root.right);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(TreeNode left, TreeNode right)</span> &#123;<br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">null</span> &amp;&amp; right == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">null</span> || right == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left.val == right.val<br>            &amp;&amp; helper(left.left, right.right)<br>            &amp;&amp; helper(left.right, right.left);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="二叉树的直径"><a href="#二叉树的直径" class="headerlink" title="二叉树的直径"></a>二叉树的直径</h2><p>二叉树的直径 = 最深左子树深度 + 最深右子树深度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">diameterOfBinaryTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        helper(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftMax</span> <span class="hljs-operator">=</span> helper(root.left);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rightMax</span> <span class="hljs-operator">=</span> helper(root.right);<br>        ans = Math.max(ans, leftMax + rightMax);<br>        <span class="hljs-keyword">return</span> Math.max(leftMax, rightMax) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="二叉树层序遍历"><a href="#二叉树层序遍历" class="headerlink" title="二叉树层序遍历"></a>二叉树层序遍历</h2><p>我的做法：先序遍历（root，左，右）的时候记住 depth 存到 map 中，然后最后把 map 中的数组组合起来：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    Map&lt;Integer, List&lt;Integer&gt;&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">depth</span> <span class="hljs-operator">=</span> helper(root, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; depth; i++) &#123;<br>            ans.add(map.get(i));<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> depth)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> depth;<br>        List&lt;Integer&gt; arr = map.getOrDefault(depth, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;());<br>        arr.add(root.val);<br>        map.put(depth, arr);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftMax</span> <span class="hljs-operator">=</span> helper(root.left, depth + <span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rightMax</span> <span class="hljs-operator">=</span> helper(root.right, depth + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> Math.max(leftMax, rightMax);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>bfs 做法：</p>
<ul>
<li>root 入队列</li>
<li>队列不为空的时候<ul>
<li>求当前队列长度 $s_i$</li>
<li>取 $s_i$ 个元素进行拓展，进入下一次迭代</li>
</ul>
</li>
</ul>
<p>它和普通广度优先搜索的区别在于，普通广度优先搜索每次只取一个元素拓展，而这里每次取 $s_i$ 个元素。在上述过程中的第 $i$ 次迭代得到了二叉树第 $i$ 层的 $s_i$ 个元素。（说白了就是每次迭代的时候把下一层级的所有元素都加到队列里面，这样每一次迭代整个队列元素的时候就是一个层级的所有元素）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> ans;<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queue.offer(root);<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">front</span> <span class="hljs-operator">=</span> queue.poll();<br>                <span class="hljs-keyword">if</span> (front.left != <span class="hljs-literal">null</span>) queue.offer(front.left);<br>                <span class="hljs-keyword">if</span> (front.right != <span class="hljs-literal">null</span>) queue.offer(front.right);<br>                list.add(front.val);<br>            &#125;<br>            ans.add(list);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="将有序数组转换为二叉搜索树"><a href="#将有序数组转换为二叉搜索树" class="headerlink" title="将有序数组转换为二叉搜索树"></a>将有序数组转换为二叉搜索树</h2><p>递归建树：</p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10^4</code></li>
<li><code>-10^4 &lt;= nums[i] &lt;= 10^4</code></li>
<li><code>nums</code> 按 <strong>严格递增</strong> 顺序排列</li>
</ul>
<p><img  src="./image-20250205185730436.png"  ><span class="image-caption">image-20250205185730436</span></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">sortedArrayToBST</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">return</span> helper(nums, <span class="hljs-number">0</span>, nums.length);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> TreeNode <span class="hljs-title function_">helper</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-keyword">if</span> (left &gt;= right) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(nums[mid]);<br>        root.left = helper(nums, left, mid);<br>        root.right = helper(nums, mid + <span class="hljs-number">1</span>, right);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h2><p>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。</p>
<p><strong>有效</strong> 二叉搜索树定义如下：</p>
<ul>
<li>节点的左子树只包含 <strong>小于</strong> 当前节点的数。</li>
<li>节点的右子树只包含 <strong>大于</strong> 当前节点的数。</li>
<li>所有左子树和右子树自身必须也是二叉搜索树。</li>
</ul>
<p>这里有一个问题是需要判断所有的子节点都大于或者都小于根节点。</p>
<p><strong>二叉搜索树的中序遍历是递增的。</strong>所以可以中序遍历，之后每个元素都小于前一个元素，则是二叉搜索树。</p>
<p>递归写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidBST</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        helper(root);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; list.size() - <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (list.get(i) &gt;= list.get(i + <span class="hljs-number">1</span>)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>        helper(root.left);<br>        list.add(root.val);<br>        helper(root.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>递归写法2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> Long.MIN_VALUE;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidBST</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">return</span> helper(root);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> helper(root.left);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> left &lt; root.val;<br>        left = root.val;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> helper(root.right);<br>        <span class="hljs-keyword">return</span> l &amp;&amp; r &amp;&amp; tmp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>递归写法3：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidBST</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">return</span> helper(root, Long.MIN_VALUE, Long.MAX_VALUE);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">long</span> lower, <span class="hljs-type">long</span> upper)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (root.val &lt;= lower || root.val &gt;= upper) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> helper(root.left, lower, root.val) &amp;&amp; helper(root.right, root.val, upper);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>迭代写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidBST</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">return</span> helper(root);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        Deque&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;TreeNode&gt;();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> Long.MIN_VALUE;<br>        <span class="hljs-keyword">while</span> (root != <span class="hljs-literal">null</span> || !stack.isEmpty()) &#123;<br>            <span class="hljs-keyword">while</span> (root != <span class="hljs-literal">null</span>) &#123;<br>                stack.push(root);<br>                root = root.left;<br>            &#125;<br>            root = stack.pop();<br>            <span class="hljs-keyword">if</span> (left &gt;= root.val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            left = root.val;<br>            root = root.right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="二叉搜索树中第-K-小的元素"><a href="#二叉搜索树中第-K-小的元素" class="headerlink" title="二叉搜索树中第 K 小的元素"></a>二叉搜索树中第 K 小的元素</h2><p>和验证二叉搜索树一样，在最外层存储一下状态。<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, target; <span class="hljs-comment">// 存储状态</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">kthSmallest</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> k)</span> &#123;<br>        target = k;<br>        <span class="hljs-keyword">return</span> helper(root);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>; <br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> helper(root.left);<br>        <span class="hljs-keyword">if</span> (left != -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> left;<br>        count++;<br>        <span class="hljs-keyword">if</span> (target == count) &#123;<br>            <span class="hljs-keyword">return</span> root.val;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> helper(root.right);<br>        <span class="hljs-keyword">if</span> (right != -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> right;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p>
<h2 id="二叉树的右视图"><a href="#二叉树的右视图" class="headerlink" title="二叉树的右视图"></a>二叉树的右视图</h2><p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p>
<p>层序遍历中最右面的那个元素就是答案，放进去就好了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">rightSideView</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> ans;<br>        Deque&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queue.offer(root);<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>                <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) queue.offer(node.left);<br>                <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) queue.offer(node.right);<br>                <span class="hljs-keyword">if</span> (i == size - <span class="hljs-number">1</span>) &#123;<br>                    ans.add(node.val);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="二叉树展开为链表"><a href="#二叉树展开为链表" class="headerlink" title="二叉树展开为链表"></a>二叉树展开为链表</h2><p>给你二叉树的根结点 <code>root</code> ，请你将它展开为一个单链表：</p>
<ul>
<li>展开后的单链表应该同样使用 <code>TreeNode</code> ，其中 <code>right</code> 子指针指向链表中下一个结点，而左子指针始终为 <code>null</code> 。</li>
<li>展开后的单链表应该与二叉树 <a href="https://baike.baidu.com/item/先序遍历/6442839?fr=aladdin"><strong>先序遍历</strong></a> 顺序相同。</li>
</ul>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>先序遍历二叉树，然后记录 last，然后修改 last 的 left 和 right，但是这样会栈溢出。</p>
<p>原因是递归遍历 root.left 的时候，root.right 被改成了 root.left 导致死循环，保存一下状态就好了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> TreeNode last;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">flatten</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        last = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">0</span>, <span class="hljs-literal">null</span>, root);<br>        helper(root);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> root.left;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> root.right;<br>        last.left = <span class="hljs-literal">null</span>;<br>        last.right = root;<br>        last = root;<br>        helper(left);<br>        helper(right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="迭代1"><a href="#迭代1" class="headerlink" title="迭代1"></a>迭代1</h3><p>迭代写法，这里注意是第三种先序遍历的方法（递归，迭代1，迭代2），注意先入栈右边再入左边，保证左边先处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">flatten</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        helper(root);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">0</span>, <span class="hljs-literal">null</span>, root);<br>        Deque&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        stack.push(root);<br>        <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">top</span> <span class="hljs-operator">=</span> stack.poll();<br>            last.left = <span class="hljs-literal">null</span>;<br>            last.right = top;<br>            last = top;<br>            <span class="hljs-comment">// 右边先入栈，保证左边先处理</span><br>            <span class="hljs-keyword">if</span> (top.right != <span class="hljs-literal">null</span>) stack.push(top.right);<br>            <span class="hljs-keyword">if</span> (top.left != <span class="hljs-literal">null</span>) stack.push(top.left);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="迭代2"><a href="#迭代2" class="headerlink" title="迭代2"></a>迭代2</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">flatten</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        helper(root);<br>    &#125;<br><br>    <span class="hljs-comment">// 先序遍历树的时候顺序是中左右</span><br>    <span class="hljs-comment">// 如果一个节点的左子节点为空，则为 中、右 ，中的右边就是下一个节点</span><br>    <span class="hljs-comment">// 如果一个节点的左子节点不为空，则为 中、左子节点的最右节点、右</span><br>    <span class="hljs-comment">// 也就是说一个节点的左子节点不为空时，中的右边应该是左子节点的最右节点，然后再跟着右节点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">while</span> (root != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (root.left != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> root.left;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> next;<br>                <span class="hljs-comment">// 找左子节点的最右节点</span><br>                <span class="hljs-keyword">while</span> (pre.right != <span class="hljs-literal">null</span>) &#123;<br>                    pre = pre.right;<br>                &#125;<br>                <span class="hljs-comment">// 左子节点的最右节点的下一个为右节点</span><br>                pre.right = root.right;<br>                root.left = <span class="hljs-literal">null</span>;<br>                root.right = next;<br>            &#125;<br>            root = root.right;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="路径总和-III"><a href="#路径总和-III" class="headerlink" title="路径总和 III"></a>路径总和 III</h2><ul>
<li>二叉树的节点个数的范围是 <code>[0,1000]</code></li>
<li><code>-10^9 &lt;= Node.val &lt;= 10^9</code> </li>
<li><code>-1000 &lt;= targetSum &lt;= 1000</code> </li>
</ul>
<p>给定一个二叉树的根节点 <code>root</code> ，和一个整数 <code>targetSum</code> ，求该二叉树里节点值之和等于 <code>targetSum</code> 的 <strong>路径</strong> 的数目。</p>
<p><strong>路径</strong> 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p>
<h3 id="穷举-O-N-2"><a href="#穷举-O-N-2" class="headerlink" title="穷举 O(N^2)"></a>穷举 O(N^2)</h3><p>访问每一个节点 <em>node</em>，检测以 <em>node</em> 为起始节点且向下延深的路径有多少种。我们递归遍历每一个节点的所有可能的路径，然后将这些路径数目加起来即为返回结果。</p>
<ul>
<li><p>定义 helper(p, val) 表示以 p 为起点向下满足和为 val 的路径数目。对每个节点 p 求出 helper(p, targetSum) 就是答案。</p>
<ul>
<li><p>helper 的实现为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">long</span> targetSum)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (root.val == targetSum) ret++;<br>    ret += helper(root.left, targetSum - root.val);<br>    ret += helper(root.right, targetSum - root.val);<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>接下来是对于每个节点都进行 helper，这里先 dfs 遍历所有节点，并对所有节点进行 helper 即可。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">long</span> targetSum)</span> &#123;<br>        <span class="hljs-keyword">return</span> dfs(root, targetSum);<br>    &#125;<br><br>    <span class="hljs-comment">// 计算所有节点的 helper</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">long</span> targetSum)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        ret += helper(root, targetSum);<br>        ret += dfs(root.left, targetSum);<br>        ret += dfs(root.right, targetSum);<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br><br>    <span class="hljs-comment">// 计算以 root 节点向下和为 val 的路径数目</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">long</span> targetSum)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (root.val == targetSum) ret++;<br>        ret += helper(root.left, targetSum - root.val);<br>        ret += helper(root.right, targetSum - root.val);<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="前缀和优化-O-N"><a href="#前缀和优化-O-N" class="headerlink" title="前缀和优化 O(N)"></a>前缀和优化 O(N)</h3><p>我们定义节点的前缀和为：由根结点到当前结点的路径上所有节点的和。</p>
<p>我们利用先序遍历二叉树，记录下根节点 root 到当前节点 p 的路径上除当前节点以外所有节点的前缀和，在已保存的路径前缀和中查找是否存在前缀和刚好等于当前节点到根节点的前缀和 cur 减去 targetSum。</p>
<p>如果 (cur - targetSum) 存在，那么 cur - (cur - targetSum) = targetSum 也存在，就是从某个路径到当前节点的和为 targetSum。</p>
<p>key保存前缀和，value保存对应此前缀和的数量。</p>
<p>然后总体的思路和 560 是一样的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> targetSum)</span> &#123;<br>        Map&lt;Long, Integer&gt; prefix = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Long, Integer&gt;();<br>        prefix.put(<span class="hljs-number">0L</span>, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> dfs(root, prefix, <span class="hljs-number">0L</span>, targetSum);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, Map&lt;Long, Integer&gt; prefix, <span class="hljs-type">long</span> cur, <span class="hljs-type">int</span> targetSum)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 前缀和</span><br>        cur += root.val;<br><br>        <span class="hljs-comment">// 当前从根节点 root 到节点 node 的前缀和为 cur</span><br>        <span class="hljs-comment">// 两节点间的路径和 = 两节点的前缀和之差</span><br>        <span class="hljs-comment">// 查找是否存在 cur - targetSum 的前缀和</span><br>        <span class="hljs-comment">// 如果该前缀和存在，那么 cur - (cur - targetSum) = targetSum 存在</span><br>        <span class="hljs-comment">// 也就是说</span><br><br>        ret = prefix.getOrDefault(cur - targetSum, <span class="hljs-number">0</span>);<br>        prefix.put(cur, prefix.getOrDefault(cur, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        ret += dfs(root.left, prefix, cur, targetSum);<br>        ret += dfs(root.right, prefix, cur, targetSum);<br>        prefix.put(cur, prefix.getOrDefault(cur, <span class="hljs-number">0</span>) - <span class="hljs-number">1</span>);<br><br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h2><h3 id="暴力递归做法"><a href="#暴力递归做法" class="headerlink" title="暴力递归做法"></a>暴力递归做法</h3><p>每个节点判断是不是子节点是不是同时包含 p 和 q</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;<br>        <span class="hljs-keyword">return</span> dfs(root, p, q);<br>    &#125;<br><br>    <span class="hljs-comment">// 遍历每个节点，当节点的子树同时包含 p 和 q 时，该节点为最近公共祖先</span><br>    <span class="hljs-keyword">private</span> TreeNode <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == p || root == q) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-keyword">if</span> (check(root.left, p, q) &amp;&amp; check(root.right, p, q)) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-keyword">if</span> (check(root.right, p, q) == <span class="hljs-literal">false</span>) <span class="hljs-keyword">return</span> dfs(root.left, p, q);<br>        <span class="hljs-keyword">return</span> dfs(root.right, p, q);<br>    &#125;<br><br>    <span class="hljs-comment">// root 开始遍历的所有节点中是否有 p 或者 q</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;<br>        <span class="hljs-comment">// 如果 p，q 的公共节点为 root，那么从 root 能遍历得到 p 和 q</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (root == p || root == q) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> check(root.left, p, q) || check(root.right, p, q);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="改进递归做法"><a href="#改进递归做法" class="headerlink" title="改进递归做法"></a>改进递归做法</h3><ul>
<li>如果要找的节点只在左子树中，那么最近公共祖先也只在左子树中。</li>
<li>如果要找的节点只在右子树中，那么最近公共祖先也只在右子树中。</li>
<li>如果要找的节点左右子树都有，那么最近公共祖先就是当前节点。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;<br>        <span class="hljs-keyword">return</span> dfs(root, p, q);<br>    &#125;<br><br>    <span class="hljs-comment">// 对于 root 找 p 和 q</span><br>    <span class="hljs-keyword">private</span> TreeNode <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (root == p || root == q) <span class="hljs-keyword">return</span> root;<br><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> dfs(root.left, p, q);<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> dfs(root.right, p, q);<br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> right; <span class="hljs-comment">// 如果要找的节点只在右子树中，那么最近公共祖先也只在右子树中</span><br>        <span class="hljs-keyword">if</span> (right == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> left; <span class="hljs-comment">// 如果要找的节点只在左子树中，那么最近公共祖先也只在左子树中</span><br>        <span class="hljs-comment">// 如果要找的节点左右子树都有，那么最近公共祖先就是当前节点</span><br>        <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">null</span> &amp;&amp; right != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="记录父节点的做法"><a href="#记录父节点的做法" class="headerlink" title="记录父节点的做法"></a>记录父节点的做法</h3><p>用哈希表记录每个 TreeNode 的父节点，然后遍历 p 的父节点和 q 的父节点，最先出现的那个就是最近公共祖先</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> HashMap&lt;TreeNode, TreeNode&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> Set&lt;TreeNode&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (root.left != <span class="hljs-literal">null</span>) &#123;<br>            map.put(root.left, root);<br>            dfs(root.left);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root.right != <span class="hljs-literal">null</span>) &#123;<br>            map.put(root.right, root);<br>            dfs(root.right);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;<br>        dfs(root);<br>        <span class="hljs-keyword">while</span>(p != <span class="hljs-literal">null</span>) &#123;<br>            set.add(p); <span class="hljs-comment">// 要在 get 之前，这样能够处理一个 p 是 q 的父节点的情况</span><br>            p = map.get(p);<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (q != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (set.contains(q)) <span class="hljs-keyword">return</span> q;<br>            q = map.get(q);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="二叉树中的最大路径和"><a href="#二叉树中的最大路径和" class="headerlink" title="二叉树中的最大路径和"></a>二叉树中的最大路径和</h2><p>与二叉树最大直径有异曲同工之妙。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxPathSum</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        helper(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftMax</span> <span class="hljs-operator">=</span> Math.max(helper(root.left), <span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rightMax</span> <span class="hljs-operator">=</span> Math.max(helper(root.right), <span class="hljs-number">0</span>);<br>        ans = Math.max(leftMax + rightMax + root.val, ans);<br>        <span class="hljs-keyword">return</span> root.val + Math.max(leftMax, rightMax);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="最深叶节点的最近公共祖先"><a href="#最深叶节点的最近公共祖先" class="headerlink" title="最深叶节点的最近公共祖先"></a>最深叶节点的最近公共祖先</h2><h3 id="暴力递归"><a href="#暴力递归" class="headerlink" title="暴力递归"></a>暴力递归</h3><p>先找到最深叶节点，然后找最近公共祖先</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    Map&lt;Integer, List&lt;TreeNode&gt;&gt; deepMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">lcaDeepestLeaves</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-comment">// 先找到最深叶节点，然后找最近公共祖先</span><br>        deepestNodes(root, <span class="hljs-number">0</span>);<br>        List&lt;TreeNode&gt; deepestNodes = <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">deep</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;Integer, List&lt;TreeNode&gt;&gt; entry : deepMap.entrySet()) &#123;<br>            <span class="hljs-keyword">if</span> (entry.getKey() &gt;= deep) &#123;<br>                deepestNodes = entry.getValue();<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 两两找最近公共祖先</span><br>        <span class="hljs-keyword">return</span> MergeLCA(root, deepestNodes, <span class="hljs-number">0</span>, deepestNodes.size() - <span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">// 数组找最近公共祖先</span><br>        <span class="hljs-comment">// return ArrayLCA(root, deepestNodes);</span><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> TreeNode <span class="hljs-title function_">ArrayLCA</span><span class="hljs-params">(TreeNode root, List&lt;TreeNode&gt; list)</span> &#123;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> list.get(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; list.size(); i++) &#123;<br>            ans = LCA(root, ans, list.get(i));<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> TreeNode <span class="hljs-title function_">MergeLCA</span><span class="hljs-params">(TreeNode root, List&lt;TreeNode&gt; list, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-keyword">if</span> (right - left == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> list.get(left);<br>        <span class="hljs-keyword">if</span> (right - left == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> LCA(root, list.get(left), list.get(right));<br>        &#125;<br>        <span class="hljs-keyword">if</span> (right - left &gt; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">return</span> LCA(root, MergeLCA(root, list, left, mid - <span class="hljs-number">1</span>), MergeLCA(root, list, mid + <span class="hljs-number">1</span>, right));<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deepestNodes</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> deep)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>        List&lt;TreeNode&gt; nodes = deepMap.getOrDefault(deep, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>        nodes.add(root);<br>        deepMap.put(deep, nodes);<br>        deepestNodes(root.left, deep + <span class="hljs-number">1</span>);<br>        deepestNodes(root.right, deep + <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> TreeNode <span class="hljs-title function_">LCA</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (root == p || root == q) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> LCA(root.left, p, q);<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> LCA(root.right, p, q);<br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> right; <span class="hljs-comment">// 左子树中没有 LCA</span><br>        <span class="hljs-keyword">if</span> (right == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> left; <span class="hljs-comment">// 右子树中没有 LCA</span><br>        <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">null</span> &amp;&amp; right != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="改进的递归"><a href="#改进的递归" class="headerlink" title="改进的递归"></a>改进的递归</h3><ol>
<li>从根节点开始递归，同时维护全局最大深度 deepMax。</li>
<li>在「递」的时候往下传 depth，用来表示当前节点的深度。</li>
<li>在「归」的时候往上传当前子树最深的空节点的深度。这里为了方便，用空节点代替叶子，因为最深的空节点的上面一定是最深的叶子。</li>
<li>设左子树最深空节点的深度为 leftMax，右子树最深空节点的深度为 rightMax。如果最深的空节点左右子树都有，也就是 leftMax=rightMax=deepMax，那么更新答案为当前节点。注意这并不代表我们找到了答案，如果后面发现了更深的空节点，答案还会更新。另外注意，这个判断方式在只有一个最深叶子的情况下，也是正确的。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">deepMax</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">lcaDeepestLeaves</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        dfs(root, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> deep)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            deepMax = Math.max(deepMax, deep);<br>            <span class="hljs-keyword">return</span> deep;<br>        &#125;<br>        <span class="hljs-comment">// 递</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftMax</span> <span class="hljs-operator">=</span> dfs(root.left, deep + <span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rightMax</span> <span class="hljs-operator">=</span> dfs(root.right, deep + <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 归</span><br>        <span class="hljs-keyword">if</span> (leftMax == deepMax &amp;&amp; rightMax == deepMax) &#123; <span class="hljs-comment">// 最深节点在左右节点都有，只关心：当前节点的左右子树是否都达到了最深深度</span><br>            ans = root;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Math.max(leftMax, rightMax);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h1><h2 id="岛屿数量"><a href="#岛屿数量" class="headerlink" title="岛屿数量"></a>岛屿数量</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span>[][] visited;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[][] dirs = &#123;<br>        &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;,<br>        &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;,<br>        &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;,<br>        &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;<br>    &#125;;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numIslands</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid[<span class="hljs-number">0</span>].length;<br>        visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[m][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (!visited[i][j] &amp;&amp; grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                    dfs(grid, i, j);<br>                    count++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br><br>    <span class="hljs-comment">// 访问所有相邻的岛屿</span><br>    <span class="hljs-comment">// x是行，y是列</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] grid, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;    <br>        visited[x][y] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123; <span class="hljs-comment">// 访问所有相邻的</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">dirX</span> <span class="hljs-operator">=</span> dirs[i][<span class="hljs-number">0</span>], dirY = dirs[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid[<span class="hljs-number">0</span>].length;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">newX</span> <span class="hljs-operator">=</span> x + dirX, newY = y + dirY;<br>            <span class="hljs-keyword">if</span> (newX &gt;= <span class="hljs-number">0</span> &amp;&amp; newX &lt; m &amp;&amp; newY &gt;= <span class="hljs-number">0</span> &amp;&amp; newY &lt; n &amp;&amp; !visited[newX][newY] &amp;&amp; grid[newX][newY] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                visited[newX][newY] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 原有的连通岛屿都设置成已经访问</span><br>                dfs(grid, newX, newY);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="腐烂的橘子"><a href="#腐烂的橘子" class="headerlink" title="腐烂的橘子"></a>腐烂的橘子</h2><h3 id="单源-bfs"><a href="#单源-bfs" class="headerlink" title="单源 bfs"></a>单源 bfs</h3><p>不要改动橘子矩阵，新增一个时间矩阵表示橘子的情况。</p>
<p>bfs，如果时间更小则更新时间矩阵。</p>
<p>这个是单源 bfs，需要对于每个腐烂的橘子都进行 bfs。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span>[][] visited;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[][] dirs = &#123;<br>        &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;,<br>        &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;,<br>        &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;,<br>        &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;,<br>    &#125;, allTime;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> m, n;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">orangesRotting</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        m = grid.length;<br>        n = grid[<span class="hljs-number">0</span>].length;<br>        visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[m][n];<br>        allTime = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] row : allTime) &#123;<br>            Arrays.fill(row, <span class="hljs-number">0x3f3f3f3f</span>);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                bfs(grid, i, j);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxTime</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (grid[i][j] != <span class="hljs-number">0</span> &amp;&amp; allTime[i][j] == <span class="hljs-number">0x3f3f3f3f</span>) &#123; <span class="hljs-comment">// 存在没腐烂的橘子</span><br>                    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (grid[i][j] &gt; <span class="hljs-number">0</span> &amp;&amp; allTime[i][j] != <span class="hljs-number">0x3f3f3f3f</span>) &#123;<br>                    maxTime = Math.max(allTime[i][j], maxTime);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxTime;<br>    &#125;<br><br>    <span class="hljs-comment">// 返回当前橘子开始最多要多少时间感染所有可感染的橘子</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid, <span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col)</span> &#123;<br>        <span class="hljs-keyword">if</span> (grid[row][col] != <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 不是腐烂橘子就不能继续传染</span><br>        Queue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;row, col, <span class="hljs-number">0</span>&#125;);<br>        allTime[row][col] = <span class="hljs-number">0</span>;<br>        visited[row][col] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span>[] pos = queue.poll();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>                <span class="hljs-keyword">if</span> (pos[<span class="hljs-number">2</span>] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 不是腐烂橘子就不能继续传染</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">newRow</span> <span class="hljs-operator">=</span> dirs[i][<span class="hljs-number">0</span>] + pos[<span class="hljs-number">0</span>];<br>                <span class="hljs-type">int</span> <span class="hljs-variable">newCol</span> <span class="hljs-operator">=</span> dirs[i][<span class="hljs-number">1</span>] + pos[<span class="hljs-number">1</span>];<br>                <span class="hljs-type">int</span> <span class="hljs-variable">newTime</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> + pos[<span class="hljs-number">2</span>];<br>                <span class="hljs-keyword">if</span> (ok(newRow, newCol, newTime) &amp;&amp; grid[newRow][newCol] &gt; <span class="hljs-number">0</span>) &#123;<br>                    queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;newRow, newCol, newTime&#125;);<br>                    visited[newRow][newCol] = <span class="hljs-literal">true</span>;<br>                    allTime[newRow][newCol] = newTime;<br>                    <span class="hljs-comment">// grad[newRow][newCol] = 2;</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">ok</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col, <span class="hljs-type">int</span> time)</span> &#123;<br>        <span class="hljs-keyword">return</span> row &gt;= <span class="hljs-number">0</span> &amp;&amp; row &lt; m &amp;&amp; col &gt;= <span class="hljs-number">0</span> &amp;&amp; col &lt; n &amp;&amp; (!visited[row][col] || time &lt; allTime[row][col]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="多源-bfs"><a href="#多源-bfs" class="headerlink" title="多源 bfs"></a>多源 bfs</h3><p>把所有腐烂的橘子都放到队列里面，进行多源 bfs，这样就不用每个腐烂橘子都 bfs 了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span>[][] visited;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[][] dirs = &#123;<br>        &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;,<br>        &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;,<br>        &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;,<br>        &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;,<br>    &#125;, allTime;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> m, n;<br>    Queue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">orangesRotting</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        m = grid.length;<br>        n = grid[<span class="hljs-number">0</span>].length;<br>        visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[m][n];<br>        allTime = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] row : allTime) &#123;<br>            Arrays.fill(row, <span class="hljs-number">0x3f3f3f3f</span>);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">2</span>) &#123;<br>                    queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;i, j, <span class="hljs-number">0</span>&#125;);<br>                    allTime[i][j] = <span class="hljs-number">0</span>;<br>                    visited[i][j] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        bfs(grid);<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxTime</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (grid[i][j] != <span class="hljs-number">0</span> &amp;&amp; allTime[i][j] == <span class="hljs-number">0x3f3f3f3f</span>) &#123; <span class="hljs-comment">// 存在没腐烂的橘子</span><br>                    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (grid[i][j] &gt; <span class="hljs-number">0</span> &amp;&amp; allTime[i][j] != <span class="hljs-number">0x3f3f3f3f</span>) &#123;<br>                    maxTime = Math.max(allTime[i][j], maxTime);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxTime;<br>    &#125;<br><br>    <span class="hljs-comment">// 返回当前橘子开始最多要多少时间感染所有可感染的橘子</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span>[] pos = queue.poll();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">newRow</span> <span class="hljs-operator">=</span> dirs[i][<span class="hljs-number">0</span>] + pos[<span class="hljs-number">0</span>];<br>                <span class="hljs-type">int</span> <span class="hljs-variable">newCol</span> <span class="hljs-operator">=</span> dirs[i][<span class="hljs-number">1</span>] + pos[<span class="hljs-number">1</span>];<br>                <span class="hljs-type">int</span> <span class="hljs-variable">newTime</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> + pos[<span class="hljs-number">2</span>];<br>                <span class="hljs-keyword">if</span> (ok(newRow, newCol, newTime) &amp;&amp; grid[newRow][newCol] &gt; <span class="hljs-number">0</span>) &#123;<br>                    queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;newRow, newCol, newTime&#125;);<br>                    visited[newRow][newCol] = <span class="hljs-literal">true</span>;<br>                    allTime[newRow][newCol] = newTime;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">ok</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col, <span class="hljs-type">int</span> time)</span> &#123;<br>        <span class="hljs-keyword">return</span> row &gt;= <span class="hljs-number">0</span> &amp;&amp; row &lt; m &amp;&amp; col &gt;= <span class="hljs-number">0</span> &amp;&amp; col &lt; n &amp;&amp; (!visited[row][col] || time &lt; allTime[row][col]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="Trie-树"><a href="#Trie-树" class="headerlink" title="Trie 树"></a>Trie 树</h2><h3 id="HashMap-实现"><a href="#HashMap-实现" class="headerlink" title="HashMap 实现"></a>HashMap 实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span> &#123;<br>    Map&lt;String, Boolean&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    Map&lt;String, Boolean&gt; prefixMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Trie</span><span class="hljs-params">()</span> &#123;<br>        <br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= word.length(); i++) &#123;<br>            prefixMap.put(word.substring(<span class="hljs-number">0</span>, i), <span class="hljs-literal">true</span>);<br>        &#125;<br>        map.put(word, <span class="hljs-literal">true</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">search</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-keyword">return</span> map.containsKey(word);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">startsWith</span><span class="hljs-params">(String prefix)</span> &#123;<br>        <span class="hljs-keyword">return</span> prefixMap.containsKey(prefix);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="正常实现"><a href="#正常实现" class="headerlink" title="正常实现"></a>正常实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span> &#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">TrieNode</span> &#123;<br>        Map&lt;Character, TrieNode&gt; children = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isEnd</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">TrieNode</span><span class="hljs-params">()</span> &#123;<br>            <br>        &#125;<br>    &#125;<br><br>    TrieNode root;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Trie</span><span class="hljs-params">()</span> &#123;<br>        root = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-type">TrieNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : word.toCharArray()) &#123;<br>            node = node.children.computeIfAbsent(ch, v -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>());<br>        &#125;<br>        node.isEnd = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">search</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-type">TrieNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : word.toCharArray()) &#123;<br>            node = node.children.get(ch);<br>            <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> node.isEnd;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">startsWith</span><span class="hljs-params">(String prefix)</span> &#123;<br>        <span class="hljs-type">TrieNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : prefix.toCharArray()) &#123;<br>            node = node.children.get(ch);<br>            <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="课程表"><a href="#课程表" class="headerlink" title="课程表"></a>课程表</h2><ul>
<li><code>1 &lt;= numCourses &lt;= 2000</code></li>
<li><code>0 &lt;= prerequisites.length &lt;= 5000</code></li>
</ul>
<p>你这个学期必须选修 <code>numCourses</code> 门课程，记为 <code>0</code> 到 <code>numCourses - 1</code> 。</p>
<p>在选修某些课程之前需要一些先修课程。 先修课程按数组 <code>prerequisites</code> 给出，其中 <code>prerequisites[i] = [ai, bi]</code> ，表示如果要学习课程 <code>ai</code> 则 <strong>必须</strong> 先学习课程 <code>bi</code> 。</p>
<ul>
<li>例如，先修课程对 <code>[0, 1]</code> 表示：想要学习课程 <code>0</code> ，你需要先完成课程 <code>1</code> 。</li>
</ul>
<p>请你判断是否可能完成所有课程的学习？如果可以，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p>像是要检测并完成图中是否有环？</p>
<p>拓扑排序的经典题？</p>
<p>我们将每一门课看成一个节点；</p>
<p>如果想要学习课程A之前必须完成课程B，那么我们从B到A连接一条有向边。这样以来，在拓扑排序中，B一定出现在A的前面。</p>
<p>求出该图是否存在拓扑排序，就可以判断是否有一种符合要求的课程学习顺序。事实上，由于求出一种拓扑排序方法的最优时间复杂度为O(n+m)，其中n和m分别是有向图G的节点数和边数，方法见210. 课程表 II 的官方题解。而判断图G是否存在拓扑排序，至少也要对其进行一次完整的遍历，时间复杂度也为O(n+m)。因此不可能存在一种仅判断图是否存在拓扑排序的方法，它的时间复杂度在渐进意义上严格优于O(n+m)。这样一来，我们使用和210. 课程表 II完全相同的方法，但无需使用数据结构记录实际的拓扑排序。为了叙述的完整性，下面的两种方法与210. 课程表 II 的官方题解完全相同，但在「算法」部分后的「优化」部分说明了如何省去对应的数据结构。</p>
<p>代码与下面的 <strong>课程表 II</strong> 相同，如果存在拓扑排序就是 true。</p>
<h2 id="课程表-II"><a href="#课程表-II" class="headerlink" title="课程表 II"></a>课程表 II</h2><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><p>拓扑排序，bfs 思路，找入度为 0 的节点，放到队列和 ans 里面，并把 uv 的 v 节点的入度减一，并检测有哪些节点的入度为 0，继续放入队列中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; edges; <span class="hljs-comment">// 有向图</span><br>    <span class="hljs-type">int</span>[] indeg;<br>    <span class="hljs-type">int</span>[] ans;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] findOrder(<span class="hljs-type">int</span> numCourses, <span class="hljs-type">int</span>[][] prerequisites) &#123;<br>        edges = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[numCourses];<br>        indeg = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[numCourses]; <span class="hljs-comment">// 节点的入度</span><br>        Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; numCourses; i++) &#123;<br>            edges.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;());<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] req : prerequisites) &#123;<br>            edges.get(req[<span class="hljs-number">1</span>]).add(req[<span class="hljs-number">0</span>]);<br>            indeg[req[<span class="hljs-number">0</span>]]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; numCourses; i++) &#123;<br>            <span class="hljs-keyword">if</span> (indeg[i] == <span class="hljs-number">0</span>) &#123;<br>                queue.offer(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> queue.poll();<br>            ans[index++] = first;<br>            List&lt;Integer&gt; v = edges.get(first);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; v.size(); i++) &#123;<br>                indeg[v.get(i)]--;<br>                <span class="hljs-keyword">if</span> (indeg[v.get(i)] == <span class="hljs-number">0</span>) &#123;<br>                    queue.offer(v.get(i));<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (index &lt; numCourses) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1><p>回溯法就是暴力搜索，并不是什么高效的算法，最多再剪枝一下。</p>
<p>回溯算法能解决如下问题：</p>
<ul>
<li>组合问题：N个数里面按一定规则找出k个数的集合</li>
<li>排列问题：N个数按一定规则全排列，有几种排列方式</li>
<li>切割问题：一个字符串按一定规则有几种切割方式</li>
<li>子集问题：一个N个数的集合里有多少符合条件的子集</li>
<li>棋盘问题：N皇后，解数独等等</li>
</ul>
<p>模板框架：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(参数)</span> &#123;<br>    <span class="hljs-keyword">if</span> (终止条件) &#123;<br>        存放结果;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;<br>        处理节点;<br>        backtracking(路径，选择列表); <span class="hljs-comment">// 递归</span><br>        回溯，撤销处理结果<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h2><p>主要就是回溯前后的状态的更新和恢复</p>
<p>还有要想清楚选定了某个元素之后，剩余的选择的范围是哪些。</p>
<p>对于全排列来说是选定了元素之后，这个元素不能再选。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span>[] visited;<br>    <span class="hljs-keyword">private</span> List&lt;List&lt;Integer&gt;&gt; ans;<br>    <span class="hljs-keyword">private</span> List&lt;Integer&gt; tmp;<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permute</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        n = nums.length;<br>        visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n];<br>        ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        dfs(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> times)</span> &#123;<br>        <span class="hljs-keyword">if</span> (times == n) &#123;<br>            ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(tmp));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (!visited[i]) &#123;<br>                tmp.add(nums[i]);<br>                visited[i] = <span class="hljs-literal">true</span>;<br>                dfs(nums, times + <span class="hljs-number">1</span>);<br>                visited[i] = <span class="hljs-literal">false</span>;<br>                tmp.remove(tmp.size() - <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h2><p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p>
<p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,3]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[]</span>,<span class="hljs-comment">[1]</span>,<span class="hljs-comment">[2]</span>,<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[3]</span>,<span class="hljs-comment">[1,3]</span>,<span class="hljs-comment">[2,3]</span>,<span class="hljs-comment">[1,2,3]</span>]</span><br></code></pre></td></tr></table></figure>
<h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p>要点在于思考选择了第一个元素，比如 [1] 之后，后续的选择就不能再选 1 了。</p>
<p>选了 [1, 2] 就不能有 [2, 1] 了。所以要点在于选元素的时候，候选项是下标大于自己的元素里面。</p>
<p>所以注意 dfs 的第二个参数是 start + 1 而不是 i + 1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span>[] visited;<br>    List&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">subsets</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n];<br>        dfs(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-comment">// start 定义候选项的开始下标</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start)</span> &#123;<br>        ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(tmp));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (!visited[i]) &#123;<br>                tmp.add(nums[i]);<br>                visited[i] = <span class="hljs-literal">true</span>;<br>                dfs(nums, start + <span class="hljs-number">1</span>);<br>                visited[i] = <span class="hljs-literal">false</span>;<br>                tmp.remove(tmp.size() - <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="位操作"><a href="#位操作" class="headerlink" title="位操作"></a>位操作</h3><p>例如，n=3，a={5,2,9}时：</p>
<p>0/1序列    子集    0/1序列对应的二进制数<br>000    {}    0<br>001    {9}    1<br>010    {2}    2<br>011    {2,9}    3<br>100    {5}    4<br>101    {5,9}    5<br>110    {5,2}    6<br>111    {5,2,9}    7</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">subsets</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; (<span class="hljs-number">1</span> &lt;&lt; n); i++) &#123;<br>            List&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> ((i &amp; (<span class="hljs-number">1</span> &lt;&lt; j)) != <span class="hljs-number">0</span>) &#123;<br>                    tmp.add(nums[j]);<br>                &#125;<br>            &#125;<br>            ans.add(tmp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="电话号码的数字组合"><a href="#电话号码的数字组合" class="headerlink" title="电话号码的数字组合"></a>电话号码的数字组合</h2><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>for 套 for，第一个 for 找上一层的号码，第二个 for 根据上一层加新的号码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    Map&lt;Character, <span class="hljs-type">char</span>[]&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    List&lt;List&lt;String&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">letterCombinations</span><span class="hljs-params">(String digits)</span> &#123;<br>        <span class="hljs-keyword">if</span> (digits.length() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>        map.put(<span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[]&#123;<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[]&#123;<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;f&#x27;</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[]&#123;<span class="hljs-string">&#x27;g&#x27;</span>, <span class="hljs-string">&#x27;h&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[]&#123;<span class="hljs-string">&#x27;j&#x27;</span>, <span class="hljs-string">&#x27;k&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[]&#123;<span class="hljs-string">&#x27;m&#x27;</span>, <span class="hljs-string">&#x27;n&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[]&#123;<span class="hljs-string">&#x27;p&#x27;</span>, <span class="hljs-string">&#x27;q&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-string">&#x27;s&#x27;</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[]&#123;<span class="hljs-string">&#x27;t&#x27;</span>, <span class="hljs-string">&#x27;u&#x27;</span>, <span class="hljs-string">&#x27;v&#x27;</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;9&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[]&#123;<span class="hljs-string">&#x27;w&#x27;</span>, <span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-string">&#x27;y&#x27;</span>, <span class="hljs-string">&#x27;z&#x27;</span>&#125;);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">digitsIndex</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; digitsIndex &lt; digits.length(); digitsIndex++) &#123;<br>            <span class="hljs-type">char</span>[] res = map.get(digits.charAt(digitsIndex));<br>            List&lt;String&gt; tmp;<br>            <span class="hljs-keyword">if</span> (digitsIndex == <span class="hljs-number">0</span>) &#123;<br>                tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : res) &#123;<br>                    tmp.add(String.valueOf(c));<br>                &#125;<br>                ans.add(tmp);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                List&lt;String&gt; old = ans.get(digitsIndex - <span class="hljs-number">1</span>);<br>                tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>                <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> old.size();<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : res) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; size; i++) &#123;<br>                        tmp.add(old.get(i) + c);<br>                    &#125;<br>                &#125;<br>                ans.add(tmp);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans.get(ans.size() - <span class="hljs-number">1</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h3><p>要点在于转换为子问题，只需要上一层的状态即可。要点在于 dfs(i) 表示第 i 个字母对应的答案。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    Map&lt;Character, <span class="hljs-type">char</span>[]&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    List&lt;List&lt;String&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">letterCombinations</span><span class="hljs-params">(String digits)</span> &#123;<br>        <span class="hljs-keyword">if</span> (digits.length() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>        map.put(<span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[]&#123;<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[]&#123;<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;f&#x27;</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[]&#123;<span class="hljs-string">&#x27;g&#x27;</span>, <span class="hljs-string">&#x27;h&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[]&#123;<span class="hljs-string">&#x27;j&#x27;</span>, <span class="hljs-string">&#x27;k&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[]&#123;<span class="hljs-string">&#x27;m&#x27;</span>, <span class="hljs-string">&#x27;n&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[]&#123;<span class="hljs-string">&#x27;p&#x27;</span>, <span class="hljs-string">&#x27;q&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-string">&#x27;s&#x27;</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[]&#123;<span class="hljs-string">&#x27;t&#x27;</span>, <span class="hljs-string">&#x27;u&#x27;</span>, <span class="hljs-string">&#x27;v&#x27;</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;9&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[]&#123;<span class="hljs-string">&#x27;w&#x27;</span>, <span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-string">&#x27;y&#x27;</span>, <span class="hljs-string">&#x27;z&#x27;</span>&#125;);<br><br>        <span class="hljs-keyword">return</span> dfs(digits, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;(), <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> List&lt;String&gt; <span class="hljs-title function_">dfs</span><span class="hljs-params">(String digits, List&lt;String&gt; lastAns, <span class="hljs-type">int</span> times)</span> &#123;<br>        <span class="hljs-keyword">if</span> (times &lt; digits.length()) &#123;<br>            List&lt;String&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-type">char</span>[] chars = map.get(digits.charAt(times));<br>            <span class="hljs-keyword">if</span> (lastAns.size() != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; lastAns.size(); i++) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : chars) &#123;<br>                        ans.add(lastAns.get(i) + ch);<br>                    &#125;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : chars) &#123;<br>                    ans.add(<span class="hljs-string">&quot;&quot;</span> + ch);<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">return</span> dfs(digits, ans, times + <span class="hljs-number">1</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> lastAns;<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="组合总数"><a href="#组合总数" class="headerlink" title="组合总数"></a>组合总数</h2><p>要点：</p>
<ol>
<li><code>ans.add(new ArrayList&lt;&gt;(tmp));</code> 添加的是 tmp 的 clone。</li>
<li><code>dfs(candidates, target - num, i);</code> 第三个参数是 <code>i</code> ，而不是 <code>start + 1</code>，既可以保证选到相同的数字，又保证没有同一种的不同组合。比如 [3, 5] 和 [5, 3]。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> List&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span> &#123;<br>        dfs(candidates, target, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> start)</span> &#123;<br>        <span class="hljs-keyword">if</span> (target &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (target == <span class="hljs-number">0</span>) &#123;<br>            ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(tmp));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; candidates.length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> candidates[i];<br>            tmp.add(num);<br>            dfs(candidates, target - num, i);<br>            tmp.remove(tmp.size() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="括号生成"><a href="#括号生成" class="headerlink" title="括号生成"></a>括号生成</h2><p>要点：</p>
<ol>
<li>候选为 <code>(</code> 和 <code>)</code>，候选的个数为 n。每次应该可以从候选中任意选择。</li>
<li>选择之后添加到 tmp，然后继续递归，之后要删除 tmp 中添加的内容。</li>
<li>right 要在 left 之后才能被选择，所以放  right 的时候要确认可以选的 right &gt; left。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;String&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br><br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">generateParenthesis</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        dfs(n, n);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-comment">// 候选者有 n 个左括号，n 个右括号</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-number">0</span> &amp;&amp; right == <span class="hljs-number">0</span>) &#123;<br>            ans.add(sb.toString());<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (left &gt; <span class="hljs-number">0</span>) &#123;<br>            sb.append(<span class="hljs-string">&#x27;(&#x27;</span>);<br>            dfs(left - <span class="hljs-number">1</span>, right);<br>            sb.delete(sb.length() - <span class="hljs-number">1</span>, sb.length());<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (right &gt; <span class="hljs-number">0</span> &amp;&amp; right &gt; left) &#123;<br>            sb.append(<span class="hljs-string">&#x27;)&#x27;</span>);<br>            dfs(left, right - <span class="hljs-number">1</span>);<br>            sb.delete(sb.length() - <span class="hljs-number">1</span>, sb.length());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="单词搜索"><a href="#单词搜索" class="headerlink" title="单词搜索"></a>单词搜索</h2><p>要点：</p>
<ol>
<li>不允许重复使用，所以要使用 visited 数组。</li>
<li>回溯记得设置 visited 为 false。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> m, n;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span>[][] visited;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[][] dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;<br>        &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;,<br>        &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;,<br>        &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;,<br>        &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;<br>    &#125;;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">exist</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board, String word)</span> &#123;<br>        m = board.length;<br>        n = board[<span class="hljs-number">0</span>].length;<br>        visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[m][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (board[i][j] == word.charAt(<span class="hljs-number">0</span>)) &#123;<br>                    <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> == word.length()) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                    visited[i][j] = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">if</span> (dfs(board, word, <span class="hljs-number">1</span>, i, j)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                    visited[i][j] = <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board, String word, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>            <span class="hljs-type">int</span>[] dir = dirs[i];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">newRow</span> <span class="hljs-operator">=</span> row + dir[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">newCol</span> <span class="hljs-operator">=</span> col + dir[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (check(board, newRow, newCol, word.charAt(start))) &#123; <span class="hljs-comment">// 继续搜索可能找到的情况</span><br>                <span class="hljs-keyword">if</span> (start == word.length() - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 找到了最后一个字母</span><br>                visited[newRow][newCol] = <span class="hljs-literal">true</span>;<br>                <span class="hljs-type">boolean</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> dfs(board, word, start + <span class="hljs-number">1</span>, newRow, newCol);<br>                visited[newRow][newCol] = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">if</span> (res) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board, <span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col, <span class="hljs-type">char</span> need)</span> &#123;<br>        <span class="hljs-keyword">return</span> row &gt;= <span class="hljs-number">0</span> &amp;&amp; row &lt; m &amp;&amp; col &gt;= <span class="hljs-number">0</span> &amp;&amp; col &lt; n &amp;&amp; !visited[row][col] &amp;&amp; need == board[row][col];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="分割回文串"><a href="#分割回文串" class="headerlink" title="分割回文串"></a>分割回文串</h2><p>要点：</p>
<ol>
<li>不管是递归还是 dp，重要的都是划分子问题，用 dp[i][j] 表示。</li>
<li>这里是枚举所有的分割方法，然后判断是不是回文字符串。枚举可以用回溯法，判断可以使用 dp 等方法进行优化。</li>
<li>枚举要有条理的枚举，比如从 i 开始，一直枚举到结尾，然后下次从 i + 1 再到结尾。</li>
</ol>
<p>数据很弱，直接回溯都能过。</p>
<h3 id="直接回溯"><a href="#直接回溯" class="headerlink" title="直接回溯"></a>直接回溯</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;String&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    List&lt;String&gt; tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-type">int</span> n;<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">partition</span><span class="hljs-params">(String s)</span> &#123;<br>        n = s.length();<br>        dfs(s, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> start)</span> &#123;<br>        <span class="hljs-keyword">if</span> (start == n) &#123;<br>            ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(tmp));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start + <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">sub</span> <span class="hljs-operator">=</span> s.substring(start, i);<br>            <span class="hljs-keyword">if</span> (check(sub)) &#123; <span class="hljs-comment">// 当前分割方法是回文串</span><br>                tmp.add(sub);<br>                dfs(s, i); <span class="hljs-comment">// 左闭右开，继续进行分割</span><br>                tmp.remove(tmp.size() - <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = s.length() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-keyword">if</span> (s.charAt(left) != s.charAt(right)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            left++;<br>            right--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="回溯-dp"><a href="#回溯-dp" class="headerlink" title="回溯 + dp"></a>回溯 + dp</h3><p>其实就是用 dp 记录一下哪些情况是回文字符串，这样就不用重复判断了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;String&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    List&lt;String&gt; tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-type">boolean</span>[][] dp;<br>    <span class="hljs-type">int</span> n;<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">partition</span><span class="hljs-params">(String s)</span> &#123;<br>        n = s.length();<br>        initDp(s);<br>        dfs(s, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initDp</span><span class="hljs-params">(String s)</span> &#123;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>]; <span class="hljs-comment">// 左闭右闭</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            dp[i][i] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 单字符为回文串</span><br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (s.charAt(i) == s.charAt(i + <span class="hljs-number">1</span>)) &#123;<br>                dp[i][i + <span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 双字符为回文串</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] &amp;&amp; s.charAt(i) == s.charAt(j))<br>                dp[i][j] = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> start)</span> &#123;<br>        <span class="hljs-keyword">if</span> (start == n) &#123;<br>            ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(tmp));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start + <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">sub</span> <span class="hljs-operator">=</span> s.substring(start, i);<br>            <span class="hljs-keyword">if</span> (dpCheck(start, i - <span class="hljs-number">1</span>)) &#123; <span class="hljs-comment">// 当前分割方法是回文串</span><br>                tmp.add(sub);<br>                dfs(s, i); <span class="hljs-comment">// 左闭右开，继续进行分割</span><br>                tmp.remove(tmp.size() - <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dpCheck</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>        <span class="hljs-keyword">return</span> dp[start][end];<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = s.length() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-keyword">if</span> (s.charAt(left) != s.charAt(right)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            left++;<br>            right--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="记忆化递归"><a href="#记忆化递归" class="headerlink" title="记忆化递归"></a>记忆化递归</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;String&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    List&lt;String&gt; tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-type">int</span>[][] dp;<br>    <span class="hljs-type">int</span> n;<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">partition</span><span class="hljs-params">(String s)</span> &#123;<br>        n = s.length();<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        dfs(s, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> start)</span> &#123;<br>        <span class="hljs-keyword">if</span> (start == n) &#123;<br>            ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(tmp));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start + <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">sub</span> <span class="hljs-operator">=</span> s.substring(start, i);<br>            <span class="hljs-keyword">if</span> (memoryCheck(s, start, i - <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 当前分割方法是回文串</span><br>                tmp.add(sub);<br>                dfs(s, i); <span class="hljs-comment">// 左闭右开，继续进行分割</span><br>                tmp.remove(tmp.size() - <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">memoryCheck</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">if</span> (dp[i][j] != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> dp[i][j]; <span class="hljs-comment">// 记忆命中</span><br>        <span class="hljs-keyword">if</span> (i &gt;= j) dp[i][j] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;<br>            dp[i][j] = memoryCheck(s, i + <span class="hljs-number">1</span>, j - <span class="hljs-number">1</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            dp[i][j] = -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[i][j];<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = s.length() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-keyword">if</span> (s.charAt(left) != s.charAt(right)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            left++;<br>            right--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><h2 id="搜索插入位置"><a href="#搜索插入位置" class="headerlink" title="搜索插入位置"></a>搜索插入位置</h2><h3 id="左闭右闭"><a href="#左闭右闭" class="headerlink" title="左闭右闭"></a>左闭右闭</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">searchInsert</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            mid = left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] == target) <span class="hljs-keyword">return</span> mid;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="左闭右开"><a href="#左闭右开" class="headerlink" title="左闭右开"></a>左闭右开</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">searchInsert</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            mid = left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] == target) <span class="hljs-keyword">return</span> mid;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>                right = mid;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="搜索二维矩阵"><a href="#搜索二维矩阵" class="headerlink" title="搜索二维矩阵"></a>搜索二维矩阵</h2><p>先在所有行中二分搜索第一个元素，然后在确定的某一行中搜索。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">searchMatrix</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 先二分行</span><br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            mid = left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (matrix[mid][<span class="hljs-number">0</span>] == target) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (matrix[mid][<span class="hljs-number">0</span>] &gt; target) &#123;<br>                right = mid;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (left &gt; <span class="hljs-number">0</span>) row = left - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> row = left;<br>        left = <span class="hljs-number">0</span>;<br>        right = matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-comment">// 再二分列</span><br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            mid = left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (matrix[row][mid] == target) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (matrix[row][mid] &gt; target) &#123;<br>                right = mid;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="在排序数组中查找元素的第一个和最后一个位置"><a href="#在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="在排序数组中查找元素的第一个和最后一个位置"></a>在排序数组中查找元素的第一个和最后一个位置</h2><p>一个搜索 lower bound，另一个 upper bound，搜索 lower bound 是等于 target 的时候设置 ans[0] = mid 并且 right = mid；upper bound 是等于 target 的时候设置ans[1] = mid 并且 left = mid + 1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] searchRange(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> mid;<br>        <span class="hljs-type">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;;<br><br>        <span class="hljs-comment">// lower bound</span><br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            mid = left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>                ans[<span class="hljs-number">0</span>] = mid;<br>                right = mid;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right = mid;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// upper bound</span><br>        left = <span class="hljs-number">0</span>;<br>        right = nums.length;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            mid = left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>                ans[<span class="hljs-number">1</span>] = mid;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right = mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="搜索旋转排序数组"><a href="#搜索旋转排序数组" class="headerlink" title="搜索旋转排序数组"></a>搜索旋转排序数组</h2><p>对一个旋转后的数组进行切分，总会切分成两部分，两部分中必定有一部分是顺序的，另一部分是乱序的，对于顺序的进行二分搜索，对于乱序的继续切分。</p>
<p>然后还要注意，判断在顺序部分的时候，nums[left] 和 target 的比较得是 <code>&lt;=</code> ，否则无法处理 <code>nums = [1, 3], target = 1</code> 的情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> mid;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            mid = left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] == target) <span class="hljs-keyword">return</span> mid;<br>            <span class="hljs-keyword">if</span> (nums[left] &lt; nums[mid]) &#123; <span class="hljs-comment">// 左边顺序，右边乱序</span><br>                <span class="hljs-keyword">if</span> (nums[left] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123; <span class="hljs-comment">// target 在左面顺序部分</span><br>                    right = mid;<br>                &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// target 在乱序部分</span><br>                    left = mid + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 右边顺序，左边乱序</span><br>                <span class="hljs-keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[right - <span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// target 在右面顺序部分</span><br>                    left = mid + <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    right = mid;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="寻找旋转排序数组中的最小值"><a href="#寻找旋转排序数组中的最小值" class="headerlink" title="寻找旋转排序数组中的最小值"></a>寻找旋转排序数组中的最小值</h2><p>搜索旋转排序数组的简化版本，无论在哪里分隔，都是有序和无序部分，有序部分取最小值，然后继续去无序部分继续搜索。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findMin</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> mid;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            mid = left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-comment">// nums[left] ... mid ... nums[right]</span><br>            <span class="hljs-keyword">if</span> (nums[left] &lt; nums[mid]) &#123; <span class="hljs-comment">// 左边有序</span><br>                min = Math.min(min, nums[left]);<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 右边有序</span><br>                min = Math.min(min, nums[mid]);<br>                right = mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> min;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="寻找两个正序数组的中位数"><a href="#寻找两个正序数组的中位数" class="headerlink" title="寻找两个正序数组的中位数"></a>寻找两个正序数组的中位数</h2><p>这道题的关键在于对中位数的理解，一个数组的中位数是能够将数组分为两部分的数，且左边部分的最大值小于右边部分最小值。</p>
<p>对于两个数组的情况：</p>
<p><img  src="/image-20250227154454826.png"   style="zoom: 67%;" /><span class="image-caption">image-20250227154454826</span></p>
<h3 id="第一个条件：左边元素个数和右边相等或左边多一个"><a href="#第一个条件：左边元素个数和右边相等或左边多一个" class="headerlink" title="第一个条件：左边元素个数和右边相等或左边多一个"></a>第一个条件：左边元素个数和右边相等或左边多一个</h3><p>然后分割线左边元素个数和右边元素个数是可以被计算的，假设长度为 m 和 n，当 m + n 为偶数时，左边元素个数 = 右边元素个数 = (m + n) / 2。</p>
<p>当 m + n 为奇数时，假设中位数在左边，于是 左边元素个数 = (m + n + 1) / 2。</p>
<p>又偶数的时候，(m + n + 1) / 2  = (m + n) / 2，因为默认是向下取整。所以统一成了  左边元素个数 = (m + n + 1) / 2。</p>
<h3 id="第二个条件：分割线左边最大元素-lt-分割线右边最大元素"><a href="#第二个条件：分割线左边最大元素-lt-分割线右边最大元素" class="headerlink" title="第二个条件：分割线左边最大元素 &lt;= 分割线右边最大元素"></a>第二个条件：分割线左边最大元素 &lt;= 分割线右边最大元素</h3><p>对于两个数组的情况下：</p>
<ol>
<li>第一个数组的分割线左边最大值 &lt;= 第二个数组的分割线右边最小值</li>
<li>第二个数组的分割线左边最大值 &lt;= 第一个数组的分割线右边最小值</li>
</ol>
<p>如果不满足上面的情况，就要进行调整。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">findMedianSortedArrays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nums1.length &gt; nums2.length) <span class="hljs-keyword">return</span> findMedianSortedArrays(nums2, nums1);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> nums1.length, n = nums2.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = m;<br>        <span class="hljs-comment">// median1: 前一部分最大值</span><br>        <span class="hljs-comment">// median2: 后一部分最小值</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">median1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, median2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-comment">// 分割线在第 1 个数组右边的第 1 个元素的下标 i = 分割线在第 1 个数组左边的元素个数</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-comment">// 分割线在第 2 个数组右边的第 1 个元素的小标 j = 分割线在第 2 个数组左边的元素的个数</span><br>            <span class="hljs-comment">// 也就是左边的部分还需要的元素的个数，根据 i 的位置，j 的位置根据数量就唯一确定了。</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> (m + n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> - i;<br><br>            <span class="hljs-type">int</span> <span class="hljs-variable">nums_i_minus_1</span> <span class="hljs-operator">=</span> (i == <span class="hljs-number">0</span> ? Integer.MIN_VALUE : nums1[i - <span class="hljs-number">1</span>]);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">nums_i_add_1</span> <span class="hljs-operator">=</span> (i == m ? Integer.MAX_VALUE : nums1[i]); <span class="hljs-comment">// 分割线右边第一个元素</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">nums_j_minus_1</span> <span class="hljs-operator">=</span> (j == <span class="hljs-number">0</span> ? Integer.MIN_VALUE : nums2[j - <span class="hljs-number">1</span>]);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">nums_j_add_1</span> <span class="hljs-operator">=</span> (j == n ? Integer.MAX_VALUE : nums2[j]); <span class="hljs-comment">// 分割线右边第一个元素</span><br><br>            <span class="hljs-comment">// if (median1 &gt; median2) &#123;</span><br>            <span class="hljs-keyword">if</span> (nums_i_minus_1 &gt; nums_j_add_1) &#123;<br>                right = i - <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                median1 = Math.max(nums_i_minus_1, nums_j_minus_1);<br>                median2 = Math.min(nums_i_add_1, nums_j_add_1);<br>                left = i + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> (m + n) % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> ? (median1 + median2) / <span class="hljs-number">2.0</span> : median1;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="统计公平数对的数目"><a href="#统计公平数对的数目" class="headerlink" title="统计公平数对的数目"></a>统计公平数对的数目</h2><p>给你一个下标从 <strong>0</strong> 开始、长度为 <code>n</code> 的整数数组 <code>nums</code> ，和两个整数 <code>lower</code> 和 <code>upper</code> ，返回 <strong>公平数对的数目</strong> 。</p>
<p>如果 <code>(i, j)</code> 数对满足以下情况，则认为它是一个 <strong>公平数对</strong> ：</p>
<ul>
<li><code>0 &lt;= i &lt; j &lt; n</code>，且</li>
<li><code>lower &lt;= nums[i] + nums[j] &lt;= upper</code></li>
</ul>
<p>由于排序不影响答案，可以先（从小到大）排序，这样可以二分查找。</p>
<p><code>nums</code> 是 <code>[1,2]</code> 还是 <code>[2,1]</code>，算出来的答案都是一样的，因为加法满足交换律 $a + b = b + a$。</p>
<p>排序后，枚举右边的 <code>nums[j]</code>，那么左边的 <code>nums[i]</code> 需要满足 $0 \leq i &lt; j$ 以及</p>
<script type="math/tex; mode=display">
lower - nums[j] \leq nums[i] \leq upper - nums[j]</script><p>计算 $\leq upper - nums[j]$ 的元素个数，减去 $&lt; lower - nums[j]$ 的元素个数，即为满足上式的元素个数。(联想一下前缀和)</p>
<p>由于 <code>nums</code> 是有序的，我们可以在 $[0, j - 1]$ 中二分查找，原理见【基础算法精讲 04】：</p>
<ul>
<li>找到 $&gt; upper - nums[j]$ 的第一个数，设其下标为 $r$，那么下标在 $[0, r - 1]$ 中的数都是 $\leq upper - nums[j]$ 的，这有 $r$ 个。如果 $[0, j - 1]$ 中没有找到这样的数，那么二分结果为 $j$。这意味着 $[0, j - 1]$ 中的数都是 $\leq upper - nums[j]$ 的，这有 $j$ 个。</li>
<li>找到 $\geq lower - nums[j]$ 的第一个数，设其下标为 $l$，那么下标在 $[0, l - 1]$ 中的数都是 $&lt; lower - nums[j]$ 的，这有 $l$ 个。如果 $[0, j - 1]$ 中没有找到这样的数，那么二分结果为 $j$。这意味着 $[0, j - 1]$ 中的数都是 $&lt; lower - nums[j]$ 的，这有 $j$ 个。 </li>
<li>满足 $lower - nums[j] \leq nums[i] \leq upper - nums[j]$ 的 <code>nums[i]</code> 的个数为 $r - l$，加入答案。 </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">countFairPairs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> lower, <span class="hljs-type">int</span> upper)</span> &#123;<br>        Arrays.sort(nums);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; nums.length; j++) &#123;<br>            <span class="hljs-comment">// 注意要在 [0, j-1] 中二分，因为题目要求两个下标 i &lt; j</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> lowerBound(nums, j, upper - nums[j] + <span class="hljs-number">1</span>);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> lowerBound(nums, j, lower - nums[j]);<br>            ans += r - l;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lowerBound</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> right, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left + <span class="hljs-number">1</span> &lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right) &gt;&gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &gt;= target) &#123;<br>                right = mid;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                left = mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> right;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h2 id="有效的括号"><a href="#有效的括号" class="headerlink" title="有效的括号"></a>有效的括号</h2><p>判断右括号的时候栈顶能不能匹配就好。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(String s)</span> &#123;<br>        Deque&lt;Character&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (s.charAt(i) == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                stack.push(<span class="hljs-string">&#x27;(&#x27;</span>);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s.charAt(i) == <span class="hljs-string">&#x27;&#123;&#x27;</span>) &#123;<br>                stack.push(<span class="hljs-string">&#x27;&#123;&#x27;</span>);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s.charAt(i) == <span class="hljs-string">&#x27;[&#x27;</span>) &#123;<br>                stack.push(<span class="hljs-string">&#x27;[&#x27;</span>);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s.charAt(i) == <span class="hljs-string">&#x27;)&#x27;</span> &amp;&amp; (stack.size() == <span class="hljs-number">0</span> || stack.pop() != <span class="hljs-string">&#x27;(&#x27;</span>)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s.charAt(i) == <span class="hljs-string">&#x27;&#125;&#x27;</span> &amp;&amp; (stack.size() == <span class="hljs-number">0</span> || stack.pop() != <span class="hljs-string">&#x27;&#123;&#x27;</span>)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s.charAt(i) == <span class="hljs-string">&#x27;]&#x27;</span> &amp;&amp; (stack.size() == <span class="hljs-number">0</span> || stack.pop() != <span class="hljs-string">&#x27;[&#x27;</span>)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> stack.size() == <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="最小栈"><a href="#最小栈" class="headerlink" title="最小栈"></a>最小栈</h2><p>设计一个支持 <code>push</code> ，<code>pop</code> ，<code>top</code> 操作，并能在常数时间内检索到最小元素的栈。</p>
<p>要点在于增加一个栈，和用的栈同步 push 和 pop 数据，只不过 push 的时候 push 进去当前的最小值，pop 的时候同步 pop。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span> &#123;<br>    Deque&lt;Integer&gt; stack;<br>    Deque&lt;Integer&gt; minStack;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MinStack</span><span class="hljs-params">()</span> &#123;<br>        stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        minStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        stack.push(val);<br>        <span class="hljs-comment">// 与 stack 同步放入最小值</span><br>        <span class="hljs-keyword">if</span> (minStack.size() == <span class="hljs-number">0</span>) &#123;<br>            minStack.push(val);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            minStack.push(Math.min(minStack.peek(), val));<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        stack.pop();<br>        minStack.pop();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">top</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> stack.peek();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMin</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> minStack.peek();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MinStack object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MinStack obj = new MinStack();</span><br><span class="hljs-comment"> * obj.push(val);</span><br><span class="hljs-comment"> * obj.pop();</span><br><span class="hljs-comment"> * int param_3 = obj.top();</span><br><span class="hljs-comment"> * int param_4 = obj.getMin();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>
<h2 id="字符串解码"><a href="#字符串解码" class="headerlink" title="字符串解码"></a>字符串解码</h2><p>给定一个经过编码的字符串，返回它解码后的字符串。</p>
<p>编码规则为: <code>k[encoded_string]</code>，表示其中方括号内部的 <code>encoded_string</code> 正好重复 <code>k</code> 次。注意 <code>k</code> 保证为正整数。</p>
<p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p>
<p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 <code>k</code> ，例如不会出现像 <code>3a</code> 或 <code>2[4]</code> 的输入。</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;3[a]2[bc]&quot;</span><br>输出：<span class="hljs-string">&quot;aaabcbc&quot;</span><br></code></pre></td></tr></table></figure>
<p>要点：</p>
<ul>
<li>括号的处理，看到左括号右括号，要想到用栈来解决。</li>
<li>括号前是数字就解析为数字</li>
<li>括号前为字母就加进来</li>
<li>括号中的内容要用解析的数字进行一个重复</li>
<li>记得清空 sb</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">decodeString</span><span class="hljs-params">(String s)</span> &#123;<br>        Deque&lt;Integer&gt; numStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        Deque&lt;String&gt; strStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">multi</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : s.toCharArray()) &#123;<br>            <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;[&#x27;</span>) &#123;<br>                numStack.push(multi);<br>                strStack.push(sb.toString());<br>                multi = <span class="hljs-number">0</span>;<br>                sb = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;]&#x27;</span>) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">times</span> <span class="hljs-operator">=</span> numStack.pop();<br>                <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; times; i++) &#123;<br>                    tmp.append(sb);<br>                &#125;<br>                sb = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>                sb.append(strStack.pop()).append(tmp);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;0&#x27;</span> &lt;= ch &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>                multi = multi * <span class="hljs-number">10</span> + (ch - <span class="hljs-string">&#x27;0&#x27;</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                sb.append(ch);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="每日温度"><a href="#每日温度" class="headerlink" title="每日温度"></a>每日温度</h2><p>给定一个整数数组 <code>temperatures</code> ，表示每天的温度，返回一个数组 <code>answer</code> ，其中 <code>answer[i]</code> 是指对于第 <code>i</code> 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 <code>0</code> 来代替。</p>
<h3 id="从右向左"><a href="#从右向左" class="headerlink" title="从右向左"></a>从右向左</h3><p>要点：单调栈</p>
<p>栈里面存的是当前 index，当新放进来的温度比栈中已有的温度低的时候，新放进来的温度就有答案了。</p>
<p>否则就更新栈。</p>
<p><img  src="/image-20250301225057849.png"   style="zoom:50%;" /><span class="image-caption">image-20250301225057849</span></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] dailyTemperatures(<span class="hljs-type">int</span>[] temperatures) &#123;<br>        <span class="hljs-type">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[temperatures.length];<br>        Deque&lt;Integer&gt; tempStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> temperatures.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> temperatures[i];<br>            <span class="hljs-keyword">while</span> (!tempStack.isEmpty() &amp;&amp; temp &gt;= temperatures[tempStack.peek()]) &#123;<br>                tempStack.pop();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!tempStack.isEmpty()) &#123;<br>                ans[i] = tempStack.peek() - i;<br>            &#125;<br>            tempStack.push(i);<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="从左向右"><a href="#从左向右" class="headerlink" title="从左向右"></a>从左向右</h3><p>单调栈内存放的是 index，然后都是新放进去的 index 大，同时只放进去没有更高温度的 index。</p>
<p>当新给的温度比栈顶的温度高的时候，那些温度就都有救了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] dailyTemperatures(<span class="hljs-type">int</span>[] temperatures) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> temperatures.length;<br>        <span class="hljs-type">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        Deque&lt;Integer&gt; st = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> temperatures[i];<br>            <span class="hljs-keyword">while</span> (!st.isEmpty() &amp;&amp; temp &gt; temperatures[st.peek()]) &#123; <span class="hljs-comment">// 单调栈内比当前小的温度都有救了</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> st.pop();<br>                ans[j] = i - j;<br>            &#125;<br>            st.push(i);<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="柱状图中最大的矩形"><a href="#柱状图中最大的矩形" class="headerlink" title="柱状图中最大的矩形"></a>柱状图中最大的矩形</h2><p><img  src="/b4125f95419bc2306c7f16d1679c32e538b0b087bd9d0f70658c1a8528afca6b-image.png"  ><span class="image-caption">image.png</span></p>
<p>所以这题的关键在于给定一个柱子，找到左边和右边第一个高度小于给定柱子的下标。</p>
<p>暴力做法就是硬找，给定一个柱子，遍历所有的柱子找到高度更小的。找柱子复杂度为 O（n）。</p>
<p>优化做法就是优化如何得到 left[i] 和 right[i]。</p>
<p>left[i] 表示给定第 i 个柱子，左边第一个比他矮的柱子的下标。</p>
<p>right[i] 表示给定第 i 个柱子，右边第一个比他矮的柱子的下标。</p>
<p>求 left[i] 的方法：从左向右，要求的是比当前柱子高度低的柱子，所以用单调栈使得：<strong>单调栈内只留下比当前柱子高度更矮的柱子</strong>。然后剩下的这个柱子就是答案。另一种理解方法是：<strong>单调栈内比当前柱子高的柱子（更左面更高的柱子）都用不到了</strong></p>
<p>求 right[i] 的方法也是同理：从右向左，要求的是比当前柱子高度低的柱子，所以用单调栈使得：<strong>单调栈内只留下比当前柱子高度更矮的柱子</strong>。然后剩下的这个柱子就是答案了。另一种理解方法是：<strong>单调栈内比当前柱子高的柱子（更右面更高的柱子）都用不到了</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">largestRectangleArea</span><span class="hljs-params">(<span class="hljs-type">int</span>[] heights)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> heights.length;<br>        <span class="hljs-type">int</span>[] left = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-type">int</span>[] right = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        Deque&lt;Integer&gt; st = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-comment">// 形成 left[i]</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> heights[i];<br>            <span class="hljs-keyword">while</span> (!st.isEmpty() &amp;&amp; h &lt;= heights[st.peek()]) &#123; <span class="hljs-comment">// 左边比当前柱子高的柱子后面用不到了</span><br>                st.pop();<br>            &#125;<br>            <span class="hljs-comment">// 栈中剩下的是高度比当前柱子低的柱子的下标</span><br>            <span class="hljs-comment">// 用于后续找更低的柱子</span><br>            left[i] = st.isEmpty() ? -<span class="hljs-number">1</span> : st.peek();<br>            st.push(i);<br>        &#125;<br><br>        <span class="hljs-comment">// 形成 right[i]</span><br>        st.clear();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> heights[i];<br>            <span class="hljs-keyword">while</span> (!st.isEmpty() &amp;&amp; h &lt;= heights[st.peek()]) &#123; <span class="hljs-comment">// 右边元素中比当前柱子高的后面也用不到了</span><br>                st.pop();<br>            &#125;<br>            <span class="hljs-comment">// 栈中剩下的是高度比当前柱子低的柱子的下标</span><br>            <span class="hljs-comment">// 用于后续找更低的柱子</span><br>            right[i] = st.isEmpty() ? n : st.peek();<br>            st.push(i);<br>        &#125;<br><br>        <span class="hljs-comment">// 计算最大面积</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            ans = Math.max(ans, heights[i] * (right[i] - left[i] - <span class="hljs-number">1</span>));<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><h2 id="数组中的第-K-个最大元素"><a href="#数组中的第-K-个最大元素" class="headerlink" title="数组中的第 K 个最大元素"></a>数组中的第 K 个最大元素</h2><h3 id="快速选择-O-n"><a href="#快速选择-O-n" class="headerlink" title="快速选择 O(n)"></a>快速选择 O(n)</h3><p>和快排的思路一致：对于一组数据，选择一个基准元素（base），通常选择第一个或最后一个元素，通过第一轮扫描，比base小的元素都在base左边，比base大的元素都在base右边，再有同样的方法递归排序这两部分，直到序列中所有数据均有序为止。</p>
<p>如果有大量相似的元素，那么要二路快排。否则时间复杂度会退化到 O(n^2)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findKthLargest</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">return</span> quickSelect(nums, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, n - k);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">quickSelect</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-keyword">if</span> (left == right) <span class="hljs-keyword">return</span> nums[left];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">pivotIndex</span> <span class="hljs-operator">=</span> partition(nums, left, right);<br>        <span class="hljs-keyword">if</span> (k == pivotIndex) &#123;<br>            <span class="hljs-keyword">return</span> nums[k];<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k &lt; pivotIndex) &#123;<br>            <span class="hljs-keyword">return</span> quickSelect(nums, left, pivotIndex - <span class="hljs-number">1</span>, k);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> quickSelect(nums, pivotIndex + <span class="hljs-number">1</span>, right, k);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 分割点位置</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">partition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">pivot</span> <span class="hljs-operator">=</span> nums[right];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> left;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> right - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt;= r) &#123; <span class="hljs-comment">// 用 l &lt;= r 代替无限循环</span><br>            <span class="hljs-keyword">while</span> (l &lt;= r &amp;&amp; nums[l] &lt; pivot) l++; <span class="hljs-comment">// 左指针 l 的行为：当 nums[l] 小于枢轴时，l 会继续向右移动。</span><br>            <span class="hljs-keyword">while</span> (l &lt;= r &amp;&amp; pivot &lt; nums[r]) r--; <span class="hljs-comment">// 右指针 r 的行为：当 nums[r] 大于枢纽时，r 会继续向左移动。</span><br>            <span class="hljs-keyword">if</span> (l &lt;= r) &#123;<br>                swap(nums, l, r);<br>                l++; <span class="hljs-comment">// 交换后必须移动指针</span><br>                r--; <span class="hljs-comment">// 避免死循环</span><br>            &#125;<br>        &#125;<br>        swap(nums, l, right); <span class="hljs-comment">// 将基准放到正确位置，l 指向第一个大于等于 privot 的值</span><br>        <span class="hljs-keyword">return</span> l; <span class="hljs-comment">// 返回基准的最终位置</span><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> nums[i];<br>        nums[i] = nums[j];<br>        nums[j] = tmp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="堆-1"><a href="#堆-1" class="headerlink" title="堆"></a>堆</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findKthLargest</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">heapSize</span> <span class="hljs-operator">=</span> nums.length;<br>        buildMaxHeap(nums, heapSize);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>; i &gt;= nums.length - k + <span class="hljs-number">1</span>; --i) &#123;<br>            swap(nums, <span class="hljs-number">0</span>, i);<br>            --heapSize;<br>            maxHeapify(nums, <span class="hljs-number">0</span>, heapSize);<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildMaxHeap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span> heapSize)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> heapSize / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>            maxHeapify(a, i, heapSize);<br>        &#125; <br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">maxHeapify</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> heapSize)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> i * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, r = i * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>, largest = i;<br>        <span class="hljs-keyword">if</span> (l &lt; heapSize &amp;&amp; a[l] &gt; a[largest]) &#123;<br>            largest = l;<br>        &#125; <br>        <span class="hljs-keyword">if</span> (r &lt; heapSize &amp;&amp; a[r] &gt; a[largest]) &#123;<br>            largest = r;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (largest != i) &#123;<br>            swap(a, i, largest);<br>            maxHeapify(a, largest, heapSize);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> a[i];<br>        a[i] = a[j];<br>        a[j] = temp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="前-k-个高频元素"><a href="#前-k-个高频元素" class="headerlink" title="前 k 个高频元素"></a>前 k 个高频元素</h2><p>遍历一遍并统计频率，并且放到堆里面。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] topKFrequent(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">if</span> (n == k) <span class="hljs-keyword">return</span> nums;<br>        Arrays.sort(nums);<br>        PriorityQueue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; &#123;<br>            <span class="hljs-keyword">return</span> b[<span class="hljs-number">0</span>] - a[<span class="hljs-number">0</span>];<br>        &#125;);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &lt; n &amp;&amp; nums[i] == nums[i + <span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// 对边界情况的处理</span><br>                count++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;count, nums[i]&#125;);<br>                count = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>            ans[i] = queue.poll()[<span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="数据流的中位数"><a href="#数据流的中位数" class="headerlink" title="数据流的中位数"></a>数据流的中位数</h2><p>要点在于：</p>
<ul>
<li>用两个堆，一个升序保存比中位数大的数，一个降序保存比中位数小的数</li>
<li>这样中位数就是比中位数大的数中最小的和比中位数小的数中最大的两个数的一半</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MedianFinder</span> &#123;<br>    PriorityQueue&lt;Integer&gt; gtQueue;<br>    PriorityQueue&lt;Integer&gt; ltQueue;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MedianFinder</span><span class="hljs-params">()</span> &#123;<br>        gtQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; (a - b)); <span class="hljs-comment">// 升序</span><br>        ltQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; (b - a)); <span class="hljs-comment">// 降序</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addNum</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-keyword">if</span> (ltQueue.isEmpty() || num &lt;= ltQueue.peek()) &#123;<br>            ltQueue.offer(num);<br>            <span class="hljs-keyword">if</span> (ltQueue.size() &gt; gtQueue.size() + <span class="hljs-number">1</span>) &#123;<br>                gtQueue.offer(ltQueue.poll());<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            gtQueue.offer(num);<br>            <span class="hljs-keyword">if</span> (gtQueue.size() &gt; ltQueue.size()) &#123;<br>                ltQueue.offer(gtQueue.poll());<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">findMedian</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (ltQueue.size() - gtQueue.size() == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> ltQueue.peek();<br>        &#125;<br>        <span class="hljs-keyword">return</span> (gtQueue.peek() + ltQueue.peek()) / <span class="hljs-number">2.0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h1><h2 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a>买卖股票的最佳时机</h2><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p>
<p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p>
<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p>
<p>要点：</p>
<p>在每天都卖，买的价格是已出现的最小值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> prices.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">lowest</span> <span class="hljs-operator">=</span> prices[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> prices[i];<br>            <span class="hljs-keyword">if</span> (x &lt; lowest) &#123;<br>                lowest = x;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                ans = Math.max(ans, x - lowest);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a>跳跃游戏</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canJump</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>        <span class="hljs-comment">// 总体思路：是否存在跳不过去的 0</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] == <span class="hljs-number">0</span> &amp;&amp; i != n - <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 最后的一个 0 不用判断</span><br>                list.add(i);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">lastStart</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; list.size(); i++) &#123;<br>            <span class="hljs-comment">// 看 0 的前面</span><br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">ok</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> list.get(i) - <span class="hljs-number">1</span>; j &gt;= lastStart; j--) &#123;<br>                <span class="hljs-keyword">if</span> (nums[j] &gt; list.get(i) - j) &#123;<br>                    ok = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!ok) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>官解：判断能跳过去的最大长度是否超过结尾</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canJump</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rightmost</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (i &lt;= rightmost) &#123;<br>                rightmost = Math.max(rightmost, i + nums[i]);<br>                <span class="hljs-keyword">if</span> (rightmost &gt;= n - <span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h2 id="x-的平方根"><a href="#x-的平方根" class="headerlink" title="x 的平方根"></a>x 的平方根</h2><h3 id="二分-1"><a href="#二分-1" class="headerlink" title="二分"></a>二分</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">mySqrt</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = x, ans = -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l + (r - l) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> ((<span class="hljs-type">long</span>) mid * mid &lt;= x) &#123;<br>                ans = mid;<br>                l = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                r = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="转换为对数"><a href="#转换为对数" class="headerlink" title="转换为对数"></a>转换为对数</h2><p>对于平方根有以下运算：</p>
<p>$\sqrt{x} = x^{1/2} = \left(e^{\ln x}\right)^{1/2} = e^{\frac{1}{2} \ln x}$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">mySqrt</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) Math.exp(<span class="hljs-number">0.5</span> * Math.log(x));<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">long</span>) (ans + <span class="hljs-number">1</span>) * (ans + <span class="hljs-number">1</span>) &lt;= x ? ans + <span class="hljs-number">1</span> : ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="统计隐藏数组数目"><a href="#统计隐藏数组数目" class="headerlink" title="统计隐藏数组数目"></a>统计隐藏数组数目</h2><p>给你一个下标从 <strong>0</strong> 开始且长度为 <code>n</code> 的整数数组 <code>differences</code> ，它表示一个长度为 <code>n + 1</code> 的 <strong>隐藏</strong> 数组 <strong>相邻</strong> 元素之间的 <strong>差值</strong> 。更正式的表述为：我们将隐藏数组记作 <code>hidden</code> ，那么 <code>differences[i] = hidden[i + 1] - hidden[i]</code> 。</p>
<p><img  src="/image-20250421172529810.png"   style="zoom: 80%;" /><span class="image-caption">image-20250421172529810</span></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numberOfArrays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] differences, <span class="hljs-type">int</span> lower, <span class="hljs-type">int</span> upper)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxWave</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">minWave</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; differences.length; i++) &#123;<br>            cur = cur + differences[i];<br>            maxWave = Math.max(maxWave, cur);<br>            minWave = Math.min(minWave, cur);<br>            <span class="hljs-keyword">if</span> (maxWave - minWave &gt; upper - lower) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> upper - lower + <span class="hljs-number">1</span>; <span class="hljs-comment">// 最好的情况</span><br>        <span class="hljs-keyword">return</span> ans - (maxWave - minWave); <span class="hljs-comment">// 最好的情况减去最大波动大小</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="子串"><a href="#子串" class="headerlink" title="子串"></a>子串</h1><h2 id="和为-K-的子数组"><a href="#和为-K-的子数组" class="headerlink" title="和为 K 的子数组"></a>和为 K 的子数组</h2><p>2 * 10^4 O(n^2) 或者 O(n)</p>
<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你统计并返回 <em>该数组中和为 <code>k</code> 的子数组的个数</em> 。</p>
<p>子数组是数组中元素的连续非空序列。</p>
<h3 id="前缀和-1"><a href="#前缀和-1" class="headerlink" title="前缀和"></a>前缀和</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">subarraySum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, n = nums.length, right = n - <span class="hljs-number">1</span>, ans = <span class="hljs-number">0</span>;;<br>        <span class="hljs-type">int</span>[] sum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        sum[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            sum[i] = sum[i - <span class="hljs-number">1</span>] + nums[i];<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (sum[j] - sum[i] == k) &#123; <span class="hljs-comment">// 这种写法无法计算前 n 个的和</span><br>                    ans++;<br>                &#125;<br>            &#125;<br>            <br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123; <span class="hljs-comment">// 补上</span><br>            <span class="hljs-keyword">if</span> (sum[i] == k) &#123;<br>                ans++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="优化前缀和中的-O-n-2"><a href="#优化前缀和中的-O-n-2" class="headerlink" title="优化前缀和中的 O(n^2)"></a>优化前缀和中的 O(n^2)</h2><p>用 “两数之和” 的思路来优化掉枚举所有前缀和的过程，用 HashMap 直接找到想要的前缀和。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">subarraySum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, n = nums.length, right = n - <span class="hljs-number">1</span>, ans = <span class="hljs-number">0</span>;;<br>        <span class="hljs-type">int</span>[] sum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        sum[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            sum[i] = sum[i - <span class="hljs-number">1</span>] + nums[i];<br>        &#125;<br>        <span class="hljs-comment">// 方法一：暴力前缀和 </span><br><br>        <span class="hljs-comment">// for (int i = 0; i &lt; n; i++) &#123;</span><br>        <span class="hljs-comment">//     for (int j = i + 1; j &lt; n; j++) &#123;</span><br>        <span class="hljs-comment">//         if (sum[j] - sum[i] == k) &#123; // 这种写法无法计算前 n 个的和</span><br>        <span class="hljs-comment">//             ans++;</span><br>        <span class="hljs-comment">//         &#125;</span><br>        <span class="hljs-comment">//     &#125;</span><br>        <span class="hljs-comment">// &#125;</span><br><br>        <span class="hljs-comment">// 方法一的实质是求两数之差为固定值的数有多少</span><br>        <span class="hljs-comment">// sum[j] - sum[i] = k</span><br>        <span class="hljs-comment">// 用 &quot;两数之和&quot; 的方法用哈希表进行优化 a + b = target -&gt; a = target - b</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> k + sum[i];<br>            <span class="hljs-keyword">if</span> (map.containsKey(sum[i])) &#123; <span class="hljs-comment">// 如果需要的正好有</span><br>                ans += map.get(sum[i]);<br>            &#125;<br>            map.put(num, map.getOrDefault(num, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>); <span class="hljs-comment">// 需要 k + sum[i]</span><br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123; <span class="hljs-comment">// 补上</span><br>            <span class="hljs-keyword">if</span> (sum[i] == k) &#123;<br>                ans++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="滑动窗口最大值"><a href="#滑动窗口最大值" class="headerlink" title="滑动窗口最大值"></a>滑动窗口最大值</h2><p>10^5 O(n) 可以做</p>
<p>给你一个整数数组 <code>nums</code>，有一个大小为 <code>k</code> 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <code>k</code> 个数字。滑动窗口每次只向右移动一位。</p>
<p>返回 <em>滑动窗口中的最大值</em> 。</p>
<p>像前缀和一样，维护区间的最大值呢？</p>
<h3 id="ST-表"><a href="#ST-表" class="headerlink" title="ST 表"></a>ST 表</h3><p>复杂度为 O(nlogn)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] maxSlidingWindow(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length, l = <span class="hljs-number">0</span>, logN = (<span class="hljs-type">int</span>)(Math.log(n) / Math.log(<span class="hljs-number">2</span>)) + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n - k + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> f[][] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>][logN];<br>        <span class="hljs-type">int</span>[] logn = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">5</span>];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            f[i][<span class="hljs-number">0</span>] = nums[i - <span class="hljs-number">1</span>];<br>        &#125;<br><br>        <span class="hljs-comment">// pre</span><br>        logn[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>        logn[<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>; i &lt; n; i++) &#123;<br>            logn[i] = logn[i / <span class="hljs-number">2</span>] + <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= logN; j++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i + (<span class="hljs-number">1</span> &lt;&lt; j) - <span class="hljs-number">1</span> &lt;= n; i++)<br>                f[i][j] = Math.max(f[i][j - <span class="hljs-number">1</span>], f[i + (<span class="hljs-number">1</span> &lt;&lt; (j - <span class="hljs-number">1</span>))][j - <span class="hljs-number">1</span>]);  <span class="hljs-comment">// ST表具体实现</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n - k + <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> i, y = Math.min(n, i + k - <span class="hljs-number">1</span>);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> logn[y - x + <span class="hljs-number">1</span>];<br>            result[i-<span class="hljs-number">1</span>] = Math.max(f[x][s], f[y - (<span class="hljs-number">1</span> &lt;&lt; s) + <span class="hljs-number">1</span>][s]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><p>O(nlogn)</p>
<p>这里的思路是用一个堆来维护最大值，同时在堆中记录下最大值的下标，当左指针移动时，要删掉那些失效的最大值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] maxSlidingWindow(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>        PriorityQueue&lt;Map.Entry&lt;Integer, Integer&gt;&gt; pq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; b.getKey() - a.getKey());<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length, l = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> ret[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n - k + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; r &lt; n; r++) &#123;<br>            pq.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.util.AbstractMap.SimpleEntry&lt;&gt;(nums[r], r));<br>            <span class="hljs-keyword">if</span> (r - l + <span class="hljs-number">1</span> == k) &#123;<br>                <span class="hljs-keyword">while</span> (pq.peek().getValue() &lt; l) pq.poll();<br>                ret[r - k + <span class="hljs-number">1</span>] = pq.peek().getKey();<br>                l++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h3><p>O(n)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] maxSlidingWindow(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length, l = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n - k + <span class="hljs-number">1</span>];<br>        Deque&lt;Integer&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;Integer&gt;(); <span class="hljs-comment">// 递增存储下标</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; r &lt; n; r++) &#123;<br>            <span class="hljs-keyword">while</span> (!deque.isEmpty() &amp;&amp; nums[r] &gt; nums[deque.peekLast()]) &#123; <span class="hljs-comment">// 放进去的是保持下标递增的情况下值最大的</span><br>                deque.pollLast();<br>            &#125;<br>            deque.offerLast(r);<br>            <span class="hljs-keyword">if</span> (r - l + <span class="hljs-number">1</span> == k) &#123;<br>                ans[l] = nums[deque.peekFirst()];<br>                <span class="hljs-keyword">while</span> (!deque.isEmpty() &amp;&amp; deque.peekFirst() &lt;= l) &#123; <span class="hljs-comment">// 淘汰掉滑动窗口以外的</span><br>                    deque.pollFirst();<br>                &#125;<br>                l++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="分块-前后缀数组"><a href="#分块-前后缀数组" class="headerlink" title="分块 + 前后缀数组"></a>分块 + 前后缀数组</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] maxSlidingWindow(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums;<br>        <span class="hljs-type">int</span>[] prefixMax = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n]; <span class="hljs-comment">// 以 i 结尾的前缀最大值，也就是查询的左边</span><br>        <span class="hljs-type">int</span>[] suffixMax = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n]; <span class="hljs-comment">// 以 i 开头的后缀最大值，也就是查询的右边</span><br>        <span class="hljs-comment">// [ a, b, c ] [ d, e, f ]</span><br>        <span class="hljs-comment">// 按 k 分块，如果是边界，那么需要第一个的后缀最大值和第二个的前缀最大值拼起来</span><br>        <span class="hljs-comment">// 如果不是边界，那么直接取后缀最大值就好</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i % k == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 边界</span><br>                prefixMax[i] = nums[i];<br><br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 在块中间</span><br>                prefixMax[i] = Math.max(prefixMax[i - <span class="hljs-number">1</span>], nums[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">if</span> ((i + <span class="hljs-number">1</span>) % k == <span class="hljs-number">0</span> || i == n - <span class="hljs-number">1</span>) &#123;<br>                suffixMax[i] = nums[i];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                suffixMax[i] = Math.max(suffixMax[i + <span class="hljs-number">1</span>], nums[i]);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n - k + <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// [ a, b, c ] [ d, e, f ]</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; n - k + <span class="hljs-number">1</span>; i++) &#123; <span class="hljs-comment">// 滑动窗口开始位置</span><br>            <span class="hljs-keyword">if</span> (i % k == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 边界</span><br>                ans[i] = prefixMax[i + k - <span class="hljs-number">1</span>];<br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// [ a, b, c ] [ d, e, f ]</span><br>                     <span class="hljs-comment">// b 为滑动窗口开始的时候，元素为 b, c, d，最大值为 max([b, c], [d])</span><br>                     <span class="hljs-comment">// -&gt; max(suffixMax[1], prefixMax[3])</span><br>                ans[i] = Math.max(suffixMax[i], prefixMax[i + k - <span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="最小覆盖子串"><a href="#最小覆盖子串" class="headerlink" title="最小覆盖子串"></a>最小覆盖子串</h2><p>要点：</p>
<ul>
<li>滑动窗口走过所有的子串</li>
<li>用哈希表判断是否涵盖所有字符</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    Map&lt;Character, Integer&gt; tMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    Map&lt;Character, Integer&gt; windowMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">minWindow</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        <span class="hljs-comment">// 滑动窗口，用哈希表判断是否涵盖所有字符</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ansL</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, ansR = -<span class="hljs-number">1</span>, ansLen = Integer.MAX_VALUE;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : t.toCharArray()) &#123;<br>            tMap.put(ch, tMap.getOrDefault(ch, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; r &lt; n; r++) &#123;<br>            windowMap.put(s.charAt(r), windowMap.getOrDefault(s.charAt(r), <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">while</span> (l &lt;= r &amp;&amp; check()) &#123;<br>                <span class="hljs-keyword">if</span> (r - l + <span class="hljs-number">1</span> &lt; ansLen) &#123;<br>                    ansL = l;<br>                    ansR = r;<br>                    ansLen = r - l + <span class="hljs-number">1</span>;<br>                &#125;<br>                windowMap.put(s.charAt(l), windowMap.getOrDefault(s.charAt(l), <span class="hljs-number">1</span>) - <span class="hljs-number">1</span>);<br>                l++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ansR == -<span class="hljs-number">1</span> ? <span class="hljs-string">&quot;&quot;</span> : s.substring(ansL, ansR + <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;Character, Integer&gt; entry : tMap.entrySet()) &#123;<br>            <span class="hljs-keyword">if</span> (windowMap.getOrDefault(entry.getKey(), <span class="hljs-number">0</span>) &lt; entry.getValue()) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="双指针-3"><a href="#双指针-3" class="headerlink" title="双指针"></a>双指针</h1><p><strong>前后指针：</strong>经典的一个 pre 指针，一个 cur 指针：可以解决反转链表、交换节点等问题。<br><strong>快慢指针：</strong>还有一个 fast 指针，一个 slow 指针：可以解决删除第 n 个元素的问题。</p>
<h2 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19.删除链表的倒数第 N 个结点"></a>19.删除链表的倒数第 N 个结点</h2><p>两个间隔 n 个节点的指针，快指针到末尾的时候，慢指针就是倒数第 n 个节点。</p>
<h2 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142.环形链表 II"></a>142.环形链表 II</h2><p>判断链表是否有环，如果有返回入环的第一个节点</p>
<p>根据题意，任意时刻，fast 指针走过的距离都为 slow 指针的 2 倍。因此，我们有</p>
<p>a+(n+1)b+nc=2(a+b)⟹a=c+(n−1)(b+c)<br>有了 a=c+(n−1)(b+c) 的等量关系，我们会发现：从相遇点到入环点的距离加上 n−1 圈的环长，恰好等于从链表头部到入环点的距离。</p>
<p>因此，当发现 slow 与 fast 相遇时，我们再额外使用一个指针 ptr。起始，它指向链表头部；随后，它和 slow 每次向后移动一个位置。最终，它们会在入环点相遇。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123;</span><br><span class="hljs-comment"> *         val = x;</span><br><span class="hljs-comment"> *         next = null;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">detectCycle</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span> (slow != <span class="hljs-literal">null</span> &amp;&amp; fast != <span class="hljs-literal">null</span> &amp;&amp; slow.next != <span class="hljs-literal">null</span> &amp;&amp; fast.next != <span class="hljs-literal">null</span> &amp;&amp; fast.next.next != <span class="hljs-literal">null</span>) &#123;<br>            slow = slow.next;<br>            fast = fast.next.next;<br>            <span class="hljs-keyword">if</span> (slow == fast) &#123; <span class="hljs-comment">// 有环</span><br>                <span class="hljs-type">ListNode</span> <span class="hljs-variable">index1</span> <span class="hljs-operator">=</span> fast;<br>                <span class="hljs-type">ListNode</span> <span class="hljs-variable">index2</span> <span class="hljs-operator">=</span> head;<br>                <span class="hljs-keyword">while</span> (index1 != index2) &#123;<br>                    index1 = index1.next;<br>                    index2 = index2.next;<br>                &#125;<br>                <span class="hljs-keyword">return</span> index1;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><h2 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h2><p>10^4 O(n)</p>
<p>一个哈希表</p>
<h2 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h2><p>3000</p>
<p>O(n^2)</p>
<p>排序+双指针</p>
<h2 id="四数之和"><a href="#四数之和" class="headerlink" title="四数之和"></a>四数之和</h2><p>排序+双指针</p>
<p>注意溢出</p>
<h2 id="四数相加"><a href="#四数相加" class="headerlink" title="四数相加"></a>四数相加</h2><p>与上一题不同在于有 4 个数组，4 个数组等长度，上一题每个区间长度不同</p>
<p>哈希表 + 哈希表</p>
<h2 id="字母异位词分组"><a href="#字母异位词分组" class="headerlink" title="字母异位词分组"></a>字母异位词分组</h2><p>10^4 O(n) 或 O(nlogn)</p>
<p>主要考虑异位词表示为相同的 map key，这样就可以将异位词聚集在一起。</p>
<h2 id="最长连续序列"><a href="#最长连续序列" class="headerlink" title="最长连续序列"></a>最长连续序列</h2><p>10^5 O(n)</p>
<p>未排序的数组，O(n) 找到数字连续的最长序列，不要求在原数组中连续。</p>
<p>排序做法为 O(nlogn)</p>
<p>key：考虑某一个数是不是连续序列的第一个数字，如果是则继续往下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : set) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (set.contains(num + i)) &#123;<br>        i++;<br>        longest = Math.max(longest, i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这种写法最坏会变成 O(n^2)，需要思考如何跳过重复情况。如果再开一个 TreeSet 来定位下一个数字是 O(logn)，应该可以。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestConsecutive</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        TreeSet&lt;Integer&gt; treeSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;();<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x3f3f3f3f</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            set.add(nums[i]);<br>            treeSet.add(nums[i]);<br>            next = Math.min(next, nums[i]);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">longest</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (next != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (set.contains(next)) &#123;<br>                next = next + <span class="hljs-number">1</span>;<br>                longest = Math.max(longest, i);<br>                i++;<br>            &#125;<br>            next = treeSet.higher(next); <span class="hljs-comment">// 定位下一个数字</span><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> longest;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>还有一种 O(1) 定位下一个数字的方法：</p>
<p>如果这个数字为 x，那么不存在 x-1 的话，这个数字一定是连续序列的第一个数字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestConsecutive</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            set.add(nums[i]);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">longest</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : set) &#123;<br>            <span class="hljs-keyword">if</span> (set.contains(num - <span class="hljs-number">1</span>)) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (set.contains(num + i)) &#123;<br>                i++;<br>                longest = Math.max(longest, i);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> longest;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="使数组的值全部为-K-的最少操作次数"><a href="#使数组的值全部为-K-的最少操作次数" class="headerlink" title="使数组的值全部为 K 的最少操作次数"></a>使数组的值全部为 K 的最少操作次数</h2><blockquote>
<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> 。</p>
<p>如果一个数组中所有 <strong>严格大于</strong> <code>h</code> 的整数值都 <strong>相等</strong> ，那么我们称整数 <code>h</code> 是 <strong>合法的</strong> 。</p>
<p>比方说，如果 <code>nums = [10, 8, 10, 8]</code> ，那么 <code>h = 9</code> 是一个 <strong>合法</strong> 整数，因为所有满足 <code>nums[i] &gt; 9</code> 的数都等于 10 ，但是 5 不是 <strong>合法</strong> 整数。</p>
<p>你可以对 <code>nums</code> 执行以下操作：</p>
<ul>
<li>选择一个整数 <code>h</code> ，它对于 <strong>当前</strong> <code>nums</code> 中的值是合法的。</li>
<li>对于每个下标 <code>i</code> ，如果它满足 <code>nums[i] &gt; h</code> ，那么将 <code>nums[i]</code> 变为 <code>h</code> 。</li>
</ul>
<p>你的目标是将 <code>nums</code> 中的所有元素都变为 <code>k</code> ，请你返回 <strong>最少</strong> 操作次数。如果无法将所有元素都变 <code>k</code> ，那么返回 -1 。</p>
</blockquote>
<p>其实就是把大的数字变小，需要变几次。</p>
<p>我的做法：用 SortedSet 统计大于 k 的有多少，以及是否有小于 k 的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 也就是说可以把大的变小</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minOperations</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        SortedSet&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            set.add(num);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (set.first() &lt; k) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (set.first() == k) <span class="hljs-keyword">return</span> set.size() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> set.size();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>官解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minOperations</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        Set&lt;Integer&gt; st = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : nums) &#123;<br>            <span class="hljs-keyword">if</span> (x &lt; k) &#123;<br>                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x &gt; k) &#123;<br>                st.add(x);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> st.size();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="统计坏数对的数目"><a href="#统计坏数对的数目" class="headerlink" title="统计坏数对的数目"></a>统计坏数对的数目</h2><p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 。如果 <code>i &lt; j</code> 且 <code>j - i != nums[j] - nums[i]</code> ，那么我们称 <code>(i, j)</code> 是一个 <strong>坏数对</strong> 。</p>
<p>请你返回 <code>nums</code> 中 <strong>坏数对</strong> 的总数目。</p>
<p>正难则反，考虑坏数对的个数=总数对-好数对。</p>
<p>好数对：<code>j - i == nums[j] - nums[i]</code> 得到 <code>j - nums[j] = nums[i] - i</code></p>
<p>于是有：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">countBadPairs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> (<span class="hljs-type">long</span>)n * (n - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>        Map&lt;Long, Long&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> nums[i] - i;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> map.getOrDefault(x, <span class="hljs-number">0L</span>);<br>            ans -= c;<br>            map.put(x, c + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="KMP-算法"><a href="#KMP-算法" class="headerlink" title="KMP 算法"></a>KMP 算法</h2><p>next 数组：<strong>是一个前缀表，前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。</strong></p>
<p>那么什么是前缀表：<strong>记录下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。</strong></p>
<p><strong>下标5之前这部分的字符串（也就是字符串aabaa）的最长相等的前缀 和 后缀字符串是 子字符串aa ，因为找到了最长相等的前缀和后缀，匹配失败的位置是后缀子串的后面，那么我们找到与其相同的前缀的后面重新匹配就可以了。</strong></p>
<h2 id="反转字符串中的单词"><a href="#反转字符串中的单词" class="headerlink" title="反转字符串中的单词"></a>反转字符串中的单词</h2><p>方法一：split 之后拼接。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-string">&quot;a good   example&quot;</span>.split() <span class="hljs-comment">// [a, good, , , example]，分割后存在 &quot;&quot;</span><br></code></pre></td></tr></table></figure>
<p>方法二：反转整个字符串之后，再反转单个字符串。</p>
<h2 id="最长公共子串"><a href="#最长公共子串" class="headerlink" title="最长公共子串"></a>最长公共子串</h2><p>状态转移方程如下，dp[i][j] 表示字符串 x 以 i 结尾，字符串 y 以 j 结尾的最长公共子串，这样就有了：</p>
<script type="math/tex; mode=display">
d p[i][j]=\left\{\begin{array}{l}
d p[i-1][j-1]+1, \text { 当且仅当 } x[i]=y[j] \\
0, \text { 当 } x[i] \ne y[j]
\end{array}\right.</script><p>按照上面方程实现的算法时间复杂度为 $O(n^2)$，空间复杂度为 $O(n^2)$。</p>
<p><img  src="../leetcode/d6f0b0e17ed6e13f5c042d172b1ddca782cb6aba589f5fcfea8944831614502f-image.png"  ><span class="image-caption">image.png</span></p>
<p>注意到，更新 $dp[i][j]$ 只需要上一列，即 $dp[i-1]$ 列，所以可以将空间复杂度降低为 $O(n)$，但是需要注意因为使用的是相同的数组列，所以字符串不相等时需要设置 $dp[j] = 0$，同时要注意从后向前更新数组，因为如果从前向后更新，那么当前的 $dp[j]$ 使用的是当前列刚刚更新过的数据，而我们需要的是上一列的数据，所以可以从后向前更新数据避免这个问题。</p>
<p>rust 代码如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">dp</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">0</span>; s2.<span class="hljs-title function_ invoke__">len</span>()];<br><span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..s1.<span class="hljs-title function_ invoke__">len</span>() &#123;<br>    <span class="hljs-comment">// 逆序迭代是因为更新a[i][j]需要a[i-1][j-1]</span><br>    <span class="hljs-comment">// 现在是一个数组，所以 a[j] 是原来的 a[i][j]，而我们需要的是 a[i-1][j]</span><br>    <span class="hljs-comment">// 所以从后向前迭代，a[j] 是原来的 a[i-1][j]</span><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">j</span> <span class="hljs-keyword">in</span> (<span class="hljs-number">0</span>..s2.<span class="hljs-title function_ invoke__">len</span>()).<span class="hljs-title function_ invoke__">s2</span>() &#123;<br>        <span class="hljs-keyword">if</span> s[i] == s2[j] &#123;<br>            <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> || j == <span class="hljs-number">0</span> &#123;<br>                dp[j] = <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[j] = dp[j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> dp[j] &gt; max_len &#123;<br>                <span class="hljs-keyword">let</span> <span class="hljs-variable">before_s2</span> = s2.<span class="hljs-title function_ invoke__">len</span>() - <span class="hljs-number">1</span> - j;<br>                <span class="hljs-keyword">if</span> before_s2 + dp[j] - <span class="hljs-number">1</span> == i &#123;<br>                    max_len = dp[j];<br>                    max_end = i;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 与之前不同，之前使用的是不同的列，所以不需要置0</span><br>            dp[j] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h2><h3 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h3><p>将字符串倒置之后求最长公共子串（状态转移方程与最长公共子串相同），并判断是否为回文子串，这里回文子串「由倒置字符串推出的原字符串末尾下标」与「i」应该相等。</p>
<p>代码中 <code>longest_palindrome1</code> 的求最长公共子串空间复杂度为 $O(n^2)$，<code>longest_palindrome2</code> 的求最长公共子串空间复杂度为 $O(n)$。</p>
<p>代码如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Solution</span>;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">longest_palindrome1</span>(s: <span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123;<br>        <span class="hljs-keyword">if</span> s.<span class="hljs-title function_ invoke__">len</span>() &lt;= <span class="hljs-number">1</span> &#123;<br>            <span class="hljs-keyword">return</span> s;<br>        &#125;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">rev</span>: <span class="hljs-type">String</span> = s.<span class="hljs-title function_ invoke__">chars</span>().<span class="hljs-title function_ invoke__">rev</span>().<span class="hljs-title function_ invoke__">collect</span>();<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">rev</span> = rev.<span class="hljs-title function_ invoke__">as_bytes</span>();<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = s.<span class="hljs-title function_ invoke__">as_bytes</span>();<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">dp</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-built_in">vec!</span>[<span class="hljs-number">0</span>; rev.<span class="hljs-title function_ invoke__">len</span>()]; s.<span class="hljs-title function_ invoke__">len</span>()];<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">max_len</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">max_end</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..s.<span class="hljs-title function_ invoke__">len</span>() &#123;<br>            <span class="hljs-keyword">for</span> <span class="hljs-variable">j</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..rev.<span class="hljs-title function_ invoke__">len</span>() &#123;<br>                <span class="hljs-keyword">if</span> s[i] == rev[j] &#123;<br>                    <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> || j == <span class="hljs-number">0</span> &#123;<br>                        dp[i][j] = <span class="hljs-number">1</span>;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span> dp[i][j] &gt; max_len &#123;<br>                    <span class="hljs-comment">// 如果是回文串，那么「由倒置字符串推出的原字符串末尾下标」与「i」应该相等</span><br>                    <span class="hljs-comment">// 其中，倒置字符串的 rev.len() - 1 - j，也就是倒置之前的开始下标，减一是因为长度比下标多一</span><br>                    <span class="hljs-comment">// 再加上 dp[i][j] - 1，就是原字符串的末尾下标。abc，a的下标为0，长度为3，0+3为3，但是最大下标为2，所以需要减一</span><br>                    <span class="hljs-keyword">let</span> <span class="hljs-variable">before_rev</span> = rev.<span class="hljs-title function_ invoke__">len</span>() - <span class="hljs-number">1</span> - j;<br>                    <span class="hljs-keyword">if</span> before_rev + dp[i][j] - <span class="hljs-number">1</span> == i &#123;<br>                        max_len = dp[i][j];<br>                        max_end = i;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        std::<span class="hljs-type">str</span>::<span class="hljs-title function_ invoke__">from_utf8</span>(&amp;s[max_end + <span class="hljs-number">1</span> - max_len..max_end + <span class="hljs-number">1</span>])<br>            .<span class="hljs-title function_ invoke__">unwrap</span>()<br>            .<span class="hljs-title function_ invoke__">to_string</span>()<br>    &#125;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">longest_palindrome2</span>(s: <span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123;<br>        <span class="hljs-keyword">if</span> s.<span class="hljs-title function_ invoke__">len</span>() &lt; <span class="hljs-number">1</span> &#123;<br>            <span class="hljs-keyword">return</span> s;<br>        &#125;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">rev</span>: <span class="hljs-type">String</span> = s.<span class="hljs-title function_ invoke__">chars</span>().<span class="hljs-title function_ invoke__">rev</span>().<span class="hljs-title function_ invoke__">collect</span>();<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = s.<span class="hljs-title function_ invoke__">as_bytes</span>();<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">rev</span> = rev.<span class="hljs-title function_ invoke__">as_bytes</span>();<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">max_len</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">max_end</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">dp</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">0</span>; rev.<span class="hljs-title function_ invoke__">len</span>()];<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..s.<span class="hljs-title function_ invoke__">len</span>() &#123;<br>            <span class="hljs-comment">// 逆序迭代是因为更新a[i][j]需要a[i-1][j-1]</span><br>            <span class="hljs-comment">// 现在是一个数组，所以 a[j] 是原来的 a[i][j]，而我们需要的是 a[i-1][j]</span><br>            <span class="hljs-comment">// 所以从后向前迭代，a[j] 是原来的 a[i-1][j]</span><br>            <span class="hljs-keyword">for</span> <span class="hljs-variable">j</span> <span class="hljs-keyword">in</span> (<span class="hljs-number">0</span>..rev.<span class="hljs-title function_ invoke__">len</span>()).<span class="hljs-title function_ invoke__">rev</span>() &#123;<br>                <span class="hljs-keyword">if</span> s[i] == rev[j] &#123;<br>                    <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> || j == <span class="hljs-number">0</span> &#123;<br>                        dp[j] = <span class="hljs-number">1</span>;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        dp[j] = dp[j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> dp[j] &gt; max_len &#123;<br>                        <span class="hljs-keyword">let</span> <span class="hljs-variable">before_rev</span> = rev.<span class="hljs-title function_ invoke__">len</span>() - <span class="hljs-number">1</span> - j;<br>                        <span class="hljs-keyword">if</span> before_rev + dp[j] - <span class="hljs-number">1</span> == i &#123;<br>                            max_len = dp[j];<br>                            max_end = i;<br>                        &#125;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 与之前不同，之前使用的是不同的列，所以不需要置0</span><br>                    dp[j] = <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        std::<span class="hljs-type">str</span>::<span class="hljs-title function_ invoke__">from_utf8</span>(&amp;s[max_end + <span class="hljs-number">1</span> - max_len..max_end + <span class="hljs-number">1</span>])<br>            .<span class="hljs-title function_ invoke__">unwrap</span>()<br>            .<span class="hljs-title function_ invoke__">to_string</span>()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="中心拓展算法"><a href="#中心拓展算法" class="headerlink" title="中心拓展算法"></a>中心拓展算法</h3><p>为了避免在之后的叙述中出现歧义，这里我们指出什么是“朴素算法”。</p>
<p>该算法通过下述方式工作：对每个中心位置 $i$ 在比较一对对应字符后，只要可能，该算法便尝试将答案加 $1$。</p>
<p>该算法是比较慢的：它只能在 $O(n^2)$ 的时间内计算答案。</p>
<p>该算法的实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// C++ Version</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">d1</span><span class="hljs-params">(n)</span>, <span class="hljs-title">d2</span><span class="hljs-params">(n)</span></span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>  d1[i] = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">0</span> &lt;= i - d1[i] &amp;&amp; i + d1[i] &lt; n &amp;&amp; s[i - d1[i]] == s[i + d1[i]]) &#123;<br>    d1[i]++;<br>  &#125;<br><br>  d2[i] = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">0</span> &lt;= i - d2[i] - <span class="hljs-number">1</span> &amp;&amp; i + d2[i] &lt; n &amp;&amp;<br>         s[i - d2[i] - <span class="hljs-number">1</span>] == s[i + d2[i]]) &#123;<br>    d2[i]++;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Python Version</span><br>d1 = [<span class="hljs-number">0</span>] * n<br>d2 = [<span class="hljs-number">0</span>] * n<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, n):<br>    d1[i] = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-number">0</span> &lt;= i - d1[i] <span class="hljs-keyword">and</span> i + d1[i] &lt; n <span class="hljs-keyword">and</span> s[i - d1[i]] == s[i + d1[i]]:<br>        d1[i] += <span class="hljs-number">1</span><br><br>    d2[i] = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-number">0</span> &lt;= i - d2[i] - <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> i + d2[i] &lt; n <span class="hljs-keyword">and</span> s[i - d2[i] - <span class="hljs-number">1</span>] == s[i + d2[i]]:<br>        d2[i] += <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>
<h3 id="Manacher-算法12"><a href="#Manacher-算法12" class="headerlink" title="Manacher 算法12"></a>Manacher 算法<sup><a href="#fn_1" id="reffn_1">1</a></sup><sup><a href="#fn_2" id="reffn_2">2</a></sup></h3><p>Manacher 算法是对中心拓展算法的优化，为了快速计算，我们维护已找到的最靠右的子回文串的 <strong>边界 $(l, r)$</strong>（即具有最大 $r$ 值的回文串，其中 $l$ 和 $r$ 分别为该回文串左右边界的位置）。初始时，我们置 $l = 0$ 和 $r = -1$（<em>-1</em>需区别于倒序索引位置，这里可为任意负数，仅为了循环初始时方便）。</p>
<p>现在假设我们要对下一个 $i$ 计算 $P[i]$，而之前所有 $P[]$ 中的值已计算完毕。我们将通过下列方式计算：</p>
<ul>
<li><p>如果 $i$ 位于当前子回文串之外，即 $i &gt; r$，那么我们调用朴素算法。</p>
<p>因此我们将连续地增加 $d_1[i]$，同时在每一步中检查当前的子串 $[i - P[i] \dots i +  P[i]]$（$P[i]$ 表示半径长度，下同）是否为一个回文串。如果我们找到了第一处对应字符不同，又或者碰到了 $s$  的边界，则算法停止。在两种情况下我们均已计算完 $P[i]$。此后，仍需记得更新 $(l, r)$。</p>
</li>
<li><p>现在考虑 $i \le r$ 的情况。我们将尝试从已计算过的 $P[]$ 的值中获取一些信息。首先在子回文串  $(l, r)$ 中反转位置 $i$，即我们得到 $j = l + (r - i)$。现在来考察值 $P[j]$。因为位置 $j$ 同位置  $i$ 对称，我们 <strong>几乎总是</strong> 可以置 $P[i] = P[j]$。</p>
<p>存在 <strong>棘手的情况</strong>，主要有以下：</p>
<ul>
<li><p>超出了 $r$</p>
<p><img  src="../leetcode/b0d52a5f30747e55ef09b3c7b7cfc23026e37040edc41f387263e8f8a0ba8f49-image.png"  ><span class="image-caption">图转自 LeetCode</span></p>
<p>当我们要求 $P [ i ]$ 的时候，$P [mirror] = 7$，而此时 $P [ i ]$ 并不等于 $7$，为什么呢，因为我们从 $i$ 开始往后数 $7$ 个，等于 $22$，已经超过了最右的 $r$，此时不能利用对称性了，但我们一定可以扩展到 $r$ 的，所以 $P [ i ]$ 至少等于 $r - i = 20 - 15 = 5$，会不会更大呢，我们只需要比较 $T [ r+1 ]$ 和 $T [ r+1 ]$ 关于 $i$ 的对称点就行了，就像中心扩展法一样一个个扩展。</p>
</li>
<li><p>$P[i]$ 遇到了原字符串的左边界</p>
<p><img  src="../leetcode/714e6f768e67304fb7162ecac3ae85fcf23ad82a21456e8ca55ac2c8cfd2609e-image.png"  ><span class="image-caption">image.png</span></p>
<p>此时$P [ i_{mirror} ] = 1$，但是 $P [ i ]$ 赋值成 1 是不正确的，出现这种情况的原因是 $P [ i_{mirror} ]$ 在扩展的时候首先是 “#” == “#”，之后遇到了 “^” 和另一个字符比较，也就是到了边界，才终止循环的。而 $P [ i ]$ 并没有遇到边界，所以我们可以继续通过中心扩展法一步一步向两边扩展就行了。</p>
</li>
<li><p>$i = r$</p>
<p>此时我们先把 P [ i ] 赋值为 0，然后通过中心扩展法一步一步扩展就行了。</p>
</li>
</ul>
<p>考虑 $r$ 的更新</p>
<p>就这样一步一步的求出每个 $P [ i ]$，当求出的 $P [ i ]$ 的右边界大于当前的 $r$ 时，我们就需要更新 $r$ 为当前的回文串了。</p>
</li>
</ul>
<h2 id="最长公共子序列（LCS）"><a href="#最长公共子序列（LCS）" class="headerlink" title="最长公共子序列（LCS）"></a>最长公共子序列（LCS）</h2><h3 id="动态规划-2"><a href="#动态规划-2" class="headerlink" title="动态规划"></a>动态规划</h3><p>状态转移方程如下：</p>
<script type="math/tex; mode=display">
d p[i][j]=\left\{\begin{array}{ll}
d p[i-1][j-1]+1, & t e x t_{1}[i-1]=t e x t_{2}[j-1] \\
\max (d p[i-1][j], d p[i][j-1]), & t e x t_{1}[i-1] \neq t e x t_{2}[j-1]
\end{array}\right.</script><p>LCS 对应的状态转移方程与最长公共子串不同之处在于：</p>
<ul>
<li>最长公共子串要求字符串连续，所以下一个状态只能由上一个对应的字符串得到。</li>
<li>LCS 不要求字符串连续，所以可以前后移动，就有了第二个式子。</li>
</ul>
<p>知道状态定义之后，我们开始写状态转移方程。</p>
<ul>
<li><p>当 $text_1[i - 1] = text_2[j - 1]$ 时，说明两个子字符串的最后一位相等，所以最长公共子序列又增加了 1，所以 $dp[i][j] = dp[i - 1][j - 1] + 1$；举个例子，比如对于 <code>ac</code> 和 <code>bc</code> 而言，他们的最长公共子序列的长度等于 <code>a</code> 和 <code>b</code> 的最长公共子序列长度 $0 + 1 = 1$。</p>
</li>
<li><p>当 $text_1[i - 1] \ne text_2[j - 1]$ 时，说明两个子字符串的最后一位不相等，那么此时的状态 $dp[i][j]$ 应该是 $dp[i - 1][j]$ 和 $dp[i][j - 1]$ 的最大值。举个例子，比如对于 <code>ace</code> 和 <code>bc</code> 而言，他们的最长公共子序列的长度等于</p>
<p> ① <code>ace</code> 和 <code>b</code> 的最长公共子序列长度 <code>0</code> 与</p>
<p>② <code>ac</code> 和 <code>bc</code> 的最长公共子序列长度 <code>1</code> 的最大值，即 <code>1</code>。</p>
</li>
</ul>
<p>代码如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Solution</span>;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">longest_common_subsequence</span>(text1: <span class="hljs-type">String</span>, text2: <span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">text1</span> = text1.<span class="hljs-title function_ invoke__">as_bytes</span>();<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">text2</span> = text2.<span class="hljs-title function_ invoke__">as_bytes</span>();<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">m</span> = text1.<span class="hljs-title function_ invoke__">len</span>();<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">n</span> = text2.<span class="hljs-title function_ invoke__">len</span>();<br>        <span class="hljs-comment">// dp[i][j] 代表 text1[0..i] 与 text2[0..j] 的最大子序列，注意不包括第 i 和第 j 个字符</span><br>        <span class="hljs-comment">// 同理，dp 数组要循环到 m 与 n 才结束</span><br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">dp</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-built_in">vec!</span>[<span class="hljs-number">0</span>; n + <span class="hljs-number">1</span>]; m + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..=m &#123;<br>            <span class="hljs-keyword">for</span> <span class="hljs-variable">j</span> <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..=n &#123;<br>                <span class="hljs-comment">// 这里要注意，比较的是第 i-1 与第 j-1 个字符</span><br>                <span class="hljs-keyword">if</span> text1[i - <span class="hljs-number">1</span>] == text2[j - <span class="hljs-number">1</span>] &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = std::cmp::<span class="hljs-title function_ invoke__">max</span>(dp[i][j - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][j]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="动态规划-3"><a href="#动态规划-3" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="动态规划总结"><a href="#动态规划总结" class="headerlink" title="动态规划总结"></a>动态规划总结</h2><p>基本步骤：</p>
<ol>
<li>确定dp数组（dp table）以及下标的含义</li>
<li>确定递推公式</li>
<li>dp数组如何初始化</li>
<li>确定遍历顺序</li>
<li>举例推导dp数组</li>
</ol>
<p>对于动态规划，可以先初始化一个 dp 数组，然后手写出 dp[0] dp[1] dp[2] dp[3] 等等。这一步可以帮助思考 dp 数组和确定递推公式。</p>
<h2 id="使用最小花费爬楼梯"><a href="#使用最小花费爬楼梯" class="headerlink" title="使用最小花费爬楼梯"></a>使用最小花费爬楼梯</h2><p>给你一个整数数组 <code>cost</code> ，其中 <code>cost[i]</code> 是从楼梯第 <code>i</code> 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。</p>
<p>你可以选择从下标为 <code>0</code> 或下标为 <code>1</code> 的台阶开始爬楼梯。</p>
<p>请你计算并返回达到楼梯顶部的最低花费。</p>
<p>要点：</p>
<ul>
<li>dp[i] 为到达第 n 层的最低花费</li>
<li>可以选择从下标为 <code>0</code> 或下标为 <code>1</code> 的台阶开始爬楼梯，dp[0] = 0，dp[1] = 0</li>
<li>第 i 层可以从 i - 1 和 i - 2 过来，从 i - 1 过来的花费是 cost[i - 1]，从 cost[i - 2] 过来的花费是 cost[i - 2]</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minCostClimbingStairs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] cost)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> cost.length;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>]; <span class="hljs-comment">// 到达第 n 层的最低花费</span><br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>            dp[i] = Math.min(dp[i - <span class="hljs-number">1</span>] + cost[i - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">2</span>] + cost[i - <span class="hljs-number">2</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="杨辉三角"><a href="#杨辉三角" class="headerlink" title="杨辉三角"></a>杨辉三角</h2><p>主要难点在处理边界情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">generate</span><span class="hljs-params">(<span class="hljs-type">int</span> numRows)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= numRows; i++) &#123;<br>            List&lt;Integer&gt; arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(i);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>                arr.add(<span class="hljs-number">0</span>);<br>            &#125;<br>            arr.set(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>            arr.set(i - <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>            List&lt;Integer&gt; lastArr;<br>            <span class="hljs-keyword">if</span> (ret.size() &gt;= <span class="hljs-number">2</span>) &#123;<br>                lastArr = ret.get(ret.size() - <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; i - <span class="hljs-number">1</span>; j++) &#123; <span class="hljs-comment">// 跳过第一个和最后一个</span><br>                    arr.set(j, lastArr.get(j-<span class="hljs-number">1</span>) + lastArr.get(j));<br>                &#125;<br>            &#125;<br>            ret.add(arr);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h2><p>要点在于对于某一个房子是否抢劫以及边界处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> Math.max(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">1</span>] = nums[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">2</span>] = Math.max(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>; i &lt;= n; i++) &#123;<br>            dp[i] = Math.max(dp[i - <span class="hljs-number">2</span>] + nums[i - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="最大子序和"><a href="#最大子序和" class="headerlink" title="最大子序和"></a>最大子序和</h2><p>要点在于当前数字结尾的最大子串的和只能来自于前一个，也就是上楼梯只能由前一个上过来，或者现在新开一个。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSubArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>]; <span class="hljs-comment">// 第 i 个数结尾的子数组最大值</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> -<span class="hljs-number">0x3f3f3f3f</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            dp[i] = Math.max(dp[i - <span class="hljs-number">1</span>] + nums[i - <span class="hljs-number">1</span>], nums[i - <span class="hljs-number">1</span>]);<br>            ans = Math.max(ans, dp[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="完全平方数"><a href="#完全平方数" class="headerlink" title="完全平方数"></a>完全平方数</h2><h3 id="动态规划-4"><a href="#动态规划-4" class="headerlink" title="动态规划"></a>动态规划</h3><p>要点是 dp[i] 表示结果为 i 的最少数量，然后转移的话，dp[i] 只能从 dp[i - 所有平方数] 来，于是写出状态转移方程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numSquares</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">5</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sqrtN</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)Math.sqrt(n) + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span>[] square = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[sqrtN];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; sqrtN; i++) &#123;<br>            square[i] = i * i;<br>        &#125;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br>        dp[<span class="hljs-number">3</span>] = <span class="hljs-number">3</span>;<br>        dp[<span class="hljs-number">4</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">5</span>] = <span class="hljs-number">2</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> <span class="hljs-number">999</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; sqrtN; j++) &#123;<br>                <span class="hljs-keyword">if</span> (i - square[j] &gt;= <span class="hljs-number">0</span>) &#123;<br>                    min = Math.min(dp[i - square[j]] + <span class="hljs-number">1</span>, min);<br>                &#125;<br>            &#125;<br>            dp[i] = min;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>优化一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numSquares</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> <span class="hljs-number">999</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j * j &lt;= i; j++) &#123;<br>                <span class="hljs-keyword">if</span> (i - j * j &gt;= <span class="hljs-number">0</span>) &#123;<br>                    min = Math.min(dp[i - j * j] + <span class="hljs-number">1</span>, min);<br>                &#125;<br>            &#125;<br>            dp[i] = min;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="四平方和定理"><a href="#四平方和定理" class="headerlink" title="四平方和定理"></a>四平方和定理</h3><p><img  src="/image-20250107155619501.png"  ><span class="image-caption">image-20250107155619501</span></p>
<h2 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a>零钱兑换</h2><p>这是一个完全背包问题，硬币可以重复使用。与爬楼梯类似。</p>
<p>$dp[i] = dp[i - coins[j]] + 1$。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> coinChange(<span class="hljs-built_in">int</span>[] coins, <span class="hljs-built_in">int</span> amount) &#123;<br>        <span class="hljs-keyword">if</span> (amount == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> n = coins.length;<br>        <span class="hljs-built_in">int</span>[] dp = new <span class="hljs-built_in">int</span>[Math.max(n, amount) + <span class="hljs-number">10</span>]; <span class="hljs-comment">// 可以凑成 n 所需的最少的硬币个数</span><br>        <span class="hljs-comment">// 与爬楼梯一样，dp[i] 可以从 dp[i - coins[j]] 过来</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (coins[i] &gt; amount) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            dp[coins[i]] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt;= amount; i++) &#123;<br>            <span class="hljs-keyword">if</span> (dp[i] == <span class="hljs-number">0</span>) &#123;<br>                dp[i] = <span class="hljs-number">0x3f3f3f3f</span>;<br>            &#125;<br>        &#125;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> max = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= amount; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (i - coins[j] &gt;= <span class="hljs-number">0</span>) &#123;<br>                    dp[i] = Math.min(dp[i - coins[j]] + <span class="hljs-number">1</span>, dp[i]);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp[amount] == <span class="hljs-number">0x3f3f3f3f</span> ? <span class="hljs-number">-1</span> : dp[amount];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="单词拆分"><a href="#单词拆分" class="headerlink" title="单词拆分"></a>单词拆分</h2><ul>
<li><code>1 &lt;= s.length &lt;= 300</code></li>
<li><code>1 &lt;= wordDict.length &lt;= 1000</code></li>
<li><code>1 &lt;= wordDict[i].length &lt;= 20</code></li>
</ul>
<h3 id="模拟-剪枝"><a href="#模拟-剪枝" class="headerlink" title="模拟 + 剪枝"></a>模拟 + 剪枝</h3><p>不断地尝试所有可能的拼接，看最后能否拼接出来，注意要剪枝，否则会超时。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">wordBreak</span><span class="hljs-params">(String s, List&lt;String&gt; wordDict)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> wordDict.size();<br>        Set&lt;String&gt; dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxLen</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x3f3f3f3f</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">word</span> <span class="hljs-operator">=</span> wordDict.get(i);<br>            <span class="hljs-keyword">if</span> (s.startsWith(word)) <span class="hljs-comment">// 剪枝</span><br>                dp.add(word);<br>            maxLen = Math.min(maxLen, word.length());<br>        &#125;<br><br><br>        <span class="hljs-keyword">while</span> (maxLen &lt; s.length()) &#123;<br>            Set&lt;String&gt; tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;(dp); <span class="hljs-comment">// 创建一个临时副本用于遍历</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">minLen</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x3f3f3f3f</span>;<br>            <span class="hljs-keyword">for</span> (String cur : tmp) &#123;<br>                <span class="hljs-keyword">if</span> (cur.length() &lt; maxLen) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>                    <span class="hljs-type">String</span> <span class="hljs-variable">newString</span> <span class="hljs-operator">=</span> cur + wordDict.get(i);<br>                    <span class="hljs-keyword">if</span> (s.startsWith(newString)) &#123; <span class="hljs-comment">// 剪枝</span><br>                        minLen = Math.min(newString.length(), minLen);<br>                        dp.add(newString);<br>                    &#125;<br>                &#125;<br>            &#125;<br>            maxLen = Math.max(maxLen, minLen);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp.contains(s);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>优化一下</p>
<h3 id="动态规划-5"><a href="#动态规划-5" class="headerlink" title="动态规划"></a>动态规划</h3><p><img  src="/image-20250107182951481.png"  ><span class="image-caption">image-20250107182951481</span></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">wordBreak</span><span class="hljs-params">(String s, List&lt;String&gt; wordDict)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> wordDict.size();<br>        Set&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;(wordDict);<br>        <span class="hljs-type">boolean</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[s.length() + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= s.length(); i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>                <span class="hljs-keyword">if</span> (dp[j] &amp;&amp; set.contains(s.substring(j, i))) &#123;<br>                    dp[i] = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[s.length()];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h2><p>要点在于 dp 为以第 i 个数字结尾的最长上升子序列长度，也就是 dp[i] 是 i 被选择的情况下的最长上升子序列长度。</p>
<p>这题要求的是子序列，而不是子数组，也就是可以跳过一些数字，所以动态转移方程就是对于 dp[i] 可以从任意的 dp[i - j] 跳过来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLIS</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span>  nums.length, max = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>]; <span class="hljs-comment">// 以第 i 个数字结尾的最长上升子序列长度</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            dp[i] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 如果选当前的 i，至少有 1 个长度</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; i; j++) &#123;<br>                <span class="hljs-keyword">if</span> (nums[i - <span class="hljs-number">1</span>] &gt; nums[j - <span class="hljs-number">1</span>]) &#123;<br>                    dp[i] = Math.max(dp[i], dp[j] + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>            max = Math.max(max, dp[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="乘积最大子数组"><a href="#乘积最大子数组" class="headerlink" title="乘积最大子数组"></a>乘积最大子数组</h2><p><code>dp_max[i]</code> 表示以第 <code>i</code> 个元素结尾的连续子数组的最大乘积。</p>
<p>对于每一个 dp[i] 来说，他会从前一个最大的 dp[i - 1] 过来，或者从最小的 dp[i - 1] 过来，或者在当前位置另起炉灶。与子序列不同，dp[i] 的子数组只能从 dp[i - 1] 过来，而不能从任意的 dp[i - j] 过来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProduct</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] dp_max = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-type">int</span>[] dp_min = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        dp_max[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        dp_min[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            dp_max[i] = Math.max(Math.max(dp_max[i-<span class="hljs-number">1</span>] * nums[i], dp_min[i-<span class="hljs-number">1</span>] * nums[i]), nums[i]);<br>            dp_min[i] = Math.min(Math.min(dp_max[i-<span class="hljs-number">1</span>] * nums[i], dp_min[i-<span class="hljs-number">1</span>] * nums[i]), nums[i]);<br>            ans = Math.max(ans, dp_max[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="分割等和子集"><a href="#分割等和子集" class="headerlink" title="分割等和子集"></a>分割等和子集</h2><p><code>1 &lt;= nums.length &lt;= 200</code>，<code>1 &lt;= nums[i] &lt;= 100</code> 数据范围暗示了是和数组中最大数有关的二维 dp</p>
<p>给你一个 <strong>只包含正整数</strong> 的 <strong>非空</strong> 数组 <code>nums</code> 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
<p>如何将该问题转换为具有最优子结构的问题是难点。</p>
<p>动态规划，时间复杂度与元素大小相关的。</p>
<p>这个问题可以转换为：给定一个只包含正整数的非空数组 nums[0]，判断是否可以从数组中选出一些数字，使得这些数字的和等于整个数组的元素和的一半。因此这个问题可以转换成「0−1 背包问题」。这道题与传统的「0−1 背包问题」的区别在于，传统的「0−1 背包问题」要求选取的物品的重量之和不能超过背包的总容量，这道题则要求选取的数字的和恰好等于整个数组的元素和的一半。类似于传统的「0−1 背包问题」，可以使用动态规划求解。</p>
<p>关键在于：<strong>将这个数组分割成两个子集 = 选出的数字的和是数组一半</strong></p>
<p>然后关键的转移方程为：</p>
<ol>
<li>和为 j 的数字可以由 j - nums[i]（如果存在的话） 得到</li>
<li>和为 j 的数字可以由 j （如果存在的话）得到</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canPartition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length, target = <span class="hljs-number">0</span>, max = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            target += nums[i];<br>            max = Math.max(max, nums[i]);<br>        &#125;<br>        <span class="hljs-keyword">if</span> ((target &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 奇数</span><br>        <span class="hljs-keyword">else</span> target /= <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (max &gt; target) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-type">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n][target + <span class="hljs-number">1</span>]; <span class="hljs-comment">// 0..i 的数字中是否存在方案使得和为 j</span><br>        <span class="hljs-comment">// 数字 nums[i] 所在的行都能使得和为 nums[i]</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>                dp[i][nums[j]] = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 0..i 中怎么选都能使得和为 0</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 和为 j 的数字可以由 j - nums[i]（如果存在的话） 得到</span><br>        <span class="hljs-comment">// 和为 j 的数字可以由 j （如果存在的话）得到</span><br>        <span class="hljs-comment">// 可以根据上面的内容对 dp 数组进行填表</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= target; j++) &#123;<br><br>                <span class="hljs-keyword">if</span> (j &gt;= nums[i]) &#123;<br><br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] | dp[i - <span class="hljs-number">1</span>][j - nums[i]];<br><br>                    <span class="hljs-comment">// 与上面的内容等价</span><br>                    <span class="hljs-comment">// if (dp[i - 1][j - nums[i]]) &#123;</span><br>                    <span class="hljs-comment">//     dp[i][j] = true;</span><br>                    <span class="hljs-comment">// &#125;</span><br>                    <span class="hljs-comment">// if (dp[i - 1][j]) &#123;</span><br>                    <span class="hljs-comment">//     dp[i][j] = true;</span><br>                    <span class="hljs-comment">// &#125;</span><br><br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br><br>                    <span class="hljs-comment">// 与上面的内容等价</span><br>                    <span class="hljs-keyword">if</span> (dp[i - <span class="hljs-number">1</span>][j]) &#123;<br>                        dp[i][j] = <span class="hljs-literal">true</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <br>        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>][target];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>然后又有这一行仅仅由上一行确定得到，于是有：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canPartition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length, target = <span class="hljs-number">0</span>, max = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            target += nums[i];<br>            max = Math.max(max, nums[i]);<br>        &#125;<br>        <span class="hljs-keyword">if</span> ((target &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 奇数</span><br>        <span class="hljs-keyword">else</span> target /= <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (max &gt; target) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-type">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n][target + <span class="hljs-number">1</span>]; <span class="hljs-comment">// 0..i 的数字中是否存在方案使得和为 j</span><br>        <span class="hljs-comment">// 数字 nums[i] 所在的行都能使得和为 nums[i]</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>                dp[i][nums[j]] = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 0..i 中怎么选都能使得和为 0</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 和为 j 的数字可以由 j - nums[i]（如果存在的话） 得到</span><br>        <span class="hljs-comment">// 和为 j 的数字可以由 j （如果存在的话）得到</span><br>        <span class="hljs-comment">// 可以根据上面的内容对 dp 数组进行填表</span><br>        <span class="hljs-comment">// for (int i = 1; i &lt; n; i++) &#123;</span><br>        <span class="hljs-comment">//     for (int j = 1; j &lt;= target; j++) &#123;</span><br><br>        <span class="hljs-comment">//         if (j &gt;= nums[i]) &#123;</span><br><br>        <span class="hljs-comment">//             dp[i][j] = dp[i - 1][j] | dp[i - 1][j - nums[i]];</span><br><br>        <span class="hljs-comment">//             // 与上面的内容等价</span><br>        <span class="hljs-comment">//             // if (dp[i - 1][j - nums[i]]) &#123;</span><br>        <span class="hljs-comment">//             //     dp[i][j] = true;</span><br>        <span class="hljs-comment">//             // &#125;</span><br>        <span class="hljs-comment">//             // if (dp[i - 1][j]) &#123;</span><br>        <span class="hljs-comment">//             //     dp[i][j] = true;</span><br>        <span class="hljs-comment">//             // &#125;</span><br><br>        <span class="hljs-comment">//         &#125; else &#123;</span><br>        <span class="hljs-comment">//             dp[i][j] = dp[i - 1][j];</span><br><br>        <span class="hljs-comment">//             // 与上面的内容等价</span><br>        <span class="hljs-comment">//             if (dp[i - 1][j]) &#123;</span><br>        <span class="hljs-comment">//                 dp[i][j] = true;</span><br>        <span class="hljs-comment">//             &#125;</span><br>        <span class="hljs-comment">//         &#125;</span><br>        <span class="hljs-comment">//     &#125;</span><br>        <span class="hljs-comment">// &#125;</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> nums[i];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= target; j++) &#123;<br>                <span class="hljs-keyword">if</span> (j &gt;= num) &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] | dp[i - <span class="hljs-number">1</span>][j - num];<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <br>        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>][target];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>优化空间：</strong></p>
<p>和零钱兑换的一个关系：</p>
<p>可以把nums看成是各种零钱组合，整数amount对应这里的target，也就是nums总和的一半。区别在于这里nums里面的值只能用一次。</p>
<p>所以外层遍历都是遍历零钱组合，而内层遍历在遍历amount的时候有一个差别，即分割等和子集是倒着遍历，而零钱是正着遍历。</p>
<p>这里为什么要<strong>倒着遍历就是因为这里的值是不能用两遍</strong>，而零钱问题中是可以用多遍的，所以从小到大遍历~~</p>
<p>另外一个只判断能否成功一个判断最小零钱只是输出上的差异了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canPartition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length, target = <span class="hljs-number">0</span>, max = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            target += nums[i];<br>            max = Math.max(max, nums[i]);<br>        &#125;<br>        <span class="hljs-keyword">if</span> ((target &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 奇数</span><br>        <span class="hljs-keyword">else</span> target /= <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (max &gt; target) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-type">boolean</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[target + <span class="hljs-number">1</span>]; <span class="hljs-comment">// 0..i 的数字中是否存在方案使得和为 j</span><br><br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123; <span class="hljs-comment">// 外层枚举数字</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> nums[i];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> target; j &gt;= num; j--) &#123;<br>                dp[j] |= dp[j - num];<br>                <span class="hljs-comment">// 等价于</span><br>                <span class="hljs-comment">// if (dp[j - num]) &#123;</span><br>                <span class="hljs-comment">//     dp[j] = true;</span><br>                <span class="hljs-comment">// &#125;</span><br>            &#125;<br>        &#125;<br><br>        <br>        <span class="hljs-keyword">return</span> dp[target];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="最长有效括号"><a href="#最长有效括号" class="headerlink" title="最长有效括号"></a>最长有效括号</h2><h3 id="动态规划-6"><a href="#动态规划-6" class="headerlink" title="动态规划"></a>动态规划</h3><p><code>0 &lt;= s.length &lt;= 3 * 10^4</code></p>
<p>给你一个只包含 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p>
<p>定义 dp[i] 表示以下标 <em>i</em> 字符结尾的最长有效括号的长度。</p>
<p>难点在于怎么思考状态转移方程。</p>
<p>想到如果是合法的括号，那么肯定是左右都有，那么是不是可以每次走两步</p>
<p><em>s</em>[<em>i</em>]=‘)’ 且 <em>s</em>[<em>i</em>−1]=‘(’，也就是字符串形如 “……()”，我们可以推出：dp[i]=dp[i−2]+2</p>
<p><strong>key：</strong> 两种有效的括号类型：（…）（…）（…），另一种为嵌套格式 （（…））</p>
<p>第一种可以 dp[i] = dp[i - 2] + 2，第二种则比较复杂。</p>
<p>考虑第一次遇到 … ））时，需要找到和右括号匹配的左括号，我们这里可以根据最优子结构得到 dp[i - 1] 代表了前一个右括号之前的有效括号，那么 i - dp[i - 1] - 1 的位置就是和当前右括号匹配的位置，如果这个位置是左括号，那么最长有效长度就可以 + 2，否则就不更新。</p>
<p><img  src="./6e07ddaac3b703cba03a9ea8438caf1407c4834b7b1e4c8ec648c34f2833a3b9-截屏2020-04-17下午4.26.34.png"  ><span class="image-caption">截屏2020-04-17下午4.26.34.png</span></p>
<p>同时还要考虑 …((…)) 的情况，也就是加上 dp[i - dp[i - 1] - 2]</p>
<p>于是有以下内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestValidParentheses</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n]; <span class="hljs-comment">// 以下标 i 结尾的最长子串长度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (s.charAt(i - <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;(&#x27;</span> &amp;&amp; s.charAt(i) == <span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>                <span class="hljs-comment">// 能够处理 ..()，但是无法处理 (())</span><br>                dp[i] = (i &gt;= <span class="hljs-number">2</span> ? dp[i - <span class="hljs-number">2</span>] : <span class="hljs-number">0</span>) + <span class="hljs-number">2</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s.charAt(i - <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;)&#x27;</span> &amp;&amp; s.charAt(i) == <span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>                <span class="hljs-comment">// 这里处理 ...((...)) 的情况</span><br>                <span class="hljs-comment">// 判断 s[i] 是否有对应的左括号</span><br>                <span class="hljs-keyword">if</span> (i - dp[i - <span class="hljs-number">1</span>] - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; s.charAt(i - dp[i - <span class="hljs-number">1</span>] - <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                    <span class="hljs-comment">// 第一项对应 ((...)) 中的三个点</span><br>                    <span class="hljs-comment">// 最后一项是和匹配的括号的情况连起来，对应 ...(()) 中的三个点</span><br>                    <span class="hljs-comment">// dp[i] = dp[i - 1] + 2 + (i - dp[i - 1] - 2) &gt; 0 ? dp[i - dp[i - 1] - 2] : 0;</span><br>                    dp[i] = dp[i - <span class="hljs-number">1</span>] + <span class="hljs-number">2</span> + ((i - dp[i - <span class="hljs-number">1</span>] - <span class="hljs-number">2</span>) &gt; <span class="hljs-number">0</span> ? dp[i - dp[i - <span class="hljs-number">1</span>] - <span class="hljs-number">2</span>] : <span class="hljs-number">0</span>);<br>                &#125;<br>            &#125;<br>            max = Math.max(max, dp[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="栈-1"><a href="#栈-1" class="headerlink" title="栈"></a>栈</h3><p>如果用栈，那么关键在于对于 …(…)() 和 …(()) 这两种情况如何判断长度和判断连续。</p>
<p>对于连续来说，可以过一遍字符串即可，对于长度判断，要点在于，如果对于右括号没有对应的左括号时，说明需要另起炉灶，重新计算最大长度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestValidParentheses</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;Integer&gt;();<br>        stack.push(-<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (s.charAt(i) == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                stack.push(i);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                stack.pop();<br>                <span class="hljs-keyword">if</span> (stack.isEmpty()) &#123;<br>                    stack.push(i);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    max = Math.max(max, i - stack.peek());<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="寻找两个正序数组的中位数3"><a href="#寻找两个正序数组的中位数3" class="headerlink" title="寻找两个正序数组的中位数3"></a>寻找两个正序数组的中位数<sup><a href="#fn_3" id="reffn_3">3</a></sup></h2><p>中位数定义：将一个集合划分为两个长度相等的子集，其中一个子集中的元素总是大于另一个子集中的元素。</p>
<pre><code>      left_part          |         right_part
A[0], A[1], ..., A[i-1]  |  A[i], A[i+1], ..., A[m-1]
B[0], B[1], ..., B[j-1]  |  B[j], B[j+1], ..., B[n-1]
</code></pre><p>根据中位数的定义，我们需要找到以上的划分（设两个数组总长度为偶数）使得</p>
<ul>
<li>$\text{len}(left_part) = \text{len}(right_part)$</li>
<li>$\max(left_part)=\max(right_part)$</li>
</ul>
<p>此时的中位数为：</p>
<script type="math/tex; mode=display">\text{median} = \frac{\max(left\_part)+\min(right\_part)}{2}</script><p>所以现在的问题关键在于寻找这样一个划分。要寻找这样一个划分需要根据这个划分满足的两个条件：</p>
<ul>
<li>左边元素共有 $i + j$ 个，右边元素共有 $(m-i)+(n-j)$ 个，所以由第一个式子可以得到 $i+j=(m-i)+(n-j)$。变形得到 $i+j=\frac{m+n}{2}$。假设 $m &lt; n$，即 B 数组长于 A 数组，则 $i\in[0,m]$，有 $j = \frac{m+n}{2}-i$ 且 $j \in [0,n]$，所以只要知道 $i$ 的值，那么 $j$ 的值也是确定的。</li>
<li>在 $(0, m)$ 中找到 $i$，满足 $A[i-1] \le B[j]$ 且 $A[i] \ge B[j-1]$ 。</li>
</ul>
<p>注意到第一个条件中，当 $i$ 增大的时候，$j$ 会减小以此来保证左右两部分的元素个数相同。同时 A、B 数组都是单调不递减的，所以一定存在一个最大的 $i$ 满足 $A[i-1] \le B[j]$。（当 $i$ 取 $i+1$ 时 $A[i] &gt; B[j-1]$）</p>
<p>所以问题转化为：找一个最大的 $i$ 使得 $A[i-1] \le B[j]$。</p>
<p>对于这个问题，我们容易枚举 $i$，同时 A、B 都是单调递增的，所以我们还能知道枚举出的 $i$ 是不是满足条件（$A[i-1] \le B[j]$），并从中找出满足条件的最大 $i$ 值即可。</p>
<p>对于两个数组总长度为奇数的情况，可以使得 $j = \lfloor \frac{m+n+1}{2}-i \rfloor$。</p>
<p>代码如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[warn(dead_code)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Solution</span>;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">find_median_sorted_arrays</span>(nums1: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt;, nums2: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">f64</span> &#123;<br>        <span class="hljs-keyword">if</span> nums1.<span class="hljs-title function_ invoke__">len</span>() &gt; nums2.<span class="hljs-title function_ invoke__">len</span>() &#123;<br>            <span class="hljs-keyword">return</span> Solution::<span class="hljs-title function_ invoke__">find_median_sorted_arrays</span>(nums2, nums1);<br>        &#125;<br>        <span class="hljs-comment">// m &lt; n</span><br>        <span class="hljs-keyword">let</span> (m, n) = (nums1.<span class="hljs-title function_ invoke__">len</span>(), nums2.<span class="hljs-title function_ invoke__">len</span>());<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">left</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">right</span> = m;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">pos</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">median1</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">median2</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> left &lt;= right &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">i</span> = (left + right) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">j</span> = (m + n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> - i;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">nums_im1</span> = <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> &#123; -<span class="hljs-number">0x3f3f3f3f</span> &#125; <span class="hljs-keyword">else</span> &#123; nums1[i - <span class="hljs-number">1</span>] &#125;;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">nums_i</span> = <span class="hljs-keyword">if</span> i == m &#123; <span class="hljs-number">0x3f3f3f3f</span> &#125; <span class="hljs-keyword">else</span> &#123; nums1[i] &#125;;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">nums_jm1</span> = <span class="hljs-keyword">if</span> j == <span class="hljs-number">0</span> &#123; -<span class="hljs-number">0x3f3f3f3f</span> &#125; <span class="hljs-keyword">else</span> &#123; nums2[j - <span class="hljs-number">1</span>] &#125;;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">nums_j</span> = <span class="hljs-keyword">if</span> j == n &#123; <span class="hljs-number">0x3f3f3f3f</span> &#125; <span class="hljs-keyword">else</span> &#123; nums2[j] &#125;;<br>            <span class="hljs-keyword">if</span> nums_im1 &lt;= nums_j &#123;<br>                median1 = std::cmp::<span class="hljs-title function_ invoke__">max</span>(nums_im1, nums_jm1);<br>                median2 = std::cmp::<span class="hljs-title function_ invoke__">min</span>(nums_i, nums_j);<br>                left = i + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right = i - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-title function_ invoke__">if</span> (m + n) &amp; <span class="hljs-number">1</span> == <span class="hljs-number">0</span> &#123;<br>            (median1 + median2) <span class="hljs-keyword">as</span> <span class="hljs-type">f64</span> / <span class="hljs-number">2.0</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            median1 <span class="hljs-keyword">as</span> <span class="hljs-type">f64</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="三数之和-1"><a href="#三数之和-1" class="headerlink" title="三数之和"></a>三数之和</h2><h3 id="朴素算法"><a href="#朴素算法" class="headerlink" title="朴素算法"></a>朴素算法</h3><p>排序之后三重循环，判断三个数之和是否为 $0$，时间复杂度 $O(n^3)$。</p>
<p>排序的目的是为了容易地去除重复数字，因为排序之后只需要判断当前和前一个元素是否相等就可以知道是否是重复数字。</p>
<h3 id="排序后双指针"><a href="#排序后双指针" class="headerlink" title="排序后双指针"></a>排序后双指针</h3><p>注意到排序之后整个数组是单调非递减的，我们需要 $a+b+c=0$，当固定了 $a$ 和 $b$ 的时候，$c$ 从大到小地判断是否有 $a+b+c=0$ 即可。看似是最外层对应 $a$ 的循环嵌套对应 $b$ 的循环，并在其中加上了 $c$ 递减的循环，但是实际上注意到当 $b$ 与 $c$ 是同一个元素时，如果仍然不满足 $a+b+c=0$，那么 $c$ 继续向左减小就与之前的数字重复了，所以对于每一次 $b$ 中的循环，最多运行 $n$ 次，外边再嵌套 $a$ 的循环，时间复杂度为 $O(n^2)$。</p>
<p>代码如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[warn(dead_code)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Solution</span>;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">three_sum</span>(<span class="hljs-keyword">mut</span> nums: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt;&gt; &#123;<br>        nums.<span class="hljs-title function_ invoke__">sort</span>();<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">len</span> = nums.<span class="hljs-title function_ invoke__">len</span>();<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">ans</span> = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">new</span>();<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..len &#123;<br>            <span class="hljs-comment">// 防止取到相同的数字</span><br>            <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i - <span class="hljs-number">1</span>] == nums[i] &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">third</span> = len - <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">// 注意这里开始位置是 i+1，目的是为了不与 a 取重</span><br>            <span class="hljs-keyword">for</span> <span class="hljs-variable">j</span> <span class="hljs-keyword">in</span> i + <span class="hljs-number">1</span>..len &#123;<br>                <span class="hljs-comment">// 注意这里判定条件是 j &gt; i+1 否则会取不到与 a 相同的数字</span><br>                <span class="hljs-keyword">if</span> j &gt; i + <span class="hljs-number">1</span> &amp;&amp; nums[j - <span class="hljs-number">1</span>] == nums[j] &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">while</span> j &lt; third &amp;&amp; nums[i] + nums[j] + nums[third] &gt; <span class="hljs-number">0</span> &#123;<br>                    third = third - <span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> j == third &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> nums[i] + nums[j] + nums[third] == <span class="hljs-number">0</span> &#123;<br>                    ans.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-built_in">vec!</span>[nums[i], nums[j], nums[third]]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        ans<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="盛最多水的容器4"><a href="#盛最多水的容器4" class="headerlink" title="盛最多水的容器4"></a>盛最多水的容器<sup><a href="#fn_4" id="reffn_4">4</a></sup></h2><script type="math/tex; mode=display">
area = (right - left) * \min (height[left], height[right])</script><p>由上面的公式可以知道，面积由两部分共同决定：</p>
<ul>
<li>宽度</li>
<li>高度</li>
</ul>
<p>所以考虑尽可能地增加宽度和高度。假设左指针指向的数为 $x$，右指针指向的数为 $y$，假设 $x &lt; y$，距离为 $t$，接下来进行具体分析：</p>
<ol>
<li>水量 $ area = \min(x, y) <em> t = x </em> t $，当左指针不变的时候，右指针无论在哪都不会影响容器的水量了，水量是固定的 $x*t$。</li>
<li>所以考虑左指针向右移动，这样才有可能取到更大的水量。</li>
<li>同理左指针指向的数大于右指针指向的数的时候，左移右指针才有可能取到更大的水量。</li>
<li>重复以上步骤就可以得到最大水量。</li>
</ol>
<p>总时间复杂度为 $O(n)$。</p>
<p>注解：</p>
<ul>
<li>对于双指针问题，两个指针的初始位置不一定都在最左或者最右，要灵活地设置指针位置。</li>
</ul>
<h2 id="最接近三数之和"><a href="#最接近三数之和" class="headerlink" title="最接近三数之和"></a>最接近三数之和</h2><p>与「盛最多水的容器」和「三数之和」类似，代码如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[warn(dead_code)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Solution</span>;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">three_sum_closest</span>(<span class="hljs-keyword">mut</span> nums: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt;, target: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;<br>        nums.<span class="hljs-title function_ invoke__">sort</span>();<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">len</span> = nums.<span class="hljs-title function_ invoke__">len</span>();<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">ans</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">diff</span> = <span class="hljs-number">0x3f3f3f3f</span>;<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..len &#123;<br>            <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>] &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">j</span> = i + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">k</span> = len - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> j &lt; k &#123;<br>                <span class="hljs-comment">//dbg!((i, j , k));</span><br>                <span class="hljs-keyword">let</span> <span class="hljs-variable">sum</span> = nums[i] + nums[j] + nums[k];<br>                <span class="hljs-keyword">if</span> sum == target &#123;<br>                    <span class="hljs-keyword">return</span> sum;<br>                &#125;<br>                <span class="hljs-keyword">let</span> <span class="hljs-variable">tmp</span> = (sum - target).<span class="hljs-title function_ invoke__">abs</span>();<br>                <span class="hljs-keyword">if</span> tmp &lt; diff &#123;<br>                    diff = tmp;<br>                    ans = sum;<br>                &#125;<br>                <span class="hljs-keyword">if</span> sum &gt; target &#123;<br>                    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">k0</span> = k - <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">while</span> j &lt; k0 &amp;&amp; nums[k0] == nums[k] &#123;<br>                        k0 = k0 - <span class="hljs-number">1</span>;<br>                    &#125;<br>                    k = k0;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">j0</span> = j + <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">while</span> j0 &lt; k &amp;&amp; nums[j0] == nums[j] &#123;<br>                        j0 = j0 + <span class="hljs-number">1</span>;<br>                    &#125;<br>                    j = j0;<br>                &#125;<br>            &#125;<br>        &#125;<br>        ans<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="最大整除子集"><a href="#最大整除子集" class="headerlink" title="最大整除子集"></a>最大整除子集</h2><p>给你一个由 <strong>无重复</strong> 正整数组成的集合 <code>nums</code> ，请你找出并返回其中最大的整除子集 <code>answer</code> ，子集中每一元素对 <code>(answer[i], answer[j])</code> 都应当满足：</p>
<ul>
<li><code>answer[i] % answer[j] == 0</code> ，或</li>
<li><code>answer[j] % answer[i] == 0</code></li>
</ul>
<p>如果存在多个有效解子集，返回其中任何一个均可。</p>
<h3 id="动态规划-7"><a href="#动态规划-7" class="headerlink" title="动态规划"></a>动态规划</h3><p>设子集为 A，题目要求对于任意 (A[i],A[j])，都满足 A[i]modA[j]=0 或者 A[j]modA[i]=0，也就是一个数是另一个数的倍数。</p>
<p>这里有两个条件，不好处理。我们可以把 A 排序，或者说把 nums 排序（从小到大）。由于 nums 所有元素互不相同（没有相等的情况），题目要求变成：</p>
<p>从（排序后的）nums 中选一个子序列，在子序列中，右边的数一定是左边的数的倍数。<br>由于 x 的倍数的倍数仍然是 x 的倍数，只要相邻元素满足倍数关系，那么任意两数一定满足倍数关系。于是题目要求变成：</p>
<p>从（排序后的）nums 中选一个子序列，在子序列中，任意相邻的两个数，右边的数一定是左边的数的倍数。<br>这类似 300. 最长递增子序列，都是相邻元素有约束，且要计算的都是子序列的最长长度。</p>
<p>下文把满足题目要求的子序列叫做合法子序列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">largestDivisibleSubset</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Arrays.sort(nums);<br>        <br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n]; <span class="hljs-comment">// 以 nums[i] 结尾的最大整除子集</span><br>        <span class="hljs-type">int</span>[] from = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        Arrays.fill(from, -<span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxI</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>                <span class="hljs-keyword">if</span> (nums[i] % nums[j] == <span class="hljs-number">0</span> &amp;&amp; dp[j] &gt; dp[i]) &#123;<br>                    dp[i] = dp[j];<br>                    from[i] = j;<br>                &#125;<br>            &#125;<br>            dp[i]++;<br>            <span class="hljs-keyword">if</span> (dp[i] &gt; dp[maxI]) &#123;<br>                maxI = i; <span class="hljs-comment">// 最大整除子集最后一个数的下标</span><br>            &#125;<br>        &#125;<br><br>        List&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(dp[maxI]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> maxI; i &gt;= <span class="hljs-number">0</span>; i = from[i]) &#123;<br>            path.add(nums[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> path;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="多维-dp"><a href="#多维-dp" class="headerlink" title="多维 dp"></a>多维 dp</h1><h2 id="不同路径"><a href="#不同路径" class="headerlink" title="不同路径"></a>不同路径</h2><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p>
<p>问总共有多少条不同的路径？</p>
<p>二维爬楼梯，对于每个位置能从上面和左边过来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            dp[<span class="hljs-number">0</span>][i] = <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 对于一个位置，能从左边或者上面过来</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>                dp[i][j] = dp[i][j - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">1</span>][j];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="最小路径和"><a href="#最小路径和" class="headerlink" title="最小路径和"></a>最小路径和</h2><p>还是和不同路径一样，不同的是从左上到右下的时候需要记录最小路径和。还有初始化状态的时候，要记得加上走过来的时候的最小值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minPathSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n]; <span class="hljs-comment">// 记录到 i, j 的最小数字和</span><br><br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            dp[<span class="hljs-number">0</span>][i] = grid[<span class="hljs-number">0</span>][i] + dp[<span class="hljs-number">0</span>][i - <span class="hljs-number">1</span>];<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<br>            dp[i][<span class="hljs-number">0</span>] = grid[i][<span class="hljs-number">0</span>] + dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>        &#125;<br><br>        <span class="hljs-comment">// 对于 dp[i][j] 只能从上面或者左边过来，记录最小和就好</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>                dp[i][j] = Math.min(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]) + grid[i][j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="最长回文子串-1"><a href="#最长回文子串-1" class="headerlink" title="最长回文子串"></a>最长回文子串</h2><p>要点在于：</p>
<ol>
<li>初始状态所有字符都和自己回文。</li>
<li>dp$$i][j] 表示子串 i…j 是否是回文串。</li>
<li>为了便于考虑边界情况，外层循环枚举 j，内层循环枚举 i。</li>
<li>dp<script type="math/tex">i][j] 如果是回文字符串，要求 dp</script>i + 1][j - 1] 是回文字符串，并且 s[i] == s[j]。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">longestPalindrome</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-comment">// dp[i][j] 表示子串 i...j 是否是回文串 </span><br>        <span class="hljs-type">boolean</span> dp[][] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n][n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxLen</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, end = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-comment">// 状态初始化，自己和自己回文</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            dp[i][i] = <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; j; i++) &#123;<br>                <span class="hljs-keyword">if</span> ((j - i &lt;= <span class="hljs-number">1</span> || dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]) &amp;&amp; s.charAt(i) == s.charAt(j)) &#123;<br>                    dp[i][j] = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">if</span> (j - i + <span class="hljs-number">1</span> &gt; maxLen) &#123;<br>                        maxLen = j - i + <span class="hljs-number">1</span>;<br>                        start = i;<br>                        end = j;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s.substring(start, end + <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><p>要点：</p>
<ol>
<li>dp[i][j] 表示字符串 s1[0…i) 和 s2[0…j) 的最长公共子序列长度，注意这里是左闭右开。</li>
<li>对于 dp[i][j] 能从 dp[i - 1][j - 1] + 1 得到，此时 s1[i] == s2[j]</li>
<li>不相等时 dp[i][j] 是 Math.max(dp[i - 1][j], dp[i][j - 1])， 也就是跳过当前字符</li>
<li>这里的 i 从 1…len1，然后 i-1 是 0…len1-1，所以 i-1 遍历了整个字符串。如果不使用这种处理方式，会导致最后一位字符未被处理。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestCommonSubsequence</span><span class="hljs-params">(String text1, String text2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len1</span> <span class="hljs-operator">=</span> text1.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len2</span> <span class="hljs-operator">=</span> text2.length();<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len1 + <span class="hljs-number">1</span>][len2 + <span class="hljs-number">1</span>]; <span class="hljs-comment">// 字符串 s1[0...i] 和 s2[0...j] 的最长公共子序列长度</span><br>        <br>        <span class="hljs-comment">// 对于 dp[i][j] 能从 dp[i - 1][j - 1] + 1 得到，此时 s1[i] == s2[j]</span><br>        <span class="hljs-comment">// 不相等时 dp[i][j] 是 Math.max(dp[i - 1][j], dp[i][j - 1])， 也就是跳过当前字符</span><br>        <span class="hljs-comment">// 注意！！！</span><br>        <span class="hljs-comment">// 这里的 i 从 1...len1，然后 i-1 是 0...len1-1，所以 i-1 遍历了整个字符串</span><br>        <span class="hljs-comment">// 如果不使用这种处理方式，会导致最后一位字符未被处理</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= len1; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= len2; j++) &#123;<br>                <span class="hljs-keyword">if</span> (text1.charAt(i - <span class="hljs-number">1</span>) == text2.charAt(j - <span class="hljs-number">1</span>)) &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = Math.max(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp[len1][len2];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h2><p>要点：</p>
<ol>
<li>dp[i][j] 表示 word1 前 i 个字符变成 word2 前 j 个字符需要的最少操作数</li>
<li>边界条件是 0 字符和有 i 个字符的情况。</li>
<li>状态转移</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css">从 dp<span class="hljs-selector-attr">[i - 1]</span><span class="hljs-selector-attr">[j - 1]</span> 过来是替换掉 word1 中的字符，因为 dp<span class="hljs-selector-attr">[i - 1]</span><span class="hljs-selector-attr">[j - 1]</span> 已经匹配<br>从 dp<span class="hljs-selector-attr">[i - 1]</span><span class="hljs-selector-attr">[j]</span> 过来是删除掉 word1 中的字符，因为 dp<span class="hljs-selector-attr">[i - 1]</span><span class="hljs-selector-attr">[j]</span> 已经匹配<br>从 dp<span class="hljs-selector-attr">[i]</span><span class="hljs-selector-attr">[j - 1]</span> 过来是删除掉 word2 中的字符（等价于 word1 增加字符），因为 dp<span class="hljs-selector-attr">[i]</span><span class="hljs-selector-attr">[j - 1]</span> 已经匹配<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minDistance</span><span class="hljs-params">(String word1, String word2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len1</span> <span class="hljs-operator">=</span> word1.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len2</span> <span class="hljs-operator">=</span> word2.length();<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len1 + <span class="hljs-number">1</span>][len2 + <span class="hljs-number">1</span>]; <span class="hljs-comment">// word1 前 i 个字符变成 word2 前 j 个字符需要的最少操作数</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= len1; i++) &#123;<br>            dp[i][<span class="hljs-number">0</span>] = i;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= len2; i++) &#123;<br>            dp[<span class="hljs-number">0</span>][i] = i;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= len1; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= len2; j++) &#123;<br>                <span class="hljs-keyword">if</span> (word1.charAt(i - <span class="hljs-number">1</span>) == word2.charAt(j - <span class="hljs-number">1</span>)) &#123; <span class="hljs-comment">// 不用编辑</span><br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>                &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 编辑 word1 使其变成 word2</span><br>                    <span class="hljs-comment">// 从 dp[i - 1][j - 1] 过来是替换掉 word1 中的字符，因为 dp[i - 1][j - 1] 已经匹配</span><br>                    <span class="hljs-comment">// 从 dp[i - 1][j] 过来是删除掉 word1 中的字符，因为 dp[i - 1][j] 已经匹配</span><br>                    <span class="hljs-comment">// 从 dp[i][j - 1] 过来是删除掉 word2 中的字符（等价于 word1 增加字符），因为 dp[i][j - 1] 已经匹配</span><br>                    dp[i][j] = Math.min(dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>], Math.min(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>])) + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[len1][len2];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="合并K个升序链表"><a href="#合并K个升序链表" class="headerlink" title="合并K个升序链表"></a>合并K个升序链表</h2><p>使用优先队列即可。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::&#123;cmp::Reverse, collections::BinaryHeap&#125;;<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">merge_k_lists</span>(lists: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">Option</span>&lt;<span class="hljs-type">Box</span>&lt;ListNode&gt;&gt;&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-type">Box</span>&lt;ListNode&gt;&gt; &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">priority_queue</span> = BinaryHeap::<span class="hljs-title function_ invoke__">new</span>();<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">ret</span> = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(ListNode::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">ptr</span> = &amp;<span class="hljs-keyword">mut</span> ret;<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">list</span> <span class="hljs-keyword">in</span> lists &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">plist</span> = &amp;list;<br>            <span class="hljs-keyword">while</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(node) = plist &#123;<br>                priority_queue.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-title function_ invoke__">Reverse</span>(node.val));<br>                plist = &amp;node.next;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(<span class="hljs-title function_ invoke__">Reverse</span>(node)) = priority_queue.<span class="hljs-title function_ invoke__">pop</span>() &#123;<br>            ptr.next = <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(ListNode::<span class="hljs-title function_ invoke__">new</span>(node)));<br>            ptr = ptr.next.<span class="hljs-title function_ invoke__">as_mut</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>        &#125;<br>        ret.next<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1><h2 id="有序三元组中的最大值-I"><a href="#有序三元组中的最大值-I" class="headerlink" title="有序三元组中的最大值 I"></a>有序三元组中的最大值 I</h2><ul>
<li><code>3 &lt;= nums.length &lt;= 100</code></li>
<li><code>1 &lt;= nums[i] &lt;= 106</code></li>
</ul>
<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 。</p>
<p>请你从所有满足 <code>i &lt; j &lt; k</code> 的下标三元组 <code>(i, j, k)</code> 中，找出并返回下标三元组的最大值。如果所有满足条件的三元组的值都是负数，则返回 <code>0</code> 。</p>
<p><strong>下标三元组</strong> <code>(i, j, k)</code> 的值等于 <code>(nums[i] - nums[j]) * nums[k]</code> 。</p>
<p>数组长度 &lt;= 100，也就是说 n^3 = 1e6，可以暴力：</p>
<p>但是要注意 ans 是 long 的，所以存在超出 int 的情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">maximumTripletValue</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">2</span>; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; k &gt;= i + <span class="hljs-number">2</span>; k--) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; k; j++) &#123;<br>                    ans = Math.max(ans, (<span class="hljs-type">long</span>)nums[k] * (nums[i] - nums[j]));<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>优化为 O(n^2)，要点在于当固定 j, k 时，i 是 0…j 的最大值，所以 i 可以由 j 动态得到。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">maximumTripletValue</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; k &lt; n; k++) &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; k; j++) &#123;<br>                ans = Math.max(ans, nums[k] * (i - nums[j]));<br>                i = Math.max(i, nums[j]);<br>            &#125;<br>        &#125;        <br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>优化为 O(n)，要点在于可以提前维护 0…j 和 j…n 的最大值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">maximumTripletValue</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] leftMax = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span>[] rightMax = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            leftMax[i] = Math.max(leftMax[i - <span class="hljs-number">1</span>], nums[i - <span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">2</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>            rightMax[i] = Math.max(rightMax[i + <span class="hljs-number">1</span>], nums[i + <span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;<br>            ans = Math.max(ans, (<span class="hljs-type">long</span>)rightMax[i] * (leftMax[i] - nums[i]));<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>优化空间为 O(1)，要点在于对于 <code>(nums[i] - nums[j]) * nums[k]</code>，i 和 j 是小于 k 的，所以 i，j 要走的路，k 都走过了，所以可以枚举 k 的时候维护其他状态。</p>
<p>然后维护其他状态的思路是考虑固定 k，如果要枚举 k，那么考虑 k 被固定的情况，其他的两个变量如何变化。</p>
<p>维护 nums[i] - nums[j] 的最大值，维护 nums[i] 的最大值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">maximumTripletValue</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxI</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxISubJ</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; n; k++) &#123;<br>            ans = Math.max(ans, (<span class="hljs-type">long</span>)maxISubJ * nums[k]);<br>            maxISubJ = Math.max(maxISubJ, maxI - nums[k]);<br>            maxI = Math.max(maxI, nums[k]);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="使数组元素互不相同所需的最少操作次数"><a href="#使数组元素互不相同所需的最少操作次数" class="headerlink" title="使数组元素互不相同所需的最少操作次数"></a>使数组元素互不相同所需的最少操作次数</h2><p>给你一个整数数组 <code>nums</code>，你需要确保数组中的元素 <strong>互不相同</strong> 。为此，你可以执行以下操作任意次：</p>
<ul>
<li>从数组的开头移除 3 个元素。如果数组中元素少于 3 个，则移除所有剩余元素。</li>
</ul>
<p><strong>注意：</strong>空数组也视作为数组元素互不相同。返回使数组元素互不相同所需的 <strong>最少操作次数</strong> 。</p>
<h3 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumOperations</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] c = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">101</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            c[nums[i]]++;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i+=<span class="hljs-number">3</span>) &#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">ok</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">100</span>; j++) &#123;<br>                <span class="hljs-keyword">if</span> (c[j] &gt; <span class="hljs-number">1</span>) &#123;<br>                    c[nums[i]]--;<br>                    <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &lt; n) c[nums[i+<span class="hljs-number">1</span>]]--;<br>                    <span class="hljs-keyword">if</span> (i + <span class="hljs-number">2</span> &lt; n) c[nums[i+<span class="hljs-number">2</span>]]--;<br>                    ok = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!ok) ans++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="技巧-1"><a href="#技巧-1" class="headerlink" title="技巧"></a>技巧</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumOperations</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// 倒序遍历</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> n / <span class="hljs-number">3</span>;<br>        <span class="hljs-type">boolean</span>[] seen = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[<span class="hljs-number">101</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">if</span> (seen[nums[i]]) &#123;<br>                <span class="hljs-keyword">return</span> i / <span class="hljs-number">3</span> + <span class="hljs-number">1</span>;<br>            &#125;<br>            seen[nums[i]] = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h1><h2 id="找出所有子集的异或总和再求和"><a href="#找出所有子集的异或总和再求和" class="headerlink" title="找出所有子集的异或总和再求和"></a>找出所有子集的异或总和再求和</h2><h3 id="简单做法"><a href="#简单做法" class="headerlink" title="简单做法"></a>简单做法</h3><p>枚举所有子集，然后求出异或总和</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">subsetXORSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; (<span class="hljs-number">1</span> &lt;&lt; n); i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">XORSum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> ((i &amp; (<span class="hljs-number">1</span> &lt;&lt; j)) != <span class="hljs-number">0</span>) &#123;<br>                    XORSum = XORSum ^ nums[j];<br>                &#125;<br>            &#125;<br>            ans += XORSum;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="数学做法"><a href="#数学做法" class="headerlink" title="数学做法"></a>数学做法</h3><h4 id="提示1"><a href="#提示1" class="headerlink" title="提示1"></a>提示1</h4><p>对于异或运算，每个比特位是互相独立的，我们可以先思考只有一个比特位的情况，也就是 nums 中只有 0 和 1 的情况。（从特殊到一般）</p>
<p>在这种情况下，如果子集中有偶数个 1，那么异或和为 0；如果子集中有奇数个 1，那么异或和为 1。所以关键是求出异或和为 1 的子集个数。题目要求的是子集的异或总和再求和，异或和为 1 的子集的个数就是最终答案。</p>
<p>设 nums 的长度为 n，且包含 1。我们可以先把其中一个 1 拿出来，剩下 n−1 个数随便选或不选，有 $2^{n−1}$ 种选法。</p>
<ul>
<li>如果这 n−1 个数中选了偶数个 1，那么放入我们拿出来的 1（选这个 1），得到奇数个 1，异或和为 1。</li>
<li>如果这 n−1 个数中选了奇数个 1，那么不放入我们拿出来的 1（不选这个 1），得到奇数个 1，异或和为 1。</li>
</ul>
<p>所以，恰好有 $2^{n−1}$ 个子集的异或和为 1。</p>
<p>注意这个结论与 nums 中有多少个 1 是无关的，只要有 1，异或和为 1 的子集个数就是 $2^{n−1}$。如果 nums 中没有 1，那么有 0 个子集的异或和为 1。</p>
<p>所以，在有至少一个 1 的情况下，nums 的所有子集的异或和的总和为 $2^{n−1}$。</p>
<h4 id="提示2"><a href="#提示2" class="headerlink" title="提示2"></a>提示2</h4><p>推广到多个比特位的情况。</p>
<p>例如 $nums = [3,2,8]$，3 = 11，2 = 10，8 = 1000</p>
<p>第 $0,1,3$ 个比特位上有 $1$，每个比特位对应的「所有子集的异或和的总和」分别为</p>
<script type="math/tex; mode=display">
2^0\cdot2^{n - 1}, 2^1\cdot2^{n - 1}, 2^3\cdot2^{n - 1}</script><p>相加得</p>
<script type="math/tex; mode=display">
(2^0 + 2^1 + 2^3)\cdot2^{n - 1}</script><p>怎么知道哪些比特位上有 $1$？计算 $nums$ 的所有元素的 OR，即 $1011_{(2)}$。</p>
<p>注意到，所有元素的 OR，就是上例中的 $2^0 + 2^1 + 2^3$。</p>
<p>一般地，设 $nums$ 所有元素的 OR 为 $or$，$nums$ 的所有子集的异或和的总和为</p>
<script type="math/tex; mode=display">
or\cdot2^{n - 1}</script><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">subsetXORSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">XORSum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            XORSum = XORSum | nums[i]; <br>        &#125;<br>        <span class="hljs-keyword">return</span> XORSum * <span class="hljs-number">1</span> &lt;&lt; (n - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="数位-dp"><a href="#数位-dp" class="headerlink" title="数位 dp"></a>数位 dp</h1><h2 id="统计强大整数的数目"><a href="#统计强大整数的数目" class="headerlink" title="统计强大整数的数目"></a>统计强大整数的数目</h2><p>给你三个整数 <code>start</code> ，<code>finish</code> 和 <code>limit</code> 。同时给你一个下标从 <strong>0</strong> 开始的字符串 <code>s</code> ，表示一个 <strong>正</strong> 整数。</p>
<p>如果一个 <strong>正</strong> 整数 <code>x</code> 末尾部分是 <code>s</code> （换句话说，<code>s</code> 是 <code>x</code> 的 <strong>后缀</strong>），且 <code>x</code> 中的每个数位至多是 <code>limit</code> ，那么我们称 <code>x</code> 是 <strong>强大的</strong> 。</p>
<p>请你返回区间 <code>[start..finish]</code> 内强大整数的 <strong>总数目</strong> 。</p>
<p>如果一个字符串 <code>x</code> 是 <code>y</code> 中某个下标开始（<strong>包括</strong> <code>0</code> ），到下标为 <code>y.length - 1</code> 结束的子字符串，那么我们称 <code>x</code> 是 <code>y</code> 的一个后缀。比方说，<code>25</code> 是 <code>5125</code> 的一个后缀，但不是 <code>512</code> 的后缀。</p>
<h3 id="组合数学"><a href="#组合数学" class="headerlink" title="组合数学"></a>组合数学</h3><p>我们可以实现一个计数函数 <code>calculate(x)</code> 来直接计算小于等于 <code>x</code> 的满足 <code>limit</code> 的数字数量，然后答案即为 <code>calculate(finish) - calculate(start - 1)</code>。 首先考虑 <code>x</code> 中与 <code>s</code> 长度相等的后缀部份（如果 <code>x</code> 长度小于 <code>s</code>，答案为 <code>0</code>），如果 <code>x</code> 的后缀大于等于 <code>s</code>，那么后缀部份对答案贡献为 <code>1</code>。 接着考虑剩余的前缀部份。令 <code>preLen</code> 表示前缀的长度，即 <code>|x| - |s|</code>。对于前缀的每一位 <code>x[i]</code>： - 如果超过了 <code>limit</code>，意味着当前位最多只能取到 <code>limit</code>，后面的所有位任取组成的数字也不会超过 <code>x</code>。因此包括第 <code>i</code> 位，后面的所有位（共 <code>preLen - i</code> 位）都可以取 <code>[0, limit]</code>（共 <code>limit + 1</code> 个数），对答案的贡献是 <code>(limit + 1)^(preLen - i)</code>。 - 如果 <code>x[i]</code> 没有超过 <code>limit</code>，那么当前位最多取到 <code>x[i]</code>，后面的所有位可以取 <code>[0, limit]</code>，对答案的贡献是 <code>x[i] × (limit + 1)^(preLen - i - 1)</code>。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">numberOfPowerfulInt</span><span class="hljs-params">(<span class="hljs-type">long</span> start, <span class="hljs-type">long</span> finish, <span class="hljs-type">int</span> limit, String s)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">StrFinish</span> <span class="hljs-operator">=</span> String.valueOf(finish);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">StrStart</span> <span class="hljs-operator">=</span> String.valueOf(start - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> calculate(StrFinish, s, limit) - calculate(StrStart, s, limit);<br>    &#125;<br><br>    <span class="hljs-comment">// 计算计算小于等于 x 的满足 limit 的数字数量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-title function_">calculate</span><span class="hljs-params">(String x, String s, <span class="hljs-type">int</span> limit)</span> &#123;<br>        <span class="hljs-keyword">if</span> (x.length() &lt; s.length()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (x.length() == s.length()) &#123;<br>            <span class="hljs-keyword">return</span> x.compareTo(s) &gt;= <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">suffix</span> <span class="hljs-operator">=</span> x.substring(x.length() - s.length()); <span class="hljs-comment">// begin index</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">preLen</span> <span class="hljs-operator">=</span> x.length() - s.length();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= preLen; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">digit</span> <span class="hljs-operator">=</span> x.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (limit &lt; digit) &#123;<br>                count += (<span class="hljs-type">long</span>) Math.pow(limit + <span class="hljs-number">1</span>, preLen - i);<br>                <span class="hljs-keyword">return</span> count;<br>            &#125;<br>            count += (<span class="hljs-type">long</span>)digit * (<span class="hljs-type">long</span>)Math.pow(limit + <span class="hljs-number">1</span>, preLen - <span class="hljs-number">1</span> - i);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (suffix.compareTo(s) &gt;= <span class="hljs-number">0</span>) &#123;<br>            count++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="数位-dp-1"><a href="#数位-dp-1" class="headerlink" title="数位 dp"></a>数位 dp</h3><p>定义 <code>dfs(i, limitLow, limitHigh)</code> 表示构造第 <code>i</code> 位及其之后数位的合法方案数，其余参数的含义为：</p>
<ul>
<li><code>limitHigh</code> 表示当前是否受到了 <code>finish</code> 的约束（我们要构造的数字不能超过 <code>finish</code>）。若为真，则第 <code>i</code> 位填入的数字至多为 <code>finish[i]</code>，否则至多为 <code>9</code>，这个数记作 <code>hi</code>。如果在受到约束的情况下填了 <code>finish[i]</code>，那么后续填入的数字仍会受到 <code>finish</code> 的约束。例如 <code>finish = 123</code>，那么 <code>i = 0</code> 填的是 <code>1</code> 的话，<code>i = 1</code> 的这一位至多填 <code>2</code>。</li>
<li><code>limitLow</code> 表示当前是否受到了 <code>start</code> 的约束（我们要构造的数字不能低于 <code>start</code>）。若为真，则第 <code>i</code> 位填入的数字至少为 <code>start[i]</code>，否则至少为 <code>0</code>，这个数记作 <code>lo</code>。如果在受到约束的情况下填了 <code>start[i]</code>，那么后续填入的数字仍会受到 <code>start</code> 的约束。</li>
</ul>
<p>枚举第 <code>i</code> 位填什么数字。</p>
<p>如果 <code>i &lt; n - |s|</code>，那么可以填 <code>[lo, min(hi, limit)]</code> 内的数，否则只能填 <code>s[i - (n - |s|)]</code>。这里 <code>|s|</code> 表示 <code>s</code> 的长度。</p>
<p>为什么不能把 <code>hi</code> 置为 <code>min(hi, limit)</code>？</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-type">int</span> hi = limitHigh ? Math.min(high[i] - <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-keyword">limit</span>) : <span class="hljs-number">9</span>;<br></code></pre></td></tr></table></figure>
<p>你就隐含地说：<strong><code>hi</code> 是由 limit 限制的，而不是由 high 限制的</strong>，这就导致之后的 <code>limitHigh &amp;&amp; d == hi</code> 判断会出错！</p>
<p><strong>举个例子：</strong></p>
<p>假设 <code>high = 5299</code>, 当前正在处理第 1 位（从左往右），也就是处理 <code>2</code>，而 <code>limit = 1</code>。</p>
<p>如果你写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">hi = Math.min(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>) = <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>
<p>你会枚举 <code>0,1</code> 而不是原本允许的 <code>0,1,2</code>，并且还会让 <code>limitHigh &amp;&amp; d == hi</code> 在本应为 <code>d==2</code> 时失效！</p>
<p><strong>正确的逻辑应该是：</strong></p>
<ul>
<li><code>hi</code> <strong>始终</strong>由 <code>limitHigh ? high[i] : 9</code> 来决定；</li>
<li><code>limit</code> 是附加的“过滤”逻辑，不应该影响 Digit DP 的状态定义；</li>
<li>在<strong>枚举循环内部</strong>使用 <code>Math.min(hi, limit)</code> 来限制合法的数位；</li>
<li>这样才能确保转移关系和 memo 的缓存是准确的。</li>
</ul>
<p>递归终点：<code>dfs(n, *, *) = 1</code>，表示成功构造出一个合法数字。</p>
<p>递归入口：<code>dfs(0, true, true)</code>，表示：</p>
<ul>
<li>从最高位开始枚举。</li>
<li>一开始要受到 <code>start</code> 和 <code>finish</code> 的约束（否则就可以随意填了，这肯定不行）。 </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">numberOfPowerfulInt</span><span class="hljs-params">(<span class="hljs-type">long</span> start, <span class="hljs-type">long</span> finish, <span class="hljs-type">int</span> limit, String s)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">low</span> <span class="hljs-operator">=</span> String.valueOf(start);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">high</span> <span class="hljs-operator">=</span> String.valueOf(finish);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> high.length();<br>        low = <span class="hljs-string">&quot;0&quot;</span>.repeat(n - low.length()) + low; <span class="hljs-comment">// 补前导零，和 high 对齐</span><br>        <span class="hljs-type">long</span>[] memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[n];<br>        Arrays.fill(memo, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>, low.toCharArray(), high.toCharArray(), limit, s.toCharArray(), memo);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">boolean</span> limitLow, <span class="hljs-type">boolean</span> limitHigh, <span class="hljs-type">char</span>[] low, <span class="hljs-type">char</span>[] high, <span class="hljs-type">int</span> limit, <span class="hljs-type">char</span>[] s, <span class="hljs-type">long</span>[] memo)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i == high.length) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">if</span> (!limitLow &amp;&amp; !limitHigh &amp;&amp; memo[i] != -<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> memo[i];<br>        &#125;<br><br>        <span class="hljs-comment">// 第 i 个数位可以从 lo 枚举到 hi</span><br>        <span class="hljs-comment">// 如果对数位还有其它约束，应当只在下面的 for 循环做限制，不应修改 lo 或 hi</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">lo</span> <span class="hljs-operator">=</span> limitLow ? low[i] - <span class="hljs-string">&#x27;0&#x27;</span> : <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">hi</span> <span class="hljs-operator">=</span> limitHigh ? high[i] - <span class="hljs-string">&#x27;0&#x27;</span> : <span class="hljs-number">9</span>;<br><br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (i &lt; high.length - s.length) &#123; <span class="hljs-comment">// 枚举这个数位填什么</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> lo; d &lt;= Math.min(hi, limit); d++) &#123;<br>                res += dfs(i + <span class="hljs-number">1</span>, limitLow &amp;&amp; d == lo, limitHigh &amp;&amp; d == hi, low, high, limit, s, memo);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> s[i - (high.length - s.length)] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (lo &lt;= x &amp;&amp; x &lt;= hi) &#123; <span class="hljs-comment">// 题目保证 x &lt;= limit，无需判断</span><br>                res = dfs(i + <span class="hljs-number">1</span>, limitLow &amp;&amp; x == lo, limitHigh &amp;&amp; x == hi, low, high, limit, s, memo);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (!limitLow &amp;&amp; !limitHigh) &#123;<br>            memo[i] = res; <span class="hljs-comment">// 记忆化 (i,false,false)</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="统计对称整数的数目"><a href="#统计对称整数的数目" class="headerlink" title="统计对称整数的数目"></a>统计对称整数的数目</h2><h3 id="暴力判断-O-high−low-loghigh"><a href="#暴力判断-O-high−low-loghigh" class="headerlink" title="暴力判断 O((high−low)loghigh)"></a>暴力判断 O((<em>high</em>−<em>low</em>)log<em>high</em>)</h3><h3 id="数位-dp-2"><a href="#数位-dp-2" class="headerlink" title="数位 dp"></a>数位 dp</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">char</span>[] lowS, highS;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> n, m, diffLh;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[][][] memo;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countSymmetricIntegers</span><span class="hljs-params">(<span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> &#123;<br>        lowS = String.valueOf(low).toCharArray();<br>        highS = String.valueOf(high).toCharArray();<br>        n = highS.length;<br>        m = n / <span class="hljs-number">2</span>;<br>        diffLh = n - lowS.length;<br><br>        memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][diffLh + <span class="hljs-number">1</span>][m * <span class="hljs-number">18</span> + <span class="hljs-number">1</span>]; <span class="hljs-comment">// 注意 start &lt;= diffLh</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[][] mat : memo) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] row : mat) &#123;<br>                Arrays.fill(row, -<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 初始化 diff = m * 9，避免出现负数导致 memo 下标越界</span><br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>, m * <span class="hljs-number">9</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> diff, <span class="hljs-type">boolean</span> limitLow, <span class="hljs-type">boolean</span> limitHigh)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i == n) &#123;<br>            <span class="hljs-keyword">return</span> diff == m * <span class="hljs-number">9</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// start 当 isNum 用</span><br>        <span class="hljs-keyword">if</span> (start != -<span class="hljs-number">1</span> &amp;&amp; !limitLow &amp;&amp; !limitHigh &amp;&amp; memo[i][start][diff] != -<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> memo[i][start][diff];<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">lo</span> <span class="hljs-operator">=</span> limitLow &amp;&amp; i &gt;= diffLh ? lowS[i - diffLh] - <span class="hljs-string">&#x27;0&#x27;</span> : <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">hi</span> <span class="hljs-operator">=</span> limitHigh ? highS[i] - <span class="hljs-string">&#x27;0&#x27;</span> : <span class="hljs-number">9</span>;<br><br>        <span class="hljs-comment">// 如果前面没有填数字，且剩余数位个数是奇数，那么当前数位不能填数字</span><br>        <span class="hljs-keyword">if</span> (start &lt; <span class="hljs-number">0</span> &amp;&amp; (n - i) % <span class="hljs-number">2</span> &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 如果必须填数字（lo &gt; 0），不合法，返回 0</span><br>            <span class="hljs-keyword">return</span> lo &gt; <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : dfs(i + <span class="hljs-number">1</span>, start, diff, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>);<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isLeft</span> <span class="hljs-operator">=</span> start &lt; <span class="hljs-number">0</span> || i &lt; (start + n) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> lo; d &lt;= hi; d++) &#123;<br>            res += dfs(i + <span class="hljs-number">1</span>,<br>                       start &lt; <span class="hljs-number">0</span> &amp;&amp; d &gt; <span class="hljs-number">0</span> ? i : start, <span class="hljs-comment">// 记录第一个填数字的位置</span><br>                       diff + (isLeft ? d : -d), <span class="hljs-comment">// 左半 +，右半 -</span><br>                       limitLow &amp;&amp; d == lo,<br>                       limitHigh &amp;&amp; d == hi);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (start != -<span class="hljs-number">1</span> &amp;&amp; !limitLow &amp;&amp; !limitHigh) &#123;<br>            memo[i][start][diff] = res;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h1><h2 id="统计数组中好三元组数目"><a href="#统计数组中好三元组数目" class="headerlink" title="统计数组中好三元组数目"></a>统计数组中好三元组数目</h2><p>给你两个下标从 <strong>0</strong> 开始且长度为 <code>n</code> 的整数数组 <code>nums1</code> 和 <code>nums2</code> ，两者都是 <code>[0, 1, ..., n - 1]</code> 的 <strong>排列</strong> 。</p>
<p><strong>好三元组</strong> 指的是 <code>3</code> 个 <strong>互不相同</strong> 的值，且它们在数组 <code>nums1</code> 和 <code>nums2</code> 中出现顺序保持一致。换句话说，如果我们将 <code>pos1v</code> 记为值 <code>v</code> 在 <code>nums1</code> 中出现的位置，<code>pos2v</code> 为值 <code>v</code> 在 <code>nums2</code> 中的位置，那么一个好三元组定义为 <code>0 &lt;= x, y, z &lt;= n - 1</code> ，且 <code>pos1x &lt; pos1y &lt; pos1z</code> 和 <code>pos2x &lt; pos2y &lt; pos2z</code> 都成立的 <code>(x, y, z)</code> 。</p>
<p>请你返回好三元组的 <strong>总数目</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><code class="hljs gcode">输入：<span class="hljs-symbol">nums1</span> = [<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>], <span class="hljs-symbol">nums2</span> = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>输出：<span class="hljs-number">1</span><br>解释：<br>总共有 <span class="hljs-number">4</span> 个三元组 <span class="hljs-comment">(x,y,z)</span> 满足 pos<span class="hljs-number">1</span>x &lt; pos<span class="hljs-number">1</span>y &lt; pos<span class="hljs-number">1</span>z ，分别是 <span class="hljs-comment">(2,0,1)</span> ，<span class="hljs-comment">(2,0,3)</span> ，<span class="hljs-comment">(2,1,3)</span> 和 <span class="hljs-comment">(0,1,3)</span> 。<br>这些三元组中，只有 <span class="hljs-comment">(0,1,3)</span> 满足 pos<span class="hljs-number">2</span>x &lt; pos<span class="hljs-number">2</span>y &lt; pos<span class="hljs-number">2</span>z 。所以只有 <span class="hljs-number">1</span> 个好三元组。<br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><code class="hljs gcode">输入：<span class="hljs-symbol">nums1</span> = [<span class="hljs-number">4</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>], <span class="hljs-symbol">nums2</span> = [<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>输出：<span class="hljs-number">4</span><br>解释：总共有 <span class="hljs-number">4</span> 个好三元组 <span class="hljs-comment">(4,0,3)</span> ，<span class="hljs-comment">(4,0,2)</span> ，<span class="hljs-comment">(4,1,3)</span> 和 <span class="hljs-comment">(4,1,2)</span> 。<br></code></pre></td></tr></table></figure>
<h3 id="题意解读"><a href="#题意解读" class="headerlink" title="题意解读"></a>题意解读</h3><p>题目本质上是求：<code>nums1</code> 和 <code>nums2</code> 的长度恰好为 3 的公共子序列的个数。</p>
<p>你可能想到了 [1143. 最长公共子序列]。但本题 $n$ 太大，写 $O(n^2)$ 的 DP 太慢。</p>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>本题是排列，所有元素互不相同。如果可以通过某种方法，把 <code>nums1</code> 变成 <code>[0,1,2, ... ,n - 1]</code>，我们就能把「公共子序列问题」变成「严格递增子序列问题」，后者有更好的性质，可以更快地求解。</p>
<p>此外，本题子序列长度为 3，对于 3 个数的问题，通常可以枚举中间那个数。</p>
<h3 id="前置知识：置换"><a href="#前置知识：置换" class="headerlink" title="前置知识：置换"></a>前置知识：置换</h3><p>置换是一个排列到另一个排列的双射。</p>
<p>以示例 2 为例，定义如下置换 $P(x)$：</p>
<script type="math/tex; mode=display">
\begin{pmatrix}
x & 0 & 1 & 2 & 3 & 4 \\
P(x) & 1 & 2 & 4 & 3 & 0
\end{pmatrix}</script><p>把 <code>nums1 = [4,0,1,3,2]</code> 中的每个元素 $x$ 替换为 $P(x)$，可以得到一个单调递增的排列 $A = [0,1,2,3,4]$。把 $P(x)$ 应用到 <code>nums2 = [4,1,0,2,3]</code> 上，可以得到一个新的排列 $B = [0,2,1,4,3]$。</p>
<p>在置换之前，<code>(4,0,3)</code> 是两个排列的公共子序列。</p>
<p>在置换之后，$(P(4),P(0),P(3)) = (0,1,3)$ 也是两个新的排列的公共子序列。</p>
<p>⚠️注意：置换不是排序，是映射（可以理解成重命名），原来的公共子序列在映射后，子序列元素的位置没变，只是数值变了，仍然是公共子序列。所以置换不会改变公共子序列的个数。 </p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>把 <code>nums1</code> 置换成排列 $A = [0,1,2, … ,n - 1]$，设这一置换为 $P(x)$。把 $P(x)$ 也应用到 <code>nums2</code> 上，得到排列 $B$。</p>
<p>置换后，我们要找的长为 3 的公共子序列，一定是严格递增的。由于 $A$ 的所有子序列都是严格递增的，我们只需关注 $B$。现在问题变成：</p>
<ul>
<li>$B$ 中有多少个长为 3 的严格递增子序列？</li>
</ul>
<p>对于长为 3 的严格递增子序列 $(x,y,z)$，枚举中间元素 $y$。现在问题变成：</p>
<ul>
<li>在 $B$ 中，元素 $y$ 的左侧有多少个比 $y$ 小的数 $x$？右侧有多少个比 $y$ 大的数 $z$？</li>
</ul>
<p>枚举 $y = B[i]$，设 $i$ 左侧有 $less_y$ 个元素比 $y$ 小，那么 $i$ 左侧有 $i - less_y$ 个元素比 $y$ 大。在整个排列 $B$ 中，比 $y$ 大的数有 $n - 1 - y$ 个，减去 $i - less_y$，得到 $i$ 右侧有 $n - 1 - y - (i - less_y)$ 个数比 $y$ 大。所以（根据乘法原理）中间元素是 $y$ 的长为 3 的严格递增子序列的个数为：</p>
<p>$ less_y \cdot (n - 1 - y - (i - less_y)) $</p>
<p>枚举 $y = B[i]$，计算上式，加入答案。</p>
<p>如何计算 $less_y$ ？这可以用<strong>值域树状数组</strong>（或者有序集合）。</p>
<p>值域树状数组的意思是，把元素值视作下标。添加一个值为 3 的数，就是调用树状数组的 <code>update(3,1)</code>。查询小于 3 的元素个数，即小于等于 2 的元素个数，就是调用树状数组的 <code>pre(2)</code>。</p>
<p>由于本题元素值是从 0 开始的，但树状数组的下标是从 1 开始的，所以把元素值转成下标，要加一。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FenwickTree</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span>[] tree;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">FenwickTree</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        tree = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>]; <span class="hljs-comment">// 使用下标 1 到 n</span><br>    &#125;<br><br>    <span class="hljs-comment">// a[i] 增加 val</span><br>    <span class="hljs-comment">// 1 &lt;= i &lt;= n</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">long</span> val)</span> &#123;<br>        <span class="hljs-keyword">for</span> (; i &lt; tree.length; i += i &amp; -i) &#123;<br>            tree[i] += val;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 求前缀和 a[1] + ... + a[i]</span><br>    <span class="hljs-comment">// 1 &lt;= i &lt;= n</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pre</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (; i &gt; <span class="hljs-number">0</span>; i &amp;= i - <span class="hljs-number">1</span>) &#123;<br>            res += tree[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">goodTriplets</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums1.length;<br>        <span class="hljs-type">int</span>[] p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            p[nums1[i]] = i;<br>        &#125;<br><br>        <span class="hljs-type">long</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">FenwickTree</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FenwickTree</span>(n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> p[nums2[i]];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">less</span> <span class="hljs-operator">=</span> t.pre(y);<br>            ans += (<span class="hljs-type">long</span>) less * (n - <span class="hljs-number">1</span> - y - (i - less));<br>            t.update(y + <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote id="fn_1">
<sup>1</sup>. <a href="https://leetcode-cn.com/problems/longest-palindromic-substring/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-bao-gu">https://leetcode-cn.com/problems/longest-palindromic-substring/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-bao-gu</a><a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_2">
<sup>2</sup>. <a href="https://oi-wiki.org/string/manacher/">https://oi-wiki.org/string/manacher/</a><a href="#reffn_2" title="Jump back to footnote [2] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_3">
<sup>3</sup>. <a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-s-114/">https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-s-114/</a><a href="#reffn_3" title="Jump back to footnote [3] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_4">
<sup>4</sup>. <a href="https://leetcode-cn.com/problems/container-with-most-water/solution/sheng-zui-duo-shui-de-rong-qi-by-leetcode-solution/">https://leetcode-cn.com/problems/container-with-most-water/solution/sheng-zui-duo-shui-de-rong-qi-by-leetcode-solution/</a><a href="#reffn_4" title="Jump back to footnote [4] in the text."> &#8617;</a>
</blockquote>
]]></content>
      <tags>
        <tag>data structure, algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>6.824 学习记录</title>
    <url>/uncategorized/6-824/</url>
    <content><![CDATA[<h1 id="Patterns-and-Hints-for-Concurrency-in-Go"><a href="#Patterns-and-Hints-for-Concurrency-in-Go" class="headerlink" title="Patterns and Hints for Concurrency in Go"></a>Patterns and Hints for Concurrency in Go</h1><p>Lecture 10: Guest Lecture on Go: Russ Cox - YouTube<br><a href="https://www.youtube.com/watch?v=IdCbMO0Ey9I">https://www.youtube.com/watch?v=IdCbMO0Ey9I</a></p>
<p>Transcript:<br>okay uh good afternoon good morning good evening good night wherever you are uh let’s get started again uh so uh today we have a guest lecture and probably speaker that needs a little introduction uh uh there’s uh russ cox uh who’s one of the co-leads on the go uh project and you know we’ll talk a lot more about it uh let me say a couple words uh and not try to embarrass russ too much russia has a long experience with distributed systems uh he was a developer and contributor to plan nine uh when he was a high school<br>student and as an undergrad at harvard he joined the phd program at mit uh which is where we met up and probably if you’re taking any sort of you know pdos class if you will there’s going to be a you will see russ’s touches on it and certainly in 824 you know the the go switch to go for us has been a wonderful thing and uh but if you differ in opinion of course feel free to ask russ questions and make suggestions um he’s always welcome to uh entertain any ideas so with that russ it’s yours great<br>thanks can you still see the slides is that working okay great so um so we built go to support writing the sort of distributed systems that we were building at google and that made go a great fit for you know what came next which is now called cloud software and also a great fit for a24 um so in this lecture i’m going to try to explain how i think about writing some current programs in go and i’m going to walk through the sort of design and implementation of programs for four different patterns that i see come up often<br>and along the way i’m going to try to highlight some hints or rules of thumb that you can keep in mind when designing your own go programs and i know the syllabus links to an older version of these slides so you might have seen them already i hope that the lecture form is a bit more intelligible than just sort of looking at the slides um and i hope that in general these patterns are like common enough that you know maybe they’ll be helpful by themselves but also that you know you’ll you’ll the hints will help you prepare<br>for whatever it is you need to implement so to start it’s important to distinguish between concurrency and parallelism and concurrency is about how you write your programs about being able to compose independently executing control flows whether you want to call them processes or threads or go routines so that your program can be dealing with lots of things at once without turning into a giant mess on the other hand parallelism is about how the programs get executed about allowing multiple computations to run<br>simultaneously so that the program can be doing lots of things at once not just dealing with lots of things at once and so concurrency lends itself naturally to parallel execution but but today the focus is on how to use go’s concurrency support to make your programs clearer not to make them faster if they do get faster that’s wonderful but but that’s not the point today so i said i’d walk through the design and implementation of some programs for four common concur excuse me concurrency patterns that i see often<br>but before we get to those i want to start with what seems like a really trivial problem but that illustrates one of the most important points about what it means to use concurrency to structure programs a decision that comes up over and over when you design concurrent programs is whether to represent states as code or as data and by as code i mean the control flow in the program so suppose we’re reading characters from a file and we need to scan over a c style quoted string oh hello so the slides aren’t changing<br>yeah it will they well can you see prologue gorgeous for state right now no we see the title slide oh no yeah i was wondering about that because um there was like a border around this thing when i started and then it went away so let me let me just unshare and reshare i have to figure out how to do that in zoom uh unfortunately the keynote menu wants to be up and i don’t know how to get to the zoom menu um ah my screen sharing is paused why is my screen sharing paused can i resume there we go yeah all right i don’t know the zoom box says<br>your screen sharing is paused so if that now now the border’s back so i’ll watch that all right so um see i was back here so so you know we’re reading a string it’s not a parallel program it’s reading one character at a time so there’s no opportunity for parallelism but there is a good opportunity for concurrency so if we don’t actually care about the exact escape sequences in the string what we need to do is match this regular expression and we don’t have to worry about understanding it exactly<br>we’ll come back to what it means but but that’s basically all you have to do is implement this regular expression and so you know you probably all know you can turn a regular expression into a state machine and so we might use a tool that generates this code and in this code there’s a single variable state that’s the state of the machine and the loop goes over the state one character at a time reads a character depending on the state and the character changes to a different state until it gets to the end<br>and so like this is a completely unreadable program but it’s the kind of thing that you know an auto-generated program might look like and and the important point is that the program state is stored in data in this variable that’s called state and if you can change it to store the state in code that’s often clearer so here’s what i mean um suppose we duplicate the read care calls into each case of the switch so we haven’t made any semantic changes here we just took the read care that was at<br>the top and we moved it into the middle now instead of setting state and then immediately doing the switch again we can change those into go to’s and then we can simplify a little bit further there’s a go to state one that’s right before the state one label we can get rid of that then there’s a um i guess yeah so then there’s uh you know there’s only one way to get to state two so we might as well pull the state two code up and put it inside the if where the go to appears and then you know both sides of that if<br>now end in go to state one so we can hoist that out and now what’s left is actually a pretty simple program you know state zero is never jumped to so it just begins there and then state one is just a regular loop so we might as well make that look like a regular loop um and now like this is you know looking like a program and then finally we can you know get rid of some variables and simplify a little bit further and um and we can rotate the loop so that you know we don’t do a return true in the middle of the loop we do the<br>return true at the end and so now we’ve got this program that is actually you know reasonably nice and it’s worth mentioning that it’s possible to clean up you know much less egregious examples you know if you had tried to write this by hand your first attempt might have been the thing on the left where you’ve got this extra piece of state and then you can apply the same kinds of transformations to move that state into the actual control flow and end up at the same program that we have on the right that’s cleaner<br>so this is you know a useful transformation to keep in mind anytime you have state that kind of looks like it might be just reiterating what’s what’s happening in the program counter um and so you know you can see this if the the origin in the original state like if state equals zero the program counter is at the beginning of the function and if state equals one or if an escape equals false and the other version the per encounter is just inside the for loop and state equals two is you know further down in the for loop<br>and the benefit of writing it this way instead of with the states is that it’s much easier to understand like i can actually just walk through the code and explain it to you you know if you just read through the code you read an opening quote and then you start looping and then until you find the closing quote you read a character and if it’s a backslash you skip the next character and that’s it right you can just read that off the page which you couldn’t do in the original this version also happens to run<br>faster although that doesn’t really matter for us um but as i mentioned i’m going to highlight what i think are kind of important lessons as hints for designing your own go programs and this is the first one to convert data state into code state when it makes your programs clearer and again like these are all hints you should you shouldn’t you know for all of these you should consider it as you know only if it helps you can decide so one problem with this hint is that not all programs have the luxury of<br>having complete control over their control flow so you know here’s a different example instead of having a read care function that can be called this code is written to have a process care method that you have to hand the character to one at a time and then process care has no choice really but to you know encode its state in an explicit state variable because after every character it has to return back out and so it can’t save the state in the program counter in the stack it has to have the state in an actual variable but<br>in go we have another choice right because we can’t save the state on that stack and in that program counter but you know we can make another go routine to hold that state for us so supposing we already have this debugged read string function that we really don’t want to rewrite in this other way we just want to reuse it it works maybe it’s really big and hairy it’s much more complicated than the thing we saw we just want to reuse it and so the way we can do that and go is we can start a new go routine<br>that does the read string part and it’s the same read string code as before we pass in the character reader and now here the um you know the init method makes this this go routine to do the character reading and then every time the process care method is called um we send a message to the go routine on the car channel that says here’s the next character and then we receive a message back that says like tell me the current status and the current status is always either i need more input or you know it basically you know was it okay or not<br>and so um you know this lets us move the this the program counter that we we couldn’t do on the first stack into the other stack of the go routine and so using additional go teams is a great way to hold additional code state and give you the ability to do these kinds of cleanups even if the original structure the product the problem makes it look like you can’t but go ahead i i assume you’re fine with uh people asking questions yeah absolutely i just wanted to make sure that yeah yeah definitely please<br>interrupt um and so so the hint here is to use additional go routines to hold additional code state and there’s there’s one caveat to this and then it’s not free to to just make go routines right you have to actually make sure that they exit because otherwise you’ll just accumulate them and so you do have to think about uh you know why does the go routine exit like you know is it going to get cleaned up and in this case we know that you know q dot parse is going to return where you know parse go<br>sorry that’s not right um oh sorry the read string here read string is going to return any time it sends a a message that says need more input where’d it go there’s something missing from this slide sorry i went through this last night um so so as we go in we go into init we kick off this go routine it’s going to call read care a bunch of times and then we read the status once and that that first status is going to happen because the the first call to read care from read string is going to send i need<br>more input and then we’re going to send a character back um we’re going to send the character back in process care and then every time process care gets called it returns a status and so up until you get um you know need more input you’re going to get the um uh sorry this is not working um you’re going to get any more input for every time you want to read a character and then when it’s done reading characters what i haven’t shown you here what seems to be missing somehow is when things exit and when<br>things exit let’s see if it’s on this slide yeah so there’s a return success and a return bad input that i’d forgotten about and so uh you know these return a different status and then they’re done so when process care uh you know in in the read stream version when it returns you know bad input or success we we say that you know it’s done and so as long as the caller is going through and um you know calling until it gets something that’s not need more input then the go routine will finish but you<br>know maybe if we stop early if the caller like hits an eof and stops on its own without telling us that it’s done there’s a go routine left over and so that could be a problem and so you just you need to make sure that you know when and why each go routine will exit and the nice thing is that if you do make a mistake and you leave guardians stuck they just sit there it’s like the best possible bug in the world because they just sit around waiting for you to look at them and all you have to do is remember to<br>look for them and so you know here’s a very simple program at least go routines and it runs an http server and so you know if we run this it kicks off a whole bunch of effort routines and they all uh block trying to send to a channel and then it makes the http server and so if i run this program it just sits there and if i type control backslash on a unix system i get a sig quit which makes it crash and dump all the stacks of the go routines and you can see on the slide that you know it’s going to print over and over<br>again here’s the go routine in h called from g called from f and and in a channel send and if you look at the line numbers you can see exactly where they are another option is that since we’re in an http server and the hp server imports the net http prof package you can actually just visit the http server’s debug pprofgoreteen url which gives you the stacks of all the running go routines and unlike the crash dump it takes a little more effort and it deduplicates the go routines based on their stacks<br>and so and then it sorts them by how many there are of each stack and so if you have a go routine leak the leak shows up at the very top so in this case you’ve got 100 go routines stuck in h called from g call from f and then we can see there’s like one of a couple other go routines and we don’t really care about them and so you know this is a new hint that it just it’s really really useful to look for stucco routines by just going to this end point all right so that was kind of the warm-up now i<br>want to look at the first real concurrency pattern which is a publish subscribe server so publish subscribe is a way of structuring a program that you decouple the parts that are publishing interesting events from the things that are subscribing to them and there’s a published subscriber pub sub server in the middle that connects those so the individual publishers and the individual subscribers don’t have to be aware of exactly who the other ones are so you know on your android phone um an app might publish a make a phone<br>call event and then the the dialer might subscribe to that and actually start and you know help dial and and so in a real pub sub server there are ways to filter events based on like what kind they are so that when you publish and make a phone call event like it doesn’t go to your email program but you know for now we’re just going to assume that the filtering is taken care of separately and we’re just worried about the actual publish and subscribe and the concurrency of that so here’s an api we want to implement with any number of<br>clients that can call subscribe with a channel and afterwards events that are published will be sent on that channel and then when a client is no longer interested it can call cancel and pass in the same channel to say stop sending me events on that channel and the way that cancel will signal that it really is done sending events on that channel is it will close the channel so that the the receive the caller can can keep receiving events until it sees the channel get closed and then it knows that the cancel has taken effect<br>um so notice that the information is only flowing one way on the channel right you can send to the channel and then it the receiver can receive from it and the information flows from the sender to the receiver and it never goes the other way so closing is also a signal from the sender to the receiver but all the sending is over the receiver cannot close the channel to tell the sender like i don’t want you to send anymore because that’s information going the opposite direction and it’s just a lot easier to reason about<br>if the information only goes one way and of course if you need communication in both directions you can use a pair of channels and it often turns out to be the case that those uh different directions may have different types of data flowing like before we saw that there were runes going in one direction and status updates going in the other direction so how do we implement this api here’s a pretty basic implementation that you know could be good enough we have a server and the server state is a map of registered subscriber channels<br>protected by a lock we initialize the server by just allocating the map and then to publish the event we just send it to every registered channel to subscribe a new channel we just add it to the map and to cancel we take it out of the map and then because these are all um these are all methods that might be called from multiple go routines um we need to call lock and unlock around these to um you know protect the map and notice that i wrote defer unlock right after the lock so i don’t have to remember to unlock it later<br>uh you’ve probably all seen this you know it’s sort of a nice idiom to just do the lock unlock and then you know have a blank line and have that be its own kind of paragraph in the code one thing i want to point out is that using defer makes sure that the mutex gets unlocked even if you have multiple returns from the function so you can’t forget but it also makes sure that it gets unlocked if you have a panic like in subscribe and cancel where there’s you know panics for misuse and there is a subtlety here about if<br>you might not want to unlock the mutex if the panic happened while the thing that was locked is in some inconsistent state but i’m going to ignore that for now in general you try to avoid having the the things that might panic happen while you’re you know potentially an inconsistent state and i should also point out that the use of panic at all in subscribe and cancel implies that you really trust your clients not to misuse the interface that it is a program error worth you know tearing down the entire program<br>potentially for that to happen and in a bigger program where other clients were using this api you’d probably want to return an error instead and not have the possibility of taking down the whole program but panicking simplifies things for now and you know error handling in general is kind of not the topic today a more important concern with this code than panics is what happens if a go routine is slow to receive events so all the operations here are done holding the mutex which means all the clients kind of have to proceed in<br>lockstep so during publish there’s a loop that’s sending on the channels sending the event to every channel and if one subscriber falls behind the next subscriber doesn’t get the event until that slow subscriber you know wakes up and actually gets the the event off off that channel and so one slow subscriber can slow down everyone else and you know forcing them to proceed in lockstep this way is not always a problem if you’ve you know documented the restriction and for whatever reason you know how the<br>clients are are written and you know that they won’t ever fall too far behind this could be totally fine it’s a really simple implementation and um and it has nice properties like on return from publish you know that the event has actually been handed off to each of the other grow routines you don’t know that they’ve started processing it but you know it’s been handed off and so you know maybe that’s good enough and you could stop here a second option is that if you need to tolerate just a little bit of slowness<br>on the the subscribers then you could say that they need to give you a buffered channel with room for a couple events in the buffer so that you know when you’re publishing you know as long as they’re not too far behind there’ll always be room for the new event to go into the channel buffer and then the actual publish won’t block for too long and again maybe that’s good enough if you’re sure that they won’t ever fall too far behind you get to stop there but in a really big program you do want to cope more gracefully with<br>arbitrarily arbitrarily slow subscribers and so then the question is what do you do and so you know in general you have three options you can slow down the event generator which is what the previous solutions implicitly do because publish stops until the subscribers catch up or you can drop events or you can queue an arbitrary number of past events those are pretty much your only options so we talked about you know publish and slowing down the event generator there’s a middle ground where you coalesce the events or you drop them<br>um so that you know the subscriber might find out that you know hey you missed some events and i can’t tell you what they were because i didn’t save them but but i’m at least going to tell you you missed five events and then maybe it can do something else to try to catch up and this is the kind of approach that um that we take in the profiler so in the profiler if you’ve used it if uh there’s a go routine that uh fills the profile on on a signal handler actually with profiling events and then there’s a<br>separate go routine whose job is to read the data back out and like write it to disk or send it to a http request or whatever it is you’re doing with profile data and there’s a buffer in the middle and if the receiver from the profile data falls behind when the buffer fills up we start adding entries to a final profile entry that just has a single entry that’s that’s a function called runtime.<br>lost profile data and so if you go look at the profile you see like hey the program spent five percent of its time in lost profile data that just means you know the the profile reader was too slow and it didn’t catch up and and we lost some of the profile but we’re clear about exactly you know what the error rate is in the profile and you pretty much never see that because all the readers actually do keep up but just in case they didn’t you have a pretty clear signal um an example of purely dropping the events is the os signal package<br>where um you have to pass in a channel that will be ready to receive the signal a signal like sig hop or sig quit and when the signal comes in the run time tries to send to each of the channels that subscribe to that signal and if it can’t send to it it just doesn’t it’s just gone um because you know we’re in a signal handler we can’t wait and so what the callers have to do is they have to pass in a buffered channel and if they pass in a buffered channel that has you know length at least one<br>buffer length at least one and they only register that channel to a single signal then you know that if a signal comes in you’re definitely going to get told about it if it comes in twice you might only get told about it once but that’s actually the same semantics that unix gives to processes for signals anyway so that’s fine so those are both examples of dropping or coalescing events and then the third choice is that you might actually just really not want to lose any events it might just be really important that you<br>never lose anything in which case you know you can queue an arbitrary number of events you can somehow arrange for the program to just save all the events that the you know slow subscriber hasn’t seen yet somewhere and and give them to the subscriber later and it’s really important to think carefully before you do that because in a distributed system you know there’s always slow computers always computers that have fallen offline or whatever and they might be gone for a while and so you don’t want to introduce<br>unbounded queuing in general you want to think very carefully before you do that and think well you know how unbounded is it really and can i tolerate that and so like that’s a reason why channels don’t have just an unbounded buffering it’s really almost never the right choice and if it is the right choice you probably want to build it very carefully um and so but we’re going to build one just to see what it would look like and before we do that i just want to adjust the program a little bit so we have this mutex in the code<br>and the mutex is an example of of keeping the the state whether you’re locked or not in a state variable but we can also move that into a program counter variable by putting it in a different go routine and so in this case we can start a new go routine that runs a program a function called s dot loop and it handles requests sent on three new channels publish subscribe and cancel and so in init we make the channels and then we we kick off s dot loop and s dot loop is sort of the amalgamation of the previous method<br>bodies and it just receives from any of the three channels a request a publish a subscriber a cancel request and it does whatever was asked and now that map the subscriber map can be just a local variable in s dot loop and and so um you know it’s the same code but now that data is clearly owned by s.<br>loop nothing else could even get to it because it’s a local variable and then we just need to change the original methods to send the work over to the loop go routine and so uppercase publish now sends on lowercase publish the channel the event that it wants to publish and similarly subscribe and cancel they create a request that has a channel uh that we want to subscribe and also a channel to get the answer back and they send that into the loop and then the loop sends back the answer and so i referred to transforming the program this way as like converting the<br>mutex into a go routine because we took the data state of the mutex there’s like a lock bit inside it and now that lock bit is implicit in the program counter of the loop um it’s very clear that you can’t ever have you know a publish and subscribe happening at the same time because it’s just single threaded code and just you know executes in sequence on the other hand the the original version had a kind of like clarity of state where you could sort of inspect it and and reason about well this is the<br>important state and and it’s harder in the go routine version to see like what’s important state and what’s kind of incidental state from just having a go routine and in a given situation you know one might be more important than the other so a couple years ago i did all the labs for the class when it first switched to go and and raft is a good example of where you probably prefer the state with the mutex is because raft is is so different from most concurrent programs and that like each replica is just kind of profoundly<br>uncertain of its state right like the state transitions you know one moment you think you’re the leader and the next moment you’ve been deposed like one moment your log has ten entries the next moment you find actually no it only has two entries and so being able to manipulate that state directly rather than having to you know somehow get it in and out of the program counter makes a lot more sense for raft but that’s pretty unique in most situations it cleans things up to put the state in the program counter<br>all right so in order to deal with the slow subscribers now we’re going to add some helper go routines and their job is to manage a particular subscriber’s backlog and keep the overall program from blocking and so this is the helper go team and the the the main loop go routine will send the events to the helper which we then trust because we wrote it not to fall arbitrarily behind and then the helpers job is to cue events if needed and send them off to the subscriber all right so this actually has um two<br>problems the first is that if there’s nothing in the queue then the select is actually wrong to try to offer q of zero and in fact just evaluating q of zero at the start of the select will panic because the queue is empty and so we can fix these by setting up the arguments separately from the select and in particular we need to make a channel send out that’s going to be nil which is never able to proceed in a select um as we know when we don’t want to send and it’s going to be the actual out channel when we do want to send and<br>then we have to have a separate variable that holds the event that we’re going to send it will only you know actually read from q of 0 if there’s something in the queue the second thing that’s wrong is that we need to handle closing of the channel of the input channel because when the input channel closes we need to flush the rest of the queue and then we need to close the output channel so to check for that we change the select from just doing e equals receive from n to e comma okay equals receive from n and the comma<br>okay we’ll be told whether or not the channel is actually sending real data or else it’s closed and so when okay is false we can set into nil to say let’s stop trying to receive from in there’s nothing there we’re just going to keep getting told that it’s closed and then when the loop is fine when the queue is finally empty we can exit the loop and so we change the for condition to say we want to keep exiting the loop as long as there actually still is an input channel and there’s something<br>to write back to the output channel and then once both of those are not true anymore it’s time to close it’s time to exit the loop and we close the output channel and we’re done and so now we’ve correctly propagated the closing of the input channel to the output channel so that was the helper and the server loop used to look like this and to update it we just changed the subscription map before it was a map from subscribe channels to bools it was just basically a set and now it’s a map from subscribe<br>channel to helper channel and every time we get a new subscription we make a helper channel we kick off a helper go routine and we record the helper channel in the subscription map instead of the the actual channel and then the rest of uh the rest of the the loop actually barely changes at all so i do want to point out that like if you wanted to have a different strategy for you know what you do with uh clients that fall too far behind that can all go in the helper go routine the code on the screen right now is completely unchanged so we’ve we’ve<br>completely separated the publish subscribe maintaining the the actual list of subscribers map from the what do you do when things get too slow map or problem and so it’s really nice that you’ve got this clean separation of concerns into completely different go routines and that can help you you know keep your program simpler and so that’s the general hint is that you can use go routines a lot of the time to separate independent concerns all right so um the second pattern for today is a work scheduler<br>and you did one of these in lab one for mapreduce and i’m just gonna you know build up to that and and this doesn’t do all the rpc stuff it just kind of assumes that there’s kind of channel channel based interfaces to all the the servers so you know we have this function scheduled it takes a fixed list of servers has a number of tasks to run and it has just this abstracted function call that you you call to run the task on a specific server you can imagine it was you know doing the rpcs underneath so we’re going to need some way to keep<br>track of which servers are available to execute new tasks and so one option is to use our own stack or queue implementation but another option is to use a channel because it’s a good synchronized queue and so we can send into the channel to add to the queue and receive from it to pop something off and in this case we’ll make the queue be a queue of servers and we’ll start off it’s a queue of idle servers servers that aren’t doing any work for us right now and we’ll start off by just initializing<br>it by sending all the known servers into the idle list and then we can loop over the tasks and for every task we kick off a go routine and its job is to pull a server off the idle list run the task and then put the server back on and this loop body is another example of the earlier hint to use guaranteeing select independent things run independently because each task is running as a separate concern they’re all running in parallel unfortunately there are two problems with this program the first one is that the closure that’s<br>running as a new go routine refers to the loop iteration variable which is task and so by the time the go routine starts exiting you know the loop has probably continued and done at task plus plus and so it’s actually getting the wrong value of task you’ve probably seen this by now um and of course the best way to to catch this is to run the race detector and at google we even encourage teams to set up canary servers that run the race detector and split off something like you know 0.<br>1 percent of their traffic to it just to catch um you know races that might be in the production system and you know finding a bug with a race detector is is way better than having to debug some you know corruption later so there are two ways to fix this race the first way is to give the closure an explicit parameter and pass it in and the go statement requires a function call specifically for this reason so that you can set specific arguments that get evaluated in the context of the original go routine and then get copied to the new<br>go routine and so in this case we can declare a new argument task two we can pass task to it and then inside the go routine task 2 is a completely different copy of of task and i only named it task 2 to make it easier to talk about but of course there’s a bug here and the bug is that i forgot to update task inside the function to refer to task two instead of task and so we basically never do that um what we do instead is we just give it the same name so that it’s impossible now for the code inside the go regime to<br>refer to the wrong copy of task um that was the first way to fix the race there’s a second way which is you know sort of cryptic the first time you see it but it amounts to the same thing and that is that you just make a copy of the the variable inside the loop body so every time a colon equals happens that creates a new variable so in the for loop in the outer for loop there’s a colon equals at the beginning and there’s not one the rest of the loop so that’s all just one variable for the entire loop<br>whereas if we put a colon equals inside the body every time we run an iteration of the loop that’s a different variable so if the guard if the go function closure captures that variable those will all be distinct so we can do the same thing we do task two and this time i remember to update the body but you know just like before it’s too easy to forget to update the body and so typically you write task colon equals task which looks kind of magical the first time you see it but but that’s what it’s for<br>all right so i said there were two bugs in the program the first one was this race on task and the second one is that uh we didn’t actually do anything after we kicked off all the tasks we’re not waiting for them to be done um and and in particular uh we’re kicking them off way too fast because you know if there’s like a million tasks you’re going to kick off a million guard teams and they’re all just going to sit waiting for one of the five servers which is kind of inefficient and so what<br>we can do is we can pull the fetching of the the next idle server up out of the go routine and we pull it up out of the go routine now we’ll only kick off a go routine when there is a next server to use and then we can kick it off and and you know use that server and put it back and the using the server and put it back runs concurrently but doing the the fetch of the idle server inside the loop slows things down so that there’s only ever now number of servers go routines running instead of number of tasks<br>and that receive is essentially creating some back pressure to slow down the loop so it doesn’t get too far ahead and then i mentioned we have to wait for the task to finish and so we can do that by just at the end of the loop uh going over the the list again and pulling all the servers out and we’ve pulled you know the right number of servers out of the idle list that means they’re all done and so that’s that’s the full program now to me the most important part of this is that you still get to write a for<br>loop to iterate over the tasks there’s lots of other languages where you have to do this with state machines or some sort of callbacks and you don’t get the luxury of encoding this in the control flow um and so this is a you know much cleaner way where you can just you know use a regular loop but there are some some changes we could make some improvements and so one improvement is to notice that there’s only one go routine that makes requests of a server at a particular time so instead of having one go routine per<br>task maybe we should have one go routine per server because there are probably going to be fewer servers than tasks and to do that we have to change from having a channel of idle servers to a channel of you know yet to be done tasks and so we’ve renamed the idle channel to work and then we also need a done channel to count um you know how many uh tasks are done so that we know when we’re completely finished and so here there’s a new function run tasks and that’s going to be the per server function and we kick off one of<br>them for each server and run tasks his job is just to loop over the work channel run the tasks and when the server is done we send true to done and the you know the server tells us that you know it’s done and the server exits when the work channel gets closed that’s what makes that for loop actually stop so then you know having kicked off the servers we can then just sit there in a loop and send each task to the work channel close the work channel and say hey there’s no more work coming all the servers you should finish and then and<br>then exit and then wait for all the servers to tell us that they’re done so in the lab there were a couple complications one was that you know you might get new servers at any given time um and so we could change that by saying the servers come in on a channel of strings and and that actually fits pretty well into the current structure where you know when you get a new server you just um kick off a new uh run tasks go routine and so the only thing we have to change here is to put that loop into its own go routine so that while<br>we’re sending tasks to servers we can still accept new servers and kick off the helper go routines but now we have this problem that we don’t really have a good way to tell when all the servers are done because we don’t know how many servers there are and so we could try to like maintain that number as servers come in but it’s a little tricky and instead we can count the number of tasks that have finished so we just move the done sending true to done up a line so that instead of doing it per server<br>we now do it per task and then at the end of the loop or at the end of the function we just have to wait for the right number of tasks to be done and so so now again we sort of know uh why these are gonna the finish um there’s actually a deadlock still and that is that if the the number of tasks is um is too big actually i think always you you’ll get a deadlock and if you run this you know you get this nice thing where the dirt it tells you like hey your routines are stuck and the problem is that you know we have this run task uh<br>server loop and the server loop is trying to say hey i’m done and you’re trying to say hey like here’s some more work so if you have more than one task you’ll run into this deadlock where you know you’re trying to send the next task to a server i guess that is more task than servers you’re trying to send the next task to a server and all the servers are trying to say hey i’m done with the previous task but you’re not there to receive from the done channel and so again you know it’s really nice<br>that the the guardians just hang around and wait for you to look at them and we can fix this one way to fix this would be to add a separate loop that actually does a select that either sends some work or accounts for some of the work being done that’s fine but a cleaner way to do this is to take the the work sending loop the task sending loop and put it in its own go routine so now it’s running independently of the counting loop and the counting loop can can run and you know unblock servers that are done with certain tasks while<br>other tasks are still being sent but the simplest possible fix for this is to just make the work channel big enough that you’re never gonna run out of space because we might decide that you know having a go routine per task is you know a couple kilobytes per task but you know an extra inch in the channel is eight bytes so probably you can spend eight bytes per task and so if you can you just make the work channel big enough that you know that all the sends on work are going to never block and you’ll always get down to the the counting loop<br>at the end pretty quickly and so doing that actually sets us up pretty well for the other wrinkle in the lab which is that sometimes calls can time out and here i’ve modeled it by the call returning a false so just say hey it didn’t work um and so you know in run task it’s really easy to say like if it’s really easy to say like if the call uh fails then or sorry if the call succeeds then you’re done but if it fails just put the task back on the work list and because it’s a queue not a stack<br>putting it back on the work list is very likely to hand it to some other server um and so that will you know probably succeed because it’s some other server i mean this is all kind of hypothetical but um uh it’s a really you know it fits really well into the structure that we’ve created all right and the final change is that because the server guarantees are sending on work we do have to uh wait to close it until we know that they’re done sending and uh because again you can’t close you know before they finish sending<br>and so we just have to move the close until after we’ve counted that all the tasks are done um and you know sometimes we get to this point and people ask like why can’t you just kill go routines like why not just be able to say look hey kill all the server guardians at this point we know that they’re not needed anymore and the answer is that you know the go routine has state and it’s interacting with the rest of the program and if it all of a sudden just stops it’s sort of like it hung right and<br>maybe it was holding a lock maybe it was in the middle of some sort of communication with some other guru team that was kind of expecting an answer so we need to find some way to tear them down more gracefully and that’s by telling them explicitly hey you know you’re done you can you can go away and then they can clean up however they need to clean up um you know speaking of cleaning up there’s there’s actually one more thing we have to do which is to shut down the loop that’s that’s watching for new<br>servers and so we do have to put a select in here where uh you know the the thing that’s waiting for new servers on the server channel we have to tell it okay we’re done just like stop watching for new servers because all the servers are gone um and we could make this the caller’s problem but but this is actually fairly easy to do all right so um pattern number three which is a a client for a replicated server of service so here’s the interface that we want to implement we have some service that we want that is replicated for<br>reliability and it’s okay for a client to talk to any one of these servers and so the the replicated client is given a list of servers the uh the arguments to init is a list of servers and a function that lets you call one of the servers with a particular argument set and get a reply and then being given that during init the replicated client then provides a call method that doesn’t tell you what server it’s going to use it just finds a good server to use and it keeps the same keeps using the same server for as long as it can until<br>it finds out that that server is no good so in this situation there’s almost no shared state that you need to isolate and so like the only state that persists from one call to the next is what server did i use last time because i’m going to try to use that again so in this case that’s totally fine for a mutex i’m just going to leave it there it’s always okay to use mutex if that’s the cleanest way to write the code you know some people get the wrong impression from how much we talk about<br>channels but it’s always okay to use a mutex if that’s all you need so now we need to implement this replicated call method whose job is to try sending to lots of different servers right but but first to try the the original server so so what does it mean if you know the try fails well there’s like no clear way for it to fail above it just always returns a reply and so the only way it can fail is if it’s taking too long so we’ll assume that if it takes too long that means it failed so in order to deal with timeouts we<br>have to run that that code in the background in a different go routine so we can do something like this um where we set a timeout we create a timer and then we use the go routine to send in the background and then at the end we wait and either we get the timeout or we get the actual reply if we get the actual reply we return it if we get the timeout we have to do something we’ll have to figure out what to do um it’s worth pointing out that you have to call tdot stop because otherwise the timer sits in a timer queue that you<br>know it’s going to go off in one second and so you know if this call took a millisecond and you have this timer that’s going to sit there for the next second and then you do this in a loop and you get a thousand timers sitting in that that um that queue before they start actually you know um disappearing and so this is kind of a wart in the api but it’s been there forever and we’ve never fixed it um and and so you just have to remember to call stop uh and then you know now we have to figure out what do we do in the case of<br>the timeout and so in the case of the timeout we’re going to need to try a different server so we’ll write a loop and we’ll start at um the id that id0 it says and you know if a reply comes in that’s great and otherwise we’ll reset the timeout and go around the loop again and try sending to a different server and notice there’s only one done channel in this program and so you know on the third iteration of the loop we might be waiting and then finally the first server gives us a reply that’s totally fine we’ll<br>take that reply that’s great um and so then we’ll stop and return it and but if we get all the way through the loop it means that we’ve sent the request to every single server in which case there’s no more timeouts we just have to wait for one of them to come back and so that’s the the plain receive and the return at the end and then it’s important to notice that the done channel is buffered now so that if you know you’ve sent the result to three different servers you’re going to take the first reply and<br>return but the others are going to want to send responses too and we don’t want those go routines to just sit around forever trying to send to a channel that we’re not reading from so we make the buffer big enough that they can send into the buffer and then go away and the channel just gets garbage collected that says like why can’t the timer just be garbage collected when nobody’s referencing it instead of having to to wait when it goes off when you said that you have multiple waiting if it goes off in one<br>millisecond yeah the the problem is the timer is referenced by the the run time it’s in the list of active timers and so calling stop takes it out of the list of active timers and and so like that’s arguably kind of a wart in that like in the specific case of a timer that’s like only going to ever get used in this channel way like we could have special case that by like having the channel because inside the timer is this t.<br>c channel right so we could have had like a different kind of channel implementation that inside had a bit that said hey i’m a timer channel right and and and then like the select on it would like know to just wait but if you just let go of it it would just disappear we’ve kind of like thought about doing that for a while but we never did and so this is like the state of the world um but but you know the garbage collector can’t distinguish between you know the reference inside the runtime and the reference and the rest<br>of the program it’s all just references and so until we like special case that channel in some way like we we can’t actually get rid of that thank you sure so um so then the only thing we have left is to have this preference where we try to use the same um id that we did the previous time and so to do that preference um we you know had the server id coming back in the reply anyway in the result channel and so you know we do the same sort of loop but we loop over an offset from the actual id we’re going to use which is<br>the pre the preferred one and then when we get an answer we uh set the preferred one to where we got the answer from and then we reply and you’ll notice that i used a go to statement that’s okay if you need to go to it’s fine um it’s not sort of there’s no zealotry here all right so uh the fourth one and then we’ll we’ll do some questions um is a protocol multiplexer and this is kind of the logic of a core of any rpc system and and this comes up a lot i feel like i wrote a lot of these in grad school<br>and sort of years after that and so the basic api of a protocol multiplexer is that it sits in from some service which we’re going to pass to the init method and then having been initialized with a service you can call and you can call call and give it a message a request message and then it’ll you know give you back the reply message at some point and the things it needs from the service to do multiflexing is that given a message it has to be able to pull out the tag that uniquely identifies the message<br>and and will identify the the reply because it will come back in with a matching tag and then it needs to be able to send a message out and to receive you know a message but the send and receive um are there arbitrary messages that are not matched it’s the multiplexer’s job to actually match them so um to start with we’ll have a go routine that’s in charge of calling send and another group team that’s in charge of calling receive both in just a simple loop and so to initialize the service we’ll<br>set up the structure and then we’ll kick off the send loop and the receive loop and then we also have a map of pending requests and the map it maps from the tag that we saw the id number in the messages to a channel where the reply is supposed to go the send loop is fairly simple you just range over the things that need to be sent and you send them and this just has the effect of serializing the calls to send because we’re not going to force the service implementation to you know deal with us sending you know from multiple<br>routines at once we’re serializing it so that it can just be thinking of you know sending one one packet at a time and then the receive loop uh is a little bit more complicated it pulls a receive it pulls a reply off the the service and again they’re serialized so we’re only reading one at a time and then it pulls the tag out of the reply and then it says ah i need to find the channel to send this to uh so it pulls the channel out of the pending map it takes it out of the pending map so that you know if we<br>accidentally get another one we won’t try to send it and then it sends the reply and then to do a call you just have to set yourself up in the map and then hand it to send and wait for the reply so we start off we get the tag out we make our own done channel we insert the tag into the map after first checking for bugs and then we send the the argument message to send and then we wait for the reply to come in undone it’s very very simple i mean like i used to write these sort of things in c and it was it was much much worse<br>so that was all the patterns that i wanted to show and um you know i hope that those end up being useful for you in whatever future program you’re writing and and i hope that they’re you know just sort of good ideas even in non-go programs but that you know thinking about them and go can help you when you go to do other things as well so i’m gonna put them all back up and then um i have some questions that fran sent that were you know from all of you and um we’ll probably have some time for uh you know questions from from the chat<br>as well i have no idea in zoom where the chat window is so when we get to that people can just speak up just i don’t use zoom on a daily basis unfortunately um so uh and and normally i know how to use zoom like regularly but with with the presentation it’s like zoom is in this minimize thing that doesn’t have half the things i’m used to anyway um someone asked how long ago took and so far it’s been about 13 and a half years we started discussions in late september 2007 i joined full-time in august 2008 when i<br>finished at mit we did the initial open source launch november 2009 we released go one the sort of first stable version in october 2011. uh or sorry the plan was october 2011. go one itself was march 2012. and then we’ve just been on you know it’s a regular schedule since then the next major change of course is is going to be generics and um and adding generics and that’s probably going to be go 118 which is going to be next in february someone asked you know how big a team does it take to build a language like go<br>and you know for those first two years there were just five of us and and that was enough to get us to uh you know something that we released that actually could run in production but it was fairly primitive um you know it was it was a good prototype it was a solid working prototype but but it wasn’t like what it is today and over time we’ve expanded a fair amount now we’re up to something like 50 people employed directly or employed by google to work directly on go and then there’s tons of open source<br>contributors i mean there’s literal cast of thousands that have helped us over the last 13 years and there’s absolutely no way we could have done it even with 50 people without all the different contributions from the outside someone asked about design priorities um and and motivations and you know we we built it for us right the priority was to build something that was gonna help google and it just turned out that google was like a couple years ahead we were just in a really lucky spot where google was a<br>couple years ahead of the rest of the industry on having to write distributed systems right now everyone using cloud software is is writing programs that talk to other programs and sending messages and you know there’s hardly any single machine programs anymore and so you know we sort of locked into at some level you know building the language that we that the rest of the world needed a couple years later and and then the other thing that that was really a priority was making it work for large numbers of programmers and because<br>you know google had a very large number of programmers working in one code base and and now we have open source where you know even if you’re a small team you’re depending on code that’s written by a ton of other people usually and so a lot of the the issues that come up with just having many programmers still come up in that context so those were really the things we were trying to solve and you know for all of these things we we took a long time before we were willing to actually commit to putting something in the<br>language like everyone basically had to agree in the the core original group and and so that meant that it took us a while to sort of get the pieces exactly the way we wanted them but once we got them there they’ve actually been very stable and solid and really nice and they work together well and and the same thing is kind of happening with generics now where we actually feel i feel personally really good about generics i feel like it feels like the rest of go and that just wasn’t the case for the proposals<br>that we had you know even a couple years ago much less the you know early ones uh someone said they they really like defer uh which is unique to language and and i do too thank you um but i wanted to point out that you know we we did absolutely you know create defer for go but um swift has adopted it and i think there’s a proposal for sipos bus to adopt it as well so you know hopefully it kind of moves out a little bit there was a question about um go and using capitalization for exporting and which i know is like something that<br>uh you know sort of is jarring when you first see it and and the story behind that is that well we needed something and we knew that we would need something but like at the beginning we just said look everything’s exported everything’s publicly visible we’ll deal with it later and after about a year it was like clear that we needed some way to you know let programmers hide things from other programmers and you know c plus plus has this public colon and private colon and in a large struct it’s actually<br>really annoying that like you’re looking you’re in the you’re looking at definitions and you have to scroll backwards and try to find where the like most recent public colon or private colon was and if it’s really big it can be hard to find one and so it’s like hard to tell whether a particular definition is public or private and then in java of course it’s at the beginning of every single field and that seemed kind of excessive too it’s just too much typing and so we looked around some more and<br>and someone pointed out to us that well python has this convention where you put an underscore in front to make something hidden and that seemed interesting but you probably don’t want the default to be not hidden you want the default to be hidden um and then we thought about well we could put like a plus in front of names um and then someone suggested well like what about uppercase could be exported and it seemed like a dumb terrible idea it really did um but as you think about it like i really didn’t like this idea um and i<br>have like very clear memory of sitting of like the room and what i was staring at as we discussed this uh but i had no logical argument against it and it turned out it was fantastic it was like it seemed bad it just like aesthetically but it is one of my favorite things now about go that when you look at a use of something you can see immediately you get that bit of is this something that other people can access or not at every use because if you know you see code calling a function to do you know whatever it is that it does you<br>think oh wow like can other people do that and and you know your brain sort of takes care of that but now i go to c plus and i see calls like that and i get really worried i’m like wait is that is that something other classes can get at um and having that bid actually turns out to be really useful for for reading code a couple people asked about generics if you don’t know we have an active proposal for generics we’re actively working on implementing it we hope that the the release later in the year<br>uh towards the end of the year will actually have you know a full version of generics that you can you can actually use the the um that’ll be like a preview release the real release that we hope it will be in is go 118 which is february of next year so maybe next class uh we’ll actually get to use generics we’ll see but i’m certainly looking forward to having like a generic min and max the reason we don’t have those is that you’d have to pick which type they were for or have like a whole suite of them<br>and it just seemed silly it seemed like we should wait for generics um someone asked is there any area of programming where go may not be the best language but it’s still used and and the answer is like absolutely like that happens all the time with every language um i think go is actually really good all around language um but you know you might use it for something that’s not perfect for just because the rest of your program is written and go and you want to interoperate with the rest of the program so you know there’s this website called<br>the online encyclopedia of integer sequences it’s a search engine you type in like two three five seven eleven and it tells you those are the primes um and it turns out that the back end for that is all written and go and if you type in a sequence it doesn’t know it actually does some pretty sophisticated math on the numbers all with big numbers and things like that and all of that is written in go to because it was too annoying to shell out to maple and mathematica and sort of do that cross-language thing<br>even though you’d much rather implement it in those languages so you know you run into those sorts of compromises all the time and that’s fine um someone asked about uh you know go is supposed to be simple so that’s why there’s like no generics and no sets but isn’t also for software developers and don’t software developers need all this stuff and you know it’s silly to reconstruct it and i think that’s it’s true that there’s someone in tension but but simplicity in the sense of leaving<br>things out was not ever the goal so like for sets you know it just seemed like maps are so close to sets you just have a set a map where the value is empty or a boolean that’s a set and for generics like you have to remember that when we started go in 2007 java was like just finishing a true fiasco of a rollout of generics and so like we were really scared of that we knew that if we just tried to do it um you know we would get it wrong and we knew that we could write a lot of useful programs without generics<br>and so that was what we did and um and we came back to it when you know we felt like okay we’ve you know spent enough time writing other programs we kind of know a lot more about what we need from from generics for go and and we can take the time to talk to real experts and i think that you know it would have been nice to have them five or ten years ago but we wouldn’t have had the really nice ones that we’re going to have now so i think it was probably the right decision um so there was a question about go<br>routines and the relation to the plan line thread library which which was all cooperatively scheduled and whether go routines were ever properly scheduled and like if that caused problems and it is absolutely the case that like go and and the go routine runtime were sort of inspired by previous experience on plan nine there was actually a different language called aleph on an early version plan nine that was compiled it had channels it had select it had things we called tasks which were a little bit like our teens but it<br>didn’t have a garbage collector and that made things really annoying in a lot of cases and also the way that tasks work they were tied to a specific thread so you might have three tasks in one thread and two tasks and another thread and in the three tasks in the first thread the only one ever ran at a time and they could only reschedule during a channel operation and so you would write code where those three tasks were all operating on the same data structure and you just knew because it was in your head when you wrote it<br>that you know it was okay for these two different tasks to be scribbling over the same data structure because they could never be running at the same time and meanwhile you know in the other thread you’ve got the same situation going on with different data and different tasks and then you come back to the same program like six months later and you totally forget which tasks could write to different pieces of data and i’m sure that we had tons of races i mean it was just it was a nice model for small programs<br>and it was a terrible model for for programming over a long period of time or having a big program that other people had to work on so so that was never the model for go the model for go was always it’s good to have these lightweight go routines but they’re gonna all be running independently and if they’re going to share anything they need to use locks and they need to use channels to commute to communicate and coordinate explicitly and and that that has definitely scaled a lot better than any of the planned line stuff ever<br>did um you know sometimes people hear that go routines are cooperatively scheduled and they they think you know something more like that it’s it’s true that early on the go routines were not as preemptively scheduled as you would like so in the very very early days the only preemption points when you called into the run time shortly after that the preemption points were any time you entered a function but if you were in a tight loop for a very long time that would never preempt and that would cause like garbage<br>collector delays because the garbage collector would need to stop all the go routines and there’d be some guaranteeing stuck in a tight loop and it would take forever to finish the loop um and so actually in the last couple releases we finally started we figured out how to get um unix signals to deliver to threads in just the right way so that and we can have the right bookkeeping to actually be able to use that as a preemption mechanism and and so now things are i think i think the preemption delays for garbage<br>collection are actually bounded finally but but from the start the model has been that you know they’re running preemptively and and they don’t get control over when they get preempted uh as a sort of follow-on question someone else asked uh you know where they can look to in the source tree to learn more about guru teams and and the go team scheduler and and the answer is that you know this is basically a little operating system like it’s a little operating system that sits on top of the other operating system instead of on<br>top of cpus um and so the first thing too is like take six eight two eight which is like there i mean i i worked on 6828 and and xv6 like literally like the year or two before i went and did the go run time and so like there’s a huge amount of 688 in the go runtime um and in the actual go runtime directory there’s a file called proc.<br>go which is you know proc stands for process because like that’s what it is in the operating systems um and i would start there like that’s the file to start with and then sort of pull on strings someone asked about python sort of negative indexing where you can write x of minus one and and that comes up a lot especially from python programmers and and it seems like a really great idea you write these like really nice elegant programs where like you want to get the last element you just say x minus one but the real problem is that like you<br>have x of i and you have a loop that’s like counting down from from you know n to zero and you have an off by one somewhere and like now x of minus one instead of being you know x of i when i is minus one instead of being an error where you see like immediately say hey there’s a bug i need to find that it just like silently grabs the element off the other end of the array and and that’s where you know the sort of python um you know simplicity you know makes things worse and so that was why we left it out<br>because it was it was gonna hide bugs too much we thought um you know you could imagine something where you say like x of dollar minus one or len minus one not len of x but just len but you know it seemed like too much of a special case and it really it doesn’t come up enough um someone asked about uh you know what aspect of go was hardest to implement and honestly like a lot of this is not very hard um we’ve done most of this before we’d written operating systems and threading libraries and channel implementations<br>and so like doing all that again was fairly straightforward the hardest thing was probably the garbage collector go is unique among garbage collected languages in that it gives programmers a lot more control over memory layout so if you want to have a struct with two different other structs inside it that’s just one big chunk of memory it’s not a struct with pointers to two other chunks of memory and because of that and you can take the address of like the second field in the struct and pass that around<br>and that means the garbage collector has to be able to deal with a pointer that could point into the middle of an allocated object and that’s just something that java and lisp and other things just don’t do um and so that makes the garbage collector a lot more complicated in how it maintains its data structures and we also knew from the start that you really want low latency because if you’re handling network requests uh you can’t you know just pause for 200 milliseconds while and block all of those<br>in progress requests to do a garbage collection it really needs to be in you know low latency and not stop things and we thought that multicore would be a good a good opportunity there because we could have the garbage collector sort of doing one core and the go program using the other cores and and that might work really well and that actually did turn out to work really well but it required hiring a real expert in garbage collection to uh like figure out how to do it um and make it work but but now it’s it’s really great um i<br>i have a quick question yeah you said um like if it’s struck like it’s declared inside another stroke it actually is all a big chunk of memory yeah why do why did you implement it like that what’s the reasoning behind that um i well so there’s a couple reasons one is for a garbage collector right it’s a service and the load on the garbage collector is proportional to the number of objects you allocate and so if you have you know a struct with five things in it you can make that one allocation that’s like a fifth of<br>the the load on the garbage collector and that turns out to be really important but the other thing that’s really important is cache locality right like if you have the processor is pulling in chunks of memory in like you know 64 byte chunks or whatever it is and it’s much better at reading memory that’s all together than reading memory that’s scattered and so um you know we have a git server at google called garrett that is written in java and it was just starting at the time that go was you know just coming out and and<br>we we just missed like garrett being written and go i think by like a year um but we talked to the the guy who had written garrett and he said that like one of the biggest problems in in garrett was like you have all these shot one hashes and just having the idea of 20 bytes is like impossible to have in java you can’t just have 20 bytes in a struct you have to have a pointer to an object and the object like you know you can’t even have 20 bytes in the object right you have to declare like five different ins or<br>something like that to get 20 bites and there’s just like no good way to do it and and it’s just the overhead of just a simple thing like that really adds up um and so you know we thought giving programmers control over memory was really important um so another question was was about automatic parallelization like for loops and things like that we don’t do anything like that in the standard go tool chain there are there are go compilers for go front ends for gcc and llvm and so to the extent that those do those<br>kind of loop optimizations in c i think you know we get the same from the go friends for those but it’s it’s not the kind of parallelization that we typically need at google it’s it’s more um you know lots of servers running different things and and so you know that sort of you know like the sort of big vector math kind of stuff doesn’t come up as much so it just hasn’t been that important to us um and then the last question i have written now is that someone uh asked about like how do you decide when<br>to acquire release locks and why don’t you have re-entry locks and for that i want to go back a slide let me see yeah here so like you know during the lecture i said things like the lock pro like new protects the map or it protects the data but what we really mean at that point is that we’re saying that the lock protects some collection of invariants that apply to the data or that are true of the data and the reason that we have the lock is to to protect the operations that depend on the invariants and that sometimes temporarily<br>invalidate the invariants from each other and so when you call lock what you’re saying is i need to make use of the invariance that this lock protects and when you call unlock what you’re saying is i don’t need them anymore and if i temporarily invalid invalidated them i’ve put them back so that the next person who calls lock will see you know correct invariants so in the mux you know we want the invariant that each registered pending channel gets at most one reply and so to do that when we take don out of the map<br>we also delete it from the map before we unlock it and if there was some separate kind of cancel operation that was directly manipulating the map as well it could lock the it could call lock it could take the thing out call unlock and then you know if it actually found one it would know no one is going to send to that anymore because i took it out whereas if you know we had written this code to have you know an extra unlock and re-lock between the done equals pending of tag and the delete then you wouldn’t have that you know<br>protection of the invariants anymore because you would have put things back you unlocked and relocked while the invariants were broken and so it’s really important to you know correctness to think about locks as protecting invariants and and so if you have re-entrant locks uh all that goes out the window without the re-entrant lock when you call lock on the next line you know okay the lock just got acquired all the invariants are true if you have a re-entrant lock all you know is well all the invariants were true<br>for whoever locked this the first time who like might be way up here on my call stack and and you really know nothing um and so that makes it a lot harder to reason about like what can you assume and and so i think reentrant locks are like a really unfortunate part of java’s legacy another big problem with re-engine locks is that if you have code where you know you call something and it is depending on the re-entrant lock for you know something where you’ve acquired the lock up above and and then at some point you say you<br>know what actually i want to like have a timeout on this or i want to do it uh you know in some other go routine while i wait for something else when you move that code to a different go routine re-entrant always means locked on the same stack that’s like the only plausible thing it could possibly mean and so if you move the code that was doing the re-entrant lock onto a different stack then it’s going to deadlock because it’s going to that lock is now actually going to real lock acquire and it’s going to be<br>waiting for you to let go of the lock i mean you’re not going to let go of it because you know you think that code needs to finish running so it’s actually like completely fundamentally incompatible with restructurings where you take code and run it in different threads or different guarantees and so so anyway like my advice there is to just you know think about locks as protecting invariants and then you know just avoid depending on reentrant locks it it really just doesn’t scale well to to real programs<br>so i’ll put this list back up actually you know we have that up long enough i can try to figure out how to stop presenting um and then i can take a few more questions um i had i had a question yeah um and i mean i i think coming from python like it’s very useful right it’s very common to use like like standard functional operations right like map yeah um or filter stuff like that like um like list comprehension and when you know i switched over to go and started programming it’s used i i looked it up and people<br>say like you shouldn’t do this do this with loop right i was wondering why um well i mean one is that like you can’t do it the other way so you might just look through the way you can do it um but uh you know a bigger a bigger issue is that well there’s that was one answer the other answer is that uh you know if you do it that way you actually end up creating a lot of garbage and if you care about like not putting too much load on the garbage collector that kind of is another way to avoid that you know so if you’ve got<br>like a map and then a filter and then another map like you can make that one loop over the data instead of three loops over the data each of which generate a new piece of garbage but you know now that we have generics coming um you’ll actually be able to write those functions like you couldn’t actually write what the type signature of those functions were before and so like you literally couldn’t write them and python gets away with this because there’s no no you know static types but now we’re<br>actually going to have a way to do that and i totally expect that once generics go in there will be a package slices and if you import slices you can do slices.map and slices.filter and like slices.unique or something like that and and i think those will all happen um and you know if if that’s the right thing then that’s great thanks sure um one of the hints that you had it was about running go routines that are independent like concurrently um and some of the examples of the code i i think i couldn’t understand it seemed<br>to me like you can just like call the function in the same thread rather than a different thread and i was not sure why you would call it in a different thread so um usually it’s because you want them to proceed independently so um so in one of the one of the examples we had like the there was a loop that was sending um you know tasks to the work queue but there was the servers were running in different go routines and reading from the work queue and doing work but then when they were done they would send uh you know hey i’m done now to the<br>done channel but ascend in go doesn’t complete until the receive actually matches with it and so if the thing that’s sending on the work queue is not going to start receiving from the done channel until it’s done sending to all the work queues or sending all the work into all the tasks into the work queue then now you have a deadlock because the the main thread the main go routine is trying to send new work to the servers the servers are not taking new work they’re trying to tell the main thread<br>that they’re done but the main thread’s not going to actually start at like reading from the done channel until it finishes giving out all the work and so there’s just they’re just staring at each other waiting for different things to happen whereas if we take that loop that if we just put the little girl routine around the loop that’s sending the work then that can go somewhere else and then it can proceed independently and while it’s stuck waiting for the servers to send to um take more work<br>the servers are stuck waiting for the main go routine to you know acknowledge that it finished some work and now the main goal team actually gets down to the loop that you know pulls that finishes that actually acknowledges that it finished the work that reads from the done channel and so it’s just a way to separate out you know these are two different things that logically they didn’t have to happen one after the other and because they were happening one after the other that caused a deadlock and by taking one out and<br>moving it let it run independently um that removes the deadlock thank you so much sure could you talk a little bit about how ghost race detector is implemented sure it is the llvm race detector um and so that probably doesn’t help but but it is exactly the thing that llvm calls thread sanitizer and um and so we actually have a little binary blob that uh you know we link against because we don’t want to depend on all of lvm but it’s the llvm race detector and the way the llvm race sector works is that it allocates a ton of<br>extra virtual memory and then based on the address of of the thing being read or written it has this other you know spot in virtual memory where it records information about like the last uh thread you know it thinks of threads but their go routines um has with the last thread that did a read or a write and then also every time a synchronizing event happens like you know a communication from one go routine to another uh that counts as establishing a happens before edge between two different go routines and if you ever get something where you<br>have a read and a write and they’re not properly sequenced right like so if you have a read and then it happens before something in another chain which then you know later does the right that’s fine but if you have a read and a write and there’s no happens before sequence that connects them then um then that’s a race and it actually you know has some pretty clever ways to you know dynamically figure out quickly you know did this read happen is there a happens before a path between this readings<br>right as they happen and it slows down the program by like maybe 10x but you know if you just divert a small amount of traffic there that’s probably fine if it’s for testing that’s also probably fine and it’s way better than like not finding out about the races so it’s totally worth it and honestly 10 or 20 x is is fantastic the original thread sanitizer was more like 100 or a thousand x and that was not good enough well what’s the rate detector called lrvm uh it’s called thread sanitizer but<br>it’s part of llvm which is um the clang c compiler the the one that um almost everyone uses now is is part of the llvm project can you talk about slices um and like the design choices having them as views on a raise which like confused me at first yeah yeah it is a little confusing at first um the the main thing is that you want it to be efficient to kind of walk through an array or to like you know if you’re in quicksort or merge sword or something where you have an array of things and now you want to say well now sort<br>this half and sort the other half you want to be able to efficiently say like here this is half of the previous one like you know sort that and so in c the way you do that is you just pass in you know the pointer to the first element and the number of elements and that’s basically all a slice is and then the other pattern that comes up a lot when you’re you know trying to be efficient with arrays is you have to grow them and and so you don’t want to recall realic on every single new element you want to amortize that<br>and so the way you do that in in c again is that you have a base pointer you have the length that you’re using right now and you have the length that you allocated and then to you know add one you you check and see if the length is is bigger than the amount you allocated if so you reallocate it and otherwise you just keep bumping it forward and and slices are really just an encoding of those idioms because those are kind of the most efficient way to manage the memory and so in in any kind of like c plus vector or<br>um sort of thing like that that’s what’s going on underneath but it makes it a lot harder to um like the c plus vector because of ownership reasons you know the vector is tied to the actual underlying memory it’s a lot harder to get like a sub vector that’s just the view onto like the second half for merge sort so that’s sort of the idea is that it just like there are all these patterns for accessing memory efficiently that came from c and we tried to make them fit and to go in an idiomatic way<br>in a safe way can you talk about how you decided to um implement the go like remote module system where you import directly from a url versus like yeah um i mean i just didn’t want to run a service and like like you know a lot of the things like ruby gems and those like were not as as for the front of my mind at the time just because they were newer but like i had used pearl for a while and like cpan and and i just thought it was it was insane that like everyone was fighting over these short names like db you know<br>there probably shouldn’t be an argument over like who gets to make the db package um and so putting domain names in the front seemed like a good way to decentralize it and and it was also a good way for us not to run any server because you know we could just say well you know we’ll recognize the host name and then and then go grab it from source control um from someone else’s server and that turned out to be a really great idea i think um because we just we don’t have that kind of same infrastructure<br>that other things depend on like in the java world it’s actually really problematic there are multiple there’s no sort of standard registry but they all use these short names and so uh like maven can be configured to build from multiple different registries and you if you’re an open source software package provider you actually have to go around and be sure that you upload it to all the different registries because if you don’t if you miss one and it becomes popular someone else will upload different code to that one<br>and um and then like maven actually just takes whichever one comes back first it just like sends a request to all of them and whatever comes back first so like you know if someone wants to make a malicious copy of your package all you do is find some registry other people use that you forgot to upload it to and like you know they get to win the race sometimes so it’s like it’s a real problem like i think having domain name there really helps split up the ownership in a really important way thank you sure<br>so the maybe we should take a quick uh pause here those people that have to go can go i’m sure russ is willing to uh stick around for a little bit longer yeah and answer any questions uh but i do want to thank ross for giving this lecture uh you know hopefully this will help you running more good go programs these patterns and uh so thank you russ very welcome it’s nice to be here and then more questions feel free to ask questions yeah oh just a little logistical thing uh the slides that are on the 6824 website are<br>not they exactly the same as russ’s slides people check them out i’ll get franz a new pdf yeah more general question about when is writing a new language the like the best solution to a problem that’s a great question um it’s almost never the best solution but you know at the time we had just an enormous number of programmers like thousands of programmers working in one code base and the compilations were just taking forever because um seatbelts plus was just not not meant for you know efficient incremental<br>compilation and and so it and furthermore at the time like threading libraries were really awful like people just didn’t use threats i remember like one of the first days i was at mit and talking to robert and robert said to me um like in 2001 he said to me like well we don’t use threads here because threads are slow and and that was like totally normal like that was just the way the world at the time um and and at google we were having a lot of trouble because it was all event-based like little callbacks in c plus plus<br>and there were these multi-core machines and we actually didn’t know how to get things to work on them because like linux threads were not something you could really rely on to work and and so we ended up like if you had a four core machine you just run four different process in completely independent processes of the web server and just treat it as like four machines um and that was clearly like not very efficient so like there were a lot of good reasons to like try something um but you know it’s a huge amount of<br>work to get to the point where go is today and i think that um so much is not the language right like there were important things that we made did in the language that enabled other um considerations but uh so much of the successful languages the ecosystem that got built up around it and the tooling that we built and the go command and like all these like not the language things so you know programming language uh people who are like focus on the language itself i think sometimes get distracted by all the stuff around like they miss all the<br>stuff around it um can i ask a follow-up on that yeah i was wondering how is working on go different now since it’s more mature than it was before oh that’s a great question um you know in the early days it was so easy to make changes and now it’s really hard to make changes i think that’s the number one thing um you know in the early days like everything was in one source code repository literally all the go code in the world was the one source code repository and so like there were days where we changed the syntax like you<br>used to have a star before chan every time you set a channel because it was then it was a pointer underneath and it was all kind of exposed so you’d always say star channel instead of jan and and and similarly for maps and at some point we realized like this is dumb like you have to say the star let’s just take it out and um and so like we made the change to the compiler and i opened up literally like the couple hundred go source files in the world in my editor and like the entire team stood behind me and like<br>i typed some regular expressions and we looked at the effect on the files yep that looks right save it you know compile it we’re done and like today you know we can’t make backwards compatible changes at all um and and even making you know new changes like it it affects a lot of people and so uh you know you sort of propose something and you know people point out well this won’t work for me and you try to like adjust that maybe um it’s just it’s a lot harder we estimate there’s at least a million<br>maybe two million go programmers in the world and it’s very different from when they were you know four or five not sure if this is a valid question but what what language is go written in is it written in go also or no now it is now it is the original um compiler runtime were written in c but a few years ago we went through a big um we actually wrote a a program to translate c to go and that only worked for rc code but still it was good enough so that we wouldn’t lose kind of all the sort of encoded knowledge in that code<br>about why things were the way they were and like how things work so we have to start from scratch but now it’s all written and go and you know a little bit of assembly and that means that um people can uh you know people who know go can help on the the go project whereas before like if you wanted to work on the compiler or the runtime you had to know c really well and like we weren’t getting a lot of people knew c really well like there’s not actually that many of them proportionately and and furthermore like our entire user<br>base is go programmers not c programmers so moving to go was was a really big deal i was wondering how did you prioritize what features to add to the language at like this point like in all generics like a lot of people were like asking for that like did y’all know like how you choose what to work on i mean we’ve considered language mostly frozen for a while and um and so we haven’t been adding much uh there was a long period where we said we weren’t adding anything and then we added a little bit of things<br>in the last couple years to lead up to generics just kind of shake the rust off on like all the like what breaks when you change something in the language so like you can put underscores between digits and long numbers now things like that um but you know generics has clearly been the next thing that needed to happen and we just had to figure out how in general we try to only add things that don’t have weird kind of interference with other features and we try to add things that are you know really important that will help a<br>lot of people for the kinds of programs that we’re trying to target with go which is like distributed systems and that sort of thing cool thank you oh i had a question actually yeah uh so um for i noticed that like you know uh go doesn’t have like basic functions like min or max for like yeah so is that like something that you’re considering like say adding with like the generic stuff maybe is that why you didn’t decide yeah exactly right because like you can’t have a min you’d have been event and you could have<br>minivan date but those had to have different names and that was kind of annoying um so now we can write just a generic name over any type that has a less than operator yeah that’ll be good and you know honestly like for the specific case of min and max so i know it’s not that hard to code i know i was gonna say i’m starting to feel like we should just make some built-ins like like you know print and things like that so that you know you can just always have them but even if we don’t like you it’ll be<br>math.min and that’ll be there at least um yeah we really didn’t want to make them built-ins until we could like express their types and we couldn’t do that until generics happened because there is actually a min for like floating points actually yeah i know it’s kind of weird because it’s because the math library is basically copied from the c math.<br>h set of things yes so that’s a good point like we can’t actually put them in math because they’re already there okay but no yeah but we’ll figure it out like i think we should probably just put them in the language but we have to get generis through first and another thing actually i noticed that you did usako like competitive programming yeah i did too actually oh cool yeah so how did you so actually i included this in one of the questions that i submitted let me pull it up um so my question was like<br>um how did how was like how did you go from doing competitive programming to like doing what you you’re doing now at google working on going how’s the transition between like competitive programming to systems also finally what made you decide to go into systems and how did it relate to programming i mean competitive programming at the time that i did it was not as all-consuming as i gather it is now like like you know you could just like be able to implement a simple dynamic programming like little two for loops and that was<br>fine and now you have all these like complex hall algorithms and all that stuff that i can’t do so like you know at some point like at some level like it was different um but you know i was actually more interested in the sort of systems you kind of stopped from the start and and the the program contests were just like something fun to do on the side so there wasn’t like a huge transition there um i was never into like implementing complex algorithms and and that you know max flow and all those sorts of things<br>on the other hand like when you start a new language you actually do get to write a lot of core things right um like someone has to write the sort function and it has to be a good general sort function and like i spent a while last month like looking into dip algorithms and and that’s like you know sort of matches that background pretty well so like it does come up um but you know it’s just it’s just a different kind of programming oh so you thought of it as more of a side thing back then no like yeah<br>it wasn’t it was definitely not the sort of main thing i did when i was writing programs yeah because like today it’s effectively like the main thing i know i know it’s you know if you don’t do it full-time like there’s just no way you can you know there just weren’t that many people who cared it you know in uh 1995 yeah 20 years later um can you ask a related question to that so how did you decide to go from i’m from like academic work into i mean your work is still like a little bit more different than<br>like the usual like software engineering thing but still yeah um you know i got lucky uh i i grew up near bell labs in new jersey and so like that was how i ended up working on playing the iron a little bit in high school and college um and so you know i sort of knew i was going to go to grad school and you know the plan was to go back to bell labs but it kind of imploded while i was in grad school with the dot com boom and the dot com crash and um and so like you know google was was sort of a just vacuuming up phds systems phds at<br>the time and and and doing really interesting things i mean you probably you know there’s a i don’t know i haven’t looked at syllabus for this year but you know there’s things like spanner and um big table and chubby and and things like that and you know they they had a whole host of good distributed systems kind of stuff going on and so you know it was sort of lucky to be able to to go to that too um and you know at the time i graduated i was also looking at you know industrial research labs like microsoft<br>research and and places like that so you know there’s definitely an opportunity there for you know researchy things but not in academia if that’s what you want um it’s a little harder to find now i mean most of the places i know like microsoft research imploded too a couple years later but um you know it’s uh it’s still an option and and you know it’s just a slightly different path um you end up the the differences i see from academia is like you end up caring a ton more about actually making things work<br>100 time and supporting them for like a decade or more whereas like you finish your paper and you kind of like get to put it off to the side and that’s that’s really nice actually at some level um it’s uh it’s definitely strange to me to be you know editing source files that i wrote you know in in some cases actually 20 years ago um because i used a bunch of code that i’d already written when we started go and it’s very weird to think that like i’ve been keeping this program running<br>for 20 years thinking</p>
<h2 id="Concurrency-and-Parallelism"><a href="#Concurrency-and-Parallelism" class="headerlink" title="Concurrency and Parallelism"></a>Concurrency and Parallelism</h2><p>Concurrency: How  you write your programs about being able to compose independently executing control flows whether you want to call them processes or threads or go routines.</p>
<p>Parallelism: How the programs get executed about allowing multiple computations to run simultaneously so that the program can be doing lots of things at once not just dealing with lots of things at once and so concurrency lends itself naturally to parallel execution</p>
<p>并发性：如何编写程序以支持独立执行的控制流的组合，无论你想称它们为进程、线程还是 Go 协程。</p>
<p>并行性：程序如何被执行，允许多个计算同时运行，使得程序可以同时处理许多事情，而不仅仅是同时应对许多事情。因此，并发性自然适合并行执行。</p>
<h2 id="Goroutines-for-State"><a href="#Goroutines-for-State" class="headerlink" title="Goroutines for State"></a>Goroutines for State</h2><p>Hint: Convert data state into code state when it makes programs clearer.</p>
<h1 id="Lab1-MapReduce"><a href="#Lab1-MapReduce" class="headerlink" title="Lab1: MapReduce"></a>Lab1: MapReduce</h1><h2 id="论文"><a href="#论文" class="headerlink" title="论文"></a>论文</h2><p><img  src="./image-20250130171236090.png"  ><span class="image-caption">MapReduce框架图</span></p>
<p><img  src="./94dee74c9845b.png"  ><span class="image-caption">MapReduce论文结构</span></p>
<h2 id="MapReduce-结构"><a href="#MapReduce-结构" class="headerlink" title="MapReduce 结构"></a>MapReduce 结构</h2><ul>
<li>Map and Reduce Function（由用户定义）</li>
<li>Worker（我们实现）</li>
<li>Coordinator（源论文中的 master，我们实现）</li>
</ul>
<h2 id="单机顺序式实现"><a href="#单机顺序式实现" class="headerlink" title="单机顺序式实现"></a>单机顺序式实现</h2><p>MapReduce 实现： <code>src/main/mrsequential.go</code>。</p>
<p>Map and Reduce Function：<code>mrapps/wc.go</code> 这里是一个 word-count app，<code>mrapps/indexer.go</code> 是</p>
<p>运行方法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/6.5840<br><span class="hljs-built_in">cd</span> src/main<br>go build -buildmode=plugin ../mrapps/wc.go<br><span class="hljs-built_in">rm</span> mr-out*<br>go run mrsequential.go wc.so pg*.txt<br>more mr-out-0<br>A 509<br>ABOUT 2<br>ACT 8<br>...<br></code></pre></td></tr></table></figure>
<h2 id="分布式实现"><a href="#分布式实现" class="headerlink" title="分布式实现"></a>分布式实现</h2><p>需要我们实现：</p>
<ul>
<li>mr/coordinator.go,</li>
<li>mr/worker.go</li>
<li>mr/rpc.go</li>
</ul>
<h3 id="运行方式"><a href="#运行方式" class="headerlink" title="运行方式"></a>运行方式</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">go build -buildmode=plugin ../mrapps/wc.go<br></code></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">rm</span> mr-out*<br>go run mrcoordinator.go pg-*.txt<br></code></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">go run mrworker.go wc.so<br></code></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> mr-out-* | <span class="hljs-built_in">sort</span> | more<br>A 509<br>ABOUT 2<br>ACT 8<br>...<br></code></pre></td></tr></table></figure>
<p>测试方案：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/6.5840/src/main<br>bash test-mr.sh<br>*** Starting <span class="hljs-built_in">wc</span> <span class="hljs-built_in">test</span>.<br></code></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">bash test-mr.sh<br>*** Starting <span class="hljs-built_in">wc</span> <span class="hljs-built_in">test</span>.<br><span class="hljs-built_in">sort</span>: No such file or directory<br>cmp: EOF on mr-wc-all<br>--- <span class="hljs-built_in">wc</span> output is not the same as mr-correct-wc.txt<br>--- <span class="hljs-built_in">wc</span> <span class="hljs-built_in">test</span>: FAIL<br><br></code></pre></td></tr></table></figure>
<h3 id="一些要求"><a href="#一些要求" class="headerlink" title="一些要求"></a>一些要求</h3><ul>
<li>在map阶段，应将中间键值根据nReduce个reduce任务的数量划分为多个桶，这里的nReduce即main/mrcoordinator.go传递给MakeCoordinator()方法的参数。每个mapper应当为reduce任务创建nReduce个中间文件以供消费。</li>
<li>worker的实现应该把第X个reduce任务的输出放置于mr-out-X文件中。每个mr-out-X文件应当包含每行一个reduce函数的输出结果。这一行需要使用Go语言的”%v %v”格式化字符串生成，调用时传入键和值。你可以在main/mrsequential.go中找到被注释为”这是正确的格式”的代码行作为参考。如果你的实现与此格式相差太多，测试脚本将会失败。</li>
<li>你可以修改mr/worker.go、mr/coordinator.go以及mr/rpc.go文件。为了测试目的，你可以暂时修改其他文件，但请确保你的代码能与原始版本兼容——我们将使用原始版本进行测试。</li>
<li>worker应将中间Map阶段的输出保存为当前目录下的文件，以便后续作为Reduce任务的输入读取这些文件。</li>
<li>main/mrcoordinator.go期望mr/coordinator.go实现一个Done()方法，在MapReduce作业完全完成时返回true；此时，mrcoordinator.go将会退出。</li>
<li>当整个作业完全完成后，worker进程也应当退出。一种简单的实现方式是利用call()的返回值：如果worker无法联系上coordinator，则可以认为coordinator因为作业已完成而退出，因此worker也可以终止。根据你的设计，你也可能会发现设置一个“请退出”的伪任务是有帮助的，coordinator可以通过这个伪任务通知workers退出。</li>
</ul>
<h3 id="一些帮助"><a href="#一些帮助" class="headerlink" title="一些帮助"></a>一些帮助</h3><ul>
<li>开始的一个方法是修改mr/worker.go中的Worker()函数，让它发送一个RPC请求给coordinator以请求任务。然后修改coordinator，使其响应返回一个尚未开始的map任务的文件名。接着，修改worker读取该文件并调用应用程序的Map函数，就像在mrsequential.go中所做的那样。</li>
<li>应用程序的Map和Reduce函数是在运行时使用Go语言的插件包从文件加载的，这些文件名以.so结尾。</li>
<li>如果你更改了mr/目录下的任何内容，你可能需要重新构建所使用的MapReduce插件，例如通过go build -buildmode=plugin ../mrapps/wc.go命令。</li>
<li>本实验依赖于workers共享一个文件系统。当所有workers在同一台机器上运行时这很简单，但如果workers运行在不同的机器上，则需要像GFS这样的全局文件系统。</li>
<li>对于中间文件采用合理的命名规则，比如mr-X-Y，其中X是Map任务编号，Y是reduce任务编号。</li>
<li>worker的map任务代码需要一种方式将中间键值对存储到文件中，并且可以在reduce任务期间正确地读回。一种可能是使用Go语言的encoding/json包。要以JSON格式写入键值对至打开的文件，可以这样做：</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">enc := json.NewEncoder(file)<br><span class="hljs-keyword">for</span> _, kv := ... &#123;<br>    err := enc.Encode(&amp;kv)<br></code></pre></td></tr></table></figure>
<p>而读回此类文件的方式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">dec := json.NewDecoder(file)<br><span class="hljs-keyword">for</span> &#123;<br>    <span class="hljs-keyword">var</span> kv KeyValue<br>    <span class="hljs-keyword">if</span> err := dec.Decode(&amp;kv); err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">break</span><br>    &#125;<br>    kva = <span class="hljs-built_in">append</span>(kva, kv)<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>你的worker的map部分可以使用worker.go中的ihash(key)函数为给定的键选择reduce任务。</li>
<li>你可以从mrsequential.go中借用一些代码用于读取Map输入文件、在Map和Reduce之间排序中间键值对以及将Reduce输出存储到文件中。</li>
<li>作为RPC服务器的coordinator将是并发执行的；不要忘记锁定共享数据。</li>
<li>使用Go语言的race detector工具，可以通过go run -race启动。test-mr.sh脚本开头有一个注释，告诉你如何与-race选项一起运行它。在我们评分时不会使用race detector，然而，如果你的代码存在竞态条件，在测试时即使不使用race detector也很可能会失败。</li>
<li>workers有时需要等待，例如reduces不能在最后一个map完成之前开始。一种可能性是让workers定期向coordinator询问工作，使用time.Sleep()在每次请求之间进行休眠。另一种可能性是在coordinator的相关RPC处理器中实现一个循环等待，可以通过time.Sleep()或sync.Cond来实现。由于Go语言为每个RPC在其自己的线程中运行处理程序，因此一个处理程序的等待不应妨碍coordinator处理其他RPCs。</li>
<li>coordinator无法可靠地区分崩溃的workers、因某种原因暂停但仍存活的workers以及执行速度过慢以至于无用的workers。最好的做法是让coordinator等待一段时间（如10秒），然后放弃并重新分配任务给另一个worker。对于这个实验，设定coordinator等待十秒钟；之后应假设worker已经死亡（当然，实际上它可能并未死亡）。</li>
<li>如果你选择实现备份任务（第3.6节），请注意我们测试了在workers执行任务但未崩溃的情况下你的代码不会调度额外的任务。备份任务应该只在一段相对较长的时间后（例如10秒）被调度。</li>
<li>为了测试崩溃恢复，你可以使用mrapps/crash.go应用插件，它会在Map和Reduce函数中随机退出。</li>
<li>为了确保在发生崩溃时没有人观察到部分写入的文件，MapReduce论文提到了使用临时文件并在完全写入后原子重命名的技巧。你可以使用ioutil.TempFile（或者如果你运行的是Go 1.17或更新版本，则使用os.CreateTemp）创建一个临时文件，并使用os.Rename原子地重命名它。</li>
<li>test-mr.sh在一个名为mr-tmp的子目录下运行所有进程，所以如果出现问题并且你想查看中间文件或输出文件，请在那里查找。你可以暂时修改test-mr.sh以便在失败的测试后退出，这样脚本就不会继续测试（并覆盖输出文件）。</li>
<li>test-mr-many.sh连续多次运行test-mr.sh，你可能想要这样做以便发现低概率的bug。它接受一个参数，即运行测试的次数。你不应该并行运行多个test-mr.sh实例，因为coordinator会重用相同的套接字，从而导致冲突。</li>
<li>Go RPC仅发送字段名称以大写字母开头的结构体。子结构也必须具有首字母大写的字段名称。</li>
<li>在调用RPC call()函数时，回复结构应当包含所有的默认值。RPC调用看起来应该是这样的：</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">reply := SomeType&#123;&#125;<br>call(..., &amp;reply)<br></code></pre></td></tr></table></figure>
<ul>
<li>在调用之前不应该设置reply的任何字段。如果你传递的reply结构体包含非默认字段，RPC系统可能会静默地返回错误值。</li>
</ul>
<h3 id="第一个版本"><a href="#第一个版本" class="headerlink" title="第一个版本"></a>第一个版本</h3><ul>
<li>完成了 rpc + 单个 worker</li>
</ul>
<p>目前的问题：</p>
<ul>
<li>测试多 worker 是否正常</li>
<li>测试的时候是把多个 redece 的结果拼起来和最终答案进行比较，所以每个 reduce 的内容得是完整的结果的一部分，而不是每个 reduce 中都是所有出现过的单词。</li>
</ul>
<h3 id="第二个版本"><a href="#第二个版本" class="headerlink" title="第二个版本"></a>第二个版本</h3><p>map 可以根据文件进行分区，可是中间结果如何进行分区呢？假设有 2 个 reduce。</p>
<p>现在有 10 个文件，分别 map 之后产生了 mr-1 mr-2 … mr-10。</p>
<p><strong>则对每个 map 进行进一步划分，根据 key 划分为 mr-1-1 mr-1-2。</strong></p>
<p><strong>map 的时候不用 sort 和组合，这些都可以交给 reduce 来完成。</strong></p>
<ul>
<li>增加数据分区</li>
<li>增加锁</li>
</ul>
<h3 id="第三个版本"><a href="#第三个版本" class="headerlink" title="第三个版本"></a>第三个版本</h3><p>wc test 可以测试通过，然而 indexer 不能，总会出现不一致的情况：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">mr-indexer-all mr-correct-indexer.txt differ: byte 2245, line 40<br>mr-indexer-all mr-correct-indexer.txt differ: byte 2245, line 40<br>mr-indexer-all mr-correct-indexer.txt differ: byte 911, line 15<br></code></pre></td></tr></table></figure>
<p>考虑原因可能是 map 还在进行中，或者在写文件时，已经触发了 reduce 任务，需要给 map 任务添加一个完成信息。</p>
<p>可以等 map 结束之后给 master 传递信息使得该任务变成完成状态，并允许 reduce。</p>
<p><strong>增加了写中间文件原子操作之后，indexer 可以正常工作了。</strong></p>
<p><strong>并不能，只是出错概率减小了</strong></p>
<ul>
<li>写文件原子操作</li>
<li><code>mr-[0-9]*-%d</code> 避免解析 mr-out-* 文件</li>
</ul>
<p>实现方法：先写到 tmp 文件，然后重命名成文件就好，重命名是原子操作。</p>
<h3 id="第四个版本"><a href="#第四个版本" class="headerlink" title="第四个版本"></a>第四个版本</h3><p>增加了</p>
<ul>
<li>容错逻辑（分发任务之后开始计时，如果时间到了还是 wait，那么就 resume 为 map/reduce）</li>
<li>把 list 换成了 map</li>
<li>修改写文件原子操作，先写到 temp 文件，注意 temp 文件一定不能重名。还要注意在同一个文件系统上，这样 rename 才是原子操作。</li>
<li>存在一个问题，当 reduce crash 时，重新开了一个在运行，之前 crash 的那个恢复之后又调用了一次 finish，同一个 finish 了 2 次，就出错了。所以要注意 crash 掉的不要 finish。在接受到 finish 请求的时候判断是不是 Wait，如果是则再 Done，并完成数量加一。</li>
</ul>
<p>完成所有的测试！芜湖！</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">--- crash <span class="hljs-built_in">test</span>: PASS<br>*** PASSED ALL TESTS<br>*** PASSED ALL 500 TESTING TRIALS<br></code></pre></td></tr></table></figure>
<h1 id="GFS"><a href="#GFS" class="headerlink" title="GFS"></a>GFS</h1><p>特点：单 master、弱一致性</p>
<p>Master 管理文件、存储文件的 Chunk ID 信息。</p>
<h2 id="GFS-一致性"><a href="#GFS-一致性" class="headerlink" title="GFS 一致性"></a>GFS 一致性</h2><h3 id="master"><a href="#master" class="headerlink" title="master"></a>master</h3><ul>
<li><p>第一个是文件名到Chunk ID或者Chunk Handle数组的对应。这个表单告诉你，文件对应了哪些Chunk。但是只有Chunk ID是做不了太多事情的，所以有了第二个表单。</p>
</li>
<li><p>第二个表单记录了Chunk ID到Chunk数据的对应关系。这里的数据又包括了：</p>
<ul>
<li><p>每个Chunk存储在哪些服务器上，所以这部分是Chunk服务器的列表</p>
</li>
<li><p>每个Chunk当前的版本号，所以Master节点必须记住每个Chunk对应的版本号。</p>
</li>
<li><p>所有对于Chunk的写操作都必须在主Chunk（Primary Chunk）上顺序处理，主Chunk是Chunk的多个副本之一。所以，Master节点必须记住哪个Chunk服务器持有主Chunk。</p>
</li>
<li><p>并且，主Chunk只能在特定的租约时间内担任主Chunk，所以，Master节点要记住主Chunk的租约过期时间。</p>
</li>
</ul>
</li>
</ul>
<p>Master会在磁盘上存储log，每次有数据变更时，Master会在磁盘的log中追加一条记录，并生成CheckPoint（类似于备份点）。</p>
<ul>
<li><p>Chunk Handle的数组（第一个表单）要保存在磁盘上。给它标记成NV（non-volatile, 非易失），这个标记表示对应的数据会写入到磁盘上。</p>
</li>
<li><p>Chunk服务器列表不用保存到磁盘上。因为Master节点重启之后可以与所有的Chunk服务器通信，并查询每个Chunk服务器存储了哪些Chunk，所以我认为它不用写入磁盘。所以这里标记成V（volatile），</p>
</li>
<li>版本号要不要写入磁盘取决于GFS是如何工作的，我认为它需要写入磁盘。我们之后在讨论系统是如何工作的时候再详细讨论这个问题。这里先标记成NV。</li>
<li>主Chunk的ID，几乎可以确定不用写入磁盘，因为Master节点重启之后会忘记谁是主Chunk，它只需要等待60秒租约到期，那么它知道对于这个Chunk来说没有主Chunk，这个时候，Master节点可以安全指定一个新的主Chunk。所以这里标记成V。</li>
<li>类似的，租约过期时间也不用写入磁盘，所以这里标记成V。</li>
</ul>
<p>任何时候，如果文件扩展到达了一个新的64MB，需要新增一个Chunk或者由于指定了新的主Chunk而导致版本号更新了，Master节点需要向磁盘中的Log追加一条记录说，我刚刚向这个文件添加了一个新的Chunk或者我刚刚修改了Chunk的版本号。所以每次有这样的更新，都需要写磁盘。GFS论文并没有讨论这么多细节，但是因为写磁盘的速度是有限的，写磁盘会导致Master节点的更新速度也是有限的，所以要尽可能少的写入数据到磁盘。</p>
<p>这里在磁盘中维护log而不是数据库的原因是，数据库本质上来说是某种B树（b-tree）或者hash table，相比之下，追加log会非常的高效，因为你可以将最近的多个log记录一次性的写入磁盘。因为这些数据都是向同一个地址追加，这样只需要等待磁盘的磁碟旋转一次。而对于B树来说，每一份数据都需要在磁盘中随机找个位置写入。所以使用Log可以使得磁盘写入更快一些。</p>
<p>当Master节点故障重启，并重建它的状态，你不会想要从log的最开始重建状态，因为log的最开始可能是几年之前，所以Master节点会在磁盘中创建一些checkpoint点，这可能要花费几秒甚至一分钟。这样Master节点重启时，会从log中的最近一个checkpoint开始恢复，再逐条执行从Checkpoint开始的log，最后恢复自己的状态。</p>
<h3 id="client-读文件"><a href="#client-读文件" class="headerlink" title="client 读文件"></a>client 读文件</h3><h1 id="Raft"><a href="#Raft" class="headerlink" title="Raft"></a>Raft</h1><h2 id="1-脑裂（Split-Brain）"><a href="#1-脑裂（Split-Brain）" class="headerlink" title="1. 脑裂（Split Brain）"></a>1. 脑裂（Split Brain）</h2><ol>
<li>脑裂（Split Brain）是指在分布式系统中，由于网络分区（Network Partition）或其他故障导致系统中的不同节点无法正常通信，进而使得系统被分割成两个或多个独立的部分，每个部分都认为自己是系统的主节点（Primary），并独立地进行操作和决策。这种情况下，系统会出现数据不一致性和决策冲突，导致系统行为异常。</li>
</ol>
<h3 id="1-脑裂的场景"><a href="#1-脑裂的场景" class="headerlink" title="1. 脑裂的场景"></a>1. <strong>脑裂的场景</strong></h3><p>   在分布式系统中，通常会有多副本（Replicas）来提高系统的容错能力。例如，VMware FT（Fault Tolerance）系统中，有一个主虚拟机（Primary VM）和一个备份虚拟机（Backup VM），它们通过一个 Test-and-Set 服务来决定谁是主节点。如果 Test-and-Set 服务本身是单点的，那么它可以通过仲裁来避免脑裂。但如果 Test-and-Set 服务本身也有多副本（例如 S1 和 S2），就可能出现脑裂。</p>
<h3 id="2-脑裂的发生"><a href="#2-脑裂的发生" class="headerlink" title="2. 脑裂的发生"></a>2. <strong>脑裂的发生</strong></h3><p>   假设系统中有两个服务器（S1 和 S2）和两个客户端（C1 和 C2）。客户端需要通过 Test-and-Set 服务来确定主节点。正常情况下，客户端会同时与两个服务器通信，确保数据一致性。但如果网络出现故障，客户端可能只能与其中一个服务器通信：</p>
<ul>
<li><strong>C1 可以访问 S1，但无法访问 S2</strong>。</li>
<li><p><strong>C2 可以访问 S2，但无法访问 S1</strong>。</p>
<p>在这种情况下：</p>
</li>
<li><p>C1 会认为 S1 是主节点，并开始执行操作。</p>
</li>
<li><p>C2 会认为 S2 是主节点，并开始执行操作。</p>
<p>此时，系统被分割成两个独立的部分，每个部分都认为自己是主节点，这就是脑裂。</p>
</li>
</ul>
<h3 id="3-脑裂的后果"><a href="#3-脑裂的后果" class="headerlink" title="3. 脑裂的后果"></a>3. <strong>脑裂的后果</strong></h3><p>   脑裂会导致以下严重问题：</p>
<ul>
<li><strong>数据不一致性</strong>：S1 和 S2 的数据可能会出现冲突，因为它们各自独立地处理请求。</li>
<li><strong>决策冲突</strong>：两个主节点可能会同时对同一资源进行操作，导致系统行为不可预测。</li>
<li><strong>系统不可用</strong>：为了避免数据不一致，系统可能需要停止服务，直到问题解决。</li>
</ul>
<h3 id="4-避免脑裂的方法"><a href="#4-避免脑裂的方法" class="headerlink" title="4. 避免脑裂的方法"></a>4. <strong>避免脑裂的方法</strong></h3><p>   为了避免脑裂，分布式系统通常会采用以下方法：</p>
<ul>
<li><strong>单点仲裁</strong>：使用一个单点（如 Test-and-Set 服务）来决定主节点。虽然单点本身是单点故障，但它可以避免脑裂。</li>
<li><strong>网络分区检测</strong>：通过检测网络分区，确保系统在分区发生时能够快速做出决策，避免两个部分各自为政。</li>
<li><strong>人工干预</strong>：在某些情况下，系统会停止自动操作，转而由人工干预来解决冲突。</li>
</ul>
<h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. <strong>总结</strong></h3><p>   脑裂是分布式系统中的一种严重故障场景，它会导致系统分裂成多个独立的部分，每个部分都认为自己是主节点，从而引发数据不一致性和决策冲突。为了避免脑裂，系统通常需要依赖单点仲裁、网络分区检测或人工干预等方法。</p>
<h2 id="2-过半票决（Majority-Vote）"><a href="#2-过半票决（Majority-Vote）" class="headerlink" title="2. 过半票决（Majority Vote）"></a>2. 过半票决（Majority Vote）</h2><p>尽管存在脑裂的可能，但是随着技术的发展，人们发现哪怕网络可能出现故障，可能出现分区，实际上是可以正确的实现能够<strong>自动完成故障切换</strong>的系统。当网络出现故障，将网络分割成两半，网络的两边独自运行，且不能访问对方，这通常被称为网络分区。</p>
<p>在构建能自动恢复，同时又避免脑裂的多副本系统时，人们发现，关键点在于过半票决（Majority Vote）。这是Raft论文中出现的，用来构建Raft的一个基本概念。过半票决系统的第一步在于，服务器的数量要是奇数，而不是偶数。例如在上图中（只有两个服务器），中间出现故障，那两边就太过对称了。这里被网络故障分隔的两边，它们看起来完全是一样的，它们运行了同样的软件，所以它们也会做相同的事情，这样不太好（会导致脑裂）。</p>
<p>但是，如果服务器的数量是奇数的，那么当出现一个网络分割时，两个网络分区将不再对称。假设出现了一个网络分割，那么一个分区会有两个服务器，另一个分区只会有一个服务器，这样就不再是对称的了。这是过半票决吸引人的地方。所以，首先你要有奇数个服务器。然后为了完成任何操作，例如Raft的Leader选举，例如提交一个Log条目，<strong>在任何时候为了完成任何操作，你必须凑够过半的服务器来批准相应的操作</strong>。这里的过半是指超过服务器总数的一半。直观来看，如果有3个服务器，那么需要2个服务器批准才能完成任何的操作。</p>
<p>这里背后的逻辑是，如果网络存在分区，那么必然不可能有超过一个分区拥有过半数量的服务器。例如，假设总共有三个服务器，如果一个网络分区有一个服务器，那么它不是一个过半的分区。如果一个网络分区有两个服务器，那么另一个分区必然只有一个服务器。因此另一个分区必然不能凑齐过半的服务器，也必然不能完成任何操作。</p>
<p>这里有一点需要明确，当我们在说过半的时候，我们是在说所有服务器数量的一半，而不是当前开机服务器数量的一半。这个点困扰了我（Robert教授）很长时间。如果你有一个系统有3个服务器，其中某些已经故障了，如果你要凑齐过半的服务器，你总是需要从3个服务器中凑出2个，即便你知道1个服务器已经因为故障关机了。过半总是相对于服务器的总数来说。</p>
<p>对于过半票决，可以用一个更通用的方程式来描述。在一个过半票决的系统中，如果有3台服务器，那么需要至少2台服务器来完成任意的操作。换个角度来看，这个系统可以接受1个服务器的故障，任意2个服务器都足以完成操作。如果你需要构建一个更加可靠的系统，那么你可以为系统加入更多的服务器。所以，更通用的方程是：</p>
<blockquote>
<p><strong>如果系统有 2 * F + 1 个服务器，那么系统最多可以接受F个服务器出现故障，仍然可以正常工作。</strong></p>
</blockquote>
<p>通常这也被称为多数投票（quorum）系统，因为3个服务器中的2个，就可以完成多数投票。</p>
<p>前面已经提过，有关过半票决系统的一个特性就是，最多只有一个网络分区会有过半的服务器，所以我们不可能有两个分区可以同时完成操作。这里背后更微妙的点在于，如果你总是需要过半的服务器才能完成任何操作，同时你有一系列的操作需要完成，其中的每一个操作都需要过半的服务器来批准，例如选举Raft的Leader，那么每一个操作对应的过半服务器，必然至少包含一个服务器存在于上一个操作的过半服务器中。也就是说，任意两组过半服务器，至少有一个服务器是重叠的。实际上，相比其他特性，Raft更依赖这个特性来避免脑裂。例如，当一个Raft Leader竞选成功，那么这个Leader必然凑够了过半服务器的选票，而这组过半服务器中，必然与旧Leader的过半服务器有重叠。所以，新的Leader必然知道旧Leader使用的任期号（term number），因为新Leader的过半服务器必然与旧Leader的过半服务器有重叠，而旧Leader的过半服务器中的每一个必然都知道旧Leader的任期号。类似的，任何旧Leader提交的操作，必然存在于过半的Raft服务器中，而任何新Leader的过半服务器中，必然有至少一个服务器包含了旧Leader的所有操作。这是Raft能正确运行的一个重要因素。</p>
<blockquote>
<p>学生提问：可以为Raft添加服务器吗？</p>
<p>Rober教授：Raft的服务器是可以添加或者修改的，Raft的论文有介绍，可能在Section 6。如果是一个长期运行的系统，例如运行5年或者10年，你可能需要定期更换或者升级一些服务器，因为某些服务器可能会出现永久的故障，又或者你可能需要将服务器搬到另一个机房去。所以，肯定需要支持修改Raft服务器的集合。虽然这不是每天都发生，但是这是一个长期运行系统的重要维护工作。Raft的作者提出了方法来处理这种场景，但是比较复杂。</p>
</blockquote>
<p>所以，在过半票决这种思想的支持下，大概1990年的时候，有两个系统基本同时被提出。这两个系统指出，你可以使用这种过半票决系统，从某种程度上来解决之前明显不可能避免的脑裂问题，例如，通过使用3个服务器而不是2个，同时使用过半票决策略。两个系统中的一个叫做Paxos，Raft论文对这个系统做了很多的讨论；另一个叫做ViewStamped Replication（VSR）。尽管Paxos的知名度高得多，Raft从设计上来说，与VSR更接近。VSR是由MIT发明的。这两个系统有着数十年的历史，但是他们仅仅是在15年前，也就是他们发明的15年之后，才开始走到最前线，被大量的大规模分布式系统所使用。</p>
<h2 id="3-Raft-初探"><a href="#3-Raft-初探" class="headerlink" title="3. Raft 初探"></a>3. Raft 初探</h2><p>Raft会以库（Library）的形式存在于服务中。如果你有一个基于Raft的多副本服务，那么每个服务的副本将会由两部分组成：应用程序代码和Raft库。应用程序代码接收RPC或者其他客户端请求；不同节点的Raft库之间相互合作，来维护多副本之间的操作同步。</p>
<p>从软件的角度来看一个Raft节点，我们可以认为在该节点的上层，是应用程序代码。例如对于Lab 3来说，这部分应用程序代码就是一个Key-Value数据库。应用程序通常都有状态，Raft层会帮助应用程序将其状态拷贝到其他副本节点。对于一个Key-Value数据库而言，对应的状态就是Key-Value Table。应用程序往下，就是Raft层。所以，Key-Value数据库需要对Raft层进行函数调用，来传递自己的状态和Raft反馈的信息。</p>
<p>同时，如Raft论文中的图2所示，Raft本身也会保持状态。对我们而言，Raft的状态中，最重要的就是Raft会记录操作的日志。</p>
<p><img  src="./image-20250131224240484.png"   style="zoom: 67%;" /><span class="image-caption">image-20250131224240484</span></p>
<p>对于一个拥有三个副本的系统来说，很明显我们会有三个服务器，这三个服务器有完全一样的结构（上面是应用程序层，下面是Raft层）。理想情况下，也会有完全相同的数据分别存在于两层（应用程序层和Raft层）中。除此之外，还有一些客户端，假设我们有了客户端1（C1），客户端2（C2）等等。</p>
<p><img  src="./image-20250131224341803.png"  ><span class="image-caption">image-20250131224341803</span></p>
<p>客户端就是一些外部程序代码，它们想要使用服务，同时它们不知道，也没有必要知道，它们正在与一个多副本服务交互。从客户端的角度来看，这个服务与一个单点服务没有区别。</p>
<p>客户端会将请求发送给当前Raft集群中的Leader节点对应的应用程序。这里的请求就是应用程序级别的请求，例如一个访问Key-Value数据库的请求。这些请求可能是Put也可能是Get。Put请求带了一个Key和一个Value，将会更新Key-Value数据库中，Key对应的Value；而Get向当前服务请求某个Key对应的Value。</p>
<p>所以，看起来似乎没有Raft什么事，看起来就像是普通的客户端服务端交互。一旦一个Put请求从客户端发送到了服务端，对于一个单节点的服务来说，应用程序会直接执行这个请求，更新Key-Value表，之后返回对于这个Put请求的响应。但是对于一个基于Raft的多副本服务，就要复杂一些。</p>
<p>假设客户端将请求发送给Raft的Leader节点，在服务端程序的内部，应用程序只会将来自客户端的请求对应的操作向下发送到Raft层，并且告知Raft层，请把这个操作提交到多副本的日志（Log）中，并在完成时通知我。</p>
<p>之后，Raft节点之间相互交互，直到过半的Raft节点将这个新的操作加入到它们的日志中，也就是说这个操作被过半的Raft节点复制了。</p>
<p>当且仅当Raft的Leader节点知道了所有（课程里说的是所有，但是这里应该是过半节点）的副本都有了这个操作的拷贝之后。Raft的Leader节点中的Raft层，会向上发送一个通知到应用程序，也就是Key-Value数据库，来说明：刚刚你提交给我的操作，我已经提交给所有（注：同上一个说明）副本，并且已经成功拷贝给它们了，现在，你可以真正的执行这个操作了。</p>
<p>所以，客户端发送请求给Key-Value数据库，这个请求不会立即被执行，因为这个请求还没有被拷贝。当且仅当这个请求存在于过半的副本节点中时，Raft才会通知Leader节点，只有在这个时候，Leader才会实际的执行这个请求。对于Put请求来说，就是更新Value，对于Get请求来说，就是读取Value。最终，请求返回给客户端，这就是一个普通请求的处理过程。</p>
<blockquote>
<p>学生提问：问题听不清。。。这里应该是学生在纠正前面对于所有节点和过半节点的混淆</p>
<p>Robert教授：这里只需要拷贝到过半服务器即可。为什么不需要拷贝到所有的节点？因为我们想构建一个容错系统，所以即使某些服务器故障了，我们依然期望服务能够继续工作。所以只要过半服务器有了相应的拷贝，那么请求就可以提交。</p>
<p>学生提问：除了Leader节点，其他节点的应用程序层会有什么样的动作？</p>
<p>Robert教授：哦对，抱歉。当一个操作最终在Leader节点被提交之后，每个副本节点的Raft层会将相同的操作提交到本地的应用程序层。在本地的应用程序层，会将这个操作更新到自己的状态。所以，理想情况是，所有的副本都将看到相同的操作序列，这些操作序列以相同的顺序出现在Raft到应用程序的upcall中，之后它们以相同的顺序被本地应用程序应用到本地的状态中。假设操作是确定的（比如一个随机数生成操作就不是确定的），所有副本节点的状态，最终将会是完全一样的。我们图中的Key-Value数据库，就是Raft论文中说的状态（也就是Key-Value数据库的多个副本最终会保持一致）。</p>
</blockquote>
<h2 id="4-Log-同步时序"><a href="#4-Log-同步时序" class="headerlink" title="4. Log 同步时序"></a>4. Log 同步时序</h2><p>接下来我将画一个时序图来描述Raft内部的消息是如何工作的。假设我们有一个客户端，服务器1是当前Raft集群的Leader。同时，我们还有服务器2，服务器3。这张图的纵坐标是时间，越往下时间越长。假设客户端将请求发送给服务器1，这里的客户端请求就是一个简单的请求，例如一个Put请求。</p>
<p><img  src="./image-20250131225756591.png"  ><span class="image-caption">image-20250131225756591</span></p>
<p>之后，服务器1的Raft层会发送一个添加日志（AppendEntries）的RPC到其他两个副本（S2，S3）。现在服务器1会一直等待其他副本节点的响应，一直等到过半节点的响应返回。这里的过半节点包括Leader自己。所以在一个只有3个副本节点的系统中，Leader只需要等待一个其他副本节点。</p>
<p><img  src="./image-20250131225809410.png"  ><span class="image-caption">image-20250131225809410</span></p>
<p>一旦过半的节点返回了响应，这里的过半节点包括了Leader自己，所以在一个只有3个副本的系统中，Leader只需要等待一个其他副本节点返回对于AppendEntries的正确响应。</p>
<p><img  src="./image-20250131225825412.png"  ><span class="image-caption">image-20250131225825412</span></p>
<p>当Leader收到了过半服务器的正确响应，Leader会执行（来自客户端的）请求，得到结果，并将结果返回给客户端。</p>
<p><img  src="./image-20250131225835695.png"  ><span class="image-caption">image-20250131225835695</span></p>
<p>与此同时，服务器3可能也会将它的响应返回给Leader，尽管这个响应是有用的，但是这里不需要等待这个响应。这一点对于理解Raft论文中的图2是有用的。</p>
<p><img  src="./image-20250131225855632.png"  ><span class="image-caption">image-20250131225855632</span></p>
<p>好了，大家明白了吗？这是系统在没有故障情况下，处理普通操作的流程。</p>
<blockquote>
<p>学生提问：S2和S3的状态怎么保持与S1同步？</p>
<p>Robert教授：我的天，我忘了一些重要的步骤。现在Leader知道过半服务器已经添加了Log，可以执行客户端请求，并返回给客户端。但是服务器2还不知道这一点，服务器2只知道：我从Leader那收到了这个请求，但是我不知道这个请求是不是已经被Leader提交（committed）了，这取决于我的响应是否被Leader收到。服务器2只知道，它的响应提交给了网络，或许Leader没有收到这个响应，也就不会决定commit这个请求。所以这里还有一个阶段。一旦Leader发现请求被commit之后，它需要将这个消息通知给其他的副本。所以这里有一个额外的消息。</p>
</blockquote>
<p><img  src="./image-20250131225909195.png"  ><span class="image-caption">image-20250131225909195</span></p>
<p>这条消息的具体内容依赖于整个系统的状态。至少在Raft中，没有明确的committed消息。相应的，committed消息被夹带在下一个AppendEntries消息中，由Leader下一次的AppendEntries对应的RPC发出。任何情况下，当有了committed消息时，这条消息会填在AppendEntries的RPC中。下一次Leader需要发送心跳，或者是收到了一个新的客户端请求，要将这个请求同步给其他副本时，Leader会将新的更大的commit号随着AppendEntries消息发出，当其他副本收到了这个消息，就知道之前的commit号已经被Leader提交，其他副本接下来也会执行相应的请求，更新本地的状态。</p>
<p><img  src="./image-20250131225921613.png"  ><span class="image-caption">image-20250131225921613</span></p>
<blockquote>
<p>学生提问：这里的内部交互有点多吧？</p>
<p>Robert教授：是的，这是一个内部需要一些交互的协议，它不是特别的快。实际上，客户端发出请求，请求到达某个服务器，这个服务器至少需要与一个其他副本交互，在返回给客户端之前，需要等待多条消息。所以，一个客户端响应的背后有多条消息的交互。</p>
<p>学生提问：也就是说commit信息是随着普通的AppendEntries消息发出的？那其他副本的状态更新就不是很及时了。</p>
<p>Robert教授：是的，作为实现者，这取决于你在什么时候将新的commit号发出。如果客户端请求很稀疏，那么Leader或许要发送一个心跳或者发送一条特殊的AppendEntries消息。如果客户端请求很频繁，那就无所谓了。因为如果每秒有1000个请求，那么下一条AppendEntries很快就会发出，你可以在下一条消息中带上新的commit号，而不用生成一条额外的消息。额外的消息代价还是有点高的，反正你要发送别的消息，可以把新的commit号带在别的消息里。</p>
<p>实际上，我不认为其他副本（非Leader）执行客户端请求的时间很重要，因为没有人在等这个步骤。至少在不出错的时候，其他副本执行请求是个不太重要的步骤。例如说，客户端就没有等待其他副本执行请求，客户端只会等待Leader执行请求。所以，其他副本在什么时候执行请求，不会影响客户端感受的请求时延。</p>
</blockquote>
<h2 id="5-日志"><a href="#5-日志" class="headerlink" title="5. 日志"></a>5. 日志</h2><p>Raft系统之所以对Log关注这么多的一个原因是，Log是Leader用来对操作排序的一种手段。这对于复制状态机（详见4.2）而言至关重要，对于这些复制状态机来说，所有副本不仅要执行相同的操作，还需要用相同的顺序执行这些操作。而Log与其他很多事物，共同构成了Leader对接收到的客户端操作分配顺序的机制。比如说，我有10个客户端同时向Leader发出请求，Leader必须对这些请求确定一个顺序，并确保所有其他的副本都遵从这个顺序。实际上，Log是一些按照数字编号的槽位（类似一个数组），槽位的数字表示了Leader选择的顺序。</p>
<p>Log的另一个用途是，在一个（非Leader，也就是Follower）副本收到了操作，但是还没有执行操作时。该副本需要将这个操作存放在某处，直到收到了Leader发送的新的commit号才执行。所以，对于Raft的Follower来说，Log是用来存放临时操作的地方。Follower收到了这些临时的操作，但是还不确定这些操作是否被commit了。我们将会看到，这些操作可能会被丢弃。</p>
<p>Log的另一个用途是用在Leader节点，我（Robert教授）很喜欢这个特性。Leader需要在它的Log中记录操作，因为这些操作可能需要重传给Follower。如果一些Follower由于网络原因或者其他原因短时间离线了或者丢了一些消息，Leader需要能够向Follower重传丢失的Log消息。所以，Leader也需要一个地方来存放客户端请求的拷贝。即使对那些已经commit的请求，为了能够向丢失了相应操作的副本重传，也需要存储在Leader的Log中。</p>
<p>所有节点都需要保存Log还有一个原因，就是它可以帮助重启的服务器恢复状态。你可能的确需要一个故障了的服务器在修复后，能重新加入到Raft集群，要不然你就永远少了一个服务器。比如对于一个3节点的集群来说，如果一个节点故障重启之后不能自动加入，那么当前系统只剩2个节点，那将不能再承受任何故障，所以我们需要能够重新并入故障重启了的服务器。对于一个重启的服务器来说，会使用存储在磁盘中的Log。每个Raft节点都需要将Log写入到它的磁盘中，这样它故障重启之后，Log还能保留。而这个Log会被Raft节点用来从头执行其中的操作进而重建故障前的状态，并继续以这个状态运行。所以，Log也会被用来持久化存储操作，服务器可以依赖这些操作来恢复状态。</p>
<blockquote>
<p>学生提问：假设Leader每秒可以执行1000条操作，Follower只能每秒执行100条操作，并且这个状态一直持续下去，会怎样？</p>
<p>Robert（教授）：这里有一点需要注意，Follower在实际执行操作前会确认操作。所以，它们会确认，并将操作堆积在Log中。而Log又是无限的，所以Follower或许可以每秒确认1000个操作。如果Follower一直这么做，它会生成无限大的Log，因为Follower的执行最终将无限落后于Log的堆积。 所以，当Follower堆积了10亿（不是具体的数字，指很多很多）Log未执行，最终这里会耗尽内存。之后Follower调用内存分配器为Log申请新的内存时，内存申请会失败。Raft并没有流控机制来处理这种情况。</p>
<p>所以我认为，在一个实际的系统中，你需要一个额外的消息，这个额外的消息可以夹带在其他消息中，也不必是实时的，但是你或许需要一些通信来（让Follower）告诉Leader，Follower目前执行到了哪一步。这样Leader就能知道自己在操作执行上领先太多。所以是的，我认为在一个生产环境中，如果你想使用系统的极限性能，你还是需要一条额外的消息来调节Leader的速度。</p>
<p>学生提问：如果其中一个服务器故障了，它的磁盘中会存有Log，因为这是Raft论文中图2要求的，所以服务器可以从磁盘中的Log恢复状态，但是这个服务器不知道它当前在Log中的执行位置。同时，当它第一次启动时，它也不知道那些Log被commit了。</p>
<p>Robert教授：所以，对于第一个问题的答案是，一个服务器故障重启之后，它会立即读取Log，但是接下来它不会根据Log做任何操作，因为它不知道当前的Raft系统对Log提交到了哪一步，或许有1000条未提交的Log。</p>
<p>学生补充问题：如果Leader出现了故障会怎样？</p>
<p>Robert教授：如果Leader也关机也没有区别。让我们来假设Leader和Follower同时故障了，那么根据Raft论文图2，它们只有non-volatile状态（也就是磁盘中存储的状态）。这里的状态包括了Log和最近一次任期号（Term Number）。如果大家都出现了故障然后大家都重启了，它们中没有一个在刚启动的时候就知道它们在故障前执行到了哪一步。所以这个时候，会先进行Leader选举，其中一个被选为Leader。如果你回顾一下Raft论文中的图2有关AppendEntries的描述，这个Leader会在发送第一次心跳时弄清楚，整个系统中目前执行到了哪一步。Leader会确认一个过半服务器认可的最近的Log执行点，这就是整个系统的执行位置。另一种方式来看这个问题，一旦你通过AppendEntries选择了一个Leader，这个Leader会迫使其他所有副本的Log与自己保持一致。这时，再配合Raft论文中介绍的一些其他内容，由于Leader知道它迫使其他所有的副本都拥有与自己一样的Log，那么它知道，这些Log必然已经commit，因为它们被过半的副本持有。这时，按照Raft论文的图2中对AppendEntries的描述，Leader会增加commit号。之后，所有节点可以从头开始执行整个Log，并从头构造自己的状态。但是这里的计算量或许会非常大。所以这是Raft论文的图2所描述的过程，很明显，这种从头开始执行的机制不是很好，但是这是Raft协议的工作流程。下一课我们会看一种更有效的，利用checkpoint的方式。</p>
</blockquote>
<h2 id="6-应用层接口"><a href="#6-应用层接口" class="headerlink" title="6. 应用层接口"></a>6. 应用层接口</h2><p>这一部分简单介绍一下应用层和Raft层之间的接口。你或许已经通过实验了解了一些，但是我们这里大概来看一下。假设我们的应用程序是一个key-value数据库，下面一层是Raft层。</p>
<p><img  src="./image-20250203170814935.png"  ><span class="image-caption">image-20250203170814935</span></p>
<p>在Raft集群中，每一个副本上，这两层之间主要有两个接口。</p>
<p>第一个接口是key-value层用来转发客户端请求的接口。如果客户端发送一个请求给key-value层，key-value层会将这个请求转发给Raft层，并说：请将这个请求存放在Log中的某处。</p>
<p><img  src="./image-20250203170845208.png"  ><span class="image-caption">image-20250203170845208</span></p>
<p>这个接口实际上是个函数调用，称之为Start函数。这个函数只接收一个参数，就是客户端请求。key-value层说：我接到了这个请求，请把它存在Log中，并在committed之后告诉我。</p>
<p><img  src="./image-20250203170906267.png"  ><span class="image-caption">image-20250203170906267</span></p>
<p>另一个接口是，随着时间的推移，Raft层会通知key-value层：哈，你刚刚在Start函数中传给我的请求已经commit了。Raft层通知的，不一定是最近一次Start函数传入的请求。例如在任何请求commit之前，可能会再有超过100个请求通过Start函数传给Raft层。</p>
<p><img  src="./image-20250203170931436.png"  ><span class="image-caption">image-20250203170931436</span></p>
<p>这个向上的接口以go channel中的一条消息的形式存在。Raft层会发出这个消息，key-value层要读取这个消息。所以这里有个叫做applyCh的channel，通过它你可以发送ApplyMsg消息。</p>
<p><img  src="./image-20250203170948828.png"  ><span class="image-caption">image-20250203170948828</span></p>
<p>当然，key-value层需要知道从applyCh中读取的消息，对应之前调用的哪个Start函数，所以Start函数的返回需要有足够的信息给key-value层，这样才能完成对应。Start函数的返回值包括，这个请求将会存放在Log中的位置（index）。这个请求不一定能commit成功，但是如果commit成功的话，会存放在这个Log位置。同时，它还会返回当前的任期号（term number）和一些其它我们现在还不太关心的内容。</p>
<p><img  src="./image-20250203171040933.png"  ><span class="image-caption">image-20250203171040933</span></p>
<p>在ApplyMsg中，将会包含请求（command）和对应的Log位置（index）。</p>
<p><img  src="./image-20250203171052069.png"  ><span class="image-caption">image-20250203171052069</span></p>
<p>所有的副本都会收到这个ApplyMsg消息，它们都知道自己应该执行这个请求，弄清楚这个请求的具体含义，并将它应用在本地的状态中。所有的副本节点还会拿到Log的位置信息（index），但是这个位置信息只在Leader有用，因为Leader需要知道ApplyMsg中的请求究竟对应哪个客户端请求（进而响应客户端请求）。</p>
<blockquote>
<p>学生提问：为什么不在Start函数返回的时候就响应客户端请求呢？</p>
<p>Robert教授：我们假设客户端发送了任意的请求，我们假设这里是一个Put或者Get请求，是什么其实不重要，我们还是假设这里是个Get请求。客户端发送了一个Get请求，并且等待响应。当Leader知道这个请求被（Raft）commit之后，会返回响应给客户端。所以这里会是一个Get响应。所以，（在Leader返回响应之前）客户端看不到任何内容。</p>
<p>这意味着，在实际的软件中，客户端调用key-value的RPC，key-value层收到RPC之后，会调用Start函数，Start函数会立即返回，但是这时，key-value层不会返回消息给客户端，因为它还没有执行客户端请求，它也不知道这个请求是否会被（Raft）commit。一个不能commit的场景是，当key-value层调用了Start函数，Start函数返回之后，它就故障了，所以它必然没有发送Apply Entry消息或者其他任何消息，所以也不能执行commit。</p>
<p>所以实际上，Start函数返回了，随着时间的推移，对应于这个客户端请求的ApplyMsg从applyCh channel中出现在了key-value层。只有在那个时候，key-value层才会执行这个请求，并返回响应给客户端。</p>
</blockquote>
<p>有一件事情你们需要熟悉，那就是，首先，对于Log来说有一件有意思的事情：不同副本的Log或许不完全一样。有很多场合都会不一样，至少不同副本节点的Log的末尾，会短暂的不同。例如，一个Leader开始发出一轮AppendEntries消息，但是在完全发完之前就故障了。这意味着某些副本收到了这个AppendEntries，并将这条新Log存在本地。而那些没有收到AppendEntries消息的副本，自然也不会将这条新Log存入本地。所以，这里很容易可以看出，不同副本中，Log有时会不一样。</p>
<p>不过对于Raft来说，Raft会最终强制不同副本的Log保持一致。或许会有短暂的不一致，但是长期来看，所有副本的Log会被Leader修改，直到Leader确认它们都是一致的。</p>
<p>接下来会有有关Raft的两个大的主题，一个是Lab2的内容：Leader Election是如何工作的；另一个是，Leader如何处理不同的副本日志的差异，尤其在出现故障之后。</p>
<h2 id="7-Leader选举（Leader-Election）"><a href="#7-Leader选举（Leader-Election）" class="headerlink" title="7. Leader选举（Leader Election）"></a>7. Leader选举（Leader Election）</h2><p>这一部分我们来看一下Leader选举。这里有个问题，为什么Raft系统会有个Leader，为什么我们需要一个Leader？</p>
<p>答案是，你可以不用Leader就构建一个类似的系统。实际上有可能不引入任何指定的Leader，通过一组服务器来共同认可Log的顺序，进而构建一个一致系统。实际上，Raft论文中引用的Paxos系统就没有Leader，所以这是有可能的。</p>
<p>有很多原因导致了Raft系统有一个Leader，其中一个最主要的是：通常情况下，如果服务器不出现故障，有一个Leader的存在，会使得整个系统更加高效。因为有了一个大家都知道的指定的Leader，对于一个请求，你可以只通过一轮消息就获得过半服务器的认可。对于一个无Leader的系统，通常需要一轮消息来确认一个临时的Leader，之后第二轮消息才能确认请求。所以，使用一个Leader可以提升系统性能至2倍。同时，有一个Leader可以更好的理解Raft系统是如何工作的。</p>
<p>Raft生命周期中可能会有不同的Leader，它使用任期号（term number）来区分不同的Leader。Followers（非Leader副本节点）不需要知道Leader的ID，它们只需要知道当前的任期号。每一个任期最多有一个Leader，这是一个很关键的特性。对于每个任期来说，或许没有Leader，或许有一个Leader，但是不可能有两个Leader出现在同一个任期中。每个任期必然最多只有一个Leader。</p>
<p>那Leader是如何创建出来的呢？每个Raft节点都有一个选举定时器（Election Timer），如果在这个定时器时间耗尽之前，当前节点没有收到任何当前Leader的消息，这个节点会认为Leader已经下线，并开始一次选举。所以我们这里有了这个选举定时器，当它的时间耗尽时，当前节点会开始一次选举。</p>
<p>开始一次选举的意思是，当前服务器会增加任期号（term number），因为它想成为一个新的Leader。而你知道的，一个任期内不能有超过一个Leader，所以为了成为一个新的Leader，这里需要开启一个新的任期。 之后，当前服务器会发出请求投票（RequestVote）RPC，这个消息会发给所有的Raft节点。其实只需要发送到N-1个节点，因为Raft规定了，Leader的候选人总是会在选举时投票给自己。</p>
<p>这里需要注意的一点是，并不是说如果Leader没有故障，就不会有选举。但是如果Leader的确出现了故障，那么一定会有新的选举。这个选举的前提是其他服务器还在运行，因为选举需要其他服务器的选举定时器超时了才会触发。另一方面，如果Leader没有故障，我们仍然有可能会有一次新的选举。比如，如果网络很慢，丢了几个心跳，或者其他原因，这时，尽管Leader还在健康运行，我们可能会有某个选举定时器超时了，进而开启一次新的选举。在考虑正确性的时候，我们需要记住这点。所以这意味着，如果有一场新的选举，有可能之前的Leader仍然在运行，并认为自己还是Leader。例如，当出现网络分区时，旧Leader始终在一个小的分区中运行，而较大的分区会进行新的选举，最终成功选出一个新的Leader。这一切，旧的Leader完全不知道。所以我们也需要关心，在不知道有新的选举时，旧的Leader会有什么样的行为？</p>
<p>（注：下面这一段实际在Lec 06的65-67分钟出现，与这一篇前后的内容在时间上不连续，但是因为内容相关就放到这里来了）</p>
<p>假设网线故障了，旧的Leader在一个网络分区中，这个网络分区中有一些客户端和少数（未过半）的服务器。在网络的另一个分区中，有着过半的服务器，这些服务器选出了一个新的Leader。旧的Leader会怎样，或者说为什么旧的Leader不会执行错误的操作？这里看起来有两个潜在的问题。第一个问题是，如果一个Leader在一个网络分区中，并且这个网络分区没有过半的服务器。那么下次客户端发送请求时，这个在少数分区的Leader，它会发出AppendEntries消息。但是因为它在少数分区，即使包括它自己，它也凑不齐过半服务器，所以它永远不会commit这个客户端请求，它永远不会执行这个请求，它也永远不会响应客户端，并告诉客户端它已经执行了这个请求。所以，如果一个旧的Leader在一个不同的网络分区中，客户端或许会发送一个请求给这个旧的Leader，但是客户端永远也不能从这个Leader获得响应。所以没有客户端会认为这个旧的Leader执行了任何操作。另一个更奇怪的问题是，有可能Leader在向一部分Followers发完AppendEntries消息之后就故障了，所以这个Leader还没决定commit这个请求。这是一个非常有趣的问题，我将会再花45分钟（下一节课）来讲。</p>
<blockquote>
<p>学生提问：有没有可能出现极端的情况，导致单向的网络出现故障，进而使得Raft系统不能工作？</p>
<p>Robert教授：我认为是有可能的。例如，如果当前Leader的网络单边出现故障，Leader可以发出心跳，但是又不能收到任何客户端请求。它发出的心跳被送达了，因为它的出方向网络是正常的，那么它的心跳会抑制其他服务器开始一次新的选举。但是它的入方向网络是故障的，这会阻止它接收或者执行任何客户端请求。这个场景是Raft并没有考虑的众多极端的网络故障场景之一。</p>
<p>我认为这个问题是可修复的。我们可以通过一个双向的心跳来解决这里的问题。在这个双向的心跳中，Leader发出心跳，但是这时Followers需要以某种形式响应这个心跳。如果Leader一段时间没有收到自己发出心跳的响应，Leader会决定卸任，这样我认为可以解决这个特定的问题和一些其他的问题。</p>
<p>你是对的，网络中可能发生非常奇怪的事情，而Raft协议没有考虑到这些场景。</p>
</blockquote>
<p>所以，我们这里有Leader选举，我们需要确保每个任期最多只有一个Leader。Raft是如何做到这一点的呢？</p>
<p>为了能够当选，Raft要求一个候选人从过半服务器中获得认可投票。每个Raft节点，只会在一个任期内投出一个认可选票。这意味着，在任意一个任期内，每一个节点只会对一个候选人投一次票。这样，就不可能有两个候选人同时获得过半的选票，因为每个节点只会投票一次。所以这里是过半原则导致了最多只能有一个胜出的候选人，这样我们在每个任期会有最多一个选举出的候选人。</p>
<p>同时，也是非常重要的一点，过半原则意味着，即使一些节点已经故障了，你仍然可以赢得选举。如果少数服务器故障了或者出现了网络问题，我们仍然可以选举出Leader。如果超过一半的节点故障了，不可用了，或者在另一个网络分区，那么系统会不断地额尝试选举Leader，并永远也不能选出一个Leader，因为没有过半的服务器在运行。</p>
<p>如果一次选举成功了，整个集群的节点是如何知道的呢？当一个服务器赢得了一次选举，这个服务器会收到过半的认可投票，这个服务器会直接知道自己是新的Leader，因为它收到了过半的投票。但是其他的服务器并不能直接知道谁赢得了选举，其他服务器甚至都不知道是否有人赢得了选举。这时，（赢得了选举的）候选人，会通过心跳通知其他服务器。Raft论文的图2规定了，如果你赢得了选举，你需要立刻发送一条AppendEntries消息给其他所有的服务器。这条代表心跳的AppendEntries并不会直接说：我赢得了选举，我就是任期23的Leader。这里的表达会更隐晦一些。Raft规定，除非是当前任期的Leader，没人可以发出AppendEntries消息。所以假设我是一个服务器，我发现对于任期19有一次选举，过了一会我收到了一条AppendEntries消息，这个消息的任期号就是19。那么这条消息告诉我，我不知道的某个节点赢得了任期19的选举。所以，其他服务器通过接收特定任期号的AppendEntries来知道，选举成功了。</p>
<h2 id="8-选举定时器（Election-Timer）"><a href="#8-选举定时器（Election-Timer）" class="headerlink" title="8. 选举定时器（Election Timer）"></a>8. 选举定时器（Election Timer）</h2><p>任何一条AppendEntries消息都会重置所有Raft节点的选举定时器。这样，只要Leader还在线，并且它还在以合理的速率（不能太慢）发出心跳或者其他的AppendEntries消息，Followers收到了AppendEntries消息，会重置自己的选举定时器，这样Leader就可以阻止任何其他节点成为一个候选人。所以只要所有环节都在正常工作，不断重复的心跳会阻止任何新的选举发生。当然，如果网络故障或者发生了丢包，不可避免的还是会有新的选举。但是如果一切都正常，我们不太可能会有一次新的选举。</p>
<p>如果一次选举选出了0个Leader，这次选举就失败了。有一些显而易见的场景会导致选举失败，例如太多的服务器关机或者不可用了，或者网络连接出现故障。这些场景会导致你不能凑齐过半的服务器，进而也不能赢得选举，这时什么事也不会发生。</p>
<p>一个导致选举失败的更有趣的场景是，所有环节都在正常工作，没有故障，没有丢包，但是候选人们几乎是同时参加竞选，它们分割了选票（Split Vote）。假设我们有一个3节点的多副本系统，3个节点的选举定时器几乎同超时，进而期触发选举。首先，每个节点都会为自己投票。之后，每个节点都会收到其他节点的RequestVote消息，因为该节点已经投票给自己了，所以它会返回反对投票。这意味着，3个节点中的每个节点都只能收到一张投票（来自于自己）。没有一个节点获得了过半投票，所以也就没有人能被选上。接下来它们的选举定时器会重新计时，因为选举定时器只会在收到了AppendEntries消息时重置，但是由于没有Leader，所有也就没有AppendEntries消息。所有的选举定时器重新开始计时，如果我们不够幸运的话，所有的定时器又会在同一时间到期，所有节点又会投票给自己，又没有人获得了过半投票，这个状态可能会一直持续下去。</p>
<p>Raft不能完全避免分割选票（Split Vote），但是可以使得这个场景出现的概率大大降低。Raft通过为选举定时器随机的选择超时时间来达到这一点。我们可以这样来看这种随机的方法。假设这里有个时间线，我会在上面画上事件。在某个时间，所有的节点收到了最后一条AppendEntries消息。之后，Leader就故障了。我们这里假设Leader在发出最后一次心跳之后就故障关机了。所有的Followers在同一时间重置了它们的选举定时器，因为它们大概率在同一时间收到了这条AppendEntries消息。</p>
<p><img  src="./image-20250203172126615.png"  ><span class="image-caption">image-20250203172126615</span></p>
<p>它们都重置了自己的选举定时器，这样在将来的某个时间会触发选举。但是这时，它们为选举定时器选择了不同的超时时间。</p>
<p>假设故障的旧的Leader是服务器1，那么服务器2（S2），服务器3（S3）会在这个点为它们的选举定时器设置随机的超时时间。</p>
<p><img  src="./image-20250203172149555.png"  ><span class="image-caption">image-20250203172149555</span></p>
<p>这个图里的关键点在于，因为不同的服务器都选取了随机的超时时间，总会有一个选举定时器先超时，而另一个后超时。假设S2和S3之间的差距足够大，先超时的那个节点（也就是S2）能够在另一个节点（也就是S3）超时之前，发起一轮选举，并获得过半的选票，那么那个节点（也就是S2）就可以成为新的Leader。大家都明白了随机化是如何去除节点之间的同步特性吗？</p>
<p>这里对于选举定时器的超时时间的设置，需要注意一些细节。一个明显的要求是，选举定时器的超时时间需要至少大于Leader的心跳间隔。这里非常明显，假设Leader每100毫秒发出一个心跳，你最好确认所有节点的选举定时器的超时时间不要小于100毫秒，否则该节点会在收到正常的心跳之前触发选举。所以，选举定时器的超时时间下限是一个心跳的间隔。实际上由于网络可能丢包，这里你或许希望将下限设置为多个心跳间隔。所以如果心跳间隔是100毫秒，你或许想要将选举定时器的最短超时时间设置为300毫秒，也就是3次心跳的间隔。所以，如果心跳间隔是这么多（两个AE之间），那么你会想要将选举定时器的超时时间下限设置成心跳间隔的几倍，在这里。</p>
<p><img  src="./image-20250203172249003.png"  ><span class="image-caption">image-20250203172249003</span></p>
<p>那超时时间的上限呢？因为随机的话都是在一个范围内随机，那我们应该在哪设置超时时间的上限呢？在一个实际系统中，有几点需要注意。</p>
<p><img  src="./image-20250203172303521.png"  ><span class="image-caption">image-20250203172303521</span></p>
<p>首先，这里的最大超时时间影响了系统能多快从故障中恢复。因为从旧的Leader故障开始，到新的选举开始这段时间，整个系统是瘫痪了。尽管还有一些其他服务器在运行，但是因为没有Leader，客户端请求会被丢弃。所以，这里的上限越大，系统的恢复时间也就越长。这里究竟有多重要，取决于我们需要达到多高的性能，以及故障出现的频率。如果一年才出一次故障，那就无所谓了。如果故障很频繁，那么我们或许就该关心恢复时间有多长。这是一个需要考虑的点。</p>
<p>另一个需要考虑的点是，不同节点的选举定时器的超时时间差（S2和S3之间）必须要足够长，使得第一个开始选举的节点能够完成一轮选举。这里至少需要大于发送一条RPC所需要的往返（Round-Trip）时间。</p>
<p><img  src="./image-20250203172448581.png"  ><span class="image-caption">image-20250203172448581</span></p>
<p>或许需要10毫秒来发送一条RPC，并从其他所有服务器获得响应。如果这样的话，我们需要设置超时时间的上限到足够大，从而使得两个随机数之间的时间差极有可能大于10毫秒。</p>
<p>在Lab2中，如果你的代码不能在几秒内从一个Leader故障的场景中恢复的话，测试代码会报错。所以这种场景下，你们需要调小选举定时器超时时间的上限。这样的话，你才可能在几秒内完成一次Leader选举。这并不是一个很严格的限制。</p>
<p>这里还有一个小点需要注意，每一次一个节点重置自己的选举定时器时，都需要重新选择一个随机的超时时间。也就是说，不要在服务器启动的时候选择一个随机的超时时间，然后反复使用同一个值。因为如果你不够幸运的话，两个服务器会以极小的概率选择相同的随机超时时间，那么你会永远处于分割选票的场景中。所以你需要每次都为选举定时器选择一个不同的随机超时时间。</p>
<h2 id="9-可能的异常情况"><a href="#9-可能的异常情况" class="headerlink" title="9. 可能的异常情况"></a>9. 可能的异常情况</h2><p>一个旧Leader在各种奇怪的场景下故障之后，为了恢复系统的一致性，一个新任的Leader如何能整理在不同副本上可能已经不一致的Log？</p>
<p>这个话题只在Leader故障之后才有意义，如果Leader正常运行，Raft不太会出现问题。如果Leader正在运行，并且在其运行时，系统中有过半服务器。Leader只需要告诉Followers，Log该是什么样子。Raft要求Followers必须同意并接收Leader的Log，这在Raft论文的图2中有说明。只要Followers还能处理，它们就会全盘接收Leader在AppendEntries中发送给它们的内容，并加到本地的Log中。之后再收到来自Leader的commit消息，在本地执行请求。这里很难出错。</p>
<p>在Raft中，当Leader故障了才有可能出错。例如，旧的Leader在发送消息的过程中故障了，或者新Leader在刚刚当选之后，还没来得及做任何操作就故障了。所以这里有一件事情我们非常感兴趣，那就是在一系列故障之后，Log会是怎样？</p>
<p>这里有个例子，假设我们有3个服务器（S1，S2，S3），我将写出每个服务器的Log，每一列对齐之后就是Log的一个槽位。我这里写的值是Log条目对应的任期号，而不是Log记录的客户端请求。所以第一列是槽位1，第二列是槽位2。所有节点在任期3的时候记录了一个请求在槽位1，S2和S3在任期3的时候记录了一个请求在槽位2。在槽位2，S1没有任何记录。 </p>
<h1 id="Lab-2-Key-Value-Server"><a href="#Lab-2-Key-Value-Server" class="headerlink" title="Lab 2: Key/Value Server"></a>Lab 2: Key/Value Server</h1><h2 id="intro"><a href="#intro" class="headerlink" title="intro"></a>intro</h2><p>在本实验中，你将构建一个单机键值服务器，该服务器确保每个操作即使在网络故障的情况下也能仅执行一次，并且操作是可线性化的。后续实验将复制此类服务器以处理服务器崩溃的情况。</p>
<p>客户端可以向键值服务器发送三种不同的远程过程调用（RPC）：Put(key, value)、Append(key, arg) 和 Get(key)。服务器维护一个内存中的键值对映射。键和值均为字符串。Put(key, value) 用于在映射中安装或替换特定键的值，Append(key, arg) 将参数 arg 追加到键的值并返回旧值，Get(key) 获取键的当前值。对于不存在的键，Get 应返回空字符串。对于不存在的键执行 Append 操作时，应将其视为现有值为零长度字符串的情况。每个客户端通过 Clerk（包含 Put/Append/Get 方法）与服务器通信。Clerk 管理与服务器的 RPC 交互。</p>
<p>你的服务器必须确保应用程序对 Clerk 的 Get/Put/Append 方法的调用是可线性化的。如果客户端请求不是并发的，每个客户端的 Get/Put/Append 调用应观察到前面一系列调用所隐含的状态修改。对于并发调用，返回值和最终状态必须与操作按某种顺序依次执行时相同。调用在时间上有重叠时即为并发，例如，如果客户端 X 调用 Clerk.Put()，客户端 Y 调用 Clerk.Append()，然后客户端 X 的调用返回。一个调用必须观察到在其开始之前已完成的所有调用的效果。</p>
<p>线性化对于应用程序来说非常方便，因为这是你从一个依次处理请求的单个服务器中看到的行为。例如，如果一个客户端从服务器获得更新请求的成功响应，随后其他客户端发起的读取操作将肯定能看到该更新的效果。对于单个服务器，提供线性化相对容易。</p>
<h2 id="线性化"><a href="#线性化" class="headerlink" title="线性化"></a>线性化</h2><p>Q: 什么是线性化（linearizability）？</p>
<p>A: 线性化是定义服务在面对并发客户端请求时行为正确性的一种方式。大致来说，它规定服务应看起来像是按请求到达的顺序依次执行请求。</p>
<p>线性化是基于“历史记录”定义的：实际客户端请求和服务器响应的轨迹，标注了客户端发送和接收每条消息的时间。线性化告诉你单个历史记录是否合法；我们可以说，如果服务可以生成的每个历史记录都是线性化的，那么该服务就是线性化的。</p>
<p>对于每个客户端请求，请求消息和对应的响应消息是历史记录中的独立元素，每条消息出现在客户端发送或接收的时间点。因此，历史记录明确展示了请求的并发性和网络延迟。</p>
<p>如果可以为每个操作分配一个“线性化点”（一个时间点），使得每个操作的点位于客户端发送请求和接收响应的时间之间，并且历史记录的响应值与按点的顺序依次执行请求时得到的值相同，那么这个历史记录就是线性化的。如果没有任何线性化点的分配能满足这两个要求，那么该历史记录就不是线性化的。</p>
<p>线性化的一个重要后果是，服务在执行并发（时间上重叠）操作的顺序上有一定的自由度。特别是，如果来自客户端C1和C2的请求是并发的，服务器可能会先执行C2的请求，即使C1发送请求消息的时间早于C2。另一方面，如果C1在C2发送请求之前收到了响应，线性化要求服务表现得像是先执行了C1的请求（即C2的操作必须观察到C1操作的效果，如果有的话）。</p>
<p>Q: 线性化检查器是如何工作的？</p>
<p>A: 一个简单的线性化检查器会尝试每一种可能的顺序（或线性化点的选择），以查看是否有一种是根据线性化定义的规则有效的。由于在大型历史记录上这样做会太慢，聪明的检查器会避免查看明显不可能的顺序（例如，提议的线性化点在操作开始时间之前），在可能的情况下将历史记录分解为可以单独检查的子历史记录，并使用启发式方法首先尝试更可能的顺序。</p>
<p>这些论文描述了这些技术；我认为Knossos是基于第一篇论文，而Porcupine增加了第二篇论文中的想法：</p>
<p><a href="http://www.cs.ox.ac.uk/people/gavin.lowe/LinearizabiltyTesting/paper.pdf">http://www.cs.ox.ac.uk/people/gavin.lowe/LinearizabiltyTesting/paper.pdf</a></p>
<p><a href="https://arxiv.org/pdf/1504.00204.pdf">https://arxiv.org/pdf/1504.00204.pdf</a></p>
<p>Q: 服务是否使用线性化检查器来实现线性化？</p>
<p>A: 不；检查器仅在测试中使用。</p>
<p>Q: 那么服务是如何实现线性化的？</p>
<p>A: 如果服务实现为单个服务器，没有复制、缓存或内部并行性，那么服务几乎只需要按请求到达的顺序依次执行客户端请求。主要的复杂性来自于客户端因为认为网络丢失了消息而重新发送请求：对于有副作用的请求，服务必须小心不要执行任何给定的客户端请求超过一次。如果服务涉及复制或缓存，则需要更复杂的设计。</p>
<p>Q: 你知道有哪些现实世界中的系统使用Porcupine或类似的测试框架进行测试的例子吗？</p>
<p>A: 这种测试很常见——例如，可以看看 <a href="https://jepsen.io/analyses；Jepsen是一个测试了许多存储系统正确性（以及适当情况下的线性化）的组织。">https://jepsen.io/analyses；Jepsen是一个测试了许多存储系统正确性（以及适当情况下的线性化）的组织。</a></p>
<p>特别是Porcupine的一个例子：</p>
<p><a href="https://www.vldb.org/pvldb/vol15/p2201-zare.pdf">https://www.vldb.org/pvldb/vol15/p2201-zare.pdf</a></p>
<p>Q: 还有哪些其他的一致性模型？</p>
<p>A: 查找以下模型：</p>
<ul>
<li>最终一致性</li>
<li>因果一致性</li>
<li>叉一致性</li>
<li>可串行化</li>
<li>顺序一致性</li>
<li>时间线一致性</li>
</ul>
<p>还有数据库、CPU内存/缓存系统和文件系统中的其他模型。</p>
<p>一般来说，不同的模型在对应用程序开发者的直观性和性能方面有所不同。例如，最终一致性允许许多异常结果（例如，即使写入已完成，后续读取可能看不到它），但在分布式/复制环境中，它可以比线性化实现更高的性能。</p>
<p>Q: 为什么线性化被称为强一致性模型？</p>
<p>A: 它之所以被称为强一致性模型，是因为它禁止了许多可能会让应用程序开发者感到惊讶的情况。</p>
<p>例如，如果我调用put(x, 22)，并且我的put完成，之后没有其他人写x，随后你调用get(x)，你保证会看到22，而不是其他值。也就是说，读取会看到最新的数据。</p>
<p>另一个例子是，如果没有人写x，我调用get(x)，你调用get(x)，我们不会看到不同的值。</p>
<p>这些属性在我们将要研究的其他一致性模型（如最终一致性和因果一致性）中并不成立。这些模型通常被称为“弱”一致性模型。</p>
<p>Q: 人们在实践中如何确保他们的分布式系统是正确的？</p>
<p>A: 我猜彻底的测试是最常见的计划。</p>
<p>正式方法的使用也很普遍；可以看看这里的一些例子：</p>
<p><a href="https://arxiv.org/pdf/2210.13661.pdf">https://arxiv.org/pdf/2210.13661.pdf</a></p>
<p><a href="https://assets.amazon.science/67/f9/92733d574c11ba1a11bd08bfb8ae/how-amazon-web-services-uses-formal-methods.pdf">https://assets.amazon.science/67/f9/92733d574c11ba1a11bd08bfb8ae/how-amazon-web-services-uses-formal-methods.pdf</a></p>
<p><a href="https://dl.acm.org/doi/abs/10.1145/3477132.3483540">https://dl.acm.org/doi/abs/10.1145/3477132.3483540</a></p>
<p><a href="https://www.ccs.neu.edu/~stavros/papers/2022-cpp-published.pdf">https://www.ccs.neu.edu/~stavros/papers/2022-cpp-published.pdf</a></p>
<p><a href="https://www.cs.purdue.edu/homes/pfonseca/papers/eurosys2017-dsbugs.pdf">https://www.cs.purdue.edu/homes/pfonseca/papers/eurosys2017-dsbugs.pdf</a></p>
<p>Q: 为什么线性化被用作一致性模型，而不是其他模型，如最终一致性？</p>
<p>A: 人们确实经常构建提供比线性化更弱一致性的存储系统，如最终一致性和因果一致性。</p>
<p>线性化对应用程序编写者有一些很好的特性：</p>
<ul>
<li>读取总是观察到最新的数据。</li>
<li>如果没有并发写入，所有读者看到相同的数据。</li>
<li>在大多数线性化系统上，你可以添加像test-and-set这样的小型事务（因为大多数线性化设计最终会依次执行每个数据项的操作）。</li>
</ul>
<p>像最终一致性和因果一致性这样的更弱方案可以允许更高的性能，因为它们不要求立即更新所有数据副本。这种更高的性能通常是决定因素。然而，弱一致性为应用程序编写者引入了一些复杂性：</p>
<ul>
<li>读取可以观察到过时的数据。</li>
<li>读取可以观察到写入的顺序错误。</li>
<li>如果你写入，然后读取，你可能看不到你的写入，而是看到过时的数据。</li>
<li>对同一项目的并发更新不是依次执行的，因此很难实现像test-and-set这样的小型事务。</li>
</ul>
<p>Q: 如何决定线性化的小橙线的位置——操作的线性化点？在图上看起来像是随机画在请求主体内的某个地方？</p>
<p>A: 这个想法是，为了证明执行是线性化的，你需要（作为人类）找到放置小橙线（线性化点）的位置。也就是说，为了证明历史记录是线性化的，你需要找到符合这些要求的操作顺序：</p>
<ul>
<li>所有函数调用都有一个线性化点，位于其调用和响应之间。</li>
<li>所有函数似乎在它们的线性化点瞬间发生，按照顺序定义的行为。</li>
</ul>
<p>因此，一些线性化点的放置是无效的，因为它们位于请求时间范围之外；其他放置是无效的，因为它们违反了顺序定义（对于键值存储，违反意味着读取没有观察到最新写入的值，其中“最新”指的是线性化点）。</p>
<p>在复杂情况下，你可能需要尝试许多线性化点顺序的组合，以找到一个能够证明历史记录是线性化的组合。如果你尝试了所有组合，但没有一个有效，那么该历史记录就不是线性化的。</p>
<p>Q: 是否存在这种情况：如果两个命令同时执行，我们能够强制执行特定行为，使得一个命令总是首先执行（即它总是有更早的线性化点）？</p>
<p>A: 在线性化的存储服务中（例如GFS或你的Lab 3），如果来自多个客户端的请求几乎同时到达，服务可以选择执行它们的顺序。尽管在实践中，大多数服务会按照请求数据包到达网络的顺序执行并发请求。</p>
<p>线性化点的概念是检查历史记录是否线性化的一种策略的一部分。实际实现通常不涉及线性化点的明确概念。相反，它们通常只是按某种串行（依次）顺序执行传入请求。你可以将每个操作的线性化点视为发生在服务执行请求期间的某个时间点。</p>
<p>Q: 我们还可以执行哪些更强的一致性检查？线性化在直觉上感觉不太有用，因为即使同时执行两个命令，你仍然可能读取到不同的数据。</p>
<p>A: 的确，线性化类似于在程序中使用线程而不使用锁——对同一数据的任何并发访问都是竞争条件。以这种方式编程是可能的，但需要小心。</p>
<p>下一个最强的一致性概念涉及事务，如许多数据库中所使用的，这实际上锁定了任何使用的数据。对于读取和写入多个数据项的程序，事务比线性化更容易编程。“可串行化”是一个提供事务的一致性模型的名称。</p>
<p>然而，事务系统比线性化系统更复杂、更慢、更难实现容错。</p>
<p>Q: 为什么验证现实系统涉及“巨大努力”？</p>
<p>A: 验证意味着证明程序是正确的，即它保证符合某些规范。事实证明，证明复杂程序的重要定理是困难的——比普通编程困难得多。</p>
<p>你可以通过尝试这门课程的实验来感受这一点：</p>
<p><a href="https://6826.csail.mit.edu/2020/">https://6826.csail.mit.edu/2020/</a></p>
<p>Q: 从指定的阅读材料来看，大多数分布式系统没有经过正式证明是正确的。那么一个团队如何决定一个框架或系统已经经过足够充分的测试，可以作为实际产品发布？</p>
<p>A: 在公司耗尽资金并破产之前，开始发布产品并获得收入是一个好主意。人们在这一点之前尽可能多地进行测试，并且通常会尝试说服一些早期客户使用该产品（并帮助发现漏洞），并明确表示产品可能无法正确工作。也许当产品功能足以满足许多客户并且没有已知的重大漏洞时，你就可以准备发布了。</p>
<p>除此之外，明智的客户也会测试他们依赖的软件。没有严肃的组织期望任何软件是无漏洞的。</p>
<p>Q: 为什么不使用客户端发送命令的时间作为线性化点？即让系统按客户端发送请求的顺序执行操作？</p>
<p>A: 很难构建一个保证这种行为的系统——开始时间是客户端代码发出请求的时间，但由于网络延迟，服务可能要到很久之后才会收到请求。也就是说，请求可能以与开始时间顺序大不相同的顺序到达服务。服务原则上可以延迟执行每个到达的请求，以防稍后到达一个具有更早发出时间的请求，但很难正确实现这一点，因为网络不保证限制延迟。而且这可能会增加每个请求的延迟，可能增加很多。话说回来，我们稍后会看到的Spanner使用了相关技术。</p>
<p>像线性化这样的正确性规范需要在足够宽松以高效实现和足够严格以提供对应用程序程序有用的保证之间找到平衡。“看起来按调用顺序执行操作”太严格，难以高效实现，而线性化的“看起来在调用和响应之间执行”虽然对应用程序开发者来说不那么直观，但可以实现。</p>
<p>Q: 如果有并发的get()操作，而同时也有并发的put()操作，get()操作可能会看到不同的值，这是否是个问题？</p>
<p>A: 在存储系统的上下文中，这通常不是问题。例如，如果我们谈论的值是我的个人资料照片，而两个人在更新照片的同时请求查看它，那么他们看到不同的照片（旧的或新的）是完全合理的。</p>
<p>一些存储系统提供了更复杂的方案，特别是事务，这使得这种情况更容易处理。“可串行化”是一个提供事务的一致性模型的名称。然而，事务系统比线性化系统更复杂、更慢、更难实现容错。</p>
<h1 id="Lab-3-Raft-协议"><a href="#Lab-3-Raft-协议" class="headerlink" title="Lab 3: Raft 协议"></a>Lab 3: Raft 协议</h1><h2 id="Raft-锁的使用方法"><a href="#Raft-锁的使用方法" class="headerlink" title="Raft 锁的使用方法"></a>Raft 锁的使用方法</h2><p>如果你在 6.824 Raft 实验中对于锁的使用感到困惑，以下规则和思考方式可能会有所帮助。</p>
<p>规则 1：当多个 goroutine 使用同一份数据，且至少有一个 goroutine 可能修改该数据时，必须使用锁来防止数据的同时访问。Go 的竞态检测器（race detector）能有效检测此类违规（但对以下其他规则的情况可能无法检测）。</p>
<p>规则 2：当代码对共享数据进行一系列修改操作，且其他 goroutine 在操作中途读取可能导致错误时，必须使用锁包裹整个操作序列。</p>
<p>示例：<br><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">rf.mu.Lock()<br>rf.currentTerm += <span class="hljs-number">1</span><br>rf.state = Candidate<br>rf.mu.Unlock()<br></code></pre></td></tr></table></figure><br>若其他 goroutine 看到这两个更新中的任意一个单独生效（例如旧状态配新任期，或新任期配旧状态）都会导致错误。因此需要在整个更新序列中持续持有锁。所有使用 <code>rf.currentTerm</code> 或 <code>rf.state</code> 的代码也必须持有锁以确保独占访问。</p>
<p><code>Lock()</code> 和 <code>Unlock()</code> 之间的代码通常称为”临界区”。程序员选择的锁规则（例如”使用 rf.currentTerm 或 rf.state 时必须持有 rf.mu”）常被称为”锁协议”。</p>
<p>规则 3：当代码对共享数据进行一系列读取（或读写混合）操作，且该序列中途被修改会导致错误时，必须使用锁包裹整个序列。</p>
<p>Raft RPC 处理程序中的示例：<br><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">rf.mu.Lock()<br><span class="hljs-keyword">if</span> args.Term &gt; rf.currentTerm &#123;<br>    rf.currentTerm = args.Term<br>&#125;<br>rf.mu.Unlock()<br></code></pre></td></tr></table></figure><br>此代码需要在整个操作序列中持续持有锁。Raft 要求 currentTerm 只能递增不能递减。若允许其他 RPC 处理程序在 if 判断和更新操作之间修改 rf.currentTerm，可能导致任期被错误降低。因此必须在整个序列中持续持有锁，同时所有其他 currentTerm 的使用也必须加锁。</p>
<p>实际 Raft 代码需要比这些示例更长的临界区。例如，Raft RPC 处理程序可能需要在整个处理过程中持有锁。</p>
<p>规则 4：在可能引起等待的操作期间持有锁通常是坏习惯，包括：读取 Go 通道、发送到通道、等待定时器、调用 time.Sleep() 或发送 RPC（等待响应）。原因有二：1）等待期间应允许其他 goroutine 继续执行；2）避免死锁。例如两个节点在持有锁时互相发送 RPC，双方的 RPC 处理程序都需要对方持有的锁，导致永久等待。</p>
<p>等待操作前应先释放锁。若不方便，可创建单独的 goroutine 执行等待。</p>
<p>规则 5：注意在释放锁后重新获取时的状态假设。这种情况常见于避免持有锁等待的场景。以下发送投票 RPC 的代码是错误的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">rf.mu.Lock()<br>rf.currentTerm += <span class="hljs-number">1</span><br>rf.state = Candidate<br><span class="hljs-keyword">for</span> &lt;each peer&gt; &#123;<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        rf.mu.Lock()<br>        args.Term = rf.currentTerm<br>        rf.mu.Unlock()<br>        Call(<span class="hljs-string">&quot;Raft.RequestVote&quot;</span>, &amp;args, ...)<br>        <span class="hljs-comment">// 处理回复...</span><br>    &#125;()<br>&#125;<br>rf.mu.Unlock()<br></code></pre></td></tr></table></figure>
<p>问题在于 args.Term 可能与发起选举时的 rf.currentTerm 不同。从创建 goroutine 到实际读取 currentTerm 可能经过多轮任期更迭，节点可能已不再是候选人。修正方法是让新 goroutine 使用外层代码在持有锁时制作的 currentTerm 副本。类似地，在 Call() 后处理回复时，必须重新获取锁并验证所有相关假设（例如检查 rf.currentTerm 是否在选举决定后发生变化）。</p>
<p>实践建议</p>
<p>这些规则的应用可能令人困惑，尤其是规则 2 和 3 中关于”不应被其他 goroutine 读写打断的操作序列”的界定。如何识别这些序列？如何确定序列的起止？</p>
<p>方法一：从无锁代码开始，仔细分析需要加锁的位置。这种方法需要对并发代码正确性进行复杂推理。</p>
<p>更实用的方法：首先注意到如果完全没有并发（无并行执行的 goroutine），就不需要锁。但 RPC 系统创建的 handler goroutine 和为避免等待而创建的 RPC 发送 goroutine 强制引入了并发。可以通过在以下位置获取锁来消除并发：</p>
<ul>
<li>RPC handlers 的起始处</li>
<li>Make() 中创建的后台 goroutine 的起始处<br>并在这些 goroutine 完全执行完毕返回时才释放锁。这种锁协议确保没有真正的并行执行，从而避免违反规则 1-3 和 5。当每个 goroutine 的代码在单线程环境下正确时，用锁抑制并发后仍能保持正确。</li>
</ul>
<p>但规则 4 的问题仍然存在。因此下一步需要找出所有等待操作的位置，谨慎地添加锁释放/重新获取（或创建新 goroutine），特别注意重新获取锁后要重新验证状态假设。这种方法可能比直接识别临界区更容易实现正确性。</p>
<p>（注：这种方法的代价是牺牲多核并行执行的性能优势——代码可能在不需要时持有锁，从而不必要地禁止并行执行。但单个 Raft 节点内部本身也没有太多 CPU 并行机会。）</p>
<h2 id="Raft-结构设计建议"><a href="#Raft-结构设计建议" class="headerlink" title="Raft 结构设计建议"></a>Raft 结构设计建议</h2><p>一个 Raft 实例需要处理外部事件（Start () 调用、AppendEntries 和 RequestVote RPC、RPC 回复）以及执行周期性任务（选举和心跳）。以下是关于代码结构的若干建议：</p>
<ol>
<li>状态管理</li>
</ol>
<ul>
<li>Raft 实例包含状态数据（日志、当前索引等），这些状态需要通过锁机制在并发协程中安全更新</li>
<li>Go 官方文档建议使用共享数据结构配合锁机制，而非通道消息传递，这种方式对 Raft 实现更为直接</li>
</ul>
<ol>
<li>时间驱动任务</li>
</ol>
<ul>
<li>领导者需要发送心跳</li>
<li>其他节点在超时未收到心跳时需要发起选举</li>
<li>建议为每个任务分配独立的长运行协程，而非合并到单一协程</li>
</ul>
<ol>
<li>选举超时管理</li>
</ol>
<ul>
<li>推荐在 Raft 结构体中维护 “最后收到心跳时间” 变量</li>
<li>选举超时协程应周期性检查（建议使用小常量参数的 time.Sleep ()）</li>
<li>避免使用 time.Ticker 和 time.Timer（容易出错）</li>
</ul>
<ol>
<li>日志提交协程</li>
</ol>
<ul>
<li>创建独立的长运行协程通过 applyCh 按顺序发送已提交日志</li>
<li>必须保持单协程发送以确保顺序性</li>
<li>使用 sync.Cond 条件变量通知该协程更新 commitIndex</li>
</ul>
<ol>
<li>RPC 处理</li>
</ol>
<ul>
<li>每个 RPC 应在其专属协程中发送和处理回复，原因：<br>a) 避免不可达节点阻塞多数响应收集<br>b) 确保心跳和选举定时器持续运行</li>
<li>RPC 处理应在同一协程完成，而非通过通道传递回复</li>
</ul>
<ol>
<li>网络注意事项</li>
</ol>
<ul>
<li>网络可能延迟或重排 RPC 及其响应</li>
<li>需注意图 2 中的 RPC 处理规范（如忽略旧 term 的 RPC）</li>
<li>领导者处理响应时需检查：<br>a) term 是否在发送后发生变化<br>b) 并发 RPC 响应可能改变领导状态（如 nextIndex）</li>
</ul>
<p>关键实现提示：</p>
<ul>
<li>保持 RPC 处理程序的幂等性</li>
<li>注意状态变更的原子性操作</li>
<li>合理使用读写锁优化性能</li>
<li>实现完善的日志压缩机制</li>
<li>注意边界条件处理（如日志回滚场景）</li>
</ul>
<h2 id="给学生的参考"><a href="#给学生的参考" class="headerlink" title="给学生的参考"></a>给学生的参考</h2><h3 id="学生指南：Raft-（阅读需-30-分钟）"><a href="#学生指南：Raft-（阅读需-30-分钟）" class="headerlink" title="学生指南：Raft （阅读需 30 分钟）"></a>学生指南：Raft （阅读需 30 分钟）</h3><p>发布于 2016 年 3 月 16 日，分享在黑客新闻（Hacker News）、推特（Twitter）、龙虾网（Lobsters）<br>在过去的几个月里，我一直担任麻省理工学院 6.824 分布式系统课程的助教。该课程传统上有一系列基于 Paxos 共识算法的实验，但今年，我们决定改用 Raft 算法。Raft 旨在 “易于理解”，我们希望这一改变能让学生们的学习过程更轻松。</p>
<p>这篇文章以及配套的《教师指南：Raft》记录了我们使用 Raft 的历程，希望对 Raft 协议的实现者以及试图更好理解 Raft 内部原理的学生有所帮助。如果你在寻找 Paxos 与 Raft 的比较，或者对 Raft 进行更具教学意义的分析，你应该去阅读《教师指南》。本文末尾列出了 6.824 课程学生常问的问题及答案。如果你遇到的问题未在本文主体内容中列出，可以查看问答部分。这篇文章篇幅较长，但其中所讲的都是很多 6.824 课程的学生（以及助教）实际遇到的问题，值得一读。</p>
<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>在深入探讨 Raft 之前，了解一些背景信息可能会有所帮助。6.824 课程过去有一组基于 Paxos 的实验，用 Go 语言编写。选择 Go 语言，一方面是因为它对学生来说易于学习，另一方面它非常适合编写并发、分布式应用（goroutine 特别好用）。在四个实验过程中，学生们构建一个容错的、分片的键值存储系统。第一个实验要求他们构建一个基于共识的日志库，第二个实验在其基础上添加一个键值存储，第三个实验在多个容错集群之间对键空间进行分片，并由一个容错的分片管理器处理配置更改。我们还有第四个实验，学生们必须处理机器的故障和恢复，包括磁盘完好和损坏的情况。这个实验是学生们默认的期末项目。</p>
<p>今年，我们决定使用 Raft 重写所有这些实验。前三个实验内容不变，但第四个实验被去掉了，因为 Raft 已经内置了持久化和故障恢复功能。本文将主要讨论我们在第一个实验中的经历，因为它与 Raft 直接相关，不过我也会提及在 Raft 之上构建应用（如第二个实验中的情况）。</p>
<p>对于刚开始了解 Raft 的人来说，用 Raft 协议网站上的文字来描述它最为合适：</p>
<p>Raft 是一种共识算法，旨在易于理解。它在容错性和性能方面与 Paxos 相当。不同之处在于，它被分解为相对独立的子问题，并且清晰地解决了实际系统所需的所有主要部分。我们希望 Raft 能让更多人了解共识算法，并且这些人能够开发出比目前更多高质量的基于共识的系统。</p>
<p>像这样的可视化图表很好地概述了该协议的主要组件，相关论文也很好地阐述了为什么需要各个部分。如果你还没有读过 Raft 的扩展论文，在继续阅读本文之前，你应该先去读一下，因为我将假设你对 Raft 有一定程度的熟悉。</p>
<p>与所有分布式共识协议一样，细节决定成败。在没有故障的稳定状态下，Raft 的行为很容易理解，可以直观地进行解释。例如，从可视化图表中很容易看出，假设没有故障，最终会选出一个领导者，并且最终发送给领导者的所有操作都会被追随者按正确顺序应用。然而，当引入消息延迟、网络分区和服务器故障时，每一个 “如果”“但是” 和 “并且” 都变得至关重要。特别是，由于阅读论文时的误解或疏忽，我们会反复看到一些错误。这个问题并非 Raft 独有，在所有提供正确性保证的复杂分布式系统中都会出现。</p>
<h4 id="实现-Raft"><a href="#实现-Raft" class="headerlink" title="实现 Raft"></a>实现 Raft</h4><p>Raft 的终极指南在 Raft 论文的图 2 中。该图指定了 Raft 服务器之间交换的每个 RPC 的行为，给出了服务器必须维护的各种不变量，并指定了某些操作应在何时发生。在本文的其余部分，我们会经常提到图 2。必须严格按照它来实现。</p>
<p>图 2 定义了每个服务器在每种状态下，对于每个传入的 RPC 应该做什么，以及某些其他事情应该在何时发生（例如何时安全地应用日志中的条目）。一开始，你可能会想把图 2 当作一种非正式的指南，读一遍后，就开始编码实现，大致按照它说的去做。这样做，你很快就能让一个基本可用的 Raft 实现运行起来。然后问题就开始出现了。</p>
<p>实际上，图 2 极其精确，从规范的角度来说，它所做的每一个陈述都应该被视为 “必须”（MUST），而不是 “应该”（SHOULD）。例如，当你收到 AppendEntries 或 RequestVote RPC 时，你可能会合理地重置某个对等节点的选举计时器，因为这两个 RPC 都表明其他某个对等节点要么认为自己是领导者，要么正在试图成为领导者。直观地说，这意味着我们不应该干扰。然而，如果你仔细阅读图 2，它说：</p>
<p>如果在没有收到当前领导者的 AppendEntries RPC，也没有投票给候选者的情况下，选举超时时间到了，就转换为候选者状态。</p>
<p>结果证明，这种区别很重要，因为前一种实现方式在某些情况下会显著降低系统的活性。</p>
<h4 id="细节的重要性"><a href="#细节的重要性" class="headerlink" title="细节的重要性"></a>细节的重要性</h4><p>为了让讨论更具体，让我们考虑一个绊倒了许多 6.824 课程学生的例子。Raft 论文在多个地方提到了心跳 RPC。具体来说，领导者会偶尔（至少每心跳间隔一次）向所有对等节点发送 AppendEntries RPC，以防止它们发起新的选举。如果领导者没有新的条目要发送给某个特定的对等节点，AppendEntries RPC 就不包含任何条目，此时它被视为心跳。</p>
<p>我们的许多学生认为心跳在某种程度上是 “特殊的”，即当一个对等节点收到心跳时，它应该与处理非心跳的 AppendEntries RPC 区别对待。特别是，许多学生在收到心跳时，只是简单地重置选举计时器，然后返回成功，而不执行图 2 中指定的任何检查。这是极其危险的。通过接受这个 RPC，追随者隐含地告诉领导者，他们的日志与领导者的日志在包括 AppendEntries 参数中 prevLogIndex 所指位置及之前的部分是匹配的。收到回复后，领导者可能会（错误地）决定某个条目已经被复制到了大多数服务器上，并开始提交它。</p>
<p>许多学生（通常是在修复了上述问题之后）遇到的另一个问题是，在收到心跳时，他们会在 prevLogIndex 之后截断追随者的日志，然后追加 AppendEntries 参数中包含的任何条目。这也是不正确的。我们可以再次参考图 2：</p>
<p>如果现有条目与新条目冲突（相同索引但不同任期），删除现有条目及其之后的所有条目。</p>
<p>这里的 “如果” 至关重要。如果追随者拥有领导者发送的所有条目，追随者 “绝不能” 截断其日志。领导者发送的条目之后的任何元素都必须保留。这是因为我们可能收到了领导者过时的 AppendEntries RPC，截断日志意味着 “撤销” 我们可能已经告诉领导者我们日志中已有的条目。</p>
<h4 id="调试-Raft"><a href="#调试-Raft" class="headerlink" title="调试 Raft"></a>调试 Raft</h4><p>不可避免的是，你的 Raft 实现的第一个版本会有漏洞。第二个版本也会有，第三个、第四个同样如此。一般来说，每个版本的漏洞会比前一个版本少，根据经验，你的大多数漏洞将是由于没有忠实地遵循图 2 导致的。</p>
<p>在调试 Raft 时，通常有四个主要的漏洞来源：活锁、不正确或不完整的 RPC 处理程序、未遵循规则以及任期混淆。死锁也是一个常见问题，但通常可以通过记录所有的加锁和解锁操作，并找出哪些锁被获取但未释放来进行调试。让我们依次考虑这些问题：</p>
<h4 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h4><p>当你的系统出现活锁时，系统中的每个节点都在做一些事情，但总体上，你的节点处于一种无法取得进展的状态。这种情况在 Raft 中很容易发生，尤其是如果你没有严格遵循图 2 的话。有一种活锁场景特别常见：无法选出领导者，或者一旦选出了领导者，其他某个节点就开始选举，迫使刚当选的领导者立即退位。</p>
<p>出现这种情况的原因有很多，但我们看到许多学生犯了以下几个错误：</p>
<ol>
<li>确保你在图 2 指定的时间准确重置选举计时器。具体来说，只有在以下情况下你才应该重新启动选举计时器：a) 你从当前领导者那里收到了 AppendEntries RPC（即，如果 AppendEntries 参数中的任期过时，你不应该重置计时器）；b) 你正在启动一次选举；或者 c) 你投票给了另一个对等节点。</li>
</ol>
<p>最后一种情况在不可靠的网络中尤其重要，在这种网络中，追随者很可能拥有不同的日志。在那些情况下，你最终往往会发现只有少数服务器能够得到大多数服务器愿意投票支持。如果你在有人请求你投票时就重置选举计时器，那么拥有过时日志的服务器和拥有更新日志的服务器成为领导者的可能性就会一样大。</p>
<p>事实上，由于拥有足够新日志的服务器很少，这些服务器不太可能在足够平静的情况下举行选举并当选。如果你遵循图 2 中的规则，拥有更新日志的服务器就不会被过时服务器的选举打断，因此更有可能完成选举并成为领导者。</p>
<ol>
<li>按照图 2 中关于何时应该启动选举的指示操作。特别要注意的是，如果你是候选者（即你当前正在进行选举），但选举计时器超时了，你应该启动另一次选举。这对于避免由于 RPC 延迟或丢失导致系统停滞很重要。</li>
<li>确保在处理传入的 RPC 之前遵循 “服务器规则” 中的第二条规则。第二条规则规定：</li>
</ol>
<p>如果 RPC 请求或响应包含的任期 T 大于当前任期，将当前任期设置为 T，转换为追随者状态（§5.1）。</p>
<p>例如，如果你已经在当前任期内投过票，而传入的 RequestVote RPC 的任期比你高，你应该首先退位并采用他们的任期（从而重置 votedFor），然后处理这个 RPC，这将导致你授予投票。</p>
<h4 id="不正确的-RPC-处理程序"><a href="#不正确的-RPC-处理程序" class="headerlink" title="不正确的 RPC 处理程序"></a>不正确的 RPC 处理程序</h4><p>尽管图 2 清楚地说明了每个 RPC 处理程序应该做什么，但一些微妙之处仍然很容易被忽略。以下是我们反复看到的一些问题，你在实现过程中应该留意：</p>
<ol>
<li>如果某一步说 “回复 false”，这意味着你应该立即回复，并且不执行后续的任何步骤。</li>
<li>如果你收到一个 AppendEntries RPC，其 prevLogIndex 指向的位置超出了你日志的末尾，你应该像处理存在该条目但任期不匹配的情况一样处理它（即回复 false）。</li>
<li>即使领导者没有发送任何条目，AppendEntries RPC 处理程序的检查 2 也应该执行。</li>
<li>AppendEntries 最后一步（#5）中的 min 操作是必要的，并且需要用最后一个新条目的索引来计算。仅仅让从日志中在 lastApplied 和 commitIndex 之间应用条目的函数在到达日志末尾时停止是不够的。这是因为在领导者发送给你的条目之后，你的日志中可能存在与领导者日志不同的条目（而领导者发送的条目与你日志中的条目是匹配的）。由于 #3 规定只有在存在冲突条目时才截断日志，这些不同的条目不会被删除，如果 leaderCommit 超出了领导者发送给你的条目，你可能会应用不正确的条目。</li>
<li>按照 5.4 节中描述的那样准确实现 “最新日志” 检查非常重要。不要偷懒，只检查日志长度！</li>
</ol>
<h4 id="未遵循规则"><a href="#未遵循规则" class="headerlink" title="未遵循规则"></a>未遵循规则</h4><p>虽然 Raft 论文非常明确地说明了如何实现每个 RPC 处理程序，但它也没有具体说明一些规则和不变量的实现方式。这些内容列在图 2 右侧的 “服务器规则” 部分。虽然其中一些内容相当直观，但也有一些需要你非常仔细地设计应用程序，以确保不违反这些规则：</p>
<ol>
<li>如果在执行过程中的任何时候，commitIndex 大于 lastApplied，你应该应用特定的日志条目。不一定要立即执行（例如在 AppendEntries RPC 处理程序中），但重要的是要确保只由一个实体来执行这个应用操作。具体来说，你要么需要有一个专门的 “应用器”，要么在这些应用操作周围加锁，这样其他例程就不会也检测到需要应用条目并尝试应用。</li>
<li>确保你定期检查 commitIndex 是否大于 lastApplied，或者在 commitIndex 更新后（即 matchIndex 更新后）进行检查。例如，如果你在向对等节点发送 AppendEntries 的同时检查 commitIndex，你可能需要等到下一个条目被追加到日志中，才能应用你刚刚发送并得到确认的条目。</li>
<li>如果领导者发送一个 AppendEntries RPC，它被拒绝，但不是因为日志不一致（这种情况只可能在我们的任期已过时才会发生），那么你应该立即退位，并且不要更新 nextIndex。如果你更新了，当你立即重新当选时，可能会与 nextIndex 的重置发生竞争。</li>
<li>领导者不允许将 commitIndex 更新到前一个任期（或者，就此而言，未来的任期）的某个位置。因此，正如规则所说，你特别需要检查 log [N].term == currentTerm。这是因为如果条目不是来自当前任期，Raft 领导者不能确定该条目实际上已被提交（并且将来不会被更改）。论文中的图 8 说明了这一点。</li>
<li>一个常见的混淆来源是 nextIndex 和 matchIndex 之间的区别。特别是，你可能会观察到 matchIndex = nextIndex - 1，然后就干脆不实现 matchIndex。这是不安全的。虽然 nextIndex 和 matchIndex 通常会同时更新为相似的值（具体来说，nextIndex = matchIndex + 1），但它们的用途截然不同。nextIndex 是对领导者与某个给定追随者共享的前缀的猜测。它通常很乐观（我们共享所有内容），只有在收到否定响应时才会向后移动。例如，当一个领导者刚刚当选时，nextIndex 被设置为日志末尾的索引。从某种意义上说，nextIndex 用于提高性能，你只需要向这个对等节点发送这些内容。</li>
</ol>
<p>matchIndex 用于保证安全性。它是对领导者与某个给定追随者共享的日志前缀的保守测量。matchIndex 绝不能设置为过高的值，因为这可能会导致 commitIndex 向前移动得太远。这就是为什么 matchIndex 初始化为 -1（即我们认为没有共享前缀），并且只有在追随者对 AppendEntries RPC 做出肯定确认时才会更新。</p>
<h4 id="任期混淆"><a href="#任期混淆" class="headerlink" title="任期混淆"></a>任期混淆</h4><p>任期混淆是指服务器被来自旧任期的 RPC 弄糊涂。一般来说，在接收 RPC 时，这不是一个问题，因为图 2 中的规则明确说明了当你看到旧任期时应该怎么做。然而，图 2 通常没有讨论当你收到旧的 RPC 回复时应该怎么做。根据经验，我们发现到目前为止最简单的做法是首先记录回复中的任期（它可能高于你当前的任期），然后将当前任期与你在原始 RPC 中发送的任期进行比较。如果两者不同，丢弃回复并返回。只有当两者任期相同时，你才应该继续处理回复。通过一些巧妙的协议推理，这里可能还有进一步的优化方法，但这种方法似乎效果很好。如果不这样做，就会陷入漫长、曲折的困境，充满心血、汗水、泪水和绝望。</p>
<p>一个相关但不完全相同的问题是，假设从发送 RPC 到收到回复期间，你的状态没有改变。一个很好的例子是，当你收到 RPC 的响应时，设置 matchIndex = nextIndex - 1，或者 matchIndex = len (log)。这是不安全的，因为自从你发送 RPC 以来，这两个值都可能已经被更新了。相反，正确的做法是将 matchIndex 更新为你最初在 RPC 参数中发送的 prevLogIndex + len (entries [])。</p>
<h4 id="关于优化的题外话"><a href="#关于优化的题外话" class="headerlink" title="关于优化的题外话"></a>关于优化的题外话</h4><p>Raft 论文包含了一些有趣的可选特性。在 6.824 课程中，我们要求学生实现其中两个：日志压缩（第 7 节）和加速日志回溯（第 8 页左上角）。前者对于避免日志无限制增长是必要的，后者对于快速使过时的追随者跟上进度很有用。</p>
<p>这些特性不属于 “核心 Raft”，因此在论文中没有像主要的共识协议那样受到那么多关注。日志压缩在图 13 中有相当详细的介绍，但如果你读得太随意，可能会忽略一些设计细节：</p>
<ol>
<li>对应用状态进行快照时，你需要确保应用状态与 Raft 日志中某个已知索引之后的状态相对应。这意味着应用程序要么需要向 Raft 传达快照对应的索引，要么 Raft 需要在快照完成之前延迟应用额外的日志条目。</li>
<li>文本没有讨论当服务器崩溃并重新启动且涉及快照时的恢复协议。特别是，如果 Raft 状态和快照是分别提交的，服务器可能会在持久化快照和持久化更新后的 Raft 状态之间崩溃。这是一个问题，因为图 13 中的步骤 7 规定，快照所涵盖的 Raft 日志必须被丢弃。</li>
</ol>
<p>如果服务器重新启动时，读取了更新后的快照，但日志是过时的，它可能最终会应用一些已经包含在快照中的日志条目。这是因为 commitIndex 和 lastApplied 没有被持久化，所以 Raft 不知道那些日志条目已经被应用过了。解决这个问题的方法是在 Raft 中引入一个持久状态，记录 Raft 持久化日志中第一个条目的 “实际” 索引对应的值。然后可以将其与加载的快照的 lastIncludedIndex 进行比较，以确定丢弃日志头部的哪些元素。</p>
<p>加速日志回溯优化的说明非常不详细，可能是因为作者认为对于大多数部署来说它不是必需的。从文本中不清楚客户端返回的冲突索引和任期应该如何被领导者用来确定使用哪个 nextIndex。我们认为作者可能希望你遵循的协议是：</p>
<ol>
<li>如果追随者的日志中没有 prevLogIndex，它应该返回 conflictIndex = len (log) 和 conflictTerm = None。</li>
<li>如果追随者的日志中有 prevLogIndex，但任期不匹配，它应该返回 conflictTerm = log [prevLogIndex].Term，然后在其日志中搜索第一个条目的任期等于 conflictTerm 的索引。</li>
<li>领导者收到冲突响应后，应该首先在其日志中搜索 conflictTerm。如果它在日志中找到一个具有该任期的条目，它应该将 nextIndex 设置为该任期在其日志中最后一个条目的索引之后的那个索引。</li>
<li>如果它没有找到具有该任期的条目，它应该将 nextIndex 设置为 conflictIndex。</li>
</ol>
<p>一个折中的解决方案是只使用 conflictIndex（忽略 conflictTerm），这简化了实现，但这样领导者有时会向追随者发送比使其跟上进度严格所需更多的日志条目。</p>
<h3 id="在-Raft-之上构建应用（续）"><a href="#在-Raft-之上构建应用（续）" class="headerlink" title="在 Raft 之上构建应用（续）"></a>在 Raft 之上构建应用（续）</h3><p>在 Raft 之上构建服务（例如 6.824 课程 Raft 实验二中的键值存储）时，服务与 Raft 日志之间的交互可能很难处理得当。本节详细介绍开发过程中的一些方面，你在构建应用程序时可能会发现它们很有用。</p>
<h4 id="应用客户端操作"><a href="#应用客户端操作" class="headerlink" title="应用客户端操作"></a>应用客户端操作</h4><p>你可能会对如何依据复制日志来实现应用程序感到困惑。一开始，你可能会让服务在每次收到客户端请求时，将该请求发送给领导者，等待 Raft 应用某些内容，执行客户端请求的操作，然后再返回给客户端。虽然这种方式在单客户端系统中可行，但对于并发客户端却不适用。</p>
<p>相反，服务应该构建为一个状态机，客户端操作会使状态机从一种状态转换到另一种状态。你应该在某个地方设置一个循环，每次获取一个客户端操作（在所有服务器上顺序相同 —— 这就是 Raft 发挥作用的地方），并按顺序将每个操作应用到状态机上。这个循环应该是你代码中唯一接触应用程序状态（6.824 课程中的键值映射）的部分。这意味着面向客户端的 RPC 方法应该只是将客户端的操作提交给 Raft，然后等待这个 “应用循环” 应用该操作。只有当客户端的命令轮到时才执行它，并读取任何返回值。请注意，这也包括读取请求！</p>
<p>这就引出了另一个问题：你如何知道客户端操作何时完成？在无故障的情况下，这很简单 —— 你只需等待放入日志中的内容返回（即被传递给 apply ()）。当这种情况发生时，你将结果返回给客户端。然而，如果出现故障会怎样呢？例如，客户端最初联系你时你可能是领导者，但此后其他人当选为领导者，而你放入日志中的客户端请求已被丢弃。显然你需要让客户端重试，但你如何知道何时告诉他们出错了呢？</p>
<p>解决这个问题的一种简单方法是在插入客户端操作时，记录它在 Raft 日志中的位置。一旦该索引处的操作被发送到 apply ()，你就可以根据该索引处出现的操作是否实际上是你放入的操作，来判断客户端操作是否成功。如果不是，则发生了故障，可以向客户端返回错误。</p>
<h4 id="重复检测"><a href="#重复检测" class="headerlink" title="重复检测"></a>重复检测</h4><p>一旦客户端在遇到错误时重试操作，你就需要某种重复检测机制。例如，如果客户端向你的服务器发送一个 APPEND 请求，没有收到回复，然后又将其重新发送到下一个服务器，你的 apply () 函数需要确保 APPEND 不会被执行两次。为此，你需要为每个客户端请求设置某种唯一标识符，以便你能够识别是否曾经见过，更重要的是，是否应用过某个特定操作。此外，这个状态需要成为你状态机的一部分，以便所有 Raft 服务器都能消除相同的重复操作。</p>
<p>有很多方法可以分配这样的标识符。一种简单且相当高效的方法是为每个客户端分配一个唯一标识符，然后让它们为每个请求标记一个单调递增的序列号。如果客户端重新发送请求，它会重用相同的序列号。你的服务器跟踪每个客户端它所见过的最新序列号，并且简单地忽略任何它已经见过的操作。</p>
<h4 id="棘手的边角情况"><a href="#棘手的边角情况" class="headerlink" title="棘手的边角情况"></a>棘手的边角情况</h4><p>如果你的实现遵循上述大致框架，那么至少有两个微妙的问题你很可能会遇到，而且如果不进行一些认真的调试可能很难发现。为你节省一些时间，以下是这两个问题：</p>
<ol>
<li><strong>重新出现的索引</strong>：假设你的 Raft 库有某个方法 Start ()，它接受一个命令，并返回该命令在日志中放置的索引（这样你就知道何时返回给客户端，如上文所述）。你可能会认为你永远不会看到 Start () 两次返回相同的索引，或者至少，如果你再次看到相同的索引，那么第一次返回该索引的命令一定失败了。事实证明，即使没有服务器崩溃，这两种情况都不是真的。</li>
</ol>
<p>考虑以下有五台服务器 S1 到 S5 的场景。最初，S1 是领导者，其日志为空。</p>
<ul>
<li>两个客户端操作（C1 和 C2）到达 S1。</li>
<li>Start () 为 C1 返回 1，为 C2 返回 2。</li>
<li>S1 向 S2 发送包含 C1 和 C2 的 AppendEntries，但它的所有其他消息都丢失了。</li>
<li>S3 站出来成为候选者。</li>
<li>S1 和 S2 不会投票给 S3，但 S3、S4 和 S5 都会投票，所以 S3 成为领导者。</li>
<li>另一个客户端请求 C3 进入 S3。</li>
<li>S3 调用 Start ()（返回 1）。</li>
<li>S3 向 S1 发送 AppendEntries，S1 从其日志中丢弃 C1 和 C2，并添加 C3。</li>
<li>S3 在向任何其他服务器发送 AppendEntries 之前失败。</li>
<li>S1 站出来，由于其日志是最新的，它被选为领导者。</li>
<li>另一个客户端请求 C4 到达 S1。</li>
<li>S1 调用 Start ()，返回 2（这也是 Start (C2) 返回的值）。</li>
<li>S1 的所有 AppendEntries 都被丢弃，S2 站出来。</li>
<li>S1 和 S3 不会投票给 S2，但 S2、S4 和 S5 都会投票，所以 S2 成为领导者。</li>
<li>一个客户端请求 C5 进入 S2。</li>
<li>S2 调用 Start ()，返回 3。</li>
<li>S2 成功地向所有服务器发送 AppendEntries，S2 通过在下一个心跳中包含更新后的 leaderCommit = 3 向服务器报告。</li>
<li>由于 S2 的日志是 [C1 C2 C5]，这意味着在索引 2 处提交（并在所有服务器上应用，包括 S1）的条目是 C2。尽管 C4 是最后一个在 S1 返回索引 2 的客户端操作。</li>
</ul>
<ol>
<li><strong>四路死锁</strong>：发现这个问题的功劳全归于 Steven Allen，他是 6.824 课程的另一位助教。他发现了以下这种在基于 Raft 构建应用程序时很容易陷入的棘手四路死锁。</li>
</ol>
<p>无论你的 Raft 代码如何构建，它可能都有一个类似 Start () 的函数，允许应用程序向 Raft 日志添加新命令。它可能还有一个循环，当 commitIndex 更新时，对日志中 lastApplied 和 commitIndex 之间的每个元素调用应用程序的 apply ()。这些例程可能都需要获取某个锁 a。在你基于 Raft 的应用程序中，你可能在 RPC 处理程序的某个地方调用 Raft 的 Start () 函数，并且在其他某个地方有一些代码，每当 Raft 应用一个新的日志条目时就会收到通知。由于这两者需要通信（即 RPC 方法需要知道它放入日志中的操作何时完成），它们可能都需要获取某个锁 b。</p>
<p>在 Go 语言中，这四个代码段可能看起来像这样：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a *App)</span></span> RPC(args <span class="hljs-keyword">interface</span>&#123;&#125;, reply <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br>    <span class="hljs-comment">//...</span><br>    a.mutex.Lock()<br>    i := a.raft.Start(args)<br>    <span class="hljs-comment">// 更新一些数据结构，以便apply知道稍后通知我们</span><br>    a.mutex.Unlock()<br>    <span class="hljs-comment">// 等待apply通知我们</span><br>    <span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Raft)</span></span> Start(cmd <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-type">int</span> &#123;<br>    r.mutex.Lock()<br>    <span class="hljs-comment">// 执行操作以就这个新命令达成共识</span><br>    <span class="hljs-comment">// 在日志中存储cmd被放置的索引</span><br>    r.mutex.Unlock()<br>    <span class="hljs-keyword">return</span> index<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a *App)</span></span> apply(index <span class="hljs-type">int</span>, cmd <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br>    a.mutex.Lock()<br>    <span class="hljs-keyword">switch</span> cmd := cmd.(<span class="hljs-keyword">type</span>) &#123;<br>    <span class="hljs-keyword">case</span> GetArgs:<br>        <span class="hljs-comment">// 执行get操作</span><br>        <span class="hljs-comment">// 查看谁在监听这个索引</span><br>        <span class="hljs-comment">// 用操作结果通知他们所有人</span><br>    <span class="hljs-comment">//...</span><br>    &#125;<br>    a.mutex.Unlock()<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Raft)</span></span> AppendEntries(...) &#123;<br>    <span class="hljs-comment">//...</span><br>    r.mutex.Lock()<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-keyword">for</span> r.lastApplied &lt; r.commitIndex &#123;<br>      r.lastApplied++<br>      r.app.apply(r.lastApplied, r.log[r.lastApplied])<br>    &#125;<br>    <span class="hljs-comment">//...</span><br>    r.mutex.Unlock()<br>&#125;<br></code></pre></td></tr></table></figure>
<p>现在考虑如果系统处于以下状态：</p>
<ul>
<li>App.RPC 刚刚获取了 a.mutex 并调用了 Raft.Start。</li>
<li>Raft.Start 正在等待获取 r.mutex。</li>
<li>Raft.AppendEntries 持有 r.mutex，并且刚刚调用了 App.apply。</li>
</ul>
<p>我们现在就出现了死锁，因为：</p>
<ul>
<li>Raft.AppendEntries 在 App.apply 返回之前不会释放锁。</li>
<li>App.apply 在获取 a.mutex 之前无法返回。</li>
<li>a.mutex 在 App.RPC 返回之前不会被释放。</li>
<li>App.RPC 在 Raft.Start 返回之前不会返回。</li>
<li>Raft.Start 在获取 r.mutex 之前无法返回。</li>
<li>Raft.Start 必须等待 Raft.AppendEntries。</li>
</ul>
<p>有几种方法可以解决这个问题。最简单的方法是在 App.RPC 中调用 a.raft.Start 之后获取 a.mutex。然而，这意味着在 App.RPC 有机会记录它希望被通知之前，App.apply 可能会被调用处理 App.RPC 刚刚调用 Raft.Start 的操作。另一种可能产生更简洁设计的方案是，让一个单独的、专门的线程从 Raft 调用 r.app.apply。这个线程可以在每次 commitIndex 更新时收到通知，然后在应用时就不需要持有锁，从而打破死锁。</p>
<h2 id="Raft-3A-实现-leader-选举"><a href="#Raft-3A-实现-leader-选举" class="headerlink" title="Raft 3A. 实现 leader 选举"></a>Raft 3A. 实现 leader 选举</h2><ul>
<li>leader election</li>
<li>heartbeats (<code>AppendEntries</code> RPCs with no log entries)</li>
</ul>
<h3 id="leader-election"><a href="#leader-election" class="headerlink" title="leader election"></a>leader election</h3><ul>
<li>Reply false if term &lt; currentTerm</li>
<li>If votedFor is null or candidateId, and candidate’s log is at least as up-to-date as receiver’s log, grant vote</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">func (rf *Raft) RequestVote(args *RequestVoteArgs, reply *RequestVoteReply) &#123;<br>	<span class="hljs-comment">// Your code here (3A, 3B).</span><br>	rf.mu.Lock()<br>	Debug(dVote, <span class="hljs-string">&quot;S%d receive RequestVote &lt;- S%d at T%d&quot;</span>, rf.me, args.CandidateId, args.Term)<br>	term := args.Term<br>	<span class="hljs-keyword">if</span> term &lt; rf.currentTerm &#123;<br>		reply.Term = rf.currentTerm<br>		reply.VoteGranted = <span class="hljs-literal">false</span><br>		<span class="hljs-title function_">Debug</span><span class="hljs-params">(dVote, <span class="hljs-string">&quot;S%d reject RequestVote -&gt; S%d at T%d&quot;</span>, rf.me, args.CandidateId, args.Term)</span><br>		rf.mu.Unlock()<br>		<span class="hljs-keyword">return</span><br>	&#125;<br>	<span class="hljs-keyword">if</span> (rf.votedFor == -<span class="hljs-number">1</span> || rf.votedFor == args.CandidateId) &amp;&amp;<br>		args.LastLogTerm &gt;= rf.log[len(rf.log)-<span class="hljs-number">1</span>].Term &amp;&amp;<br>		args.LastLogIndex &gt;= rf.log[len(rf.log)-<span class="hljs-number">1</span>].Index &#123;<br>		reply.Term = rf.currentTerm<br>		reply.VoteGranted = <span class="hljs-literal">true</span><br>		rf.votedFor = args.CandidateId<br>		<span class="hljs-title function_">Debug</span><span class="hljs-params">(dVote, <span class="hljs-string">&quot;S%d grant RequestVote -&gt; S%d at T%d&quot;</span>, rf.me, args.CandidateId, args.Term)</span><br>		rf.mu.Unlock()<br>		<span class="hljs-keyword">return</span><br>	&#125;<br>	rf.mu.Unlock()<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="heartbeats"><a href="#heartbeats" class="headerlink" title="heartbeats"></a>heartbeats</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">func (rf *Raft) broadcastHeartbeat() &#123;<br>	<span class="hljs-keyword">for</span> i := range rf.peers &#123;<br>		<span class="hljs-keyword">if</span> i == rf.me &#123;<br>			<span class="hljs-keyword">continue</span><br>		&#125;<br>		Debug(dLeader, <span class="hljs-string">&quot;S%d send heartbeat -&gt; S%d at T%d&quot;</span>, rf.me, i, rf.currentTerm)<br>		args := &amp;AppendEntriesArgs&#123;<br>			LeaderId:     rf.me,<br>			PrevLogIndex: rf.log[rf.nextIndex[i]-<span class="hljs-number">1</span>].Index,<br>			PrevLogTerm:  rf.log[rf.nextIndex[i]-<span class="hljs-number">1</span>].Term,<br>			LeaderCommit: rf.commitIndex,<br>			Term:         rf.currentTerm,<br>		&#125;<br>		go <span class="hljs-title function_">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span> &#123; <span class="hljs-comment">// rpc AppendEntries and handle reply</span><br>			reply := AppendEntriesReply&#123;&#125;<br>			<span class="hljs-keyword">if</span> ok := rf.sendAppendEntries(i, args, &amp;reply); ok &#123;<br>				rf.mu.Lock()<br>				Debug(dLeader, <span class="hljs-string">&quot;S%d send heartbeat -&gt; S%d&quot;</span>, rf.me, i)<br>				rf.mu.Unlock()<br>			&#125;<br>		&#125;(i)<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">func (rf *Raft) AppendEntries(args *AppendEntriesArgs, reply *AppendEntriesReply) &#123;<br>	rf.mu.Lock()<br>	<span class="hljs-comment">// Debug(dLog, &quot;S%d receive AppendEntries(%+v) &lt;- S%d at T%d&quot;, rf.me, args, args.LeaderId, rf.currentTerm)</span><br>	<span class="hljs-keyword">if</span> args.Term &lt; rf.currentTerm &#123;<br>		Debug(dLog, <span class="hljs-string">&quot;S%d reject AppendEntries &lt;- S%d at T%d&quot;</span>, rf.me, args.LeaderId, rf.currentTerm)<br>		reply.Success = <span class="hljs-literal">false</span><br>		reply.Term = rf.currentTerm<br>		rf.mu.Unlock()<br>		<span class="hljs-keyword">return</span><br>	&#125;<br>	<span class="hljs-keyword">if</span> args.Term &gt; rf.currentTerm &#123;<br>		Debug(dLog, <span class="hljs-string">&quot;S%d update term to %d at T%d&quot;</span>, rf.me, args.Term, rf.currentTerm)<br>		rf.currentTerm = args.Term<br>		rf.votedFor = -<span class="hljs-number">1</span> <span class="hljs-comment">// reset the voting status in the new term</span><br>		rf.becomeFollower()<br>	&#125;<br>	Debug(dTimer, <span class="hljs-string">&quot;S%d reset election timeout at T%d &lt;- AppendEntries from S%d&quot;</span>, rf.me, rf.currentTerm, args.LeaderId)<br>	rf.resetElectionTime()<br>	<span class="hljs-comment">// log doesn’t contain an entry at prevLogIndex</span><br>	<span class="hljs-keyword">if</span> <span class="hljs-title function_">len</span><span class="hljs-params">(rf.log)</span>-<span class="hljs-number">1</span> &lt; args.PrevLogIndex &amp;&amp;<br>		rf.log[args.PrevLogIndex].Term != args.PrevLogTerm &#123;<br>		reply.Success = <span class="hljs-literal">false</span><br>		reply.Term = rf.currentTerm<br>	&#125;<br>	<span class="hljs-comment">// an existing entry conflict with a new one</span><br>	<span class="hljs-keyword">if</span> rf.log[args.PrevLogIndex].Term != args.PrevLogTerm &#123;<br>	&#125;<br><br>	rf.commitIndex = min(args.LeaderCommit, len(rf.log)-<span class="hljs-number">1</span>)<br>	rf.mu.Unlock()<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="TestInitialElection3A-过不去"><a href="#TestInitialElection3A-过不去" class="headerlink" title="TestInitialElection3A 过不去"></a>TestInitialElection3A 过不去</h3><p>TestInitialElection3A 要注意初始化的时候设置 voteFor = -1，为未投票状态</p>
<h3 id="TestReElection3A-过不去"><a href="#TestReElection3A-过不去" class="headerlink" title="TestReElection3A 过不去"></a>TestReElection3A 过不去</h3><p>上面的写法能够过去 TestInitialElection3A，但是无法过去 TestReElection3A。</p>
<p>TestReElection3A 在 3 个节点中选出一个 leader 之后，让 leader disconnected。</p>
<p>这个时候剩余两个节点，一个节点在等待选举超时时，另外一个节点已经触发了超时，这个时候就能够选出一个新的 leader。</p>
<p>这里就有一个问题，上一个 term 选出了 old leader，新 term 的候选者是否应该被投票。因为这个时候的 votedFor 还是 old leader。</p>
<p>这里查看 voteFor 的定义是：candidateId that received vote in current term (or null if none)</p>
<p><strong>更新了 term 之后，voteFor 也要相应地更新。</strong></p>
<p><strong>If RPC request or response contains term T &gt; currentTerm: set currentTerm = T, convert to follower</strong></p>
<p>所以不管是 AppendEntries 还是 RequestVote，只要有更大的 term 就 update。</p>
<p>更新了上面这条之后整个 3A （leader 选举）就完成了。</p>
<p>主要包括：</p>
<ul>
<li>初始化都是 follower 的情况下的 leader 选举。</li>
<li>掉线的重新选举。</li>
<li>7 个节点任意掉线 3 个的选举。</li>
</ul>
<h2 id="Raft-3B-实现日志添加"><a href="#Raft-3B-实现日志添加" class="headerlink" title="Raft 3B. 实现日志添加"></a>Raft 3B. 实现日志添加</h2><p><img  src="image-20250216151609443.png"   style="zoom:80%;" /><span class="image-caption">AE RPC</span></p>
<p><img  src="image-20250216151411190.png"   style="zoom:80%;" /><span class="image-caption">follower 可能出现的日志情况</span></p>
<h3 id="TestBasicAgree3B"><a href="#TestBasicAgree3B" class="headerlink" title="TestBasicAgree3B"></a>TestBasicAgree3B</h3><p>在网络不可靠的情况下实现最基础的共识算法，为了保证日志匹配属性（如果两个日志包含相同任期和相同index的日志，那么在给定 index 之前的所有 log 都是相同的），需要实现以下两个内容：</p>
<ul>
<li>如果不同日志两条目有相同的 index 和 term，那么他们存储相同的命令。</li>
<li>如果不同日志两条目有相同的 index 和 term，那么所有先前的条目都相同。</li>
</ul>
<p>正常运行时，这样就保证了 leader 的日志和 follower 的日志完全一致。但是因为 leader 可能会宕机，这就导致了日志不一致的情况。于是 follower 可能存在以下情况：</p>
<ul>
<li>缺少条目</li>
<li>额外的未提交条目</li>
<li>上面两者都有</li>
</ul>
<p>在 Raft 中，leader 强制 follower 复制自己的日志来保持一致性，于是 follower 的冲突条目将被 leader 给覆盖。</p>
<p>为了实现安全覆盖，leader 需要知道两个日志中一致的最新一条条目，并删除该条目之后的所有条目，并给 follower 发送所有该条目之后的条目。</p>
<p>leader 为每个 follower 维护一个 nextIndex 数组，记录要发给 follower 的下一条的条目的 index。</p>
<p><strong>当首次当选 leader 时，将 nextIndex 初始化为 leader 日志最后一个条目的下一个的 index（也就是假设所有 follower 与 leader 的日志一致，图 7 中就是都是 11）。</strong></p>
<p>如果 follower 和 leader 的日志不一样，那么下一个 AppendEntries RPC 的一致性检查就会失败（AE RPC 图中的 2、3），在拒绝之后 leader 减少 nextIndex 并重新发送 AE RPC，直到 leader 和 follower 的日志匹配。这种情况下，AE RPC 会成功，并且会删除 follower 中任何冲突的条目，并添加新的条目（如果有的话）。一旦成功之后，leader 和 follower 的日志就会在剩下的 leader term 中都保持一致了。</p>
<p><strong>一些优化：</strong></p>
<p>现在 AE RPC 是每次递减 1，然而可以在冲突时，follower 包含冲突的 term 以及该 term 的第一个 index，这样就变成了每次回退一个 term 而不是一个 index。</p>
<p>作者说这个优化其实是不必要的，因为故障发生的频率较低，不会有多个不一致的条目。</p>
<p><strong>AppendEntries RPC 实现：</strong></p>
<p>Reply false if log doesn’t contain an entry at prevLogIndex whose term matches prevLogTerm。</p>
<p>如果日志中没有包含与 preLogTerm 条目匹配的 preLogIndex 条目，则应答 false。</p>
<p>如果是 PrevLogTerm 匹配了，但是 PrevLogIndex 不匹配，这种情况 reply false，让 leader 的 nextIndex - 1 就好。这里也可以使用优化。</p>
<p>If an existing entry conflicts with a new one (same index but different terms), delete the existing entry and all that follow it</p>
<p>这里是 PrevLogIndex 匹配了，而且 PrevLogIndex 对应的 PrevLogTerm 匹配，但是后续的 term 不匹配，这种情况要删除已有的条目和后续条目。</p>
<p>总之，要 PrevLogIndex 和 PrevLogTerm 都匹配才会开始在 follower 写日志，PrevLogIndex 和 PrevLogTerm 匹配代表着找到了相同的 log，于是之后的 log 就以 leader 的为准就好。</p>
<p>PrevLogIndex 和 PrevLogTerm 任意一个不匹配就回退 nextIndex：</p>
<ul>
<li>PrevLogIndex 不匹配 nextIndex 就回退到 follower 存在的最大 PrevLogIndex </li>
<li>PrevLogTerm 不匹配就回退到 follower 和 leader 在 <code>PrevLogTerm</code> 和 <code>PrevLogIndex</code> 都相同的 index。</li>
</ul>
<p><strong>handleAppendEntriesReply 实现：</strong></p>
<p>这里要注意 matchIndex 的更新是 PrevLogIndex + len (Entries) 而不是 matchIndex = len (log) 这种，因为受到 reply 的时候，log 已经被改变了。</p>
<p>然后要注意如果用了条件变量，要根据需要更新条件变量，否则不会启动日志复制。</p>
<p>同时要注意 follower 以 leader 为准，只要 follower 收到 leader 的 AppendEntries 并 success 之后，就直接添加日志了。</p>
<p>这样就可以过去了。</p>
<h2 id="Raft-3B-TestRPCBytes3B"><a href="#Raft-3B-TestRPCBytes3B" class="headerlink" title="Raft 3B. TestRPCBytes3B"></a>Raft 3B. TestRPCBytes3B</h2><p>这个用例测试每个 command 只被发送到 peer 一次。</p>
<p>把测试用例里面自己添加的 Debug 输出给注释掉就过了。</p>
<p><code>Debug(dTest, &quot;nCommitted cfg.logs: %+v&quot;, cfg.logs)</code></p>
<p>原因应该是  rpc 内容太长了，然后我 debug 输出的时候，耗时太久了，然后 follower 以为 leader 寄了，然后重新当选 leader 触发重传了。</p>
<p>把 debug 的地方换成 <code>time.Sleep(50 * time.Millisecond)</code> 进行测试，发现延时越高，发送的字节数越多。</p>
<p>很神奇的，添加延时之后，heartbeat rpc 就变成了 AppendEntries RPC。</p>
<h2 id="Raft-3B-TestFailNoAgree3B"><a href="#Raft-3B-TestFailNoAgree3B" class="headerlink" title="Raft 3B. TestFailNoAgree3B"></a>Raft 3B. TestFailNoAgree3B</h2><h3 id="条件变量标准使用模式"><a href="#条件变量标准使用模式" class="headerlink" title="条件变量标准使用模式"></a>条件变量标准使用模式</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">mu.<span class="hljs-constructor">Lock()</span><br><span class="hljs-keyword">for</span> condition_not_met &#123;  <span class="hljs-comment">// 必须用循环检查</span><br>	cond.<span class="hljs-constructor">Wait()</span><br>&#125;<br><span class="hljs-comment">// 操作共享数据</span><br>mu.<span class="hljs-constructor">Unlock()</span><br></code></pre></td></tr></table></figure>
<h3 id="互斥锁与条件变量的协作"><a href="#互斥锁与条件变量的协作" class="headerlink" title="互斥锁与条件变量的协作"></a>互斥锁与条件变量的协作</h3><ol>
<li><strong>进入临界区</strong>：先获取互斥锁</li>
<li><strong>条件检查</strong>：在锁保护下检查条件</li>
<li><strong>等待操作</strong>：<code>Wait()</code> 内部自动释放锁，允许其他协程进入临界区</li>
<li><strong>被唤醒</strong>：重新自动获取锁，再次检查条件</li>
<li><strong>退出临界区</strong>：显式释放锁</li>
</ol>
<p>Signal 之前也要先 lock。</p>
<h3 id="Raft-中和集群断开网络的-follower-会自己不断地递增-currentTerm-吗"><a href="#Raft-中和集群断开网络的-follower-会自己不断地递增-currentTerm-吗" class="headerlink" title="Raft 中和集群断开网络的 follower 会自己不断地递增 currentTerm 吗?"></a>Raft 中和集群断开网络的 follower 会自己不断地递增 currentTerm 吗?</h3><p>答案是肯定的。该 follower 会有很高的 term，那么该 follower 很可能会成为 leader 吗？答案是否定的，因为投票的时候，除了未投票这一条件，还有一个条件是候选者的要和接收者的日志一样新，这样才会去投票。</p>
<p>这个时候原先的节点在知道了有更高的 term 之后，立马成为 follower，并且设置自己的 term = 更高的 term，然后以更高的 term 重新当选为 leader，这个时候掉线的节点就可以恢复日志了。</p>
<h2 id="Raft-3B-TestRejoin3B-过不去"><a href="#Raft-3B-TestRejoin3B-过不去" class="headerlink" title="Raft 3B. TestRejoin3B 过不去"></a>Raft 3B. TestRejoin3B 过不去</h2><h3 id="投票的时候判断日志是否是最新"><a href="#投票的时候判断日志是否是最新" class="headerlink" title="投票的时候判断日志是否是最新"></a>投票的时候判断日志是否是最新</h3><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rf *Raft)</span></span> isLogLeastAsReceiver(args *RequestVoteArgs) <span class="hljs-type">bool</span> &#123;<br>	<span class="hljs-keyword">return</span> args.LastLogTerm &gt; rf.log[<span class="hljs-built_in">len</span>(rf.log)<span class="hljs-number">-1</span>].Term ||<br>		(args.LastLogIndex == rf.log[<span class="hljs-built_in">len</span>(rf.log)<span class="hljs-number">-1</span>].Term &amp;&amp;<br>			args.LastLogIndex &gt;= rf.log[<span class="hljs-built_in">len</span>(rf.log)<span class="hljs-number">-1</span>].Index)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里很关键的是，不是要求 index 和 term 都是候选者大才行，而是任期大，或者任期相同的情况下 index 大。</p>
<h2 id="Raft-3B-TestCount3B"><a href="#Raft-3B-TestCount3B" class="headerlink" title="Raft 3B. TestCount3B"></a>Raft 3B. TestCount3B</h2><p>提示 <code>too many RPCs (%v) for 1 second of idleness</code> 原因是判断是否需要复制日志写错了，应该是</p>
<p><code>return rf.role == Leader &amp;&amp; rf.nextIndex[peer] &lt; rf.log[len(rf.log)-1].Index</code> （过不去 TestLeaderFailure3B）</p>
<p>之前写成了</p>
<p><code>return rf.role == Leader &amp;&amp; rf.nextIndex[peer] &lt;= len(rf.log)</code></p>
<p>导致总是 return true 无限加日志。</p>
<p>又改成了 <code>return rf.role == Leader &amp;&amp; rf.nextIndex[peer] &lt; len(rf.log)</code> （过不去 TestFailAgree3B）</p>
<p>按照论文的写法应该是：<code>return rf.role == Leader &amp;&amp; rf.nextIndex[peer] &lt;= rf.log[len(rf.log)-1].Index</code></p>
<p>但是过不去 <code>TestFailAgree3B</code> 以及 <code>TestRejoin3B</code>、<code>TestBackup3B</code>，除此之外都是 ok 的。</p>
<p><code>TestRejoin3B</code> 过不去原因是 <code>apply error: commit index=3 server=1 105 != server=2 104</code>，但是有时候能过去。</p>
<p>修改了 <code>rf.commitIndex = min(args.LeaderCommit, args.PrevLogIndex+len(args.Entries))</code> 之后，剩余 <code>TestFailAgree3B</code> 和 <code>TestBackup3B</code>（测试了好几次能过去了）</p>
<p>TestFailAgree3B 是相互之间都不给对方投票，因为 candidate’s older log。原因是上面的 isLogLeastAsReceiver 写错了，改写成</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rf *Raft)</span></span> isLogLeastAsReceiver(args *RequestVoteArgs) <span class="hljs-type">bool</span> &#123;<br>	<span class="hljs-keyword">return</span> args.LastLogTerm &gt; rf.log[<span class="hljs-built_in">len</span>(rf.log)<span class="hljs-number">-1</span>].Term ||<br>		(args.LastLogTerm == rf.log[<span class="hljs-built_in">len</span>(rf.log)<span class="hljs-number">-1</span>].Term &amp;&amp;<br>			args.LastLogIndex &gt;= rf.log[<span class="hljs-built_in">len</span>(rf.log)<span class="hljs-number">-1</span>].Index)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>就 OK 了。</p>
<p>还有 <code>rf.replicatorCond[peer].L.Lock()</code> 不要乱用。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://mit-public-courses-cn-translatio.gitbook.io/mit6-824">https://mit-public-courses-cn-translatio.gitbook.io/mit6-824</a></li>
</ol>
]]></content>
      <tags>
        <tag>cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>面经整理</title>
    <url>/uncategorized/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h2><h3 id="TCP-IP-网络层"><a href="#TCP-IP-网络层" class="headerlink" title="TCP/IP 网络层"></a>TCP/IP 网络层</h3><p><img  src="/封装.png"   style="zoom:67%;" /><span class="image-caption">img</span></p>
<h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>HTTP、FTP、Telnet、DNS、SMTP等。</p>
<p>应用层是工作在操作系统中的用户态，传输层及以下则工作在内核态。</p>
<h4 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h4><p>有 TCP、UDP 协议等。</p>
<p>TCP 有 MSS （TCP 最大报文段长度）</p>
<h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><p>实际的传输功能。</p>
<p>网络层最常使用的是 IP 协议（Internet Protocol），IP 协议会将传输层的报文作为数据部分，再加上 IP 包头组装成 IP 报文，如果 IP 报文大小超过 MTU（以太网中一般为 1500 字节）就会<strong>再次进行分片</strong>，得到一个即将发送到网络的 IP 报文。</p>
<p><img  src="12.jpg"   style="zoom: 67%;" /><span class="image-caption">img</span></p>
<p>IP 和子网掩码与运算得到<strong>网络号</strong>，子网掩码取反后和 IP 与运算得到<strong>主机号</strong>。</p>
<p>IP 协议的寻址作用是告诉我们去往下一个目的地该朝哪个方向走，路由则是根据「下一个目的地」选择路径。寻址更像在导航，路由更像在操作方向盘。</p>
<h4 id="网络接口层"><a href="#网络接口层" class="headerlink" title="网络接口层"></a>网络接口层</h4><p>生成了 IP 头部之后，接下来要交给网络接口层，在 IP 头部的前面加上 MAC 头部，并封装成数据帧（Data frame）发送到网络上。</p>
<p>MAC 头部是以太网使用的头部，它包含了接收方和发送方的 MAC 地址等信息，我们可以通过 ARP 协议获取对方的 MAC 地址。</p>
<h3 id="输入网址到网页显示的全过程"><a href="#输入网址到网页显示的全过程" class="headerlink" title="输入网址到网页显示的全过程"></a>输入网址到网页显示的全过程</h3><h4 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h4><p>浏览器解析 url，生成发送给 web 服务器的请求信息。</p>
<p><img  src="/4.jpg"  ><span class="image-caption">HTTP 的消息格式</span></p>
<h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><p>查询服务器域名对应的 IP 地址。</p>
<ul>
<li>根 DNS 服务器（.）</li>
<li>顶级域 DNS 服务器（.com）</li>
<li>权威 DNS 服务器（server.com）</li>
</ul>
<p><img  src="/6.jpg"  ><span class="image-caption">域名解析的工作流程</span></p>
<p>浏览器会先看自身有没有对这个域名的缓存，如果有，就直接返回，如果没有，就去问操作系统，操作系统也会去看自己的缓存，如果有，就直接返回，如果没有，再去 hosts 文件看，也没有，才会去问「本地 DNS 服务器」。</p>
<h4 id="协议栈"><a href="#协议栈" class="headerlink" title="协议栈"></a>协议栈</h4><p><img  src="/7.jpg"  ><span class="image-caption">img</span></p>
<h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><p>tcp 报文头部：</p>
<p><img  src="/8.jpg"  ><span class="image-caption">TCP 包头格式</span></p>
<p>首先，<strong>源端口号</strong>和<strong>目标端口</strong>号是不可少的，如果没有这两个端口号，数据就不知道应该发给哪个应用。</p>
<p>接下来有包的<strong>序</strong>号，这个是为了解决包乱序的问题。</p>
<p>还有应该有的是<strong>确认号</strong>，目的是确认发出去对方是否有收到。如果没有收到就应该重新发送，直到送达，这个是为了解决丢包的问题。</p>
<p>接下来还有一些<strong>状态位</strong>。例如 <code>SYN</code> 是发起一个连接，<code>ACK</code> 是回复，<code>RST</code> 是重新连接，<code>FIN</code> 是结束连接等。TCP 是面向连接的，因而双方要维护连接的状态，这些带状态位的包的发送，会引起双方的状态变更。</p>
<p>还有一个重要的就是<strong>窗口大小</strong>。TCP 要做<strong>流量控制</strong>，通信双方各声明一个窗口（缓存大小），标识自己当前能够的处理能力，别发送的太快，撑死我，也别发的太慢，饿死我。</p>
<p>除了做流量控制以外，TCP还会做<strong>拥塞控制</strong>，对于真正的通路堵车不堵车，它无能为力，唯一能做的就是控制自己，也即控制发送的速度。不能改变世界，就改变自己嘛。</p>
<h5 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h5><p><img  src="/TCP三次握手.drawio.png"   style="zoom:67%;" /><span class="image-caption">TCP 三次握手</span></p>
<p>三次握手目的是<strong>保证双方都有发送和接收的能力</strong>。</p>
<p>TCP 的连接状态查看，在 Linux 可以通过 <code>netstat -napt</code> 命令查看。</p>
<p><img  src="/10.jpg"  ><span class="image-caption">TCP 连接状态查看</span></p>
<p><img  src="/11.jpg"  ><span class="image-caption">MTU 与 MSS</span></p>
<h4 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h4><p>IP 报文头部：</p>
<p><img  src="/14.jpg"   style="zoom:67%;" /><span class="image-caption">IP 包头格式</span></p>
<p>因为 HTTP 是经过 TCP 传输的，所以在 IP 包头的<strong>协议号</strong>，要填写为 <code>06</code>（十六进制），表示协议为 TCP。</p>
<h5 id="假设客户端有多个网卡，就会有多个-IP-地址，那-IP-头部的源地址应该选择哪个-IP-呢？"><a href="#假设客户端有多个网卡，就会有多个-IP-地址，那-IP-头部的源地址应该选择哪个-IP-呢？" class="headerlink" title="假设客户端有多个网卡，就会有多个 IP 地址，那 IP 头部的源地址应该选择哪个 IP 呢？"></a>假设客户端有多个网卡，就会有多个 IP 地址，那 IP 头部的源地址应该选择哪个 IP 呢？</h5><p>当存在多个网卡时，在填写源地址 IP 时，就需要判断到底应该填写哪个地址。这个判断相当于在多块网卡中判断应该使用哪个一块网卡来发送包。</p>
<p>这个时候就需要根据<strong>路由表</strong>规则，来判断哪一个网卡作为源地址 IP。</p>
<p>在 Linux 操作系统，我们可以使用 <code>route -n</code> 命令查看当前系统的路由表。</p>
<p><img  src="/15.jpg"   style="zoom:67%;" /><span class="image-caption">路由表</span></p>
<p><img  src="/16.jpg"  ><span class="image-caption">路由规则判断</span></p>
<p>第三条目比较特殊，它目标地址和子网掩码都是 <code>0.0.0.0</code>，这表示<strong>默认网关</strong>，如果其他所有条目都无法匹配，就会自动匹配这一行。并且后续就把包发给路由器，<code>Gateway</code> 即是路由器的 IP 地址。</p>
<h4 id="MAC"><a href="#MAC" class="headerlink" title="MAC"></a>MAC</h4><p><img  src="/18.jpg"  ><span class="image-caption">MAC 包头格式</span></p>
<p>一般在 TCP/IP 通信里，MAC 包头的<strong>协议类型</strong>只使用：</p>
<ul>
<li><code>0800</code> ： IP 协议</li>
<li><code>0806</code> ： ARP 协议</li>
</ul>
<p>发送方的 MAC 地址获取就比较简单了，MAC 地址是在网卡生产时写入到 ROM 里的，只要将这个值读取出来写入到 MAC 头部就可以了。</p>
<p>接收方的 MAC 地址就有点复杂了，只要告诉以太网对方的 MAC 的地址，以太网就会帮我们把包发送过去，那么很显然这里应该填写对方的 MAC 地址。</p>
<p>所以先得搞清楚应该把包发给谁，这个只要查一下路由表就知道了。在路由表中找到相匹配的条目，然后把包发给 GateWay  列中的 IP 地址就可以了。</p>
<h5 id="既然知道要发给谁，按如何获取对方的-MAC-地址呢？"><a href="#既然知道要发给谁，按如何获取对方的-MAC-地址呢？" class="headerlink" title="既然知道要发给谁，按如何获取对方的 MAC 地址呢？"></a>既然知道要发给谁，按如何获取对方的 MAC 地址呢？</h5><p><img  src="/19.jpg"  ><span class="image-caption">ARP 广播</span></p>
<p>ARP 协议会在以太网中以<strong>广播</strong>的形式，对以太网所有的设备喊出：“这个 IP 地址是谁的？请把你的 MAC 地址告诉我”。</p>
<p>在后续操作系统会把本次查询结果放到一块叫做 <strong>ARP 缓存</strong>的内存空间留着以后用，不过缓存的时间就几分钟。</p>
<p>在 Linux 系统中，我们可以使用 <code>arp -a</code> 命令来查看 ARP 缓存的内容。</p>
<p><img  src="/20.jpg"  ><span class="image-caption">ARP 缓存内容</span></p>
<h4 id="网卡"><a href="#网卡" class="headerlink" title="网卡"></a>网卡</h4><p>我们需要将<strong>数字信息转换为电信号</strong>，才能在网线上传输，也就是说，这才是真正的数据发送过程。</p>
<p>负责执行这一操作的是<strong>网卡</strong>，要控制网卡还需要靠<strong>网卡驱动程序</strong>。</p>
<p>网卡驱动获取网络包之后，会将其<strong>复制</strong>到网卡内的缓存区中，接着会在其<strong>开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列</strong>。</p>
<p><img  src="/数据包.drawio.png"  ><span class="image-caption">数据包</span></p>
<ul>
<li>起始帧分界符是一个用来表示包起始位置的标记</li>
<li>末尾的 <code>FCS</code>（帧校验序列）用来检查包传输过程是否有损坏</li>
</ul>
<h4 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h4><p>交换机的设计是将网络包<strong>原样</strong>转发到目的地。交换机工作在 MAC 层，也称为<strong>二层网络设备</strong>。</p>
<p>计算机的网卡本身具有 MAC 地址，并通过核对收到的包的接收方 MAC 地址判断是不是发给自己的，如果不是发给自己的则丢弃；相对地，交换机的端口不核对接收方 MAC 地址，而是直接接收所有的包并存放到缓冲区中。因此，和网卡不同，交换机的端口不具有 MAC 地址。</p>
<p><img  src="/23.jpg"   style="zoom: 67%;" /><span class="image-caption">交换机的 MAC 地址表</span></p>
<p>所以，<strong>交换机根据 MAC 地址表查找 MAC 地址，然后将信号发送到相应的端口</strong>。</p>
<p>交换机无法判断应该把包转发到哪个端口，只能将包转发到除了源端口之外的所有端口上，无论该设备连接在哪个端口上都能收到这个包。</p>
<p><strong>只有相应的接收者才接收包，而其他设备则会忽略这个包</strong>。</p>
<p>以下两个属于广播地址：</p>
<ul>
<li>MAC 地址中的 <code>FF:FF:FF:FF:FF:FF</code></li>
<li>IP 地址中的 <code>255.255.255.255</code></li>
</ul>
<h4 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h4><p>因为<strong>路由器</strong>是基于 IP 设计的，俗称<strong>三层</strong>网络设备，路由器的各个端口都具有 MAC 地址和 IP 地址；</p>
<p>而<strong>交换机</strong>是基于以太网设计的，俗称<strong>二层</strong>网络设备，交换机的端口不具有 MAC 地址。</p>
<p>当转发包时，首先路由器端口会接收发给自己的以太网包，然后<strong>路由表</strong>查询转发目标，再由相应的端口作为发送方将以太网包发送出去。</p>
<p><img  src="/24.jpg"  ><span class="image-caption">路由器转发</span></p>
<h4 id="服务端与客户端"><a href="#服务端与客户端" class="headerlink" title="服务端与客户端"></a>服务端与客户端</h4><p><img  src="/25.jpg"  ><span class="image-caption">网络分层模型</span></p>
<h3 id="Linux-协议栈"><a href="#Linux-协议栈" class="headerlink" title="Linux 协议栈"></a>Linux 协议栈</h3><p><img  src="/协议栈.png"  ><span class="image-caption">img</span></p>
<p>网卡是计算机里的一个硬件，专门负责接收和发送网络包，当网卡接收到一个网络包后，会通过 DMA 技术，将网络包写入到指定的内存地址，也就是写入到 Ring Buffer ，这个是一个环形缓冲区，接着就会告诉操作系统这个网络包已经到达。</p>
<h3 id="Linux-接受包"><a href="#Linux-接受包" class="headerlink" title="Linux 接受包"></a>Linux 接受包</h3><p>那应该怎么告诉操作系统这个网络包已经到达了呢？</p>
<p>最简单的一种方式就是触发中断，也就是每当网卡收到一个网络包，就触发一个中断告诉操作系统。</p>
<p>但是，这存在一个问题，在高性能网络场景下，网络包的数量会非常多，那么就会触发非常多的中断，要知道当 CPU  收到了中断，就会停下手里的事情，而去处理这些网络包，处理完毕后，才会回去继续其他事情，那么频繁地触发中断，则会导致 CPU 一直没完没了的处理中断，而导致其他任务可能无法继续前进，从而影响系统的整体效率。</p>
<p>所以为了解决频繁中断带来的性能开销，Linux 内核在 2.6 版本中引入了 <strong>NAPI 机制</strong>，它是混合「中断和轮询」的方式来接收网络包，它的核心概念就是<strong>不采用中断的方式读取数据</strong>，而是首先采用中断唤醒数据接收的服务程序，然后 <code>poll</code> 的方法来轮询数据。</p>
<p>因此，当有网络包到达时，会通过 DMA 技术，将网络包写入到指定的内存地址，接着网卡向 CPU 发起硬件中断，当 CPU 收到硬件中断请求后，根据中断表，调用已经注册的中断处理函数。</p>
<p>硬件中断处理函数会做如下的事情：</p>
<ul>
<li>需要先「暂时屏蔽中断」，表示已经知道内存中有数据了，告诉网卡下次再收到数据包直接写内存就可以了，不要再通知 CPU 了，这样可以提高效率，避免 CPU 不停的被中断。</li>
<li>接着，发起「软中断」，然后恢复刚才屏蔽的中断。</li>
</ul>
<p>至此，硬件中断处理函数的工作就已经完成。</p>
<p>硬件中断处理函数做的事情很少，主要耗时的工作都交给软中断处理函数了。</p>
<h4 id="软中断的处理"><a href="#软中断的处理" class="headerlink" title="软中断的处理"></a>软中断的处理</h4><p>内核中的 ksoftirqd 线程专门负责软中断的处理，当 ksoftirqd 内核线程收到软中断后，就会来轮询处理数据。</p>
<p>ksoftirqd 线程会从 Ring Buffer 中获取一个数据帧，用 sk_buff 表示，从而可以作为一个网络包交给网络协议栈进行逐层处理。</p>
<h3 id="Linux-发送包"><a href="#Linux-发送包" class="headerlink" title="Linux 发送包"></a>Linux 发送包</h3><p>首先，应用程序会调用 Socket 发送数据包的接口，由于这个是系统调用，所以会从用户态陷入到内核态中的 Socket 层，内核会申请一个内核态的 sk_buff 内存，<strong>将用户待发送的数据拷贝到 sk_buff 内存，并将其加入到发送缓冲区</strong>。</p>
<p>接下来，网络协议栈从 Socket 发送缓冲区中取出 sk_buff，并按照 TCP/IP 协议栈从上到下逐层处理。</p>
<p>如果使用的是 TCP 传输协议发送数据，那么<strong>先拷贝一个新的 sk_buff 副本</strong> ， 这是因为 sk_buff 后续在调用网络层，最后到达网卡发送完成的时候，这个 sk_buff 会被释放掉。而 TCP 协议是支持丢失重传的，在收到对方的 ACK 之前，这个 sk_buff 不能被删除。所以内核的做法就是每次调用网卡发送的时候，实际上传递出去的是 sk_buff 的一个拷贝，等收到 ACK 再真正删除。</p>
<p>接着，对 sk_buff 填充 TCP 头。这里提一下，sk_buff 可以表示各个层的数据包，在应用层数据包叫 data，在 TCP 层我们称为 segment，在 IP 层我们叫 packet，在数据链路层称为 frame。</p>
<p>你可能会好奇，为什么全部数据包只用一个结构体来描述呢？协议栈采用的是分层结构，上层向下层传递数据时需要增加包头，下层向上层数据时又需要去掉包头，如果每一层都用一个结构体，那在层之间传递数据的时候，就要发生多次拷贝，这将大大降低 CPU 效率。</p>
<p>于是，为了在层级之间传递数据时，不发生拷贝，只用 sk_buff 一个结构体来描述所有的网络包，那它是如何做到的呢？是通过调整 sk_buff 中 data 的指针，比如：</p>
<ul>
<li>当接收报文时，从网卡驱动开始，通过协议栈层层往上传送数据报，通过增加 skb-&gt;data 的值，来逐步剥离协议首部。</li>
<li>当要发送报文时，创建 sk_buff 结构体，数据缓存区的头部预留足够的空间，用来填充各层首部，在经过各下层协议时，通过减少 skb-&gt;data 的值来增加协议首部。</li>
</ul>
<p><img  src="/sk_buff.jpg"  ><span class="image-caption">img</span></p>
<h4 id="发送网络数据的时候，涉及几次内存拷贝操作？"><a href="#发送网络数据的时候，涉及几次内存拷贝操作？" class="headerlink" title="发送网络数据的时候，涉及几次内存拷贝操作？"></a>发送网络数据的时候，涉及几次内存拷贝操作？</h4><p>第一次，调用发送数据的系统调用的时候，内核会申请一个内核态的 sk_buff 内存，将用户待发送的数据拷贝到 sk_buff 内存，并将其加入到发送缓冲区。</p>
<p>第二次，在使用 TCP 传输协议的情况下，从传输层进入网络层的时候，每一个 sk_buff 都会被克隆一个新的副本出来。副本 sk_buff 会被送往网络层，等它发送完的时候就会释放掉，然后原始的 sk_buff 还保留在传输层，目的是为了实现 TCP 的可靠传输，等收到这个数据包的 ACK 时，才会释放原始的 sk_buff 。</p>
<p>第三次，当 IP 层发现 sk_buff 大于 MTU 时才需要进行。会再申请额外的 sk_buff，并将原来的 sk_buff 拷贝为多个小的 sk_buff。</p>
<h2 id="HTTP-篇"><a href="#HTTP-篇" class="headerlink" title="HTTP 篇"></a>HTTP 篇</h2><h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><p><code>1xx</code> 类状态码属于<strong>提示信息</strong>，是协议处理中的一种中间状态，实际用到的比较少。</p>
<p><code>2xx</code> 类状态码表示服务器<strong>成功</strong>处理了客户端的请求，也是我们最愿意看到的状态。</p>
<ul>
<li>「<strong>200 OK</strong>」是最常见的成功状态码，表示一切正常。如果是非 <code>HEAD</code> 请求，服务器返回的响应头都会有 body 数据。</li>
<li>「<strong>204 No Content</strong>」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。</li>
<li>「<strong>206 Partial Content</strong>」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。</li>
</ul>
<p><code>3xx</code> 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是<strong>重定向</strong>。</p>
<ul>
<li>「<strong>301 Moved Permanently</strong>」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。</li>
<li>「<strong>302 Found</strong>」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。</li>
</ul>
<p>301 和 302 都会在响应头里使用字段 <code>Location</code>，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。</p>
<ul>
<li>「<strong>304 Not Modified</strong>」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。</li>
</ul>
<p><code>4xx</code> 类状态码表示客户端发送的<strong>报文有误</strong>，服务器无法处理，也就是错误码的含义。</p>
<ul>
<li>「<strong>400 Bad Request</strong>」表示客户端请求的报文有错误，但只是个笼统的错误。</li>
<li>「<strong>403 Forbidden</strong>」表示服务器禁止访问资源，并不是客户端的请求出错。</li>
<li>「<strong>404 Not Found</strong>」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。</li>
</ul>
<p><code>5xx</code> 类状态码表示客户端请求报文正确，但是<strong>服务器处理时内部发生了错误</strong>，属于服务器端的错误码。</p>
<ul>
<li>「<strong>500 Internal Server Error</strong>」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。</li>
<li>「<strong>501 Not Implemented</strong>」表示客户端请求的功能还不支持。</li>
<li>「<strong>502 Bad Gateway</strong>」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。</li>
<li>「<strong>503 Service Unavailable</strong>」表示服务器当前很忙，暂时无法响应客户端。</li>
</ul>
<h3 id="常见字段"><a href="#常见字段" class="headerlink" title="常见字段"></a>常见字段</h3><p><em>Host</em> 字段：客户端发送请求时，用来指定服务器的域名。</p>
<p><em>Content-Length 字段</em>：服务器在返回数据时，会有 <code>Content-Length</code> 字段，表明本次回应的数据长度。</p>
<ul>
<li><strong>HTTP 协议通过设置回车符、换行符作为 HTTP header 的边界通过 Content-Length 字段作为 HTTP body 的边界，这两个方式都是为了解决“粘包”的问题</strong>。</li>
</ul>
<p><em>Connection 字段</em>：<code>Connection</code> 字段最常用于客户端要求服务器使用「HTTP 长连接」机制，以便其他请求复用。</p>
<ul>
<li>HTTP 长连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。</li>
<li>HTTP/1.1 版本的默认连接都是长连接，但为了兼容老版本的 HTTP，需要指定 <code>Connection</code> 首部字段的值为 <code>Keep-Alive</code>。</li>
</ul>
<p><em>Content-Type 字段</em>：<code>Content-Type</code> 字段用于服务器回应时，告诉客户端，本次数据是什么格式。</p>
<ul>
<li><code>Content-Type: text/html; Charset=utf-8</code></li>
<li>客户端请求的时候，可以使用 <code>Accept</code> 字段声明自己可以接受哪些数据格式。<code>Accept: */*</code></li>
</ul>
<p><em>Content-Encoding 字段</em>：说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式。</p>
<ul>
<li><code>Content-Encoding: gzip</code></li>
<li>客户端在请求时，用 <code>Accept-Encoding</code> 字段说明自己可以接受哪些压缩方法。<code>Accept-Encoding: gzip, deflate</code></li>
</ul>
<h3 id="GET-和-POST-方法都是安全和幂等的吗？"><a href="#GET-和-POST-方法都是安全和幂等的吗？" class="headerlink" title="GET 和 POST 方法都是安全和幂等的吗？"></a>GET 和 POST 方法都是安全和幂等的吗？</h3><ul>
<li>在 HTTP 协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。</li>
<li>所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。</li>
</ul>
<ul>
<li><strong>GET 方法就是安全且幂等的</strong>，因为它是「只读」操作</li>
<li><strong>POST</strong> 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是<strong>不安全</strong>的，且多次提交数据就会创建多个资源，所以<strong>不是幂等</strong>的。</li>
</ul>
<h3 id="HTTP-缓存"><a href="#HTTP-缓存" class="headerlink" title="HTTP 缓存"></a>HTTP 缓存</h3><p>HTTP 缓存有两种实现方式，分别是<strong>强制缓存和协商缓存</strong>。</p>
<h4 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h4><p>强制缓存指的是只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在于浏览器这边。</p>
<p>如下图中，返回的是 200 状态码，但在 size 项中标识的是 from disk cache，就是使用了强制缓存。</p>
<p><img  src="/1cb6bc37597e4af8adfef412bfc57a42.png"  ><span class="image-caption">img</span></p>
<p>强缓存是利用下面这两个 HTTP 响应头部（Response Header）字段实现的，它们都用来表示资源在客户端缓存的有效期：</p>
<ul>
<li><code>Cache-Control</code>， 是一个相对时间；</li>
<li><code>Expires</code>，是一个绝对时间；</li>
</ul>
<p>如果 HTTP 响应头部同时有 Cache-Control 和 Expires 字段的话，<strong>Cache-Control 的优先级高于 Expires</strong> 。</p>
<ul>
<li>当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 Cache-Control，Cache-Control 中设置了过期时间大小；</li>
<li>浏览器再次请求访问服务器中的该资源时，会先<strong>通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期</strong>，如果没有，则使用该缓存，否则重新请求服务器；</li>
<li>服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control。</li>
</ul>
<h4 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h4><p>当我们在浏览器使用开发者工具的时候，你可能会看到过某些请求的响应码是 <code>304</code>，这个是告诉浏览器可以使用本地缓存的资源，通常这种通过服务端告知客户端是否可以使用缓存的方式被称为协商缓存。</p>
<p><img  src="/缓存etag.png"   style="zoom: 67%;" /><span class="image-caption">img</span></p>
<p>协商缓存可以基于两种头部来实现。</p>
<p>第一种：请求头部中的 <code>If-Modified-Since</code> 字段与响应头部中的 <code>Last-Modified</code> 字段实现，这两个字段的意思是：</p>
<ul>
<li>响应头部中的 <code>Last-Modified</code>：标示这个响应资源的最后修改时间；</li>
<li>请求头部中的 <code>If-Modified-Since</code>：当资源过期了，发现响应头中具有 Last-Modified 声明，则再次发起请求的时候带上 Last-Modified 的时间，服务器收到请求后发现有 If-Modified-Since 则与被请求资源的最后修改时间进行对比（Last-Modified），如果最后修改时间较新（大），说明资源又被改过，则返回最新资源，HTTP 200 OK；如果最后修改时间较旧（小），说明资源无新修改，响应 HTTP 304 走缓存。</li>
</ul>
<p>第二种：请求头部中的 <code>If-None-Match</code> 字段与响应头部中的 <code>ETag</code> 字段，这两个字段的意思是：</p>
<ul>
<li>响应头部中 <code>Etag</code>：唯一标识响应资源；</li>
<li>请求头部中的 <code>If-None-Match</code>：当资源过期时，浏览器发现响应头里有 Etag，则再次向服务器发起请求时，会将请求头 If-None-Match 值设置为 Etag 的值。服务器收到请求后进行比对，如果资源没有变化返回 304，如果资源变化了返回 200。</li>
</ul>
<p>第一种实现方式是基于时间实现的，第二种实现方式是基于一个唯一标识实现的，相对来说后者可以更加准确地判断文件内容是否被修改，避免由于时间篡改导致的不可靠问题。</p>
<p><strong>为什么 ETag 的优先级更高？</strong>这是因为 ETag 主要能解决 Last-Modified 几个比较难以解决的问题：</p>
<ol>
<li>在没有修改文件内容情况下文件的最后修改时间可能也会改变，这会导致客户端认为这文件被改动了，从而重新请求；</li>
<li>可能有些文件是在秒级以内修改的，<code>If-Modified-Since</code> 能检查到的粒度是秒级的，使用 Etag就能够保证这种需求下客户端在 1 秒内能刷新多次；</li>
<li>有些服务器不能精确获取文件的最后修改时间。</li>
</ol>
<p>注意，<strong>协商缓存这两个字段都需要配合强制缓存中 Cache-Control 字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求</strong>。</p>
<p><img  src="/http缓存.png"   style="zoom: 50%;" /><span class="image-caption">img</span></p>
<p>当使用 ETag 字段实现的协商缓存的过程：</p>
<ul>
<li><p>当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 ETag 唯一标识，这个唯一标识的值是根据当前请求的资源生成的；</p>
</li>
<li><p>当浏览器再次请求访问服务器中的该资源时，首先会先检查强制缓存是否过期：</p>
<ul>
<li>如果没有过期，则直接使用本地缓存；</li>
<li>如果缓存过期了，会在 Request 头部加上 If-None-Match 字段，该字段的值就是 ETag 唯一标识；</li>
</ul>
</li>
<li><p>服务器再次收到请求后，</p>
<p>会根据请求中的 If-None-Match 值与当前请求的资源生成的唯一标识进行比较：</p>
<ul>
<li><strong>如果值相等，则返回 304 Not Modified，不会返回资源</strong>；</li>
<li>如果不相等，则返回 200 状态码和返回资源，并在 Response 头部加上新的 ETag 唯一标识；</li>
</ul>
</li>
<li><p>如果浏览器收到 304 的请求响应状态码，则会从本地缓存中加载资源，否则更新资源。</p>
</li>
</ul>
<h2 id="HTTP-特性"><a href="#HTTP-特性" class="headerlink" title="HTTP 特性"></a>HTTP 特性</h2><h3 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h3><p>HTTP 最突出的优点是「简单、灵活和易于扩展、应用广泛和跨平台」。</p>
<p>HTTP 协议里有优缺点一体的<strong>双刃剑</strong>，分别是「无状态、明文传输」，同时还有一大缺点「不安全」。</p>
<p>HTTP 协议是基于 <strong>TCP/IP</strong>，并且使用了「<strong>请求 - 应答</strong>」的通信模式，所以性能的关键就在这<strong>两点</strong>里。</p>
<p><img  src="16-短连接与长连接.png"    /><span class="image-caption">短连接与长连接</span></p>
<ul>
<li><p>长连接</p>
<ul>
<li>HTTP/1.1 提出了<strong>长连接</strong>的通信方式，也叫持久连接。这种方式的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。</li>
<li>持久连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。</li>
</ul>
</li>
<li><p>管道网络传输</p>
<ul>
<li>即可在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以<strong>减少整体的响应时间。</strong></li>
<li>但是<strong>服务器必须按照接收请求的顺序发送对这些管道化请求的响应</strong>。如果服务端在处理 A 请求时耗时比较长，那么后续的请求的处理都会被阻塞住，这称为「队头堵塞」。</li>
<li><strong>HTTP/1.1 管道解决了请求的队头阻塞，但是没有解决响应的队头阻塞</strong>。</li>
</ul>
</li>
</ul>
<h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><ul>
<li>HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。</li>
<li>两者的默认端口不一样，HTTP 默认端口号是 80，HTTPS 默认端口号是 443。</li>
<li>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</li>
</ul>
<blockquote>
<p>HTTPS 是如何解决<strong>窃听风险</strong>、<strong>篡改风险</strong>、<strong>冒充风险</strong>的？</p>
</blockquote>
<ul>
<li><strong>混合加密</strong>的方式实现信息的<strong>机密性</strong>，解决了窃听的风险。<ul>
<li>在通信建立前采用<strong>非对称加密</strong>的方式交换「会话秘钥」，后续就不再使用非对称加密。<strong>非对称加密</strong>使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。</li>
<li>在通信过程中全部使用<strong>对称加密</strong>的「会话秘钥」的方式加密明文数据。<strong>对称加密</strong>只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。</li>
</ul>
</li>
<li><strong>摘要算法</strong>的方式来实现<strong>完整性</strong>，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。</li>
<li>将服务器公钥放入到<strong>数字证书</strong>中，解决了冒充的风险。</li>
</ul>
<h4 id="HTTPS-是如何建立连接的？其间交互了什么？"><a href="#HTTPS-是如何建立连接的？其间交互了什么？" class="headerlink" title="HTTPS 是如何建立连接的？其间交互了什么？"></a>HTTPS 是如何建立连接的？其间交互了什么？</h4><p>SSL/TLS 协议基本流程：</p>
<ul>
<li>客户端向服务器索要并验证服务器的公钥。</li>
<li>双方协商生产「会话秘钥」。</li>
<li>双方采用「会话秘钥」进行加密通信。</li>
</ul>
<p>前两步也就是 SSL/TLS 的建立过程，也就是 TLS 握手阶段。</p>
<p>LS 的「握手阶段」涉及<strong>四次</strong>通信，使用不同的密钥交换算法，TLS 握手流程也会不一样的，现在常用的密钥交换算法有两种：<a href="https://xiaolincoding.com/network/2_http/https_rsa.html">RSA 算法</a>和 <a href="https://xiaolincoding.com/network/2_http/https_ecdhe.html">ECDHE 算法</a>。</p>
<h4 id="HTTPS-的应用数据是如何保证完整性的？"><a href="#HTTPS-的应用数据是如何保证完整性的？" class="headerlink" title="HTTPS 的应用数据是如何保证完整性的？"></a>HTTPS 的应用数据是如何保证完整性的？</h4><p>TLS 在实现上分为<strong>握手协议</strong>和<strong>记录协议</strong>两层：</p>
<ul>
<li>TLS 握手协议就是我们前面说的 TLS 四次握手的过程，负责协商加密算法和生成对称密钥，后续用此密钥来保护应用程序数据（即 HTTP 数据）；</li>
<li>TLS 记录协议负责保护应用程序数据并验证其完整性和来源，所以对 HTTP 数据加密是使用记录协议；</li>
</ul>
<h4 id="TLS-握手"><a href="#TLS-握手" class="headerlink" title="TLS 握手"></a>TLS 握手</h4><p><em>1. ClientHello</em></p>
<p>首先，由客户端向服务器发起加密通信请求，也就是 <code>ClientHello</code> 请求。</p>
<p>在这一步，客户端主要向服务器发送以下信息：</p>
<p>（1）客户端支持的 TLS 协议版本，如 TLS 1.2 版本。</p>
<p>（2）客户端生产的随机数（<code>Client Random</code>），后面用于生成「会话秘钥」条件之一。</p>
<p>（3）客户端支持的密码套件列表，如 RSA 加密算法。</p>
<p><em>2. SeverHello</em></p>
<p>服务器收到客户端请求后，向客户端发出响应，也就是 <code>SeverHello</code>。服务器回应的内容有如下内容：</p>
<p>（1）确认 TLS 协议版本，如果浏览器不支持，则关闭加密通信。</p>
<p>（2）服务器生产的随机数（<code>Server Random</code>），也是后面用于生产「会话秘钥」条件之一。</p>
<p>（3）确认的密码套件列表，如 RSA 加密算法。</p>
<p>（4）服务器的数字证书。</p>
<p><em>3.客户端回应</em></p>
<p>客户端收到服务器的回应之后，首先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。</p>
<p>如果证书没有问题，客户端会<strong>从数字证书中取出服务器的公钥</strong>，然后使用它加密报文，向服务器发送如下信息：</p>
<p>（1）一个随机数（<code>pre-master key</code>）。该随机数会被服务器公钥加密。</p>
<p>（2）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</p>
<p>（3）客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。</p>
<p>上面第一项的随机数是整个握手阶段的第三个随机数，会发给服务端，所以这个随机数客户端和服务端都是一样的。</p>
<p><strong>服务器和客户端有了这三个随机数（Client Random、Server Random、pre-master key），接着就用双方协商的加密算法，各自生成本次通信的「会话秘钥」</strong>。</p>
<p><em>4. 服务器的最后回应</em></p>
<p>服务器收到客户端的第三个随机数（<code>pre-master key</code>）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。</p>
<p>然后，向客户端发送最后的信息：</p>
<p>（1）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</p>
<p>（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。</p>
<p>至此，整个 TLS 的握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的 HTTP 协议，只不过用「会话秘钥」加密内容。</p>
<h4 id="如何避免被中间人抓取数据？"><a href="#如何避免被中间人抓取数据？" class="headerlink" title="如何避免被中间人抓取数据？"></a>如何避免被中间人抓取数据？</h4><p>通过 <strong>HTTPS 双向认证</strong>来避免这种问题。</p>
<p>如果用了双向认证方式，不仅客户端会验证服务端的身份，而且服务端也会验证客户端的身份。服务端一旦验证到请求自己的客户端为不可信任的，服务端就拒绝继续通信，客户端如果发现服务端为不可信任的，那么也中止通信。</p>
<h3 id="HTTP-1-1-HTTP-2-HTTP-3"><a href="#HTTP-1-1-HTTP-2-HTTP-3" class="headerlink" title="HTTP/1.1 HTTP/2 HTTP/3"></a>HTTP/1.1 HTTP/2 HTTP/3</h3><h3 id="HTTP-1-1-相比-HTTP-1-0-提高了什么性能？"><a href="#HTTP-1-1-相比-HTTP-1-0-提高了什么性能？" class="headerlink" title="HTTP/1.1 相比 HTTP/1.0 提高了什么性能？"></a>HTTP/1.1 相比 HTTP/1.0 提高了什么性能？</h3><ul>
<li>长连接</li>
<li>管道</li>
</ul>
<h3 id="HTTP-1-1-仍然存在的问题？"><a href="#HTTP-1-1-仍然存在的问题？" class="headerlink" title="HTTP/1.1 仍然存在的问题？"></a>HTTP/1.1 仍然存在的问题？</h3><ul>
<li>请求 / 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 <code>Body</code> 的部分；</li>
<li>服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是队头阻塞；</li>
<li>没有请求优先级控制；</li>
<li>请求只能从客户端开始，服务器只能被动响应。</li>
</ul>
<h3 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h3><p>相比于 HTTP/1.1 的改进：</p>
<ul>
<li>头部压缩<ul>
<li>HTTP/2 会<strong>压缩头</strong>（Header）如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你<strong>消除重复的部分</strong>。</li>
<li>这就是所谓的 <code>HPACK</code> 算法：在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就<strong>提高速度</strong>了。</li>
</ul>
</li>
<li>二进制格式<ul>
<li>HTTP/2 不再像 HTTP/1.1 里的纯文本形式的报文，而是全面采用了<strong>二进制格式</strong>，头信息和数据体都是二进制，并且统称为帧（frame）：<strong>头信息帧（Headers Frame）和数据帧（Data Frame）</strong>。<strong>增加了数据传输的效率</strong>。</li>
</ul>
</li>
<li>并发传输<ul>
<li>HTTP/1.1 中如果响应迟迟不来，那么后续的请求是无法发送的，也造成了<strong>队头阻塞</strong>的问题。</li>
<li>HTTP/2 引出了 Stream 概念，多个 Stream 复用在一条 TCP 连接。</li>
<li>1 个 TCP 连接包含多个 Stream，Stream 里可以包含 1 个或多个 Message，Message 对应 HTTP/1 中的请求或响应，由 HTTP 头部和包体构成。Message 里包含一条或者多个 Frame，Frame 是 HTTP/2 最小单位，以二进制压缩格式存放 HTTP/1 中的内容（头部和包体）。</li>
<li><strong>针对不同的 HTTP 请求用独一无二的 Stream ID 来区分，接收端可以通过 Stream ID 有序组装成 HTTP 消息，不同 Stream 的帧是可以乱序发送的，因此可以并发不同的 Stream ，也就是 HTTP/2 可以并行交错地发送请求和响应</strong>。</li>
</ul>
</li>
<li>服务器主动推送资源<ul>
<li>服务端不再是被动地响应，可以<strong>主动</strong>向客户端发送消息。</li>
<li>客户端和服务器<strong>双方都可以建立 Stream</strong>， Stream ID 也是有区别的，客户端建立的 Stream 必须是奇数号，而服务器建立的 Stream 必须是偶数号。</li>
</ul>
</li>
</ul>
<h4 id="HTTP-2-有什么缺陷？"><a href="#HTTP-2-有什么缺陷？" class="headerlink" title="HTTP/2 有什么缺陷？"></a>HTTP/2 有什么缺陷？</h4><p>HTTP/2 通过 Stream 的并发能力，解决了 HTTP/1 队头阻塞的问题，看似很完美了，但是 HTTP/2 还是存在“队头阻塞”的问题，只不过问题不是在 HTTP 这一层面，而是在 TCP 这一层。</p>
<p><strong>HTTP/2 是基于 TCP 协议来传输数据的，TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且连续的，这样内核才会将缓冲区里的数据返回给 HTTP 应用，那么当「前 1 个字节数据」没有到达时，后收到的字节数据只能存放在内核缓冲区里，只有等到这 1 个字节数据到达时，HTTP/2 应用层才能从内核中拿到数据，这就是 HTTP/2 队头阻塞问题。</strong></p>
<p>一旦发生了丢包现象，就会触发 TCP 的重传机制，这样在一个 TCP 连接中的<strong>所有的 HTTP 请求都必须等待这个丢了的包被重传回来</strong>。</p>
<h3 id="HTTP-3"><a href="#HTTP-3" class="headerlink" title="HTTP/3"></a>HTTP/3</h3><p>前面我们知道了 HTTP/1.1 和 HTTP/2 都有队头阻塞的问题：</p>
<ul>
<li>HTTP/1.1 中的管道（ pipeline）虽然解决了请求的队头阻塞，但是<strong>没有解决响应的队头阻塞</strong>，因为服务端需要按顺序响应收到的请求，如果服务端处理某个请求消耗的时间比较长，那么只能等响应完这个请求后， 才能处理下一个请求，这属于 HTTP 层队头阻塞。</li>
<li>HTTP/2 虽然通过多个请求复用一个 TCP 连接解决了 HTTP 的队头阻塞 ，但是<strong>一旦发生丢包，就会阻塞住所有的 HTTP 请求</strong>，这属于 TCP 层队头阻塞。</li>
</ul>
<p>HTTP/2 队头阻塞的问题是因为 TCP，所以 <strong>HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP！</strong></p>
<p>UDP 发送是不管顺序，也不管丢包的，所以不会出现像 HTTP/2 队头阻塞的问题。大家都知道 UDP 是不可靠传输的，但基于 UDP 的 <strong>QUIC 协议</strong> 可以实现类似 TCP 的可靠性传输。</p>
<p>QUIC 有以下 3 个特点。</p>
<ul>
<li><p>无队头阻塞</p>
<ul>
<li>QUIC 协议也有类似 HTTP/2 Stream 与多路复用的概念，也是可以在同一条连接上并发传输多个 Stream，Stream 可以认为就是一条 HTTP 请求。</li>
<li>QUIC 有自己的一套机制可以保证传输的可靠性的。<strong>当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响，因此不存在队头阻塞问题</strong>。这与 HTTP/2 不同，HTTP/2 只要某个流中的数据包丢失了，其他流也会因此受影响。</li>
<li>所以，QUIC 连接上的多个 Stream 之间并没有依赖，都是独立的，某个流发生丢包了，只会影响该流，其他流不受影响。</li>
</ul>
</li>
<li><p>更快的连接建立</p>
<ul>
<li><p>对于 HTTP/1 和 HTTP/2 协议，TCP 和 TLS 是分层的，分别属于内核实现的传输层、openssl 库实现的表示层，因此它们难以合并在一起，需要分批次来握手，先 TCP 握手，再 TLS 握手。</p>
</li>
<li><p>HTTP/3 在传输数据前虽然需要 QUIC 协议握手，但是这个握手过程只需要 1 RTT，握手的目的是为确认双方的「连接 ID」，连接迁移就是基于连接 ID 实现的。</p>
<p>但是 HTTP/3 的 QUIC 协议并不是与 TLS 分层，而是 QUIC 内部包含了 TLS，它在自己的帧会携带 TLS 里的“记录”，再加上 QUIC 使用的是 TLS/1.3，因此仅需 1 个 RTT 就可以「同时」完成建立连接与密钥协商，如下图：</p>
<p><img  src="/28-HTTP3交互次数.jpeg"  ><span class="image-caption">TCP HTTPS（TLS/1.3） 和 QUIC HTTPS </span></p>
</li>
</ul>
</li>
<li><p>连接迁移</p>
<ul>
<li>那么<strong>当移动设备的网络从 4G 切换到 WIFI 时，意味着 IP 地址变化了，那么就必须要断开连接，然后重新建立连接</strong>。而建立连接的过程包含 TCP 三次握手和 TLS 四次握手的时延，以及 TCP 慢启动的减速过程，给用户的感觉就是网络突然卡顿了一下，因此连接的迁移成本是很高的。</li>
<li>而 QUIC 协议没有用四元组的方式来“绑定”连接，而是通过<strong>连接 ID</strong> 来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本，没有丝毫卡顿感，达到了<strong>连接迁移</strong>的功能。</li>
</ul>
</li>
</ul>
<p>QUIC 是新协议，对于很多网络设备，根本不知道什么是 QUIC，只会当做 UDP，这样会出现新的问题，因为有的网络设备是会丢掉 UDP 包的，而 QUIC 是基于 UDP 实现的，那么如果网络设备无法识别这个是 QUIC 包，那么就会当作 UDP包，然后被丢弃。</p>
<h3 id="HTTP-1-1-如何优化？"><a href="#HTTP-1-1-如何优化？" class="headerlink" title="HTTP/1.1 如何优化？"></a>HTTP/1.1 如何优化？</h3><ul>
<li><em>尽量避免发送 HTTP 请求</em>；<ul>
<li>缓存</li>
</ul>
</li>
<li><em>在需要发送 HTTP 请求时，考虑如何减少请求次数</em>；<ul>
<li><em>减少重定向请求次数</em>；<ul>
<li>用代理服务器实现，代理服务器自己取得重定向之后的内容返回。</li>
</ul>
</li>
<li><em>合并请求</em>；<ul>
<li>如果把多个访问小文件的请求合并成一个大的请求，虽然传输的总资源还是一样，但是减少请求，也就意味着<strong>减少了重复发送的 HTTP 头部</strong>。除了将小图片合并成大图片的方式，还有服务端使用 <code>webpack</code> 等打包工具将 js、css 等资源合并打包成大文件，也是能达到类似的效果。</li>
</ul>
</li>
<li><em>延迟发送请求</em>；<ul>
<li>请求网页的时候，没必要把全部资源都获取到，而是只获取当前用户所看到的页面资源，当用户向下滑动页面的时候，再向服务器获取接下来的资源，这样就达到了延迟发送请求的效果。</li>
</ul>
</li>
</ul>
</li>
<li><em>减少服务器的 HTTP 响应的数据大小</em>；<ul>
<li><em>无损压缩</em>；<ul>
<li>gzip 就是比较常见的无损压缩。客户端支持的压缩算法，会在 HTTP 请求中通过头部中的 <code>Accept-Encoding</code> 字段告诉服务器。</li>
</ul>
</li>
<li><em>有损压缩</em>；<ul>
<li>可以通过 HTTP 请求头部中的 <code>Accept</code> 字段里的「 q 质量因子」，告诉服务器期望的资源质量。</li>
<li>关于音视频的压缩，音视频主要是动态的，每个帧都有时序的关系，通常时间连续的帧之间的变化是很小的。</li>
<li>比如，一个在看书的视频，画面通常只有人物的手和书桌上的书是会有变化的，而其他地方通常都是静态的，于是只需要在一个静态的关键帧，使用<strong>增量数据</strong>来表达后续的帧，这样便减少了很多数据，提高了网络传输的性能。对于视频常见的编码格式有 H264、H265 等，音频常见的编码格式有 AAC、AC3。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="HTTPS-如何优化？"><a href="#HTTPS-如何优化？" class="headerlink" title="HTTPS 如何优化？"></a>HTTPS 如何优化？</h3><p><img  src="/优化https提纲.png"  ><span class="image-caption">img</span></p>
<h3 id="HTTP-和-RPC-有什么区别"><a href="#HTTP-和-RPC-有什么区别" class="headerlink" title="HTTP 和 RPC 有什么区别"></a>HTTP 和 RPC 有什么区别</h3><ul>
<li>服务发现</li>
<li>底层连接形式<ul>
<li>而 <strong>RPC</strong> 协议，跟 HTTP 类似，也是通过建立 TCP 长链接进行数据交互，但不同的地方在于，RPC 协议一般还会再建个<strong>连接池</strong>，在请求量大的时候，建立多条连接放在池内，要发数据的时候就从池里取一条连接出来，<strong>用完放回去，下次再复用</strong>，可以说非常环保。</li>
</ul>
</li>
<li>传输的内容<ul>
<li>RPC，因为它定制化程度更高，可以采用体积更小的 Protobuf 或其他序列化协议去保存结构体数据，同时也不需要像 HTTP 那样考虑各种浏览器行为，比如 302 重定向跳转啥的。<strong>因此性能也会更好一些，这也是在公司内部微服务中抛弃 HTTP，选择使用 RPC 的最主要原因。</strong></li>
<li>上面说的 HTTP，其实<strong>特指的是现在主流使用的 HTTP/1.1</strong>，<code>HTTP/2</code> 在前者的基础上做了很多改进，所以<strong>性能可能比很多 RPC 协议还要好</strong>，甚至连 <code>gRPC</code> 底层都直接用的 <code>HTTP/2</code>。</li>
</ul>
</li>
</ul>
<h3 id="既然有-HTTP-协议，为什么还要有-WebSocket？"><a href="#既然有-HTTP-协议，为什么还要有-WebSocket？" class="headerlink" title="既然有 HTTP 协议，为什么还要有 WebSocket？"></a>既然有 HTTP 协议，为什么还要有 WebSocket？</h3><p>我们知道 TCP 连接的两端，<strong>同一时间里</strong>，<strong>双方</strong>都可以<strong>主动</strong>向对方发送数据。这就是所谓的<strong>全双工</strong>。</p>
<p>而现在使用最广泛的<code>HTTP/1.1</code>，也是基于TCP协议的，<strong>同一时间里</strong>，客户端和服务器<strong>只能有一方主动</strong>发数据，这就是所谓的<strong>半双工</strong>。</p>
<p>如果想建立 WebSocket 连接<strong>，就会在 HTTP 请求里带上一些</strong>特殊的header 头**，如下：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>Upgrade<br><span class="hljs-attribute">Upgrade</span><span class="hljs-punctuation">: </span>WebSocket<br><span class="hljs-attribute">Sec-WebSocket-Key</span><span class="hljs-punctuation">: </span>T2a6wZlAwhgQNqruZ2YUyg==\r\n<br></code></pre></td></tr></table></figure>
<p>这些 header 头的意思是，浏览器想<strong>升级协议（Connection: Upgrade）</strong>，并且<strong>想升级成 WebSocket 协议（Upgrade: WebSocket）</strong>。同时带上一段<strong>随机生成的 base64 码（Sec-WebSocket-Key）</strong>，发给服务器。</p>
<p>如果服务器正好支持升级成 WebSocket 协议。就会走 WebSocket 握手流程，同时根据客户端生成的 base64 码，用某个<strong>公开的</strong>算法变成另一段字符串，放在 HTTP 响应的 <code>Sec-WebSocket-Accept</code> 头里，同时带上<code>101状态码</code>，发回给浏览器。HTTP 的响应如下：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">101</span> Switching Protocols\r\n<br><span class="hljs-attribute">Sec-WebSocket-Accept</span><span class="hljs-punctuation">: </span>iBJKv/ALIW2DobfoA4dmr3JHBCY=\r\n<br><span class="hljs-attribute">Upgrade</span><span class="hljs-punctuation">: </span>WebSocket\r\n<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>Upgrade\r\n<br></code></pre></td></tr></table></figure>
<h4 id="WebSocket-消息格式"><a href="#WebSocket-消息格式" class="headerlink" title="WebSocket 消息格式"></a>WebSocket 消息格式</h4><p><img  src="/3a63a86e5d7e72a37b9828fc6e65c21f.png"  ><span class="image-caption">图片</span></p>
<p><strong>opcode字段</strong>：这个是用来标志这是个<strong>什么类型</strong>的数据帧。比如。</p>
<ul>
<li>等于 1 ，是指text类型（<code>string</code>）的数据包</li>
<li>等于 2 ，是二进制数据类型（<code>[]byte</code>）的数据包</li>
<li>等于 8 ，是关闭连接的信号</li>
</ul>
<p><strong>payload字段</strong>：存放的是我们<strong>真正想要传输的数据的长度</strong>，单位是<strong>字节</strong>。比如你要发送的数据是<code>字符串&quot;111&quot;</code>，那它的长度就是<code>3</code>。</p>
<h4 id="WS-适用场景"><a href="#WS-适用场景" class="headerlink" title="WS 适用场景"></a>WS 适用场景</h4><p>WebSocket完美继承了 TCP 协议的<strong>全双工</strong>能力，并且还贴心的提供了解决粘包的方案。</p>
<p>它适用于<strong>需要服务器和客户端（浏览器）频繁交互</strong>的大部分场景，比如网页/小程序游戏，网页聊天室，以及一些类似飞书这样的网页协同办公软件。</p>
<h2 id="TCP-篇"><a href="#TCP-篇" class="headerlink" title="TCP 篇"></a>TCP 篇</h2><p>TCP 是<strong>面向连接的、可靠的、基于字节流</strong>的传输层通信协议。</p>
<h3 id="协议头"><a href="#协议头" class="headerlink" title="协议头"></a>协议头</h3><p><img  src="/format,png-20230309230534096.png"   style="zoom:67%;" /><span class="image-caption">TCP 头格式</span></p>
<p><strong>序列号</strong>：在建立连接时由计算机生成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。<strong>用来解决网络包乱序问题。</strong></p>
<p><strong>确认应答号</strong>：指下一次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。<strong>用来解决丢包的问题。</strong></p>
<p><strong>控制位：</strong></p>
<ul>
<li><em>ACK</em>：该位为 <code>1</code> 时，「确认应答」的字段变为有效，TCP 规定除了最初建立连接时的 <code>SYN</code> 包之外该位必须设置为 <code>1</code> 。</li>
<li><em>RST</em>：该位为 <code>1</code> 时，表示 TCP 连接中出现异常必须强制断开连接。</li>
<li><em>SYN</em>：该位为 <code>1</code> 时，表示希望建立连接，并在其「序列号」的字段进行序列号初始值的设定。</li>
<li><em>FIN</em>：该位为 <code>1</code> 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 <code>FIN</code> 位为 1 的 TCP 段。</li>
</ul>
<h3 id="TCP-和-UDP-区别"><a href="#TCP-和-UDP-区别" class="headerlink" title="TCP 和 UDP 区别"></a><strong>TCP 和 UDP 区别</strong></h3><p><em>1. 连接</em></p>
<ul>
<li>TCP 是面向连接的传输层协议，传输数据前先要建立连接。</li>
<li>UDP 是不需要连接，即刻传输数据。</li>
</ul>
<p><em>2. 服务对象</em></p>
<ul>
<li>TCP 是一对一的两点服务，即一条连接只有两个端点。</li>
<li>UDP 支持一对一、一对多、多对多的交互通信</li>
</ul>
<p><em>3. 可靠性</em></p>
<ul>
<li>TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按序到达。</li>
<li>UDP 是尽最大努力交付，不保证可靠交付数据。但是我们可以基于 UDP 传输协议实现一个可靠的传输协议，比如 QUIC 协议，具体可以参见这篇文章：<a href="https://xiaolincoding.com/network/3_tcp/quic.html">如何基于 UDP 协议实现可靠传输？</a></li>
</ul>
<p><em>4. 拥塞控制、流量控制</em></p>
<ul>
<li>TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。</li>
<li>UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。</li>
</ul>
<p><em>5. 首部开销</em></p>
<ul>
<li>TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 <code>20</code> 个字节，如果使用了「选项」字段则会变长的。</li>
<li>UDP 首部只有 8 个字节，并且是固定不变的，开销较小。</li>
</ul>
<p><em>6. 传输方式</em></p>
<ul>
<li>TCP 是流式传输，没有边界，但保证顺序和可靠。</li>
<li>UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。</li>
</ul>
<p><em>7. 分片不同</em></p>
<ul>
<li>TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。</li>
<li>UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层。</li>
</ul>
<h3 id="三次握手-1"><a href="#三次握手-1" class="headerlink" title="三次握手"></a>三次握手</h3><p><img  src="/TCP三次握手.drawio-1742366660756-59.png"   style="zoom: 50%;" /><span class="image-caption">TCP 三次握手</span></p>
<p><strong>第三次握手是可以携带数据的，前两次握手是不可以携带数据的</strong></p>
<h4 id="为什么是三次握手？不是两次、四次？"><a href="#为什么是三次握手？不是两次、四次？" class="headerlink" title="为什么是三次握手？不是两次、四次？"></a>为什么是三次握手？不是两次、四次？</h4><ul>
<li>三次握手才可以阻止重复历史连接的初始化（主要原因）<ul>
<li>客户端根据服务器的响应确认是不是旧的，如果是旧的就 RST</li>
</ul>
</li>
<li>三次握手才可以同步双方的初始序列号<ul>
<li>当客户端发送携带「初始序列号」的 <code>SYN</code> 报文的时候，需要服务端回一个 <code>ACK</code> 应答报文，表示客户端的 SYN 报文已被服务端成功接收，那当服务端发送「初始序列号」给客户端的时候，依然也要得到客户端的应答回应，<strong>这样一来一回，才能确保双方的初始序列号能被可靠的同步。</strong></li>
</ul>
</li>
<li>三次握手才可以避免资源浪费<ul>
<li>如果只有「两次握手」，当客户端发生的 <code>SYN</code> 报文在网络中阻塞，客户端没有接收到 <code>ACK</code> 报文，就会重新发送 <code>SYN</code> ，<strong>由于没有第三次握手，服务端不清楚客户端是否收到了自己回复的 <code>ACK</code> 报文，所以服务端每收到一个 <code>SYN</code> 就只能先主动建立一个连接</strong>，这会造成什么情况呢？</li>
<li>如果客户端发送的 <code>SYN</code> 报文在网络中阻塞了，重复发送多次 <code>SYN</code> 报文，那么服务端在收到请求后就会<strong>建立多个冗余的无效链接，造成不必要的资源浪费。</strong></li>
</ul>
</li>
</ul>
<h4 id="第一次握手丢失了，会发生什么？"><a href="#第一次握手丢失了，会发生什么？" class="headerlink" title="第一次握手丢失了，会发生什么？"></a>第一次握手丢失了，会发生什么？</h4><p>如果客户端迟迟收不到服务端的 SYN-ACK 报文（第二次握手），就会触发「超时重传」机制，重传 SYN 报文，而且<strong>重传的 SYN 报文的序列号都是一样的</strong>。</p>
<p>在 Linux 里，客户端的 SYN 报文最大重传次数由 <code>tcp_syn_retries</code>内核参数控制，这个参数是可以自定义的，默认值一般是 5。</p>
<p>通常，第一次超时重传是在 1 秒后，第二次超时重传是在 2 秒，第三次超时重传是在 4 秒后，第四次超时重传是在 8 秒后，第五次是在超时重传 16 秒后。没错，<strong>每次超时的时间是上一次的 2 倍</strong>。</p>
<h4 id="第二次握手丢失了，会发生什么？"><a href="#第二次握手丢失了，会发生什么？" class="headerlink" title="第二次握手丢失了，会发生什么？"></a>第二次握手丢失了，会发生什么？</h4><p>当服务端收到客户端的第一次握手后，就会回 SYN-ACK 报文给客户端，这个就是第二次握手，此时服务端会进入 <code>SYN_RCVD</code> 状态。</p>
<p>第二次握手的 <code>SYN-ACK</code> 报文其实有两个目的 ：</p>
<ul>
<li>第二次握手里的 ACK， 是对第一次握手的确认报文；</li>
<li>第二次握手里的 SYN，是服务端发起建立 TCP 连接的报文；</li>
</ul>
<p>当第二次握手丢失了，客户端和服务端都会重传：</p>
<ul>
<li>客户端会重传 SYN 报文，也就是第一次握手，最大重传次数由 <code>tcp_syn_retries</code>内核参数决定；</li>
<li>服务端会重传 SYN-ACK 报文，也就是第二次握手，最大重传次数由 <code>tcp_synack_retries</code> 内核参数决定。</li>
</ul>
<p>在 Linux 下，SYN-ACK 报文的最大重传次数由 <code>tcp_synack_retries</code>内核参数决定，默认值是 5。</p>
<h4 id="第三次握手丢失了，会发生什么？"><a href="#第三次握手丢失了，会发生什么？" class="headerlink" title="第三次握手丢失了，会发生什么？"></a>第三次握手丢失了，会发生什么？</h4><p>客户端收到服务端的 SYN-ACK 报文后，就会给服务端回一个 ACK 报文，也就是第三次握手，此时客户端状态进入到 <code>ESTABLISH</code> 状态。</p>
<p>因为这个第三次握手的 ACK 是对第二次握手的 SYN 的确认报文，所以当第三次握手丢失了，如果服务端那一方迟迟收不到这个确认报文，就会触发超时重传机制，重传 SYN-ACK 报文，直到收到第三次握手，或者达到最大重传次数。</p>
<p><strong>ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的报文</strong>。</p>
<h4 id="什么是-SYN-攻击？如何避免-SYN-攻击？"><a href="#什么是-SYN-攻击？如何避免-SYN-攻击？" class="headerlink" title="什么是 SYN 攻击？如何避免 SYN 攻击？"></a>什么是 SYN 攻击？如何避免 SYN 攻击？</h4><p>我们都知道 TCP 连接建立是需要三次握手，假设攻击者短时间伪造不同 IP 地址的 <code>SYN</code> 报文，服务端每接收到一个 <code>SYN</code> 报文，就进入<code>SYN_RCVD</code> 状态，但服务端发送出去的 <code>ACK + SYN</code> 报文，无法得到未知 IP 主机的 <code>ACK</code> 应答，久而久之就会<strong>占满服务端的半连接队列</strong>，使得服务端不能为正常用户服务。</p>
<p>在 TCP 三次握手的时候，Linux 内核会维护两个队列，分别是：</p>
<ul>
<li>半连接队列，也称 SYN 队列；</li>
<li>全连接队列，也称 accept 队列；</li>
</ul>
<p>SYN 攻击方式最直接的表现就会把 TCP 半连接队列打满，这样<strong>当 TCP 半连接队列满了，后续再在收到 SYN 报文就会丢弃</strong>，导致客户端无法和服务端建立连接。</p>
<p>避免 SYN 攻击方式，可以有以下四种方法：</p>
<ul>
<li>调大 netdev_max_backlog；<ul>
<li>当网卡接收数据包的速度大于内核处理的速度时，会有一个队列保存这些数据包。</li>
</ul>
</li>
<li>增大 TCP 半连接队列；<ul>
<li>增大 net.ipv4.tcp_max_syn_backlog</li>
<li>增大 listen() 函数中的 backlog</li>
<li>增大 net.core.somaxconn</li>
</ul>
</li>
<li>开启 tcp_syncookies；<ul>
<li>开启 syncookies 功能就可以在不使用 SYN 半连接队列的情况下成功建立连接，相当于绕过了 SYN 半连接来建立连接。</li>
</ul>
</li>
<li>减少 SYN+ACK 重传次数<ul>
<li>针对 SYN 攻击的场景，我们可以减少 SYN-ACK 的重传次数，以加快处于 SYN_REVC 状态的 TCP 连接断开。</li>
</ul>
</li>
</ul>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p><img  src="/format,png-20230309230614791.png"   style="zoom: 80%;" /><span class="image-caption">客户端主动关闭连接 —— TCP 四次挥手</span></p>
<p>每个方向都需要<strong>一个 FIN 和一个 ACK</strong>，因此通常被称为<strong>四次挥手</strong>。</p>
<p><strong>主动关闭连接的，才有 TIME_WAIT 状态。</strong></p>
<h4 id="为什么挥手需要四次？"><a href="#为什么挥手需要四次？" class="headerlink" title="为什么挥手需要四次？"></a>为什么挥手需要四次？</h4><ul>
<li>关闭连接时，客户端向服务端发送 <code>FIN</code> 时，仅仅表示客户端不再发送数据了但是还能接收数据。</li>
<li>服务端收到客户端的 <code>FIN</code> 报文时，先回一个 <code>ACK</code> 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 <code>FIN</code> 报文给客户端来表示同意现在关闭连接。</li>
</ul>
<p>从上面过程可知，服务端通常需要等待完成数据的发送和处理，所以服务端的 <code>ACK</code> 和 <code>FIN</code> 一般都会分开发送，因此是需要四次挥手。</p>
<h4 id="第一次挥手丢失了，会发生什么？"><a href="#第一次挥手丢失了，会发生什么？" class="headerlink" title="第一次挥手丢失了，会发生什么？"></a>第一次挥手丢失了，会发生什么？</h4><p>当客户端（主动关闭方）调用 close 函数后，就会向服务端发送 FIN 报文，试图与服务端断开连接，此时客户端的连接进入到 <code>FIN_WAIT_1</code> 状态。</p>
<p>正常情况下，如果能及时收到服务端（被动关闭方）的 ACK，则会很快变为 <code>FIN_WAIT2</code>状态。</p>
<p>如果第一次挥手丢失了，那么客户端迟迟收不到被动方的 ACK 的话，也就会触发超时重传机制，重传 FIN 报文，重发次数由 <code>tcp_orphan_retries</code> 参数控制。</p>
<p><img  src="/第1次握手丢失.png"   style="zoom: 50%;" /><span class="image-caption">img</span></p>
<h4 id="第二次挥手丢失了，会发生什么？"><a href="#第二次挥手丢失了，会发生什么？" class="headerlink" title="第二次挥手丢失了，会发生什么？"></a>第二次挥手丢失了，会发生什么？</h4><p>当服务端收到客户端的第一次挥手后，就会先回一个 ACK 确认报文，此时服务端的连接进入到 <code>CLOSE_WAIT</code> 状态。</p>
<p>在前面我们也提了，ACK 报文是不会重传的，所以如果服务端的第二次挥手丢失了，客户端就会触发超时重传机制，重传 FIN 报文，直到收到服务端的第二次挥手，或者达到最大的重传次数。</p>
<ul>
<li>当客户端超时重传 2 次 FIN 报文后，由于 tcp_orphan_retries 为 2，已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到服务端的第二次挥手（ACK 报文），那么客户端就会断开连接。</li>
</ul>
<p><img  src="/第2次握手丢失.png"   style="zoom:50%;" /><span class="image-caption">img</span></p>
<h4 id="第三次挥手丢失了，会发生什么？"><a href="#第三次挥手丢失了，会发生什么？" class="headerlink" title="第三次挥手丢失了，会发生什么？"></a>第三次挥手丢失了，会发生什么？</h4><p>当服务端（被动关闭方）收到客户端（主动关闭方）的 FIN 报文后，内核会自动回复 ACK，同时连接处于 <code>CLOSE_WAIT</code> 状态，顾名思义，它表示等待应用进程调用 close 函数关闭连接。</p>
<p>此时，内核是没有权利替代进程关闭连接，必须由进程主动调用 close 函数来触发服务端发送 FIN 报文。</p>
<p>服务端处于 CLOSE_WAIT 状态时，调用了 close 函数，内核就会发出 FIN 报文，同时连接进入 LAST_ACK 状态，等待客户端返回 ACK 来确认连接关闭。</p>
<p>如果迟迟收不到这个 ACK，服务端就会重发 FIN 报文，重发次数仍然由 <code>tcp_orphan_retries</code> 参数控制，这与客户端重发 FIN 报文的重传次数控制方式是一样的。</p>
<p><img  src="/第三次握手丢失.drawio.png"   style="zoom:50%;" /><span class="image-caption">img</span></p>
<h4 id="第四次挥手丢失了，会发生什么？"><a href="#第四次挥手丢失了，会发生什么？" class="headerlink" title="第四次挥手丢失了，会发生什么？"></a>第四次挥手丢失了，会发生什么？</h4><p>当客户端收到服务端的第三次挥手的 FIN 报文后，就会回 ACK 报文，也就是第四次挥手，此时客户端连接进入 <code>TIME_WAIT</code> 状态。</p>
<p>在 Linux 系统，TIME_WAIT 状态会持续 2MSL 后才会进入关闭状态。</p>
<p>然后，服务端（被动关闭方）没有收到 ACK 报文前，还是处于 LAST_ACK 状态。</p>
<p>如果第四次挥手的 ACK 报文没有到达服务端，服务端就会重发 FIN 报文，重发次数仍然由前面介绍过的 <code>tcp_orphan_retries</code> 参数控制。</p>
<p><img  src="/第四次挥手丢失drawio.drawio.png"   style="zoom:50%;" /><span class="image-caption">img</span></p>
<h4 id="为什么-TIME-WAIT-等待的时间是-2MSL？"><a href="#为什么-TIME-WAIT-等待的时间是-2MSL？" class="headerlink" title="为什么 TIME_WAIT 等待的时间是 2MSL？"></a>为什么 TIME_WAIT 等待的时间是 2MSL？</h4><p><code>MSL</code> 是 Maximum Segment Lifetime，<strong>报文最大生存时间</strong>，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。因为 TCP 报文基于是 IP 协议的，而 IP 头中有一个 <code>TTL</code> 字段，是 IP 数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃，同时发送 ICMP 报文通知源主机。</p>
<p>MSL 与 TTL 的区别： MSL 的单位是时间，而 TTL 是经过路由跳数。所以 <strong>MSL 应该要大于等于 TTL 消耗为 0 的时间</strong>，以确保报文已被自然消亡。</p>
<p><strong>TTL 的值一般是 64，Linux 将 MSL 设置为 30 秒，意味着 Linux 认为数据报文经过 64 个路由器的时间不会超过 30 秒，如果超过了，就认为报文已经消失在网络中了</strong>。</p>
<p>TIME_WAIT 等待 2 倍的 MSL，比较合理的解释是： 网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以<strong>一来一回需要等待 2 倍的时间</strong>。</p>
<p>比如，如果被动关闭方没有收到断开连接的最后的 ACK 报文，就会触发超时重发 <code>FIN</code> 报文，另一方接收到 FIN 后，会重发 ACK 给被动关闭方， 一来一去正好 2 个 MSL。</p>
<p>可以看到 <strong>2MSL时长</strong> 这其实是相当于<strong>至少允许报文丢失一次</strong>。比如，若 ACK 在一个 MSL 内丢失，这样被动方重发的 FIN 会在第 2 个 MSL 内到达，TIME_WAIT 状态的连接可以应对。</p>
<p>为什么不是 4 或者 8 MSL 的时长呢？你可以想象一个丢包率达到百分之一的糟糕网络，连续两次丢包的概率只有万分之一，这个概率实在是太小了，忽略它比解决它更具性价比。</p>
<p><code>2MSL</code> 的时间是从<strong>客户端接收到 FIN 后发送 ACK 开始计时的</strong>。如果在 TIME-WAIT 时间内，因为客户端的 ACK 没有传输到服务端，客户端又接收到了服务端重发的 FIN 报文，那么 <strong>2MSL 时间将重新计时</strong>。</p>
<p>在 Linux 系统里 <code>2MSL</code> 默认是 <code>60</code> 秒，那么一个 <code>MSL</code> 也就是 <code>30</code> 秒。<strong>Linux 系统停留在 TIME_WAIT 的时间为固定的 60 秒</strong>。</p>
<h4 id="为什么需要-TIME-WAIT-状态？"><a href="#为什么需要-TIME-WAIT-状态？" class="headerlink" title="为什么需要 TIME_WAIT 状态？"></a>为什么需要 TIME_WAIT 状态？</h4><p>主动发起关闭连接的一方，才会有 <code>TIME-WAIT</code> 状态。</p>
<p>需要 TIME-WAIT 状态，主要是两个原因：</p>
<ul>
<li>防止历史连接中的数据，被后面相同四元组的连接错误的接收；</li>
<li>保证「被动关闭连接」的一方，能被正确的关闭；</li>
</ul>
<h4 id="TIME-WAIT-过多有什么危害？"><a href="#TIME-WAIT-过多有什么危害？" class="headerlink" title="TIME_WAIT 过多有什么危害？"></a>TIME_WAIT 过多有什么危害？</h4><p>过多的 TIME-WAIT 状态主要的危害有两种：</p>
<ul>
<li>第一是占用系统资源，比如文件描述符、内存资源、CPU 资源、线程资源等；</li>
<li>第二是占用端口资源，端口资源也是有限的，一般可以开启的端口为 <code>32768～61000</code>，也可以通过 <code>net.ipv4.ip_local_port_range</code>参数指定范围。</li>
</ul>
<p>客户端和服务端 TIME_WAIT 过多，造成的影响是不同的。</p>
<p><strong>如果客户端（主动发起关闭连接方）的 TIME_WAIT 状态过多</strong>，占满了所有端口资源，那么就无法对「目的 IP+ 目的 PORT」都一样的服务端发起连接了，但是被使用的端口，还是可以继续对另外一个服务端发起连接的。</p>
<p><strong>如果服务端（主动发起关闭连接方）的 TIME_WAIT 状态过多</strong>，并不会导致端口资源受限，因为服务端只监听一个端口，而且由于一个四元组唯一确定一个 TCP 连接，因此理论上服务端可以建立很多连接，但是 TCP 连接过多，会占用系统资源，比如文件描述符、内存资源、CPU 资源、线程资源等。</p>
<h4 id="如何优化-TIME-WAIT？"><a href="#如何优化-TIME-WAIT？" class="headerlink" title="如何优化 TIME_WAIT？"></a>如何优化 TIME_WAIT？</h4><ul>
<li><p>打开 net.ipv4.tcp_tw_reuse 和 net.ipv4.tcp_timestamps 选项；</p>
<ul>
<li><strong>复用处于 TIME_WAIT 的 socket 为新的连接所用</strong>。</li>
</ul>
</li>
<li><p>net.ipv4.tcp_max_tw_buckets</p>
<ul>
<li><strong>当系统中处于 TIME_WAIT 的连接一旦超过这个值时，系统就会将后面的 TIME_WAIT 连接状态重置</strong></li>
</ul>
</li>
<li><p>程序中使用 SO_LINGER ，应用强制使用 RST 关闭。</p>
<ul>
<li><p>我们可以通过设置 socket 选项，来设置调用 close 关闭连接行为。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">linger</span> <span class="hljs-title">so_linger</span>;</span><br>so_linger.l_onoff = <span class="hljs-number">1</span>;<br>so_linger.l_linger = <span class="hljs-number">0</span>;<br>setsockopt(s, SOL_SOCKET, SO_LINGER, &amp;so_linger,<span class="hljs-keyword">sizeof</span>(so_linger));<br></code></pre></td></tr></table></figure>
<p>如果<code>l_onoff</code>为非 0， 且<code>l_linger</code>值为 0，那么调用<code>close</code>后，会立该发送一个<code>RST</code>标志给对端，该 TCP 连接将跳过四次挥手，也就跳过了<code>TIME_WAIT</code>状态，直接关闭。</p>
</li>
</ul>
</li>
</ul>
<h4 id="服务器出现大量-TIME-WAIT-状态的原因有哪些？"><a href="#服务器出现大量-TIME-WAIT-状态的原因有哪些？" class="headerlink" title="服务器出现大量 TIME_WAIT 状态的原因有哪些？"></a>服务器出现大量 TIME_WAIT 状态的原因有哪些？</h4><p>首先要知道 TIME_WAIT 状态是主动关闭连接方才会出现的状态，所以如果服务器出现大量的 TIME_WAIT 状态的 TCP 连接，就是说明服务器主动断开了很多 TCP 连接。</p>
<p><strong>什么场景下服务端会主动断开连接呢？</strong></p>
<ul>
<li>第一个场景：HTTP 没有使用长连接<ul>
<li>HTTP/1.0</li>
</ul>
</li>
<li>第二个场景：HTTP 长连接超时<ul>
<li><strong>如果客户端在完后一个 HTTP 请求后，在 60 秒内都没有再发起新的请求，定时器的时间一到，nginx 就会触发回调函数来关闭该连接，那么此时服务端上就会出现 TIME_WAIT 状态的连接</strong>。</li>
</ul>
</li>
<li>第三个场景：HTTP 长连接的请求数量达到上限<ul>
<li>比如 nginx 的 keepalive_requests 这个参数，这个参数是指一个 HTTP 长连接建立之后，nginx 就会为这个连接设置一个计数器，记录这个 HTTP 长连接上已经接收并处理的客户端请求的数量。<strong>如果达到这个参数设置的最大值时，则 nginx 会主动关闭这个长连接</strong>，那么此时服务端上就会出现 TIME_WAIT 状态的连接。</li>
<li>针对这个场景下，解决的方式也很简单，调大 nginx 的 keepalive_requests 参数就行。</li>
</ul>
</li>
</ul>
<h4 id="服务器出现大量-CLOSE-WAIT-状态的原因有哪些？"><a href="#服务器出现大量-CLOSE-WAIT-状态的原因有哪些？" class="headerlink" title="服务器出现大量 CLOSE_WAIT 状态的原因有哪些？"></a>服务器出现大量 CLOSE_WAIT 状态的原因有哪些？</h4><p>CLOSE_WAIT 状态是「被动关闭方」才会有的状态，而且如果「被动关闭方」没有调用 close 函数关闭连接，那么就无法发出 FIN 报文，从而无法使得 CLOSE_WAIT 状态的连接转变为 LAST_ACK 状态。</p>
<p>所以，<strong>当服务端出现大量 CLOSE_WAIT 状态的连接的时候，说明服务端的程序没有调用 close 函数关闭连接，通常都是代码问题</strong>。</p>
<p>我们先来分析一个普通的 TCP 服务端的流程：</p>
<ol>
<li>创建服务端 socket，bind 绑定端口、listen 监听端口</li>
<li>将服务端 socket 注册到 epoll</li>
<li>epoll_wait 等待连接到来，连接到来时，调用 accpet 获取已连接的 socket</li>
<li>将已连接的 socket 注册到 epoll</li>
<li>epoll_wait 等待事件发生</li>
<li>对方连接关闭时，我方调用 close</li>
</ol>
<h4 id="如果已经建立了连接，但是客户端突然出现故障了怎么办？"><a href="#如果已经建立了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="如果已经建立了连接，但是客户端突然出现故障了怎么办？"></a>如果已经建立了连接，但是客户端突然出现故障了怎么办？</h4><p>为了避免这种情况，TCP 搞了个<strong>保活机制</strong>。这个机制的原理是这样的：</p>
<p>定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作用，每隔一个时间间隔，发送一个探测报文，该探测报文包含的数据非常少，如果连续几个探测报文都没有得到响应，则认为当前的 TCP 连接已经死亡，系统内核将错误信息通知给上层应用程序。</p>
<h4 id="如果已经建立了连接，但是服务端的进程崩溃会发生什么？"><a href="#如果已经建立了连接，但是服务端的进程崩溃会发生什么？" class="headerlink" title="如果已经建立了连接，但是服务端的进程崩溃会发生什么？"></a>如果已经建立了连接，但是服务端的进程崩溃会发生什么？</h4><p>TCP 的连接信息是由内核维护的，所以当服务端的进程崩溃后，内核需要回收该进程的所有 TCP 连接资源，于是内核会发送第一次挥手 FIN 报文，后续的挥手过程也都是在内核完成，并不需要进程的参与，所以即使服务端的进程退出了，还是能与客户端完成 TCP 四次挥手的过程。</p>
<h3 id="Socket-编程"><a href="#Socket-编程" class="headerlink" title="Socket 编程"></a>Socket 编程</h3><h4 id="listen-的-backlog-参数意义"><a href="#listen-的-backlog-参数意义" class="headerlink" title="listen 的 backlog 参数意义"></a>listen 的 backlog 参数意义</h4><p>Linux内核中会维护两个队列：</p>
<ul>
<li>半连接队列（SYN 队列）：接收到一个 SYN 建立连接请求，处于 SYN_RCVD 状态；</li>
<li>全连接队列（Accpet 队列）：已完成 TCP 三次握手过程，处于 ESTABLISHED 状态；</li>
</ul>
<p><img  src="/format,png-20230309230542373.png"   style="zoom:67%;" /><span class="image-caption"> SYN 队列 与 Accpet 队列 </span></p>
<p>在 Linux 内核 2.2 之后，backlog 变成 accept 队列，也就是已完成连接建立的队列长度，<strong>所以现在通常认为 backlog 是 accept 队列。</strong></p>
<p><strong>但是上限值是内核参数 somaxconn 的大小，也就说 accpet 队列长度 = min(backlog, somaxconn)。</strong></p>
<h4 id="accept-发生在三次握手的哪一步？"><a href="#accept-发生在三次握手的哪一步？" class="headerlink" title="accept 发生在三次握手的哪一步？"></a>accept 发生在三次握手的哪一步？</h4><p><img  src="/socket三次握手.drawio.png"   style="zoom:67%;" /><span class="image-caption">socket 三次握手</span></p>
<p>从上面的描述过程，我们可以得知<strong>客户端 connect 成功返回是在第二次握手，服务端 accept 成功返回是在三次握手成功之后。</strong></p>
<h4 id="客户端调用-close-了，连接是断开的流程是什么？"><a href="#客户端调用-close-了，连接是断开的流程是什么？" class="headerlink" title="客户端调用 close 了，连接是断开的流程是什么？"></a>客户端调用 close 了，连接是断开的流程是什么？</h4><p><img  src="/format,png-20230309230538308.png"   style="zoom:67%;" /><span class="image-caption">客户端调用 close 过程</span></p>
<ul>
<li>客户端调用 <code>close</code>，表明客户端没有数据需要发送了，则此时会向服务端发送 FIN 报文，进入 FIN_WAIT_1 状态；</li>
<li>服务端接收到了 FIN 报文，TCP 协议栈会为 FIN 包插入一个文件结束符 <code>EOF</code> 到接收缓冲区中，应用程序可以通过 <code>read</code> 调用来感知这个 FIN 包。这个 <code>EOF</code> 会被<strong>放在已排队等候的其他已接收的数据之后</strong>，这就意味着服务端需要处理这种异常情况，因为 EOF 表示在该连接上再无额外数据到达。此时，服务端进入 CLOSE_WAIT 状态；</li>
<li>接着，当处理完数据后，自然就会读到 <code>EOF</code>，于是也调用 <code>close</code> 关闭它的套接字，这会使得服务端发出一个 FIN 包，之后处于 LAST_ACK 状态；</li>
<li>客户端接收到服务端的 FIN 包，并发送 ACK 确认包给服务端，此时客户端将进入 TIME_WAIT 状态；</li>
<li>服务端收到 ACK 确认包后，就进入了最后的 CLOSE 状态；</li>
<li>客户端经过 <code>2MSL</code> 时间之后，也进入 CLOSE 状态；</li>
</ul>
<h4 id="没有-accept，能建立-TCP-连接吗？"><a href="#没有-accept，能建立-TCP-连接吗？" class="headerlink" title="没有 accept，能建立 TCP 连接吗？"></a>没有 accept，能建立 TCP 连接吗？</h4><p>答案：<strong>可以的</strong>。</p>
<p>accpet 系统调用并不参与 TCP 三次握手过程，它只是负责从 TCP 全连接队列取出一个已经建立连接的 socket，用户层通过 accpet 系统调用拿到了已经建立连接的 socket，就可以对该 socket 进行读写操作了。</p>
<h4 id="没有-listen，能建立-TCP-连接吗？"><a href="#没有-listen，能建立-TCP-连接吗？" class="headerlink" title="没有 listen，能建立 TCP 连接吗？"></a>没有 listen，能建立 TCP 连接吗？</h4><p>答案：<strong>可以的</strong>。</p>
<p>客户端是可以自己连自己的形成连接（<strong>TCP自连接</strong>），也可以两个客户端同时向对方发出请求建立连接（<strong>TCP同时打开</strong>），这两个情况都有个共同点，就是<strong>没有服务端参与，也就是没有 listen，就能 TCP 建立连接。</strong></p>
<h4 id="TCP-和-UDP-可以同时绑定相同的端口吗？"><a href="#TCP-和-UDP-可以同时绑定相同的端口吗？" class="headerlink" title="TCP 和 UDP 可以同时绑定相同的端口吗？"></a>TCP 和 UDP 可以同时绑定相同的端口吗？</h4><p>答案：<strong>可以的</strong>。</p>
<p>在数据链路层中，通过 MAC 地址来寻找局域网中的主机。在网际层中，通过 IP 地址来寻找网络中互连的主机或路由器。在传输层中，需要通过端口进行寻址，来识别同一计算机中同时通信的不同应用程序。</p>
<p>所以，传输层的「端口号」的作用，是为了区分同一个主机上不同应用程序的数据包。</p>
<p>传输层有两个传输协议分别是 TCP 和 UDP，在内核中是两个完全独立的软件模块。</p>
<h4 id="多个-TCP-服务进程可以绑定同一个端口吗？"><a href="#多个-TCP-服务进程可以绑定同一个端口吗？" class="headerlink" title="多个 TCP 服务进程可以绑定同一个端口吗？"></a>多个 TCP 服务进程可以绑定同一个端口吗？</h4><p>这个问题的答案是：<strong>如果两个 TCP 服务进程同时绑定的 IP 地址和端口都相同，那么执行 bind() 时候就会出错，错误是“Address already in use”</strong>。</p>
<h4 id="重启-TCP-服务进程时，为什么会有“Address-in-use”的报错信息？"><a href="#重启-TCP-服务进程时，为什么会有“Address-in-use”的报错信息？" class="headerlink" title="重启 TCP 服务进程时，为什么会有“Address in use”的报错信息？"></a>重启 TCP 服务进程时，为什么会有“Address in use”的报错信息？</h4><p><strong>当 TCP 服务进程重启时，服务端会出现 TIME_WAIT 状态的连接，TIME_WAIT 状态的连接使用的 IP+PORT 仍然被认为是一个有效的 IP+PORT 组合，相同机器上不能够在该 IP+PORT 组合上进行绑定，那么执行 bind() 函数的时候，就会返回了 Address already in use 的错误</strong>。</p>
<p>我们可以在调用 bind 前，对 socket 设置 SO_REUSEADDR 属性，可以解决这个问题。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> on = <span class="hljs-number">1</span>;<br>setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;on, <span class="hljs-keyword">sizeof</span>(on));<br></code></pre></td></tr></table></figure>
<p>因为 SO_REUSEADDR 作用是：<strong>如果当前启动进程绑定的 IP+PORT 与处于TIME_WAIT 状态的连接占用的 IP+PORT 存在冲突，但是新启动的进程使用了 SO_REUSEADDR 选项，那么该进程就可以绑定成功</strong>。</p>
<h3 id="序列号和确认号"><a href="#序列号和确认号" class="headerlink" title="序列号和确认号"></a>序列号和确认号</h3><p><strong>发送的 TCP 报文：</strong></p>
<ul>
<li><strong>公式一：序列号 = 上一次发送的序列号 + len（数据长度）。特殊情况，如果上一次发送的报文是 SYN 报文或者 FIN 报文，则改为 上一次发送的序列号 + 1。</strong></li>
<li><strong>公式二：确认号 = 上一次收到的报文中的序列号 + len（数据长度）。特殊情况，如果收到的是 SYN 报文或者 FIN 报文，则改为上一次收到的报文中的序列号 + 1。</strong></li>
</ul>
<ul>
<li><strong>序列号</strong>：在建立连接时由内核生成的随机数作为其初始值，通过 SYN 报文传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。<strong>用来解决网络包乱序问题。</strong></li>
<li><strong>确认号</strong>：指下一次「期望」收到的数据的序列号，发送端收到接收方发来的 ACK 确认报文以后，就可以认为在这个序号以前的数据都已经被正常接收。<strong>用来解决丢包的问题。</strong></li>
<li><strong>控制位：</strong>用来标识 TCP 报文是什么类型的报文，比如是 SYN 报文、数据报文、ACK 报文，FIN 报文等。</li>
</ul>
<p><img  src="/ae18cbf6071c47b98014a68d05c37d16.png"   style="zoom:67%;" /><span class="image-caption">在这里插入图片描述</span></p>
<h2 id="IP-篇"><a href="#IP-篇" class="headerlink" title="IP 篇"></a>IP 篇</h2><p>网络层的主要作用是：<strong>实现主机与主机之间的通信，也叫点对点（end to end）通信。</strong></p>
<p><strong>MAC（数据链路层） 的作用则是实现「直连」的两个设备之间通信，而 IP 则负责在「没有直连」的两个网络之间进行通信传输。</strong></p>
<h3 id="IP-地址分类"><a href="#IP-地址分类" class="headerlink" title="IP 地址分类"></a>IP 地址分类</h3><p><img  src="/7-1742387166512-1.jpg"  ><span class="image-caption">IP 地址分类</span></p>
<h3 id="无分类地址-CIDR"><a href="#无分类地址-CIDR" class="headerlink" title="无分类地址 CIDR"></a>无分类地址 CIDR</h3><p>32 比特的 IP 地址被划分为两部分，前面是<strong>网络号</strong>，后面是<strong>主机号</strong></p>
<p>表示形式 <code>a.b.c.d/x</code>，其中 <code>/x</code> 表示前 x 位属于<strong>网络号</strong>， x 的范围是 <code>0 ~ 32</code>，这就使得 IP 地址更加具有灵活性。</p>
<h4 id="为什么要分离网络号和主机号？"><a href="#为什么要分离网络号和主机号？" class="headerlink" title="为什么要分离网络号和主机号？"></a>为什么要分离网络号和主机号？</h4><p>因为两台计算机要通讯，首先要判断是否处于同一个广播域内，即网络地址是否相同。如果网络地址相同，表明接受方在本网络上，那么可以把数据包直接发送到目标主机。</p>
<p>路由器寻址工作中，也就是通过这样的方式来找到对应的网络号的，进而把数据包转发给对应的网络内。</p>
<h4 id="怎么进行子网划分？"><a href="#怎么进行子网划分？" class="headerlink" title="怎么进行子网划分？"></a>怎么进行子网划分？</h4><p><strong>子网划分实际上是将主机地址分为两个部分：子网网络地址和子网主机地址</strong>。形式如下：</p>
<p><img  src="/18-1742387270279-4.jpg"   style="zoom:80%;" /><span class="image-caption">img</span></p>
<h3 id="IPV6"><a href="#IPV6" class="headerlink" title="IPV6"></a>IPV6</h3><p>IPv4 的地址是 32 位的，大约可以提供 42 亿个地址，但是早在 2011 年 IPv4 地址就已经被分配完了。</p>
<p>但是 IPv6 的地址是 <code>128</code> 位的。 IPv4 和 IPv6 不能相互兼容。</p>
<h4 id="IPv6-的亮点"><a href="#IPv6-的亮点" class="headerlink" title="IPv6 的亮点"></a>IPv6 的亮点</h4><ul>
<li>IPv6 可自动配置，即使没有 DHCP 服务器也可以实现自动分配IP地址，真是<strong>便捷到即插即用</strong>啊。</li>
<li>IPv6 包头包首部长度采用固定的值 <code>40</code> 字节，去掉了包头校验和，简化了首部结构，减轻了路由器负荷，大大<strong>提高了传输的性能</strong>。</li>
<li>IPv6 有应对伪造 IP 地址的网络安全功能以及防止线路窃听的功能，大大<strong>提升了安全性</strong>。</li>
</ul>
<h4 id="IPv6-地址的结构"><a href="#IPv6-地址的结构" class="headerlink" title="IPv6 地址的结构"></a>IPv6 地址的结构</h4><p>IPv6 的地址主要有以下类型地址：</p>
<ul>
<li>单播地址，用于一对一的通信</li>
<li>组播地址，用于一对多的通信</li>
<li>任播地址，用于通信最近的节点，最近的节点是由路由协议决定</li>
<li>没有广播地址</li>
</ul>
<p><img  src="/29.jpg"   style="zoom:67%;" /><span class="image-caption">IPv6地址结构</span></p>
<p>对于一对一通信的 IPv6 地址，主要划分了三类单播地址，每类地址的有效范围都不同。</p>
<ul>
<li>在同一链路单播通信，不经过路由器，可以使用<strong>链路本地单播地址</strong>，IPv4 没有此类型</li>
<li>在内网里单播通信，可以使用<strong>唯一本地地址</strong>，相当于 IPv4 的私有 IP</li>
<li>在互联网通信，可以使用<strong>全局单播地址</strong>，相当于 IPv4 的公有 IP</li>
</ul>
<h4 id="IPv4-首部与-IPv6-首部"><a href="#IPv4-首部与-IPv6-首部" class="headerlink" title="IPv4 首部与 IPv6 首部"></a>IPv4 首部与 IPv6 首部</h4><p><img  src="/31.jpg"  ><span class="image-caption">IPv4 首部与 IPv6 首部的差异</span></p>
<p>IPv6 相比 IPv4 的首部改进：</p>
<ul>
<li><strong>取消了首部校验和字段。</strong> 因为在数据链路层和传输层都会校验，因此 IPv6 直接取消了 IP 的校验。</li>
<li><strong>取消了分片/重新组装相关字段。</strong> 分片与重组是耗时的过程，IPv6 不允许在中间路由器进行分片与重组，这种操作只能在源与目标主机，这将大大提高了路由器转发的速度。</li>
<li><strong>取消选项字段。</strong> 选项字段不再是标准 IP 首部的一部分了，但它并没有消失，而是可能出现在 IPv6 首部中的「下一个首部」指出的位置上。删除该选项字段使的 IPv6 的首部成为固定长度的 <code>40</code> 字节。</li>
</ul>
<h3 id="IP-协议相关技术"><a href="#IP-协议相关技术" class="headerlink" title="IP 协议相关技术"></a>IP 协议相关技术</h3><h4 id="DNS-1"><a href="#DNS-1" class="headerlink" title="DNS"></a>DNS</h4><p>域名 -&gt; IP 地址</p>
<h4 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h4><p>IP 地址 -&gt; MAC 地址</p>
<h4 id="RARP"><a href="#RARP" class="headerlink" title="RARP"></a>RARP</h4><p>MAC 地址 -&gt; IP 地址</p>
<p>将打印机服务器等小型嵌入式设备接入到网络时就经常会用得到。</p>
<h4 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h4><p>DHCP 客户端进程监听的是 68 端口号，DHCP 服务端进程监听的是 67 端口号。</p>
<ul>
<li>客户端首先发起 <strong>DHCP 发现报文（DHCP DISCOVER）</strong> 的 IP 数据报，由于客户端没有 IP 地址，也不知道 DHCP 服务器的地址，所以使用的是 UDP <strong>广播</strong>通信，其使用的广播目的地址是 255.255.255.255（端口 67） 并且使用 0.0.0.0（端口 68） 作为源 IP 地址。DHCP 客户端将该 IP 数据报传递给链路层，链路层然后将帧广播到所有的网络中设备。</li>
<li>DHCP 服务器收到 DHCP 发现报文时，用 <strong>DHCP 提供报文（DHCP OFFER）</strong> 向客户端做出响应。该报文仍然使用 IP 广播地址 255.255.255.255，该报文信息携带服务器提供可租约的 IP 地址、子网掩码、默认网关、DNS 服务器以及 <strong>IP 地址租用期</strong>。</li>
<li>客户端收到一个或多个服务器的 DHCP 提供报文后，从中选择一个服务器，并向选中的服务器发送 <strong>DHCP 请求报文（DHCP REQUEST）</strong>进行响应，回显配置的参数。</li>
<li>最后，服务端用 <strong>DHCP ACK 报文</strong> 对 DHCP 请求报文进行响应，应答所要求的参数。</li>
</ul>
<p>如果 DHCP 服务器和客户端不是在同一个局域网内，路由器又不会转发广播包，那不是每个网络都要配一个 DHCP 服务器？</p>
<p>所以，为了解决这一问题，就出现了 <strong>DHCP 中继代理</strong>。有了 DHCP 中继代理以后，<strong>对不同网段的 IP 地址分配也可以由一个 DHCP 服务器统一进行管理。</strong></p>
<h4 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h4><p>可以把 IP 地址 + 端口号一起转换为全球 IP + 端口</p>
<p>于是，生成一个 NAPT 路由器的转换表，就可以正确地转换地址跟端口的组合，令客户端 A、B 能同时与服务器之间进行通信。</p>
<p>由于 NAT/NAPT 都依赖于自己的转换表，因此会有以下的问题：</p>
<ul>
<li>外部无法主动与 NAT 内部服务器建立连接，因为 NAPT 转换表没有转换记录。</li>
<li>转换表的生成与转换操作都会产生性能开销。</li>
<li>通信过程中，如果 NAT 路由器重启了，所有的 TCP 连接都将被重置。</li>
</ul>
<p>解决办法：</p>
<ul>
<li>IPV6</li>
<li>NAT 穿透技术<ul>
<li>让网络应用程序主动发现自己位于 NAT 设备之后，并且会主动获得 NAT 设备的公有 IP，并为自己建立端口映射条目，注意这些都是 NAT设备后的应用程序自动完成的。</li>
</ul>
</li>
</ul>
<h4 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h4><p>ICMP 全称是 <strong>Internet Control Message Protocol</strong>，也就是<strong>互联网控制报文协议</strong>。</p>
<p><strong>确认 IP 包是否成功送达目标地址、报告发送过程中 IP 包被废弃的原因和改善网络设置等。</strong></p>
<h3 id="Ping-的原理"><a href="#Ping-的原理" class="headerlink" title="Ping 的原理"></a>Ping 的原理</h3><p><strong>回送消息</strong>用于进行通信的主机或路由器之间，判断所发送的数据包是否已经成功到达对端的一种消息，<code>ping</code> 命令就是利用这个消息实现的。</p>
<h2 id="traceroute-——-差错报文类型的使用"><a href="#traceroute-——-差错报文类型的使用" class="headerlink" title="traceroute —— 差错报文类型的使用"></a>traceroute —— 差错报文类型的使用</h2><p>traceroute 的第一个作用就是<strong>故意设置特殊的 TTL，来追踪去往目的地时沿途经过的路由器。</strong></p>
<p>它的原理就是利用 IP 包的<strong>生存期限</strong> 从 <code>1</code> 开始按照顺序递增的同时发送 <strong>UDP 包</strong>，强制接收 <strong>ICMP 超时消息</strong>的一种方法。</p>
<p>比如，将 TTL 设置 为 <code>1</code>，则遇到第一个路由器，就牺牲了，接着返回 ICMP 差错报文网络包，类型是<strong>时间超时</strong>。</p>
<p>接下来将 TTL 设置为 <code>2</code>，第一个路由器过了，遇到第二个路由器也牺牲了，也同时返回了 ICMP 差错报文数据包，如此往复，直到到达目的主机。</p>
<p>这样的过程，traceroute 就可以拿到了所有的路由器 IP。</p>
<blockquote>
<p>发送方如何知道发出的 UDP 包是否到达了目的主机呢？</p>
</blockquote>
<p>traceroute 在发送 <code>UDP</code> 包时，会填入一个<strong>不可能的端口号</strong>值作为 UDP 目标端口号：33434。然后对于每个下一个探针，它都会增加一个，这些端口都是通常认为不会被使用，不过，没有人知道当某些应用程序监听此类端口时会发生什么。</p>
<p>当目的主机，收到 UDP 包后，会返回 ICMP 差错报文消息，但这个差错报文消息的类型是「<strong>端口不可达</strong>」。</p>
<p>所以，<strong>当差错报文类型是端口不可达时，说明发送方发出的 UDP 包到达了目的主机。</strong></p>
<p>traceroute 还有一个作用是<strong>故意设置不分片，从而确定路径的 MTU</strong>。</p>
<p>这样做的目的是为了<strong>路径MTU发现</strong>。</p>
<h2 id="SSH-访问-Server-的整个网络流程是怎样的"><a href="#SSH-访问-Server-的整个网络流程是怎样的" class="headerlink" title="SSH 访问 Server 的整个网络流程是怎样的"></a>SSH 访问 Server 的整个网络流程是怎样的</h2><h3 id="1-客户端发起连接（TCP握手）"><a href="#1-客户端发起连接（TCP握手）" class="headerlink" title="1. 客户端发起连接（TCP握手）"></a>1. 客户端发起连接（TCP握手）</h3><ul>
<li><strong>客户端（SSH Client）</strong> 通过命令如 <code>ssh user@host</code> 发起连接。</li>
<li>使用 <strong>TCP协议</strong> 连接服务器的 <strong>22端口</strong>（默认端口，可配置）。</li>
<li>完成 <strong>三次握手（Three-way Handshake）</strong> 来建立基础的网络连接。</li>
</ul>
<h3 id="2-SSH协议协商（版本与加密）"><a href="#2-SSH协议协商（版本与加密）" class="headerlink" title="2. SSH协议协商（版本与加密）"></a>2. SSH协议协商（版本与加密）</h3><ul>
<li>客户端和服务器互相发送 <strong>SSH版本信息</strong>（例如 <code>SSH-2.0-OpenSSH_8.0</code>）。</li>
<li>协商使用的加密算法，包括：<ul>
<li><strong>密钥交换算法</strong>（如 <code>diffie-hellman</code>）</li>
<li><strong>对称加密算法</strong>（如 <code>AES</code>）</li>
<li><strong>MAC算法</strong>（消息认证，如 <code>hmac-sha2-256</code>）</li>
</ul>
</li>
<li>确定后，进入密钥交换流程。</li>
</ul>
<h3 id="3-密钥交换（Key-Exchange）"><a href="#3-密钥交换（Key-Exchange）" class="headerlink" title="3. 密钥交换（Key Exchange）"></a>3. 密钥交换（Key Exchange）</h3><ul>
<li>双方使用 <strong>Diffie-Hellman</strong> 或其他密钥交换协议生成共享密钥（Session Key）。</li>
<li>过程如下：<ol>
<li>服务器生成一对密钥，发送公钥给客户端；</li>
<li>客户端基于公钥生成共享密钥材料；</li>
<li>双方计算出相同的共享密钥（但彼此不知道对方私钥）。</li>
</ol>
</li>
<li><strong>传输加密开始</strong>：后续通信开始使用这个共享密钥加密。</li>
</ul>
<p>以常见的 <strong>Diffie-Hellman Group14</strong> 为例：</p>
<ol>
<li><p>服务器生成私钥 <code>x</code>，计算 <code>e = g^x mod p</code>；</p>
</li>
<li><p>客户端生成私钥 <code>y</code>，计算 <code>f = g^y mod p</code>；</p>
</li>
<li><p>双方交换 <code>e</code> 和 <code>f</code>；</p>
</li>
<li><p>都计算共享密钥：</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><code class="hljs ada">K = f^x <span class="hljs-keyword">mod</span> p = e^y <span class="hljs-keyword">mod</span> p = g^(xy) <span class="hljs-keyword">mod</span> p<br></code></pre></td></tr></table></figure>
</li>
<li><p>客户端生成 session ID（称为 exchange hash <code>H</code>）：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><code class="hljs lisp">H = hash(<span class="hljs-name">V_C</span> || V_S || I_C || I_S || K_S || e || f || K)<br></code></pre></td></tr></table></figure>
<ul>
<li><code>V_C</code>：客户端版本字符串</li>
<li><code>V_S</code>：服务器版本字符串</li>
<li><code>I_C</code> / <code>I_S</code>：KEXINIT 数据包</li>
<li><code>K_S</code>：服务器公钥</li>
</ul>
</li>
<li><p>服务器用其主机私钥对 <code>H</code> 签名，客户端验证签名来 <strong>确认服务器身份</strong>。</p>
</li>
<li><p>使用 <code>K</code> 和 <code>H</code> 推导出多个密钥：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><code class="hljs lisp">session_key = hash(<span class="hljs-name">K</span> || H || ID)<br></code></pre></td></tr></table></figure>
</li>
</ol>
<p>🔐 至此，加密会话建立成功。</p>
<h3 id="4-服务器身份验证"><a href="#4-服务器身份验证" class="headerlink" title="4. 服务器身份验证"></a>4. 服务器身份验证</h3><ul>
<li>服务器将自己公钥的签名发送给客户端；</li>
<li>客户端校验：<ul>
<li>公钥是否可信（是否在 <code>~/.ssh/known_hosts</code> 中）；</li>
<li>签名是否正确。</li>
</ul>
</li>
<li>防止中间人攻击。</li>
</ul>
<h3 id="5-用户身份验证"><a href="#5-用户身份验证" class="headerlink" title="5. 用户身份验证"></a>5. 用户身份验证</h3><p>客户端进行身份验证，有以下几种方式：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>密码登录</strong></td>
<td>用户输入密码，服务器验证</td>
</tr>
<tr>
<td><strong>公钥登录</strong></td>
<td>客户端发送公钥，服务器验证是否信任该公钥，并用其加密 challenge</td>
</tr>
<tr>
<td><strong>多因素认证</strong></td>
<td>增加 OTP、验证码等</td>
</tr>
</tbody>
</table>
</div>
<p>验证成功后，服务器返回成功响应。</p>
<h3 id="6-建立会话和执行命令"><a href="#6-建立会话和执行命令" class="headerlink" title="6. 建立会话和执行命令"></a>6. 建立会话和执行命令</h3><ul>
<li>会话通道建立，客户端可以：<ul>
<li>启动 shell（如 bash）</li>
<li>执行远程命令（如 <code>ls</code>, <code>top</code>）</li>
<li>启动 SFTP 或端口转发（例如 <code>-L</code>、<code>-R</code> 参数）</li>
</ul>
</li>
</ul>
<p>每一个行为都会开启一个独立的子通道（channel），但都在同一个 SSH 连接中。</p>
<h2 id="SSH-的端口转发是怎么实现的"><a href="#SSH-的端口转发是怎么实现的" class="headerlink" title="SSH 的端口转发是怎么实现的"></a>SSH 的端口转发是怎么实现的</h2><p>SSH 支持三种端口转发模式：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>模式名称</th>
<th>命令参数</th>
<th>流量方向</th>
<th>应用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>本地端口转发（Local）</td>
<td><code>-L</code></td>
<td><strong>客户端 → 服务器再转发</strong></td>
<td>访问内网资源</td>
</tr>
<tr>
<td>远程端口转发（Remote）</td>
<td><code>-R</code></td>
<td><strong>服务器 → 客户端再转发</strong></td>
<td>暴露内网服务给外部</td>
</tr>
<tr>
<td>动态端口转发（Dynamic）</td>
<td><code>-D</code></td>
<td><strong>SOCKS 代理（客户端）</strong></td>
<td>构建加密代理，像 VPN 一样使用</td>
</tr>
</tbody>
</table>
</div>
<h6 id=""><a href="#" class="headerlink" title=" "></a> </h6><h2 id="redis，nginx，netty-是依赖什么做的这么高性能？"><a href="#redis，nginx，netty-是依赖什么做的这么高性能？" class="headerlink" title="redis，nginx，netty 是依赖什么做的这么高性能？"></a>redis，nginx，netty 是依赖什么做的这么高性能？</h2><p>主要是依赖<strong>Reactor 模式</strong>实现了高性能网络模式，这个是在i/o多路复用接口基础上实现的了网络模型。Reactor 翻译过来的意思是「反应堆」，这里的反应指的是「<strong>对事件反应</strong>」，也就是<strong>来了一个事件，Reactor 就有相对应的反应/响应</strong>。</p>
<p>Reactor 模式主要由 Reactor 和处理资源池这两个核心部分组成，它俩负责的事情如下：</p>
<ul>
<li>Reactor 负责监听和分发事件，事件类型包含连接事件、读写事件；</li>
<li>处理资源池负责处理事件，如 read -&gt; 业务逻辑 -&gt; send；</li>
</ul>
<p>Reactor 模式是灵活多变的，可以应对不同的业务场景，灵活在于：</p>
<ul>
<li>Reactor 的数量可以只有一个，也可以有多个；</li>
<li>处理资源池可以是单个进程 / 线程，也可以是多个进程 /线程；</li>
</ul>
<h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p>Redis 6.0 之前使用的 Reactor 模型就是单 Reactor 单进程模式。单 Reactor 单进程的方案因为全部工作都在同一个进程内完成，所以实现起来比较简单，不需要考虑进程间通信，也不用担心多进程竞争。</p>
<p><img  src="1720420600761-3cf6a703-4650-4ed4-b900-f2ca71efa57e.webp"   style="zoom:80%;" /><span class="image-caption">img</span></p>
<p>但是，这种方案存在 2 个缺点：</p>
<ul>
<li>第一个缺点，因为只有一个进程，<strong>无法充分利用 多核 CPU 的性能</strong>；</li>
<li>第二个缺点，Handler 对象在业务处理时，整个进程是无法处理其他连接的事件的，<strong>如果业务处理耗时比较长，那么就造成响应的延迟</strong>；</li>
</ul>
<p>所以，单 Reactor 单进程的方案<strong>不适用计算机密集型的场景，只适用于业务处理非常快速的场景</strong>。</p>
<p>Redis 是由 C 语言实现的，在 Redis 6.0 版本之前采用的正是「单 Reactor 单进程」的方案，因为 Redis 业务处理主要是在内存中完成，操作的速度是很快的，性能瓶颈不在 CPU 上，所以 Redis 对于命令的处理是单进程的方案。</p>
<h3 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h3><p>Netty 是采用了多 Reactor 多线程方案，如下图：</p>
<p><img  src="1720420601537-460e47c6-27b5-4daa-a631-01e17b7d71f5.webp"   style="zoom:80%;" /><span class="image-caption">img</span></p>
<p>多 Reactor 多线程的方案优势：</p>
<ul>
<li>主线程和子线程分工明确，主线程只负责接收新连接，子线程负责完成后续的业务处理。</li>
<li>主线程和子线程的交互很简单，主线程只需要把新连接传给子线程，子线程无须返回数据，直接就可以在子线程将处理结果发送给客户端。</li>
</ul>
<h3 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h3><p>nginx 是多 Reactor 多进程方案，不过方案与标准的多 Reactor 多进程有些差异。</p>
<p><img  src="1720420601634-1d2e5786-5633-4406-b8e2-45ba4ab0a2da.webp"   style="zoom:80%;" /><span class="image-caption">img</span></p>
<p>具体差异表现在主进程中仅仅用来初始化 socket，并没有创建 mainReactor 来 accept 连接，而是由子进程的 Reactor 来 accept 连接，通过锁来控制一次只有一个子进程进行 accept（防止出现惊群现象），子进程 accept 新连接后就放到自己的 Reactor 进行处理，不会再分配给其他子进程。</p>
<h2 id="惊群现象是什么？"><a href="#惊群现象是什么？" class="headerlink" title="惊群现象是什么？"></a>惊群现象是什么？</h2><p>“<strong>惊群现象（Thundering Herd Problem）</strong>”是一个在高并发服务器中常见的性能问题，尤其在使用 <strong>多进程 / 多线程</strong> 或 <strong>多协程模型</strong> 并通过 <code>select</code>、<code>poll</code>、<code>epoll</code> 等监听同一 socket 时更为突出。</p>
<p>当多个进程或线程 <strong>同时等待某个资源（如 socket 连接、文件描述符事件）</strong>，而这个资源变得可用时，<strong>所有等待者会一起被唤醒</strong>，但最终只有<strong>一个</strong>能真正处理这个事件，<strong>其他的白白被唤醒后又回去睡眠</strong>。</p>
<p>这就像一群牛（herd）都在等门开吃草（资源），门一开，<strong>所有牛都冲上来（惊群）</strong>，但其实只够一头牛吃，其他牛白跑一趟。</p>
<h3 id="为什么它是个问题？"><a href="#为什么它是个问题？" class="headerlink" title="为什么它是个问题？"></a>为什么它是个问题？</h3><div class="table-container">
<table>
<thead>
<tr>
<th>影响</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>CPU资源浪费</strong></td>
<td>多个进程/线程被唤醒、竞争、失败、重新等待，频繁上下文切换</td>
</tr>
<tr>
<td><strong>可扩展性变差</strong></td>
<td>越多 worker，越容易发生激烈竞争</td>
</tr>
<tr>
<td><strong>系统性能抖动</strong></td>
<td>在高并发场景中可能出现延迟波动甚至连接失败</td>
</tr>
</tbody>
</table>
</div>
<h3 id="惊群出现的场景"><a href="#惊群出现的场景" class="headerlink" title="惊群出现的场景"></a>惊群出现的场景</h3><div class="table-container">
<table>
<thead>
<tr>
<th>场景</th>
<th>是否可能惊群</th>
</tr>
</thead>
<tbody>
<tr>
<td>多进程都监听同一个 socket</td>
<td>✅ 高概率</td>
</tr>
<tr>
<td>多线程/协程在同一个 epoll 上 wait</td>
<td>✅</td>
</tr>
<tr>
<td>多进程共享 epoll fd</td>
<td>✅</td>
</tr>
<tr>
<td>单线程/单进程异步 epoll</td>
<td>❌ 安全</td>
</tr>
</tbody>
</table>
</div>
<h3 id="如何解决惊群问题？"><a href="#如何解决惊群问题？" class="headerlink" title="如何解决惊群问题？"></a>如何解决惊群问题？</h3><p>以下是多种有效缓解或避免惊群的方法：</p>
<h3 id="1-使用-epoll-EPOLLEXCLUSIVE（Linux-4-5-）"><a href="#1-使用-epoll-EPOLLEXCLUSIVE（Linux-4-5-）" class="headerlink" title="1. 使用 epoll + EPOLLEXCLUSIVE（Linux 4.5+）"></a>1. <strong>使用 epoll + EPOLLEXCLUSIVE（Linux 4.5+）</strong></h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">c复制代码epoll<span class="hljs-constructor">_ctl(<span class="hljs-params">epfd</span>, EPOLL_CTL_ADD, <span class="hljs-params">fd</span>, &amp;(<span class="hljs-params">struct</span> <span class="hljs-params">epoll_event</span>)</span>&#123;<br>    .events = EPOLLIN <span class="hljs-pattern-match">| <span class="hljs-constructor">EPOLLEXCLUSIVE</span>,</span><br><span class="hljs-pattern-match">    .data.fd = fd</span><br><span class="hljs-pattern-match">&#125;);</span><br></code></pre></td></tr></table></figure>
<ul>
<li>内核保证 <strong>每个事件只唤醒一个监听者</strong></li>
<li>解决根本问题，但仅在 Linux 4.5+ 可用</li>
</ul>
<hr>
<h3 id="2-使用-Accept-Mutex（Nginx做法）"><a href="#2-使用-Accept-Mutex（Nginx做法）" class="headerlink" title="2. 使用 Accept Mutex（Nginx做法）"></a>2. <strong>使用 Accept Mutex（Nginx做法）</strong></h3><ul>
<li>设一个全局“抢锁”逻辑，只允许<strong>一个 worker accept 连接</strong>，其他 worker 等待锁。</li>
<li>每次连接处理完后释放锁给其他 worker。</li>
<li>减少无效唤醒。</li>
</ul>
<hr>
<h3 id="3-只用一个进程负责-accept，其他处理连接"><a href="#3-只用一个进程负责-accept，其他处理连接" class="headerlink" title="3. 只用一个进程负责 accept，其他处理连接"></a>3. <strong>只用一个进程负责 accept，其他处理连接</strong></h3><ul>
<li>主进程专门 accept，然后将连接通过 Unix Socket 或 pipe 分发给其他 worker。</li>
<li>类似于“负载均衡器 + worker pool”。</li>
</ul>
<hr>
<h3 id="4-reuseport（Linux-3-9-）"><a href="#4-reuseport（Linux-3-9-）" class="headerlink" title="4. reuseport（Linux 3.9+）"></a>4. <strong>reuseport（Linux 3.9+）</strong></h3><ul>
<li>多进程都 bind 同一个端口，但内核进行连接负载均衡。</li>
<li>各进程各自处理连接，不共享 socket。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">setsockopt(fd, SOL_SOCKET, SO_REUSEPORT, &amp;val, <span class="hljs-keyword">sizeof</span>(val));<br></code></pre></td></tr></table></figure>
<h2 id="零拷贝是什么？"><a href="#零拷贝是什么？" class="headerlink" title="零拷贝是什么？"></a>零拷贝是什么？</h2><p>传统 IO 的工作方式，从硬盘读取数据，然后再通过网卡向外发送，我们需要进行 4 上下文切换，和 4 次数据拷贝，其中 2 次数据拷贝发生在内存里的缓冲区和对应的硬件设备之间，这个是由 DMA 完成，另外 2 次则发生在内核态和用户态之间，这个数据搬移工作是由 CPU 完成的。</p>
<p><img  src="1713775119392-03ed8749-6f4b-43f1-b3ca-005c731fd41f.png"   style="zoom:80%;" /><span class="image-caption">img</span></p>
<p>为了提高文件传输的性能，于是就出现了零拷贝技术，它通过一次系统调用（sendfile 方法）合并了磁盘读取与网络发送两个操作，降低了上下文切换次数。另外，拷贝数据都是发生在内核中的，天然就降低了数据拷贝的次数。</p>
<p><img  src="1713775083722-bd89e407-dfca-487e-83ee-1563e46f1d85.png"   style="zoom:80%;" /><span class="image-caption">img</span></p>
<p>sendfile函数在两个文件描述符之间传递数据（完全在内核中操作），从而避免了内核缓冲区和用户缓冲区之间的数据拷贝，效率很高，被称为零拷贝。函数定义为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/sendfile.h&gt;</span></span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">senfile</span><span class="hljs-params">(<span class="hljs-type">int</span> out_fd,<span class="hljs-type">int</span> in_fd,<span class="hljs-type">off_t</span>* offset,<span class="hljs-type">size_t</span> count)</span>;<br></code></pre></td></tr></table></figure>
<p><strong>in_fd必须是一个支持类似mmap函数的文件描述符，即它必须指向真实的文件，不能是socket和管道，而out_fd必须是一个socket。</strong></p>
<p>零拷贝技术的文件传输方式相比传统文件传输的方式，减少了 2 次上下文切换和数据拷贝次数，<strong>只需要 2 次上下文切换和数据拷贝次数，就可以完成文件的传输，而且 2 次的数据拷贝过程，都不需要通过 CPU，2 次都是由 DMA 来搬运。</strong></p>
<p>总体来看，<strong>零拷贝技术可以把文件传输的性能提高至少一倍以上</strong>。</p>
<h2 id="零拷贝有哪些坏处？"><a href="#零拷贝有哪些坏处？" class="headerlink" title="零拷贝有哪些坏处？"></a>零拷贝有哪些坏处？</h2><h3 id="增加系统复杂性"><a href="#增加系统复杂性" class="headerlink" title="增加系统复杂性"></a>增加系统复杂性</h3><p><strong>🔍 原因：</strong></p>
<ul>
<li>使用零拷贝往往要跳过用户空间的缓冲逻辑，靠内核直接搬运；</li>
<li>程序中不能直接“<strong>看到/修改</strong>”正在传输的数据；</li>
<li>必须重新设计：应用逻辑不再处理字节流，而只处理传输动作。</li>
</ul>
<p><strong>💥 后果：</strong></p>
<p>开发更复杂，调试更困难；</p>
<p>不适合需要<strong>修改数据内容</strong>的场景（如 HTTP gzip压缩、加密等）。</p>
<h3 id="缓冲控制能力下降"><a href="#缓冲控制能力下降" class="headerlink" title="缓冲控制能力下降"></a>缓冲控制能力下降</h3><p><strong>🔍 原因：</strong></p>
<ul>
<li>零拷贝数据不会进入用户空间内存；</li>
<li>应用层<strong>看不到 buffer 的真实状态</strong>，难以控制其生命周期。</li>
</ul>
<p><strong>💥 后果：</strong></p>
<ul>
<li>对数据生命周期、流控（Flow Control）管理不灵；</li>
<li>很难与业务缓存、对象池等机制协同。</li>
</ul>
<h3 id="不支持数据加工（无法中间处理）"><a href="#不支持数据加工（无法中间处理）" class="headerlink" title="不支持数据加工（无法中间处理）"></a>不支持数据加工（无法中间处理）</h3><p><strong>🔍 原因：</strong></p>
<ul>
<li>零拷贝数据不会真正经过用户程序；</li>
<li>例如 <code>sendfile()</code>：直接从文件拷贝到 socket，用户程序无法插入压缩、加密逻辑。</li>
</ul>
<p><strong>💥 后果：</strong></p>
<ul>
<li><strong>数据不可变</strong>；</li>
<li>必须借助其他 I/O 手段（如 mmap + copy）来实现“边传边处理”。</li>
</ul>
<h3 id="零拷贝可能导致内核资源消耗上升"><a href="#零拷贝可能导致内核资源消耗上升" class="headerlink" title="零拷贝可能导致内核资源消耗上升"></a>零拷贝可能导致内核资源消耗上升</h3><p><code>sendfile()</code> 会增加 <strong>页缓存（page cache）压力</strong>；</p>
<p>如果发送数据速度过快，可能导致<strong>socket buffer 占满、内存水位升高</strong>；</p>
<p>零拷贝不当控制还可能导致<strong>TCP 拥塞控制失效</strong>（比如 buffer 溢出前未 flush）。</p>
<p>回顾前面说道文件传输过程，其中第一步都是先需要先把磁盘文件数据拷贝「内核缓冲区」里，这个「内核缓冲区」实际上是<strong>磁盘高速缓存（*PageCache*）</strong>。</p>
<p>由于零拷贝使用了 PageCache 技术，可以使得零拷贝进一步提升了性能，我们接下来看看 PageCache 是如何做到这一点的。</p>
<p>读写磁盘相比读写内存的速度慢太多了，所以我们应该想办法把「读写磁盘」替换成「读写内存」。于是，我们会通过 DMA 把磁盘里的数据搬运到内存里，这样就可以用读内存替换读磁盘。</p>
<p>但是，内存空间远比磁盘要小，内存注定只能拷贝磁盘里的一小部分数据。</p>
<p>那问题来了，选择哪些磁盘数据拷贝到内存呢？</p>
<p>我们都知道程序运行的时候，具有「局部性」，所以通常，刚被访问的数据在短时间内再次被访问的概率很高，于是我们可以用 <strong>PageCache 来缓存最近被访问的数据</strong>，当空间不足时淘汰最久未被访问的缓存。</p>
<p>所以，读磁盘数据的时候，优先在 PageCache 找，如果数据存在则可以直接返回；如果没有，则从磁盘中读取，然后缓存 PageCache 中。</p>
<p>还有一点，读取磁盘数据的时候，需要找到数据所在的位置，但是对于机械磁盘来说，就是通过磁头旋转到数据所在的扇区，再开始「顺序」读取数据，但是旋转磁头这个物理动作是非常耗时的，为了降低它的影响，<strong>PageCache 使用了「预读功能」</strong>。</p>
<p>比如，假设 read 方法每次只会读 <code>32 KB</code> 的字节，虽然 read 刚开始只会读 0 ～ 32 KB 的字节，但内核会把其后面的 32～64 KB 也读取到 PageCache，这样后面读取 32～64 KB 的成本就很低，如果在 32～64 KB 淘汰出 PageCache 前，进程读取到它了，收益就非常大。</p>
<p>所以，PageCache 的优点主要是两个：</p>
<ul>
<li>缓存最近被访问的数据；</li>
<li>预读功能；</li>
</ul>
<p>这两个做法，将大大提高读写磁盘的性能。</p>
<p><strong>但是，在传输大文件（GB 级别的文件）的时候，PageCache 会不起作用，那就白白浪费 DMA 多做的一次数据拷贝，造成性能的降低，即使使用了 PageCache 的零拷贝也会损失性能</strong></p>
<p>这是因为如果你有很多 GB 级别文件需要传输，每当用户访问这些大文件的时候，内核就会把它们载入 PageCache 中，于是 PageCache 空间很快被这些大文件占满。</p>
<p>另外，由于文件太大，可能某些部分的文件数据被再次访问的概率比较低，这样就会带来 2 个问题：</p>
<ul>
<li>PageCache 由于长时间被大文件占据，其他「热点」的小文件可能就无法充分使用到 PageCache，于是这样磁盘读写的性能就会下降了；</li>
<li>PageCache 中的大文件数据，由于没有享受到缓存带来的好处，但却耗费 DMA 多拷贝到 PageCache 一次；</li>
</ul>
<p>所以，针对大文件的传输，不应该使用 PageCache，也就是说不应该使用零拷贝技术，因为可能由于 PageCache 被大文件占据，而导致「热点」小文件无法利用到 PageCache，这样在高并发的环境下，会带来严重的性能问题。</p>
<h2 id="大文件传输用什么方式实现？"><a href="#大文件传输用什么方式实现？" class="headerlink" title="大文件传输用什么方式实现？"></a>大文件传输用什么方式实现？</h2><p>那针对大文件的传输，我们应该使用什么方式呢？</p>
<p>我们先来看看最初的例子，当调用 read 方法读取文件时，进程实际上会阻塞在 read 方法调用，因为要等待磁盘数据的返回，如下图：</p>
<p><img  src="阻塞 IO 的过程.png"   style="zoom: 67%;" /><span class="image-caption">img</span></p>
<p>具体过程：</p>
<ul>
<li>当调用 read 方法时，会阻塞着，此时内核会向磁盘发起 I/O 请求，磁盘收到请求后，便会寻址，当磁盘数据准备好后，就会向内核发起 I/O 中断，告知内核磁盘数据已经准备好；</li>
<li>内核收到 I/O 中断后，就将数据从磁盘控制器缓冲区拷贝到 PageCache 里；</li>
<li>最后，内核再把 PageCache 中的数据拷贝到用户缓冲区，于是 read 调用就正常返回了。</li>
</ul>
<p>对于阻塞的问题，可以用异步 I/O 来解决，它工作方式如下图：</p>
<p><img  src="异步 IO 的过程.png"   style="zoom:67%;" /><span class="image-caption">img</span></p>
<p>它把读操作分为两部分：</p>
<ul>
<li>前半部分，内核向磁盘发起读请求，但是可以<strong>不等待数据就位就可以返回</strong>，于是进程此时可以处理其他任务；</li>
<li>后半部分，当内核将磁盘中的数据拷贝到进程缓冲区后，进程将接收到内核的<strong>通知</strong>，再去处理数据；</li>
</ul>
<p>而且，我们可以发现，异步 I/O 并没有涉及到 PageCache，所以使用异步 I/O 就意味着要绕开 PageCache。</p>
<p>绕开 PageCache 的 I/O 叫直接 I/O，使用 PageCache 的 I/O 则叫缓存 I/O。通常，对于磁盘，异步 I/O 只支持直接 I/O。</p>
<p>前面也提到，大文件的传输不应该使用 PageCache，因为可能由于 PageCache 被大文件占据，而导致「热点」小文件无法利用到 PageCache。</p>
<p>于是，<strong>在高并发的场景下，针对大文件的传输的方式，应该使用「异步 I/O + 直接 I/O」来替代零拷贝技术</strong>。</p>
<p>直接 I/O 应用场景常见的两种：</p>
<ul>
<li>应用程序已经实现了磁盘数据的缓存，那么可以不需要 PageCache 再次缓存，减少额外的性能损耗。在 MySQL 数据库中，可以通过参数设置开启直接 I/O，默认是不开启；</li>
<li>传输大文件的时候，由于大文件难以命中 PageCache 缓存，而且会占满 PageCache 导致「热点」文件无法充分利用缓存，从而增大了性能开销，因此，这时应该使用直接 I/O。</li>
</ul>
<p>另外，由于直接 I/O 绕过了 PageCache，就无法享受内核的这两点的优化：</p>
<ul>
<li>内核的 I/O 调度算法会缓存尽可能多的 I/O 请求在 PageCache 中，最后「<strong>合并</strong>」成一个更大的 I/O 请求再发给磁盘，这样做是为了减少磁盘的寻址操作；</li>
<li>内核也会「<strong>预读</strong>」后续的 I/O 请求放在 PageCache 中，一样是为了减少对磁盘的操作；</li>
</ul>
<p>于是，传输大文件的时候，使用「异步 I/O + 直接 I/O」了，就可以无阻塞地读取文件了。</p>
<p>所以，传输文件的时候，我们要根据文件的大小来使用不同的方式：</p>
<ul>
<li>传输大文件的时候，使用「异步 I/O + 直接 I/O」；</li>
<li>传输小文件的时候，则使用「零拷贝技术」；</li>
</ul>
<p>在 nginx 中，我们可以用如下配置，来根据文件的大小来使用不同的方式：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><code class="hljs text">location /video/ &#123; <br>    sendfile on; <br>    aio on; <br>    directio 1024m; <br>&#125;<br></code></pre></td></tr></table></figure>
<p>当文件大小大于 <code>directio</code> 值后，使用「异步 I/O + 直接 I/O」，否则使用「零拷贝技术」。</p>
<h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><h3 id="在-Java-JVM-中的直接内存（Direct-Memory）"><a href="#在-Java-JVM-中的直接内存（Direct-Memory）" class="headerlink" title="在 Java / JVM 中的直接内存（Direct Memory）"></a>在 <strong>Java / JVM</strong> 中的直接内存（Direct Memory）</h3><p>指 <strong>不受 JVM 垃圾回收器（GC）控制</strong> 的内存；</p>
<p>使用 <code>ByteBuffer.allocateDirect()</code> 创建；</p>
<p>实际上是通过 <strong>JNI（native调用）向操作系统申请的堆外内存</strong>。</p>
<p><strong>特点</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>特性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>不占 Java 堆空间</td>
<td>不影响 GC 性能</td>
</tr>
<tr>
<td>手动释放或等待 JVM finalize</td>
<td>不受 GC 控制，需谨慎管理</td>
</tr>
<tr>
<td>适用于 I/O 场景</td>
<td>与 <code>FileChannel</code>、<code>SocketChannel</code> 配合使用效率高</td>
</tr>
</tbody>
</table>
</div>
<p><strong>作用场景</strong></p>
<ul>
<li><strong>Netty、Kafka、Hadoop 等中间件</strong>广泛使用；</li>
<li>适合<strong>零拷贝传输</strong>、减少内存复制；</li>
<li>可以减少 GC 频率，提升性能。</li>
</ul>
<p><strong>示例代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">directBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocateDirect(<span class="hljs-number">1024</span>);<br>directBuffer.put((<span class="hljs-type">byte</span>) <span class="hljs-number">0x1A</span>);<br></code></pre></td></tr></table></figure>
<p>这样申请的是<strong>堆外内存</strong>，JVM 通过 <code>Unsafe</code> 或 <code>malloc</code> 分配。</p>
<h3 id="在-操作系统-网络IO-中的直接内存（DMA-Zero-Copy）"><a href="#在-操作系统-网络IO-中的直接内存（DMA-Zero-Copy）" class="headerlink" title="在 操作系统 / 网络IO 中的直接内存（DMA / Zero-Copy）"></a>在 <strong>操作系统 / 网络IO</strong> 中的直接内存（DMA / Zero-Copy）</h3><p>指不经过 CPU 用户空间的数据传输方式；</p>
<p><strong>数据直接在 I/O 设备和内核缓冲区之间搬运</strong>，绕过用户态缓冲。</p>
<p>比如 <code>sendfile()</code>、<code>mmap()</code>、<code>splice()</code> 中用到的就是<strong>直接内存传输机制</strong>。</p>
<h3 id="直接内存-vs-常规内存对比"><a href="#直接内存-vs-常规内存对比" class="headerlink" title="直接内存 vs 常规内存对比"></a>直接内存 vs 常规内存对比</h3><div class="table-container">
<table>
<thead>
<tr>
<th>项目</th>
<th>堆内存（Heap）</th>
<th>直接内存（Direct）</th>
</tr>
</thead>
<tbody>
<tr>
<td>控制权</td>
<td>由 JVM 控制（GC）</td>
<td>操作系统控制，JVM 仅引用指针</td>
</tr>
<tr>
<td>访问方式</td>
<td>普通对象操作、数组</td>
<td>通过 <code>ByteBuffer</code> 映射</td>
</tr>
<tr>
<td>性能</td>
<td>频繁GC可能导致性能抖动</td>
<td>高效、适合高频IO</td>
</tr>
<tr>
<td>分配/释放成本</td>
<td>快速</td>
<td>相对慢（可能涉及 JNI / mmap）</td>
</tr>
</tbody>
</table>
</div>
<p><strong>直接内存不受 <code>-Xmx</code> 限制</strong>，但受 <code>-XX:MaxDirectMemorySize</code> 控制；</p>
<p>如果分配过多直接内存而不释放，可能导致 <strong>OOM（OutOfMemoryError: Direct buffer memory）</strong>；</p>
<p>直接内存不能自动回收，必须显式释放或通过 <code>Cleaner</code>。</p>
<h2 id="Netty-对直接内存的优化"><a href="#Netty-对直接内存的优化" class="headerlink" title="Netty 对直接内存的优化"></a>Netty 对直接内存的优化</h2><h3 id="使用堆外内存（DirectBuffer）"><a href="#使用堆外内存（DirectBuffer）" class="headerlink" title="使用堆外内存（DirectBuffer）"></a>使用堆外内存（DirectBuffer）</h3><ul>
<li><strong>默认就偏向使用 DirectByteBuffer</strong>（除非手动改为 heap buffer）；</li>
<li>原因：<strong>避免一次用户空间的内存复制</strong>（I/O 更快）；</li>
<li>对于 NIO 的 <code>SocketChannel.read()</code> / <code>write()</code>，<code>ByteBuffer.allocateDirect()</code> 性能更优。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">ByteBuf</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> Unpooled.directBuffer(<span class="hljs-number">1024</span>);<br></code></pre></td></tr></table></figure>
<h3 id="引入内存池（PooledByteBufAllocator）"><a href="#引入内存池（PooledByteBufAllocator）" class="headerlink" title="引入内存池（PooledByteBufAllocator）"></a>引入内存池（PooledByteBufAllocator）</h3><p>Netty 默认使用 <strong>池化分配器</strong>，它封装了类似 jemalloc 的 <strong>内存分级分配策略</strong>。</p>
<p><strong>✨ 特点：</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>特性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>避免频繁 <code>malloc</code> / <code>free</code></td>
<td>使用预分配好的大块内存</td>
</tr>
<tr>
<td>减少 GC 压力</td>
<td>内存块复用，避免频繁创建和销毁对象</td>
</tr>
<tr>
<td>线程本地缓存</td>
<td>提高线程间隔离性与分配效率</td>
</tr>
<tr>
<td>分级划分块</td>
<td>将内存分成 tiny、small、normal 三类</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p><code>PooledByteBufAllocator.DEFAULT</code> 是 Netty 的默认分配器。</p>
</blockquote>
<p><strong>📦 内存分类结构（简略）：</strong></p>
<figure class="highlight scss"><table><tr><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-attr">[Chunk]</span> (<span class="hljs-number">16</span>MB)<br>  ├─ Page (<span class="hljs-number">8</span>KB)<br>  │    ├─ SubPage (<span class="hljs-number">512</span>B ~ <span class="hljs-number">4</span>KB)<br></code></pre></td></tr></table></figure>
<ul>
<li>一个线程在需要 buffer 时，从自己的本地缓存取；</li>
<li>没有的话，就从内存池的 chunk/page 分配。</li>
</ul>
<h3 id="Recycle机制（Recycler）"><a href="#Recycle机制（Recycler）" class="headerlink" title="Recycle机制（Recycler）"></a>Recycle机制（Recycler）</h3><p>Netty 的所有 <code>ByteBuf</code> 实例并不会每次都 <code>new</code>，而是通过自定义的 <code>Recycler</code>：</p>
<ul>
<li>类似对象池（Object Pool）；</li>
<li>使用<strong>线程本地缓存</strong>；</li>
<li>减少频繁的堆内存垃圾生成；</li>
<li>适用于 <code>ByteBuf</code>、<code>ChannelHandlerContext</code>、<code>Promise</code> 等 Netty 核心对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">ByteBuf</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> PooledByteBufAllocator.DEFAULT.directBuffer(<span class="hljs-number">1024</span>);<br>...<br>buf.release(); <span class="hljs-comment">// 内部归还 recycler</span><br></code></pre></td></tr></table></figure>
<h3 id="支持对-buffer-的零拷贝处理"><a href="#支持对-buffer-的零拷贝处理" class="headerlink" title="支持对 buffer 的零拷贝处理"></a>支持对 buffer 的零拷贝处理</h3><p>Netty 提供了多个 <strong>组合型 buffer</strong> 操作，进一步减少数据复制：</p>
<p><strong>🧩 组合 Buffer（CompositeByteBuf）：</strong></p>
<ul>
<li>多个 <code>ByteBuf</code> 合成一个逻辑缓冲区；</li>
<li>避免为了拼接数据而手动 copy；</li>
<li>底层数据仍存在多个内存块中，但逻辑上视为一个整体。</li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">CompositeByteBuf compositeBuf = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Unpooled</span>.</span></span>composite<span class="hljs-constructor">Buffer()</span>;<br>compositeBuf.add<span class="hljs-constructor">Components(<span class="hljs-params">buf1</span>, <span class="hljs-params">buf2</span>)</span>;<br></code></pre></td></tr></table></figure>
<h3 id="手动释放-DirectBuffer"><a href="#手动释放-DirectBuffer" class="headerlink" title="手动释放 DirectBuffer"></a>手动释放 DirectBuffer</h3><p>Netty 使用了 <code>ReferenceCounted</code> 接口管理内存引用计数：</p>
<ul>
<li>每个 <code>ByteBuf</code> 都可以调用 <code>retain()</code> / <code>release()</code>；</li>
<li>防止内存泄漏（尤其是直接内存）；</li>
<li>支持引用计数的 buffer 只在没有引用后才回收。</li>
</ul>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">buf.retain();   <span class="hljs-regexp">//</span> +<span class="hljs-number">1</span><br>buf.release();  <span class="hljs-regexp">//</span> -<span class="hljs-number">1</span>，到<span class="hljs-number">0</span>就释放<br></code></pre></td></tr></table></figure>
<p>📌 所有 handler、codec、pipeline 操作都要求你在 buffer 使用后记得释放。</p>
<h2 id="Netty中直接内存的内存池分配算法"><a href="#Netty中直接内存的内存池分配算法" class="headerlink" title="Netty中直接内存的内存池分配算法"></a>Netty中直接内存的内存池分配算法</h2><p>Netty 中的直接内存池分配算法是其高性能架构的核心组成部分之一。它参考了 <code>jemalloc</code> 的思想，构建了一套适用于网络通信场景的分级内存管理机制。</p>
<p>所有内存管理逻辑由类 <code>PooledByteBufAllocator</code> 驱动，底层通过 <code>PoolArena</code>、<code>PoolChunk</code>、<code>PoolSubpage</code> 来组织内存。</p>
<h3 id="分配器结构层级"><a href="#分配器结构层级" class="headerlink" title="分配器结构层级"></a>分配器结构层级</h3><figure class="highlight coq"><table><tr><td class="code"><pre><code class="hljs coq">PooledByteBufAllocator<br> ├── PoolArena （<span class="hljs-keyword">Heap</span>/Direct 分别维护）<br>      ├── PoolChunkList[]（多级链表）<br>          ├── PoolChunk（大块内存）<br>              ├── Page（内存页，固定大小）<br>                  ├── Subpage（小块内存的分配单元）<br></code></pre></td></tr></table></figure>
<p>每个线程会绑定一个 <strong>ThreadCache</strong>，优先从本地 cache 取块。</p>
<h3 id="内存划分粒度"><a href="#内存划分粒度" class="headerlink" title="内存划分粒度"></a>内存划分粒度</h3><p>Netty 采用 <strong>分级粒度策略</strong> 分配不同大小的数据块：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>内存类型</th>
<th>大小范围</th>
<th>分配结构</th>
</tr>
</thead>
<tbody>
<tr>
<td>tiny</td>
<td>&lt; 512 B</td>
<td>Subpage</td>
</tr>
<tr>
<td>small</td>
<td>512 B ~ page size</td>
<td>Subpage</td>
</tr>
<tr>
<td>normal</td>
<td>page size ~ chunk</td>
<td>从 PoolChunk 分配页</td>
</tr>
<tr>
<td>huge</td>
<td>&gt; chunk</td>
<td>直接 <code>malloc</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="分配算法逻辑：分配一个-1024-字节的-direct-buffer"><a href="#分配算法逻辑：分配一个-1024-字节的-direct-buffer" class="headerlink" title="分配算法逻辑：分配一个 1024 字节的 direct buffer"></a>分配算法逻辑：分配一个 1024 字节的 direct buffer</h3><h4 id="步骤-1：选择-Arena"><a href="#步骤-1：选择-Arena" class="headerlink" title="步骤 1：选择 Arena"></a>步骤 1：选择 Arena</h4><ul>
<li>Netty 初始化时分配多个 <code>PoolArena</code> 实例（CPU 核心数相关）；</li>
<li>当前线程绑定一个 <code>PoolThreadCache</code>，指向一个 Arena。</li>
</ul>
<h4 id="步骤-2：决定分配类型"><a href="#步骤-2：决定分配类型" class="headerlink" title="步骤 2：决定分配类型"></a>步骤 2：决定分配类型</h4><ul>
<li>1024B 属于 <code>small</code>；</li>
<li>使用 <code>PoolSubpage</code> 管理。</li>
</ul>
<h4 id="步骤-3：从-Subpage-bitmap-中找可用槽位"><a href="#步骤-3：从-Subpage-bitmap-中找可用槽位" class="headerlink" title="步骤 3：从 Subpage bitmap 中找可用槽位"></a>步骤 3：从 Subpage bitmap 中找可用槽位</h4><ul>
<li>每个 Subpage 会维护一个 <strong>位图 bitmap</strong>；</li>
<li>找到第一个可用 bit（0 表示可用）；</li>
<li>标记为已用，返回该内存块。</li>
</ul>
<h4 id="步骤-4：记录引用计数"><a href="#步骤-4：记录引用计数" class="headerlink" title="步骤 4：记录引用计数"></a>步骤 4：记录引用计数</h4><ul>
<li>返回的是 <code>PooledByteBuf</code>；</li>
<li>带有引用计数机制 <code>refCnt</code>；</li>
<li>默认是 <code>1</code>，使用完必须调用 <code>.release()</code> 回收。</li>
</ul>
<h3 id="释放内存算法"><a href="#释放内存算法" class="headerlink" title="释放内存算法"></a>释放内存算法</h3><figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">buf.release()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>
<p>释放逻辑：</p>
<ol>
<li>将引用计数 <code>refCnt - 1</code>；</li>
<li>若为 0，则归还该槽位（重置 bitmap）；</li>
<li>如果页全部空闲，可能将 chunk 回收。</li>
</ol>
<h3 id="chunk-复用机制（PoolChunkList）"><a href="#chunk-复用机制（PoolChunkList）" class="headerlink" title="chunk 复用机制（PoolChunkList）"></a>chunk 复用机制（PoolChunkList）</h3><p>Netty 设计了一组 <code>PoolChunkList</code>，表示 chunk 的<strong>使用率区间</strong>：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>ChunkList 名称</th>
<th>使用率区间</th>
</tr>
</thead>
<tbody>
<tr>
<td>qInit</td>
<td>0–25%</td>
</tr>
<tr>
<td>q000</td>
<td>1–50%</td>
</tr>
<tr>
<td>q025</td>
<td>25–75%</td>
</tr>
<tr>
<td>q050</td>
<td>50–100%</td>
</tr>
<tr>
<td>q075, q100</td>
<td>75%+，完全使用</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>每次分配时优先从低使用率的 chunk 取；</li>
<li>回收后 chunk 会移动到新的列表中。</li>
</ul>
<p>这样做的好处是 <strong>避免碎片化和提升重用率</strong>。</p>
<h3 id="直接内存的申请实现（unsafe-malloc）"><a href="#直接内存的申请实现（unsafe-malloc）" class="headerlink" title="直接内存的申请实现（unsafe + malloc）"></a>直接内存的申请实现（unsafe + malloc）</h3><p>对于 DirectBuffer 的底层分配方式：</p>
<ul>
<li>使用 <code>PlatformDependent.allocateDirectNoCleaner()</code>；</li>
<li>内部使用 <code>sun.misc.Unsafe.allocateMemory()</code> 或 <code>malloc()</code>；</li>
<li>避免 Java 的 <code>Cleaner</code> 延迟释放带来的 OOM 风险。</li>
</ul>
<h3 id="内存泄露与检测机制"><a href="#内存泄露与检测机制" class="headerlink" title="内存泄露与检测机制"></a>内存泄露与检测机制</h3><p>Netty 提供 <code>ResourceLeakDetector</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">ResourceLeakDetector.setLevel(ADVANCED);<br></code></pre></td></tr></table></figure>
<p>可在泄露未释放的 <code>ByteBuf</code> 时抛出日志警告，包括使用栈跟踪。</p>
<h2 id="为什么-Netty-绕开-GC，自建内存管理？"><a href="#为什么-Netty-绕开-GC，自建内存管理？" class="headerlink" title="为什么 Netty 绕开 GC，自建内存管理？"></a>为什么 Netty 绕开 GC，自建内存管理？</h2><h3 id="JVM-GC-不适合管理网络-IO-缓冲区"><a href="#JVM-GC-不适合管理网络-IO-缓冲区" class="headerlink" title="JVM GC 不适合管理网络 IO 缓冲区"></a><strong>JVM GC 不适合管理网络 IO 缓冲区</strong></h3><p>在高并发网络服务中，会频繁创建/释放短生命周期的 <code>ByteBuffer</code> 对象（如：每个连接、请求、消息都需要 buffer）。</p>
<p>但：</p>
<ul>
<li>Java 的 GC（尤其是 Full GC）可能延迟回收这些 buffer；</li>
<li>大量临时 buffer 会在老年代堆积，触发 <strong>Stop-The-World GC</strong>；</li>
<li>导致系统抖动、延迟跳升、吞吐下降（GC 暴击）💣。</li>
</ul>
<h3 id="堆外内存更适合-Zero-Copy-DMA"><a href="#堆外内存更适合-Zero-Copy-DMA" class="headerlink" title="堆外内存更适合 Zero-Copy / DMA"></a><strong>堆外内存更适合 Zero-Copy / DMA</strong></h3><ul>
<li><code>HeapByteBuffer</code> 在底层写入 socket 时，仍需拷贝到直接内核缓冲区；</li>
<li>而 <code>DirectByteBuffer</code> 则可直接用于 <code>write()</code> / <code>sendfile()</code>；</li>
<li>Netty 使用堆外内存可以更好地配合 Linux 的 <strong>零拷贝（zero-copy）机制</strong>，显著减少性能损耗。</li>
</ul>
<h3 id="Netty-自建内存池做了什么？"><a href="#Netty-自建内存池做了什么？" class="headerlink" title="Netty 自建内存池做了什么？"></a>Netty 自建内存池做了什么？</h3><div class="table-container">
<table>
<thead>
<tr>
<th>能力</th>
<th>对应设计</th>
</tr>
</thead>
<tbody>
<tr>
<td>内存分配策略</td>
<td>Arena + Chunk + Page + Subpage</td>
</tr>
<tr>
<td>内存回收机制</td>
<td>引用计数 + recycler 对象池</td>
</tr>
<tr>
<td>内存复用机制</td>
<td>ThreadLocal 缓存 + PoolChunkList</td>
</tr>
<tr>
<td>分配性能优化</td>
<td>位图分配 + page 大块申请</td>
</tr>
<tr>
<td>内存泄露检测</td>
<td>ResourceLeakDetector</td>
</tr>
</tbody>
</table>
</div>
<h2 id="Paxos"><a href="#Paxos" class="headerlink" title="Paxos"></a>Paxos</h2><p>Paxos 是一个 <strong>CP 系统（Consistent and Partition-tolerant）</strong>，根据 <strong>CAP 理论</strong> 的划分，它<strong>强调一致性</strong>，<strong>容忍分区故障</strong>，<strong>牺牲可用性</strong>。</p>
<h2 id="Protobuf"><a href="#Protobuf" class="headerlink" title="Protobuf"></a>Protobuf</h2><p>由 Google 开发的<strong>高效、灵活、跨语言的序列化协议</strong>，常用于分布式系统中的通信数据格式（比如微服务、RPC、消息队列、配置文件等场景）。它是 JSON、XML 的更高性能替代品。</p>
<p><strong>IDL（接口描述语言）</strong>：用于定义数据结构</p>
<p><strong>序列化工具</strong>：将结构转成紧凑的二进制格式，用于网络传输或存储</p>
<p>由 <code>.proto</code> 文件描述数据结构，通过编译器 <code>protoc</code> 生成代码，支持多种语言如 Java、C++、Python、Go、C# 等。</p>
<h3 id="Protobuf-编码方式"><a href="#Protobuf-编码方式" class="headerlink" title="Protobuf 编码方式"></a>Protobuf 编码方式</h3><p>编码是<strong>紧凑的二进制格式</strong>，体积远小于 JSON/XML；</p>
<p>使用 <strong>Varint 编码</strong>：整数按大小自适应压缩；</p>
<p>字段顺序不影响编码，但<strong>字段编号必须稳定</strong>；</p>
<p>字段以 <code>&lt;field_number + wire_type&gt;</code> 头 + 内容方式编码，便于跳过未知字段。</p>
<h3 id="Protobuf-的版本兼容性"><a href="#Protobuf-的版本兼容性" class="headerlink" title="Protobuf 的版本兼容性"></a>Protobuf 的版本兼容性</h3><p><strong>向后兼容（new → old）：</strong></p>
<ul>
<li><strong>新增字段</strong>：老代码忽略（跳过未知字段）</li>
<li><strong>删除字段</strong>：只要字段编号不重复，可安全删除</li>
</ul>
<p><strong>向前兼容（old → new）：</strong></p>
<ul>
<li>解码旧数据，<strong>新字段会使用默认值</strong></li>
<li>不影响使用，但新特性会失效</li>
</ul>
<h3 id="破坏兼容性的操作"><a href="#破坏兼容性的操作" class="headerlink" title="破坏兼容性的操作"></a>破坏兼容性的操作</h3><div class="table-container">
<table>
<thead>
<tr>
<th>动作</th>
<th>是否兼容</th>
<th>原因</th>
</tr>
</thead>
<tbody>
<tr>
<td>❌ 修改字段编号</td>
<td>❌ 否</td>
<td>编码/解码不匹配</td>
</tr>
<tr>
<td>❌ 修改字段类型</td>
<td>❌ 否</td>
<td>类型不一致导致数据解析错误</td>
</tr>
<tr>
<td>✅ 添加字段</td>
<td>✅ 是</td>
<td>可被新版本解析，旧版本忽略</td>
</tr>
<tr>
<td>✅ 弃用字段（不删除）</td>
<td>✅ 是</td>
<td>使用 <code>reserved</code> 保留编号或字段名</td>
</tr>
</tbody>
</table>
</div>
<h2 id="优化-RPC-框架的思路"><a href="#优化-RPC-框架的思路" class="headerlink" title="优化 RPC 框架的思路"></a>优化 RPC 框架的思路</h2><h3 id="通信层优化"><a href="#通信层优化" class="headerlink" title="通信层优化"></a>通信层优化</h3><p><strong>1. 使用高效的 IO 模型</strong></p>
<ul>
<li>使用 <strong>异步非阻塞 I/O</strong>（如 Netty、epoll/kqueue）</li>
<li>使用 <strong>连接复用</strong>（共享 TCP 长连接，避免三次握手频繁开销）</li>
<li>合理配置 <strong>线程模型（boss/worker/event loop）</strong></li>
</ul>
<p><strong>2. 支持压缩 &amp; 零拷贝</strong></p>
<ul>
<li>压缩请求/响应体（如 GZIP、LZ4、Snappy）</li>
<li>利用 <code>sendfile</code> / Netty <code>DirectByteBuf</code> 实现 <strong>zero-copy</strong></li>
</ul>
<p><strong>3. 减少网络交互轮次</strong></p>
<ul>
<li>尽量合并请求（如批量发送、流水线/pipelining）</li>
<li>减少连接握手：Keep-Alive + 连接池管理</li>
</ul>
<h3 id="编解码层优化"><a href="#编解码层优化" class="headerlink" title="编解码层优化"></a>编解码层优化</h3><p><strong>1. 使用高性能序列化协议</strong></p>
<ul>
<li>替换 JSON/XML 为：Protobuf、Avro、Thrift、Kryo、MsgPack</li>
<li>序列化字段编号稳定、支持版本演进</li>
</ul>
<p><strong>2. 减少冗余字段 / 支持 schema</strong></p>
<ul>
<li>让协议“瘦身”，只传必要数据</li>
<li>如果能共享 schema，可以只传字段值，提升传输效率</li>
</ul>
<p><strong>3.优化内存管理</strong></p>
<ul>
<li>编解码使用 <strong>对象池（ObjectPool）</strong></li>
<li>buffer 重用（如 Netty 的 PooledByteBuf）</li>
</ul>
<h3 id="线程-调度优化"><a href="#线程-调度优化" class="headerlink" title="线程/调度优化"></a>线程/调度优化</h3><p><strong>1. 分离业务线程与 IO 线程</strong></p>
<ul>
<li>避免业务阻塞影响 IO 接收；</li>
<li>使用线程池处理 handler/request，支持线程隔离。</li>
</ul>
<p><strong>2. Reactor + Callback 模式</strong></p>
<ul>
<li>提高并发模型伸缩性；</li>
<li>避免线程阻塞，适配异步非阻塞通信。</li>
</ul>
<p><strong>3. 请求限流 / 拒绝策略</strong></p>
<ul>
<li>每个服务/方法配置 QPS 上限，防止雪崩；</li>
<li>提供 <code>FailFast</code>、<code>FailOver</code>、<code>FailSafe</code> 等调用策略。</li>
</ul>
<h3 id="容错与高可用机制（可用性是关键）"><a href="#容错与高可用机制（可用性是关键）" class="headerlink" title="容错与高可用机制（可用性是关键）"></a>容错与高可用机制（可用性是关键）</h3><p><strong>1. 服务注册与发现</strong></p>
<ul>
<li>支持注册中心（如 ZooKeeper、etcd、Consul）；</li>
<li>支持自动健康检查、实例动态上下线。</li>
</ul>
<p><strong>2. 超时控制与重试机制</strong></p>
<ul>
<li>每个 RPC 方法配置超时时间；</li>
<li>智能重试（避免幂等操作带来的数据一致性风险）；</li>
<li>超时后快速 failover，防止级联阻塞。</li>
</ul>
<p><strong>3. 熔断 + 限流 + 降级</strong></p>
<ul>
<li>借助 Hystrix、Sentinel 等组件；</li>
<li>防止服务间依赖传播故障；</li>
<li>降级策略兜底响应。</li>
</ul>
<h3 id="扩展性和服务治理"><a href="#扩展性和服务治理" class="headerlink" title="扩展性和服务治理"></a>扩展性和服务治理</h3><p><strong>1. 支持多协议栈（可插拔）</strong></p>
<ul>
<li>抽象统一协议层，可支持 HTTP、gRPC、自定义 TCP 协议等；</li>
<li>使用 SPI 插件机制支持动态扩展。</li>
</ul>
<p><strong>2. 服务路由与动态配置</strong></p>
<ul>
<li>按标签、权重、版本、地域路由；</li>
<li>支持热更新配置中心（如 Nacos）控制参数。</li>
</ul>
<p><strong>3. 服务监控与追踪</strong></p>
<ul>
<li>埋点上报调用链（TraceId、SpanId）；</li>
<li>集成 Zipkin、Skywalking、Prometheus；</li>
<li>支持慢调用统计、异常码汇总、QPS/RT 监控。</li>
</ul>
<h2 id="动态代理中的优化"><a href="#动态代理中的优化" class="headerlink" title="动态代理中的优化"></a>动态代理中的优化</h2><h3 id="为什么要优化动态代理？"><a href="#为什么要优化动态代理？" class="headerlink" title="为什么要优化动态代理？"></a>为什么要优化动态代理？</h3><p>动态代理本质上是通过<strong>在运行时生成代理类</strong>来插入额外逻辑（如日志、鉴权、序列化等），<strong>但它带来的性能开销主要来自</strong>：</p>
<ul>
<li>反射调用开销</li>
<li>字节码生成/加载成本</li>
<li>频繁代理链导致堆栈复杂</li>
<li>可读性 &amp; 可调试性下降</li>
</ul>
<h3 id="动态代理的优化思路大全"><a href="#动态代理的优化思路大全" class="headerlink" title="动态代理的优化思路大全"></a>动态代理的优化思路大全</h3><p><strong>动态代理的优化本质是“绕开反射 + 缓存生成 + 降低开销”</strong>，在性能敏感场景下选用 ByteBuddy、LambdaFactory、代码生成等技术，是关键手段。</p>
<h4 id="选择合适的代理实现方式"><a href="#选择合适的代理实现方式" class="headerlink" title="选择合适的代理实现方式"></a>选择合适的代理实现方式</h4><div class="table-container">
<table>
<thead>
<tr>
<th>技术</th>
<th>性能表现</th>
<th>是否支持接口代理</th>
<th>是否支持类代理</th>
</tr>
</thead>
<tbody>
<tr>
<td>JDK Proxy</td>
<td>较慢</td>
<td>✅ 是</td>
<td>❌ 否</td>
</tr>
<tr>
<td>CGLIB</td>
<td>快</td>
<td>✅ 是</td>
<td>✅ 是</td>
</tr>
<tr>
<td>ByteBuddy</td>
<td>最快/最灵活</td>
<td>✅ 是</td>
<td>✅ 是</td>
</tr>
<tr>
<td>ASM</td>
<td>原始字节码</td>
<td>✅ 是</td>
<td>✅ 是</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>如果你代理的是接口：可以先用 JDK Proxy；</li>
<li>如果你代理的是类（如 RPC 框架的调用器）：<strong>建议用 CGLIB 或 ByteBuddy</strong>；</li>
<li><strong>性能极致场景</strong>（如大规模代理类）：可以用 ByteBuddy + 缓存机制。</li>
</ul>
<h4 id="避免反射调用，使用-MethodHandle-LambdaMetafactory"><a href="#避免反射调用，使用-MethodHandle-LambdaMetafactory" class="headerlink" title="避免反射调用，使用 MethodHandle / LambdaMetafactory"></a>避免反射调用，使用 MethodHandle / LambdaMetafactory</h4><p>JDK Proxy 默认使用 <code>Method.invoke()</code>，效率较低，可优化为：</p>
<ul>
<li><strong>MethodHandle</strong>（JDK 7+）：更接近原生调用的性能；</li>
<li><strong>LambdaMetafactory</strong>（JDK 8+）：生成类似 <code>lambda</code> 的代理，<strong>性能接近手写代码！</strong></li>
</ul>
<p><strong>示例：替换反射为 lambda 调用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">CallSite</span> <span class="hljs-variable">site</span> <span class="hljs-operator">=</span> LambdaMetafactory.metafactory(...);<br><span class="hljs-type">MethodHandle</span> <span class="hljs-variable">handle</span> <span class="hljs-operator">=</span> site.getTarget();<br>handle.invoke(...);<br></code></pre></td></tr></table></figure>
<p>✅ 适用于高频调用的代理方法（如 RPC Stub）。</p>
<h4 id="代理类生成做缓存"><a href="#代理类生成做缓存" class="headerlink" title="代理类生成做缓存"></a>代理类生成做缓存</h4><p>动态代理生成的类本质上是<strong>运行时的 Class 文件</strong>，每次生成都很耗资源。</p>
<p><strong>优化策略：</strong></p>
<ul>
<li>对 <strong>相同的接口 + handler 逻辑</strong> 缓存代理类；</li>
<li>使用类似 Guava Cache / LRU Cache 来避免重复生成；</li>
<li><strong>ByteBuddy 有 built-in 缓存机制</strong>，利用 <code>TypeCache</code>。</li>
</ul>
<h4 id="减少代理链层级-精简-AOP-切面"><a href="#减少代理链层级-精简-AOP-切面" class="headerlink" title="减少代理链层级 / 精简 AOP 切面"></a>减少代理链层级 / 精简 AOP 切面</h4><p>在 AOP 或 Filter 链场景中，代理链太深会：</p>
<ul>
<li>增加堆栈深度；</li>
<li>导致性能下降；</li>
<li>调试困难。</li>
</ul>
<p><strong>优化建议：</strong></p>
<ul>
<li>合并多个代理为一个逻辑代理；</li>
<li>使用统一入口（如 Spring 的 Advisor 合并优化）；</li>
<li>动态判断是否需要进入代理（如条件判断 + fast path）；</li>
</ul>
<h4 id="动态代理异步化（适用于RPC）"><a href="#动态代理异步化（适用于RPC）" class="headerlink" title="动态代理异步化（适用于RPC）"></a>动态代理异步化（适用于RPC）</h4><p>如果你在 RPC 框架中用代理做方法拦截，考虑加入：</p>
<ul>
<li><strong>异步化执行：Future/CompletableFuture</strong></li>
<li><strong>响应式模型</strong>（如返回 <code>Mono&lt;T&gt;</code> 或 <code>RxJava</code>）</li>
<li>这样可以<strong>减少阻塞等待</strong>，提升整体并发能力</li>
</ul>
<h4 id="代码生成替代反射（提前静态生成-Stub）"><a href="#代码生成替代反射（提前静态生成-Stub）" class="headerlink" title="代码生成替代反射（提前静态生成 Stub）"></a>代码生成替代反射（提前静态生成 Stub）</h4><p>在一些性能敏感场景（RPC、数据库 ORM），你可以直接：</p>
<ul>
<li>提前生成代理类（代码生成）；</li>
<li>或在编译期用注解处理器（APT）生成代码；</li>
<li>替换运行时动态生成逻辑。</li>
</ul>
<p>比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">MyServiceProxy</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyServiceProxyImpl</span>(); <span class="hljs-comment">// 编译期生成的类</span><br></code></pre></td></tr></table></figure>
<p>这会 <strong>显著优于运行时动态代理</strong>，且易于调试。</p>
<h3 id="Bonus：不同框架的动态代理技术栈对比"><a href="#Bonus：不同框架的动态代理技术栈对比" class="headerlink" title="Bonus：不同框架的动态代理技术栈对比"></a>Bonus：不同框架的动态代理技术栈对比</h3><div class="table-container">
<table>
<thead>
<tr>
<th>框架</th>
<th>代理实现</th>
<th>是否缓存生成类</th>
<th>是否优化调用方式</th>
</tr>
</thead>
<tbody>
<tr>
<td>Spring AOP</td>
<td>JDK Proxy / CGLIB</td>
<td>✅ 是</td>
<td>❌ 基本用反射</td>
</tr>
<tr>
<td>Dubbo</td>
<td>Javassist / ASM</td>
<td>✅ 是</td>
<td>✅ 支持 FastInvoke</td>
</tr>
<tr>
<td>Netty RPC</td>
<td>通常是动态代码生成</td>
<td>✅</td>
<td>✅ 支持 lambda</td>
</tr>
<tr>
<td>gRPC</td>
<td>纯代码生成 stub</td>
<td>✅</td>
<td>✅ 高性能手写</td>
</tr>
</tbody>
</table>
</div>
<h1 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h1><h2 id="执行一条-select-语句，期间发生了什么？"><a href="#执行一条-select-语句，期间发生了什么？" class="headerlink" title="执行一条 select 语句，期间发生了什么？"></a>执行一条 select 语句，期间发生了什么？</h2><ol>
<li>连接器：建立连接，管理连接、校验用户身份；</li>
<li>查询缓存：查询语句如果命中查询缓存则直接返回，否则继续往下执行。MySQL 8.0 已删除该模块；</li>
<li>解析 SQL，通过解析器对 SQL 查询语句进行词法分析、语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型；</li>
<li>执行 SQL：执行 SQL 共有三个阶段：<ul>
<li>预处理阶段：检查表或字段是否存在；将 <code>select *</code> 中的 <code>*</code> 符号扩展为表上的所有列。</li>
<li>优化阶段：基于查询成本的考虑， 选择查询成本最小的执行计划；</li>
<li>执行阶段：根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端；</li>
</ul>
</li>
</ol>
<p>MySQL 的架构共分为两层：<strong>Server 层和存储引擎层</strong></p>
<ul>
<li><strong>Server 层负责建立连接、分析和执行 SQL</strong>。MySQL 大多数的核心功能模块都在这实现，主要包括连接器，查询缓存、解析器、预处理器、优化器、执行器等。另外，所有的内置函数（如日期、时间、数学和加密函数等）和所有跨存储引擎的功能（如存储过程、触发器、视图等。）都在 Server 层实现。</li>
<li><strong>存储引擎层负责数据的存储和提取</strong>。支持 InnoDB、MyISAM、Memory 等多个存储引擎，不同的存储引擎共用一个 Server 层。现在最常用的存储引擎是 InnoDB，从 MySQL 5.5 版本开始， InnoDB 成为了 MySQL 的默认存储引擎。我们常说的索引数据结构，就是由存储引擎层实现的，不同的存储引擎支持的索引类型也不相同，比如 InnoDB 支持索引类型是 B+树 ，且是默认使用，也就是说在数据表中创建的主键索引和二级索引默认使用的是 B+ 树索引。</li>
</ul>
<h3 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h3><ol>
<li>身份验证<ol>
<li>与客户端进行 TCP 三次握手建立连接；</li>
<li>校验客户端的用户名和密码，如果用户名或密码不对，则会报错；</li>
<li>如果用户名和密码都对了，会读取该用户的权限，然后后面的权限逻辑判断都基于此时读取到的权限；</li>
</ol>
</li>
<li>长连接占用内存：<strong>定期断开长连接</strong>。或<strong>客户端主动重置连接</strong></li>
</ol>
<h3 id="解析-SQL"><a href="#解析-SQL" class="headerlink" title="解析 SQL"></a>解析 SQL</h3><p><strong>词法分析</strong>：MySQL 会根据你输入的字符串识别出关键字出来。</p>
<p><strong>语法分析</strong>：根据词法分析的结果，语法解析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法，如果没问题就会构建出 SQL 语法树，这样方便后面模块获取 SQL 类型、表名、字段名、 where 条件等等。</p>
<h3 id="执行-SQL"><a href="#执行-SQL" class="headerlink" title="执行 SQL"></a>执行 SQL</h3><ul>
<li>prepare 阶段，也就是预处理阶段；</li>
<li>optimize 阶段，也就是优化阶段；</li>
<li>execute 阶段，也就是执行阶段；</li>
</ul>
<h4 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h4><ul>
<li>检查 SQL 查询语句中的表或者字段是否存在；</li>
<li>将 <code>select *</code> 中的 <code>*</code> 符号，扩展为表上的所有列；</li>
</ul>
<h4 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h4><p><strong>优化器主要负责将 SQL 查询语句的执行方案确定下来</strong>，比如在表里面有多个索引的时候，优化器会基于查询成本的考虑，来决定选择使用哪个索引。</p>
<h4 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h4><ul>
<li>主键索引查询</li>
<li>全表扫描</li>
<li>索引下推</li>
</ul>
<h5 id="主键索引查询"><a href="#主键索引查询" class="headerlink" title="主键索引查询"></a>主键索引查询</h5><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> product <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>
<p>这条查询语句的查询条件用到了主键索引，而且是等值查询，同时主键 id 是唯一，不会有 id 相同的记录，所以优化器决定选用访问类型为 const 进行查询，也就是使用主键索引查询一条记录，那么执行器与存储引擎的执行流程是这样的：</p>
<ul>
<li>执行器第一次查询，会调用 read_first_record 函数指针指向的函数，因为优化器选择的访问类型为 const，这个函数指针被指向为 InnoDB 引擎索引查询的接口，把条件 <code>id = 1</code> 交给存储引擎，<strong>让存储引擎定位符合条件的第一条记录</strong>。</li>
<li>存储引擎通过主键索引的 B+ 树结构定位到 id = 1的第一条记录，如果记录是不存在的，就会向执行器上报记录找不到的错误，然后查询结束。如果记录是存在的，就会将记录返回给执行器；</li>
<li>执行器从存储引擎读到记录后，接着判断记录是否符合查询条件，如果符合则发送给客户端，如果不符合则跳过该记录。</li>
<li>执行器查询的过程是一个 while 循环，所以还会再查一次，但是这次因为不是第一次查询了，所以会调用 read_record 函数指针指向的函数，因为优化器选择的访问类型为 const，这个函数指针被指向为一个永远返回 - 1 的函数，所以当调用该函数的时候，执行器就退出循环，也就是结束查询了。</li>
</ul>
<h5 id="全表扫描"><a href="#全表扫描" class="headerlink" title="全表扫描"></a>全表扫描</h5><p>举个全表扫描的例子：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><code class="hljs text">select * from product where name = &#x27;iphone&#x27;;<br></code></pre></td></tr></table></figure>
<p>这条查询语句的查询条件没有用到索引，所以优化器决定选用访问类型为 ALL 进行查询，也就是全表扫描的方式查询，那么这时执行器与存储引擎的执行流程是这样的：</p>
<ul>
<li>执行器第一次查询，会调用 read_first_record 函数指针指向的函数，因为优化器选择的访问类型为 all，这个函数指针被指向为 InnoDB 引擎全扫描的接口，<strong>让存储引擎读取表中的第一条记录</strong>；</li>
<li>执行器会判断读到的这条记录的 name 是不是 iphone，如果不是则跳过；如果是则将记录发给客户的（是的没错，Server 层每从存储引擎读到一条记录就会发送给客户端，之所以客户端显示的时候是直接显示所有记录的，是因为客户端是等查询语句查询完成后，才会显示出所有的记录）。</li>
<li>执行器查询的过程是一个 while 循环，所以还会再查一次，会调用 read_record 函数指针指向的函数，因为优化器选择的访问类型为 all，read_record 函数指针指向的还是 InnoDB 引擎全扫描的接口，所以接着向存储引擎层要求继续读刚才那条记录的下一条记录，存储引擎把下一条记录取出后就将其返回给执行器（Server层），执行器继续判断条件，不符合查询条件即跳过该记录，否则发送到客户端；</li>
<li>一直重复上述过程，直到存储引擎把表中的所有记录读完，然后向执行器（Server层） 返回了读取完毕的信息；</li>
<li>执行器收到存储引擎报告的查询完毕的信息，退出循环，停止查询。</li>
</ul>
<h5 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h5><p>索引下推能够减少<strong>二级索引</strong>在查询时的回表操作，提高查询的效率，因为它将 Server 层部分负责的事情，交给存储引擎层去处理了。</p>
<p>举一个具体的例子，方便大家理解，这里一张用户表如下，我对 age 和 reward 字段建立了联合索引（age，reward）：</p>
<p><img  src="/路飞表.png"  ><span class="image-caption">img</span></p>
<p>现在有下面这条查询语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t_user <span class="hljs-keyword">where</span> age <span class="hljs-operator">&gt;</span> <span class="hljs-number">20</span> <span class="hljs-keyword">and</span> reward <span class="hljs-operator">=</span> <span class="hljs-number">100000</span>;<br></code></pre></td></tr></table></figure>
<p>联合索引当遇到范围查询 (&gt;、&lt;) 就会停止匹配，也就是 <strong>age 字段能用到联合索引，但是 reward 字段则无法利用到索引</strong>。</p>
<p>使用索引下推后，判断记录的 reward 是否等于 100000 的工作交给了存储引擎层，过程如下 ：</p>
<ul>
<li>Server 层首先调用存储引擎的接口定位到满足查询条件的第一条二级索引记录，也就是定位到 age &gt; 20 的第一条记录；</li>
<li>存储引擎定位到二级索引后，<strong>先不执行回表</strong>操作，而是先判断一下该索引中包含的列（reward列）的条件（reward 是否等于 100000）是否成立。如果<strong>条件不成立</strong>，则直接<strong>跳过该二级索引</strong>。如果<strong>成立</strong>，则<strong>执行回表</strong>操作，将完成记录返回给 Server 层。</li>
<li>Server 层在判断其他的查询条件（本次查询没有其他条件）是否成立，如果成立则将其发送给客户端；否则跳过该记录，然后向存储引擎索要下一条记录。</li>
<li>如此往复，直到存储引擎把表中的所有记录读完。</li>
</ul>
<p>可以看到，使用了索引下推后，虽然 reward 列无法使用到联合索引，但是因为它包含在联合索引（age，reward）里，所以直接在存储引擎过滤出满足 reward = 100000 的记录后，才去执行回表操作获取整个记录。相比于没有使用索引下推，节省了很多回表操作。</p>
<p>当你发现执行计划里的 Extr 部分显示了 “Using index condition”，说明使用了索引下推。</p>
<h2 id="MySQL-一行记录是怎么存储的？"><a href="#MySQL-一行记录是怎么存储的？" class="headerlink" title="MySQL 一行记录是怎么存储的？"></a>MySQL 一行记录是怎么存储的？</h2><p>可以看到，共有三个文件，这三个文件分别代表着：</p>
<ul>
<li>db.opt，用来存储当前数据库的默认字符集和字符校验规则。</li>
<li>t_order.frm ，t_order 的<strong>表结构</strong>会保存在这个文件。在 MySQL 中建立一张表都会生成一个.frm 文件，该文件是用来保存每个表的元数据信息的，主要包含表结构定义。</li>
<li>t_order.ibd，t_order 的<strong>表数据</strong>会保存在这个文件。表数据既可以存在共享表空间文件（文件名：ibdata1）里，也可以存放在独占表空间文件（文件名：表名字.ibd）。这个行为是由参数 innodb_file_per_table 控制的，若设置了参数 innodb_file_per_table 为 1，则会将存储的数据、索引等信息单独存储在一个独占表空间，从 MySQL 5.6.6 版本开始，它的默认值就是 1 了，因此从这个版本之后， MySQL 中每一张表的数据都存放在一个独立的 .ibd 文件。</li>
</ul>
<p>好了，现在我们知道了一张数据库表的数据是保存在「 表名字.ibd 」的文件里的，这个文件也称为独占表空间文件。</p>
<h3 id="表空间文件的结构是怎么样的？"><a href="#表空间文件的结构是怎么样的？" class="headerlink" title="表空间文件的结构是怎么样的？"></a>表空间文件的结构是怎么样的？</h3><p><strong>表空间由段（segment）、区（extent）、页（page）、行（row）组成</strong>，InnoDB存储引擎的逻辑存储结构大致如下图：</p>
<p><img  src="/表空间结构.drawio.png"   style="zoom:80%;" /><span class="image-caption">img</span></p>
<h4 id="行（row）"><a href="#行（row）" class="headerlink" title="行（row）"></a>行（row）</h4><p>数据库表中的记录都是按行（row）进行存放的，每行记录根据不同的行格式，有不同的存储结构。</p>
<h4 id="页（page）"><a href="#页（page）" class="headerlink" title="页（page）"></a>页（page）</h4><p>记录是按照行来存储的，但是数据库的读取并不以「行」为单位，否则一次读取（也就是一次 I/O 操作）只能处理一行数据，效率会非常低。</p>
<p>因此，<strong>InnoDB 的数据是按「页」为单位来读写的</strong>，也就是说，当需要读一条记录的时候，并不是将这个行记录从磁盘读出来，而是以页为单位，将其整体读入内存。</p>
<p><strong>默认每个页的大小为 16KB</strong>，也就是最多能保证 16KB 的连续存储空间。</p>
<p>页是 InnoDB 存储引擎磁盘管理的最小单元，意味着数据库每次读写都是以 16KB 为单位的，一次最少从磁盘中读取 16K 的内容到内存中，一次最少把内存中的 16K 内容刷新到磁盘中。</p>
<p>页的类型有很多，常见的有数据页、undo 日志页、溢出页等等。数据表中的行记录是用「数据页」来管理的</p>
<h4 id="区（extent）"><a href="#区（extent）" class="headerlink" title="区（extent）"></a>区（extent）</h4><p>B+ 树中每一层都是通过双向链表连接起来的，如果是以页为单位来分配存储空间，那么链表中相邻的两个页之间的物理位置并不是连续的，可能离得非常远，那么磁盘查询时就会有大量的随机I/O，随机 I/O 是非常慢的。</p>
<p><strong>在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照区（extent）为单位分配。每个区的大小为 1MB，对于 16KB 的页来说，连续的 64 个页会被划为一个区，这样就使得链表中相邻的页的物理位置也相邻，就能使用顺序 I/O 了</strong>。</p>
<h4 id="段（segment）"><a href="#段（segment）" class="headerlink" title="段（segment）"></a>段（segment）</h4><p>表空间是由各个段（segment）组成的，段是由多个区（extent）组成的。段一般分为数据段、索引段和回滚段等。</p>
<ul>
<li>索引段：存放 B + 树的非叶子节点的区的集合；</li>
<li>数据段：存放 B + 树的叶子节点的区的集合；</li>
<li>回滚段：存放的是回滚数据的区的集合，之前讲<a href="https://xiaolincoding.com/mysql/transaction/mvcc.html">事务隔离</a>的时候就介绍到了 MVCC 利用了回滚段实现了多版本查询数据。</li>
</ul>
<h3 id="InnoDB-行格式有哪些？"><a href="#InnoDB-行格式有哪些？" class="headerlink" title="InnoDB 行格式有哪些？"></a>InnoDB 行格式有哪些？</h3><p>InnoDB 提供了 4 种行格式，分别是 Redundant、Compact、Dynamic和 Compressed 行格式。</p>
<ul>
<li>Redundant 是很古老的行格式了， MySQL 5.0 版本之前用的行格式，现在基本没人用了。</li>
<li>由于 Redundant 不是一种紧凑的行格式，所以 MySQL 5.0 之后引入了 Compact 行记录存储方式，Compact 是一种紧凑的行格式，设计的初衷就是为了让一个数据页中可以存放更多的行记录，从 MySQL 5.1 版本之后，行格式默认设置成 Compact。</li>
<li>Dynamic 和 Compressed 两个都是紧凑的行格式，它们的行格式都和 Compact 差不多，因为都是基于 Compact 改进一点东西。从 MySQL5.7 版本之后，默认使用 Dynamic 行格式。</li>
</ul>
<p>Dynamic 和 Compressed 这两个行格式跟 Compact 非常像。</p>
<h3 id="COMPACT-行格式长什么样？"><a href="#COMPACT-行格式长什么样？" class="headerlink" title="COMPACT 行格式长什么样？"></a>COMPACT 行格式长什么样？</h3><p><img  src="/COMPACT.drawio.png"  ><span class="image-caption">img</span></p>
<p><strong>记录的额外信息</strong>包含 3 个部分：变长字段长度列表、NULL 值列表、记录头信息。</p>
<p>varchar(n) 和 char(n) 的区别是什么，相信大家都非常清楚，char 是定长的，varchar 是变长的，变长字段实际存储的数据的长度（大小）不固定的。</p>
<p>在存储数据的时候，也要把数据占用的大小存起来，存到「变长字段长度列表」里面，读取数据的时候才能根据这个「变长字段长度列表」去读取对应长度的数据。其他 TEXT、BLOB 等变长字段也是这么实现的。</p>
<p>「变长字段长度列表」中的信息之所以要逆序存放，是因为这样可以<strong>使得位置靠前的记录的真实数据和数据对应的字段长度信息可以同时在一个 CPU Cache Line 中，这样就可以提高 CPU Cache 的命中率</strong>。</p>
<p>同样的道理， NULL 值列表的信息也需要逆序存放。</p>
<p><strong>记录的真实数据</strong></p>
<ul>
<li>row_id</li>
</ul>
<p>如果我们建表的时候指定了主键或者唯一约束列，那么就没有 row_id 隐藏字段了。如果既没有指定主键，又没有唯一约束，那么 InnoDB 就会为记录添加 row_id 隐藏字段。row_id不是必需的，占用 6 个字节。</p>
<ul>
<li>trx_id</li>
</ul>
<p>事务id，表示这个数据是由哪个事务生成的。 trx_id是必需的，占用 6 个字节。</p>
<ul>
<li>roll_pointer</li>
</ul>
<p>这条记录上一个版本的指针。roll_pointer 是必需的，占用 7 个字节。</p>
<h3 id="行溢出后，MySQL-是怎么处理的？"><a href="#行溢出后，MySQL-是怎么处理的？" class="headerlink" title="行溢出后，MySQL 是怎么处理的？"></a>行溢出后，MySQL 是怎么处理的？</h3><p>MySQL 中磁盘和内存交互的基本单位是页，一个页的大小一般是 <code>16KB</code>，也就是 <code>16384字节</code>，而一个 varchar(n) 类型的列最多可以存储 <code>65532字节</code>，一些大对象如 TEXT、BLOB 可能存储更多的数据，这时一个页可能就存不了一条记录。这个时候就会<strong>发生行溢出，多的数据就会存到另外的「溢出页」中</strong>。</p>
<p>如果一个数据页存不了一条记录，InnoDB 存储引擎会自动将溢出的数据存放到「溢出页」中。在一般情况下，InnoDB 的数据都是存放在 「数据页」中。但是当发生行溢出时，溢出的数据会存放到「溢出页」中。</p>
<p>当发生行溢出时，在记录的真实数据处只会保存该列的一部分数据，而把剩余的数据放在「溢出页」中，然后真实数据处用 20 字节存储指向溢出页的地址，从而可以找到剩余数据所在的页。大致如下图所示。</p>
<p><img  src="/行溢出.png"   style="zoom:67%;" /><span class="image-caption">img</span></p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul>
<li>按「数据结构」分类：<strong>B+tree索引、Hash索引(innodb 不支持手动创建)、Full-text索引</strong>。</li>
<li>按「物理存储」分类：<strong>聚簇索引（主键索引）、二级索引（辅助索引）</strong>。</li>
<li>按「字段特性」分类：<strong>主键索引、唯一索引、普通索引、前缀索引（char、 varchar、binary、varbinary）</strong>。</li>
<li>按「字段个数」分类：<strong>单列索引、联合索引</strong>。</li>
</ul>
<p>在创建表时，InnoDB 存储引擎会根据不同的场景选择不同的列作为索引：</p>
<ul>
<li>如果有主键，默认会使用主键作为聚簇索引的索引键（key）；</li>
<li>如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键（key）；</li>
<li>在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键（key）；</li>
</ul>
<p>其它索引都属于辅助索引（Secondary Index），也被称为二级索引或非聚簇索引。<strong>创建的主键索引和二级索引默认使用的是 B+Tree 索引</strong>。</p>
<p>B+Tree 存储千万级的数据只需要 3-4 层高度就可以满足，这意味着从千万级的表查询目标数据最多需要 3-4 次磁盘 I/O，所以<strong>B+Tree 相比于 B 树和二叉树来说，最大的优势在于查询效率很高，因为即使在数据量很大的情况，查询一个数据的磁盘 I/O 依然维持在 3-4次。</strong></p>
<p>主键索引和二级索引的叶子节点不同：</p>
<ul>
<li>主键索引的 B+Tree 的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里；</li>
<li>二级索引的 B+Tree 的叶子节点存放的是主键值，而不是实际数据。</li>
</ul>
<h3 id="回表"><a href="#回表" class="headerlink" title="回表"></a>回表</h3><p><strong>回表：</strong>先检索二级索引，找到叶子节点，获取主键，然后在主键索引中查询到叶子节点获取整行数据，查两个B+ Tree。</p>
<p><strong>覆盖索引</strong>：<strong>在二级索引的 B+Tree 就能查询到结果的过程</strong>。</p>
<h3 id="对比其他结构"><a href="#对比其他结构" class="headerlink" title="对比其他结构"></a>对比其他结构</h3><p><strong><em>B+Tree vs B Tree</em></strong></p>
<p>B+Tree 只在叶子节点存储数据，而 B 树 的非叶子节点也要存储数据，所以 B+Tree 的单个节点的数据量更小，在相同的磁盘 I/O 次数下，就能查询更多的节点。</p>
<p>另外，B+Tree 叶子节点采用的是双链表连接，适合 MySQL 中常见的基于范围的顺序查找，而 B 树无法做到这一点。</p>
<p><strong><em>B+Tree vs 二叉树</em></strong></p>
<p>对于有 N 个叶子节点的 B+Tree，其搜索复杂度为<code>O(logdN)</code>，其中 d 表示节点允许的最大子节点个数为 d 个。</p>
<p>在实际的应用当中， d 值是大于100的，这样就保证了，即使数据达到千万级别时，B+Tree 的高度依然维持在 3~4 层左右，也就是说一次数据查询操作只需要做 3~4 次的磁盘 I/O 操作就能查询到目标数据。</p>
<p>而二叉树的每个父节点的儿子节点个数只能是 2 个，意味着其搜索复杂度为 <code>O(logN)</code>，这已经比 B+Tree 高出不少，因此二叉树检索到目标数据所经历的磁盘 I/O 次数要更多。</p>
<p><strong><em>B+Tree vs Hash</em></strong></p>
<p>Hash 在做等值查询的时候效率贼快，搜索复杂度为 O(1)。</p>
<p>但是 Hash 表不适合做范围查询，它更适合做等值的查询，这也是 B+Tree 索引要比 Hash 表索引有着更广泛的适用场景的原因。</p>
<h3 id="联合索引，最左匹配"><a href="#联合索引，最左匹配" class="headerlink" title="联合索引，最左匹配"></a>联合索引，最左匹配</h3><p>使用联合索引时，存在<strong>最左匹配原则</strong>，也就是按照最左优先的方式进行索引的匹配。在使用联合索引进行查询的时候，如果不遵循「最左匹配原则」，联合索引会失效。</p>
<p>比如，如果创建了一个 <code>(a, b, c)</code> 联合索引，如果查询条件是以下这几种，就可以匹配上联合索引：</p>
<ul>
<li>where a=1；</li>
<li>where a=1 and b=2 and c=3；</li>
<li>where a=1 and b=2；</li>
</ul>
<p>因为有查询优化器，所以 a 字段在 where 子句的顺序并不重要。</p>
<p>但是，如果查询条件是以下这几种，因为不符合最左匹配原则，所以就无法匹配上联合索引，联合索引就会失效:</p>
<ul>
<li>where b=2；</li>
<li>where c=3；</li>
<li>where b=2 and c=3；</li>
</ul>
<p>上面这些查询条件之所以会失效，是因为<code>(a, b, c)</code> 联合索引，是先按 a 排序，在 a 相同的情况再按 b 排序，在 b 相同的情况再按 c 排序。所以，<strong>b 和 c 是全局无序，局部相对有序的</strong>，这样在没有遵循最左匹配原则的情况下，是无法利用到索引的。</p>
<p><strong>并不是查询过程使用了联合索引查询，就代表联合索引中的所有字段都用到了联合索引进行索引查询。</strong>有可能只有部分字段用了联合索引，比如下面的 Q1。</p>
<p><strong>也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引</strong>。</p>
<blockquote>
<p>Q1：<code>select * from t_table where a &gt; 1 and b = 2</code>，联合索引（a, b）哪一个字段用到了联合索引的 B+Tree？</p>
</blockquote>
<p><strong>这条查询语句只有 a 字段用到了联合索引进行索引查询，而 b 字段并没有使用到联合索引</strong>。</p>
<blockquote>
<p>Q2: <code>select * from t_table where a &gt;= 1 and b = 2</code>，联合索引（a, b）哪一个字段用到了联合索引的 B+Tree？</p>
</blockquote>
<p>虽然在符合 a&gt;= 1 条件的二级索引记录的范围里，b 字段的值是「无序」的，<strong>但是对于符合 a = 1 的二级索引记录的范围里，b 字段的值是「有序」的</strong>（因为对于联合索引，是先按照 a 字段的值排序，然后在 a 字段的值相同的情况下，再按照 b 字段的值进行排序）。</p>
<p>当二级索引记录的 a 字段值为 1 时，可以通过 b = 2 条件减少需要扫描的二级索引记录范围。</p>
<p><strong>Q2 这条查询语句 a 和 b 字段都用到了联合索引进行索引查询</strong>。</p>
<blockquote>
<p>Q3: <code>SELECT * FROM t_table WHERE a BETWEEN 2 AND 8 AND b = 2</code>，联合索引（a, b）哪一个字段用到了联合索引的 B+Tree？</p>
</blockquote>
<p>Q3 查询条件中 <code>a BETWEEN 2 AND 8</code> 的意思在 MySQL 中是 &gt;= 2 &amp;&amp; &lt;= 8。类似于 Q2，能够用到<strong>联合索引进行索引查询</strong>。</p>
<blockquote>
<p>Q4: <code>SELECT * FROM t_user WHERE name like &#39;j%&#39; and age = 22</code>，联合索引（name, age）哪一个字段用到了联合索引的 B+Tree？</p>
</blockquote>
<p>虽然在符合前缀为 ‘j’ 的 name 字段的二级索引记录的范围里，age 字段的值是「无序」的，<strong>但是对于符合 name = j 的二级索引记录的范围里，age字段的值是「有序」的</strong>（因为对于联合索引，是先按照 name 字段的值排序，然后在 name 字段的值相同的情况下，再按照 age 字段的值进行排序）。</p>
<p>所以，<strong>Q4 这条查询语句 a 和 b 字段都用到了联合索引进行索引查询</strong>。</p>
<p><strong>联合索引的最左匹配原则，在遇到范围查询（如 &gt;、&lt;）的时候，就会停止匹配，也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引。注意，对于 &gt;=、&lt;=、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配</strong></p>
<h3 id="索引下推-1"><a href="#索引下推-1" class="headerlink" title="索引下推"></a>索引下推</h3><p>联合索引（a, b），在执行 <code>select * from table where a &gt; 1 and b = 2</code> 语句的时候，只有 a 字段能用到索引，那在联合索引的 B+Tree 找到第一个满足条件的主键值（ID 为 2）后，还需要判断其他条件是否满足（看 b 是否等于 2），那是在联合索引里判断？还是回主键索引去判断呢？</p>
<p>MySQL 5.6 引入的<strong>索引下推优化</strong>（index condition pushdown)， <strong>可以在联合索引遍历过程中，对联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数</strong>。</p>
<p>当你的查询语句的执行计划里，出现了 Extra 为 <code>Using index condition</code>，那么说明使用了索引下推的优化。</p>
<h3 id="索引区分度"><a href="#索引区分度" class="headerlink" title="索引区分度"></a>索引区分度</h3><p>建立联合索引时的字段顺序，对索引效率也有很大影响。越靠前的字段被用于索引过滤的概率越高，实际开发工作中<strong>建立联合索引时，要把区分度大的字段排在前面，这样区分度大的字段越有可能被更多的 SQL 使用到</strong>。</p>
<p><img  src="/区分度.png"   style="zoom:67%;" /><span class="image-caption">区分度计算公式</span></p>
<p>性别的区分度就很小，不适合建立索引或不适合排在联合索引列的靠前的位置，而 UUID 这类字段就比较适合做索引或排在联合索引列的靠前的位置。</p>
<h3 id="联合索引进行排序"><a href="#联合索引进行排序" class="headerlink" title="联合索引进行排序"></a>联合索引进行排序</h3><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">where</span> status <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> create_time <span class="hljs-keyword">asc</span><br></code></pre></td></tr></table></figure>
<p>更好的方式给 status 和 create_time 列建立一个联合索引，因为这样可以避免 MySQL 数据库发生文件排序。</p>
<h3 id="什么时候不需要索引"><a href="#什么时候不需要索引" class="headerlink" title="什么时候不需要索引"></a>什么时候不需要索引</h3><p>索引的缺点：</p>
<ul>
<li>需要占用物理空间，数量越大，占用空间越大；</li>
<li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增大；</li>
<li>会降低表的增删改的效率，因为每次增删改索引，B+ 树为了维护索引有序性，都需要进行动态维护。</li>
</ul>
<h4 id="什么时候适用索引？"><a href="#什么时候适用索引？" class="headerlink" title="什么时候适用索引？"></a>什么时候适用索引？</h4><ul>
<li>字段有唯一性限制的，比如商品编码；</li>
<li>经常用于 <code>WHERE</code> 查询条件的字段，这样能够提高整个表的查询速度，如果查询条件不是一个字段，可以建立联合索引。</li>
<li>经常用于 <code>GROUP BY</code> 和 <code>ORDER BY</code> 的字段，这样在查询的时候就不需要再去做一次排序了，因为我们都已经知道了建立索引之后在 B+Tree 中的记录都是排序好的。</li>
</ul>
<h4 id="什么时候不需要创建索引？"><a href="#什么时候不需要创建索引？" class="headerlink" title="什么时候不需要创建索引？"></a>什么时候不需要创建索引？</h4><ul>
<li><code>WHERE</code> 条件，<code>GROUP BY</code>，<code>ORDER BY</code> 里用不到的字段，索引的价值是快速定位，如果起不到定位的字段通常是不需要创建索引的，因为索引是会占用物理空间的。</li>
<li>字段中存在大量重复数据，不需要创建索引，比如性别字段，只有男女，如果数据库表中，男女的记录分布均匀，那么无论搜索哪个值都可能得到一半的数据。在这些情况下，还不如不要索引，因为 MySQL 还有一个查询优化器，查询优化器发现某个值出现在表的数据行中的百分比很高的时候，它一般会忽略索引，进行全表扫描。</li>
<li>表数据太少的时候，不需要创建索引；</li>
<li>经常更新的字段不用创建索引，比如不要对电商项目的用户余额建立索引，因为索引字段频繁修改，由于要维护 B+Tree的有序性，那么就需要频繁的重建索引，这个过程是会影响数据库性能的。</li>
</ul>
<h3 id="有什么优化索引的方法？"><a href="#有什么优化索引的方法？" class="headerlink" title="有什么优化索引的方法？"></a>有什么优化索引的方法？</h3><ul>
<li>前缀索引优化；</li>
<li>覆盖索引优化；</li>
<li>主键索引最好是自增的；</li>
<li>防止索引失效；</li>
</ul>
<h3 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h3><p><strong>前缀索引优化；</strong></p>
<p>使用前缀索引是为了减小索引字段大小，可以增加一个索引页中存储的索引值，有效提高索引的查询速度。</p>
<p><strong>覆盖索引优化；</strong></p>
<p>建立联合索引防止回表</p>
<p><strong>主键索引最好是自增的；</strong></p>
<p>使用自增主键，使得插入一条新记录，都是追加操作，不用移动数据。</p>
<p>非自增主键可能导致页分裂，造成大量内存碎片，索引结构不紧凑。</p>
<p>主键字段长度越小，意味着二级索引的叶子节点越小（二级索引的叶子节点存放的数据是主键值），这样二级索引占用的空间也就越小。</p>
<p><strong>防止索引失效；</strong></p>
<ul>
<li>当我们使用左或者左右模糊匹配的时候，也就是 <code>like %xx</code> 或者 <code>like %xx%</code>这两种方式都会造成索引失效；</li>
<li>当我们在查询条件中对索引列做了计算、函数、类型转换操作，这些情况下都会造成索引失效；</li>
<li>联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。</li>
<li>在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</li>
</ul>
<p><strong>索引最好设置为 NOT NULL</strong></p>
<p>type 字段就是描述了找到所需数据时使用的扫描方式是什么，常见扫描类型的<strong>执行效率从低到高的顺序为</strong>：</p>
<ul>
<li>All（全表扫描）；</li>
<li>index（全索引扫描）；</li>
<li>range（索引范围扫描）；</li>
<li>ref（非唯一索引扫描）；</li>
<li>eq_ref（唯一索引扫描）；</li>
<li>const（结果只有一条的主键或唯一索引扫描）。</li>
</ul>
<blockquote>
<p>除了关注 type，我们也要关注 extra 显示的结果。</p>
</blockquote>
<p>这里说几个重要的参考指标：</p>
<ul>
<li>Using filesort ：当查询语句中包含 group by 操作，而且无法利用索引完成排序操作的时候， 这时不得不选择相应的排序算法进行，甚至可能会通过文件排序，效率是很低的，所以要避免这种问题的出现。</li>
<li>Using temporary：使了用临时表保存中间结果，MySQL 在对查询结果排序时使用临时表，常见于排序 order by 和分组查询 group by。效率低，要避免这种问题的出现。</li>
<li>Using index：所需数据只需在索引即可全部获得，不须要再到表中取数据，也就是使用了覆盖索引，避免了回表操作，效率不错。</li>
</ul>
<h3 id="索引失效的情况"><a href="#索引失效的情况" class="headerlink" title="索引失效的情况"></a>索引失效的情况</h3><ul>
<li>当我们使用左或者左右模糊匹配的时候，也就是 <code>like %xx</code> 或者 <code>like %xx%</code>这两种方式都会造成索引失效；</li>
<li>当我们在查询条件中对索引列使用函数，就会导致索引失效。</li>
<li>当我们在查询条件中对索引列进行表达式计算，也是无法走索引的。</li>
<li>MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较。如果字符串是索引列，而条件语句中的输入参数是数字的话，那么索引列会发生隐式类型转换，由于隐式类型转换是通过 CAST 函数实现的，等同于对索引列使用了函数，所以就会导致索引失效。</li>
<li>联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。</li>
<li>在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</li>
</ul>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="事务特性"><a href="#事务特性" class="headerlink" title="事务特性"></a>事务特性</h3><ul>
<li><strong>原子性（Atomicity）</strong>：一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节，而且事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样，就好比买一件商品，购买成功时，则给商家付了钱，商品到手；购买失败时，则商品在商家手中，消费者的钱也没花出去。</li>
<li><strong>一致性（Consistency）</strong>：是指事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态。比如，用户 A 和用户 B 在银行分别有 800 元和 600 元，总共 1400 元，用户 A 给用户 B 转账 200 元，分为两个步骤，从 A 的账户扣除 200 元和对 B 的账户增加 200 元。一致性就是要求上述步骤操作后，最后的结果是用户 A 还有 600 元，用户 B 有 800 元，总共 1400 元，而不会出现用户 A 扣除了 200 元，但用户 B 未增加的情况（该情况，用户 A 和 B 均为 600 元，总共 1200 元）。</li>
<li><strong>隔离性（Isolation）</strong>：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致，因为多个事务同时使用相同的数据时，不会相互干扰，每个事务都有一个完整的数据空间，对其他并发事务是隔离的。也就是说，消费者购买商品这个事务，是不影响其他消费者购买的。</li>
<li><strong>持久性（Durability）</strong>：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li>
</ul>
<h3 id="如何保证事务的-ACID"><a href="#如何保证事务的-ACID" class="headerlink" title="如何保证事务的 ACID"></a>如何保证事务的 ACID</h3><ul>
<li>持久性是通过 redo log （重做日志）来保证的；</li>
<li>原子性是通过 undo log（回滚日志） 来保证的；</li>
<li>隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的；</li>
<li>一致性则是通过持久性+原子性+隔离性来保证；</li>
</ul>
<h3 id="并发事务的问题"><a href="#并发事务的问题" class="headerlink" title="并发事务的问题"></a>并发事务的问题</h3><ul>
<li><strong>脏读：</strong>读到其他事务未提交的数据；</li>
<li><strong>不可重复读：</strong>前后读取的数据不一致；</li>
<li><strong>幻读：</strong>前后读取的记录数量不一致。</li>
</ul>
<h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><ul>
<li><strong>读未提交（*read uncommitted*）</strong>，指一个事务还没提交时，它做的变更就能被其他事务看到；</li>
<li><strong>读提交（*read committed*）</strong>，指一个事务提交之后，它做的变更才能被其他事务看到；</li>
<li><strong>可重复读（*repeatable read*）</strong>，指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，<strong>MySQL InnoDB 引擎的默认隔离级别</strong>；</li>
<li><strong>串行化（*serializable* ）</strong>；会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；</li>
</ul>
<p><strong>MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象（并不是完全解决了，详见这篇<a href="https://xiaolincoding.com/mysql/transaction/phantom.html">文章</a>）</strong>，解决的方案有两种：</p>
<ul>
<li>针对<strong>快照读</strong>（普通 select 语句），是<strong>通过 MVCC 方式解决了幻读</strong>，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。</li>
<li>针对<strong>当前读</strong>（select … for update 等语句），是<strong>通过 next-key lock（记录锁+间隙锁）方式解决了幻读</strong>，因为当执行 select … for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。</li>
</ul>
<h3 id="隔离级别的实现"><a href="#隔离级别的实现" class="headerlink" title="隔离级别的实现"></a>隔离级别的实现</h3><ul>
<li>对于「读未提交」隔离级别的事务来说，因为可以读到未提交事务修改的数据，所以直接读取最新的数据就好了；</li>
<li>对于「串行化」隔离级别的事务来说，通过加读写锁的方式来避免并行访问；</li>
<li>对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 <strong>Read View \</strong>来实现的，它们的区别在于创建 Read View 的时机不同，大家可以把 Read View 理解成一个数据快照，就像相机拍照那样，定格某一时刻的风景。*<em>「读提交」隔离级别是在「每个语句执行前」都会重新生成一个 Read View，而「可重复读」隔离级别是「启动事务时」生成一个 Read View，然后整个事务期间都在用这个 Read View*</em>。</li>
</ul>
<h3 id="开启事务的两种方式"><a href="#开启事务的两种方式" class="headerlink" title="开启事务的两种方式"></a>开启事务的两种方式</h3><p>在 MySQL 有两种开启事务的命令，分别是：</p>
<ul>
<li>第一种：begin/start transaction 命令；</li>
<li>第二种：start transaction with consistent snapshot 命令；</li>
</ul>
<p>这两种开启事务的命令，事务的启动时机是不同的：</p>
<ul>
<li>执行了 begin/start transaction 命令后，并不代表事务启动了。只有在执行这个命令后，执行了第一条 select 语句，才是事务真正启动的时机；</li>
<li>执行了 start transaction with consistent snapshot 命令，就会马上启动事务。</li>
</ul>
<h3 id="Read-View-在-MVCC-中如何工作？"><a href="#Read-View-在-MVCC-中如何工作？" class="headerlink" title="Read View 在 MVCC 中如何工作？"></a>Read View 在 MVCC 中如何工作？</h3><p>Read View 的四个字段</p>
<ul>
<li>m_ids ：指的是在创建 Read View 时，当前数据库中「活跃事务」的<strong>事务 id 列表</strong>，注意是一个列表，<strong>“活跃事务”指的就是，启动了但还没提交的事务</strong>。</li>
<li>min_trx_id ：指的是在创建 Read View 时，当前数据库中「活跃事务」中事务 <strong>id 最小的事务</strong>，也就是 m_ids 的最小值。</li>
<li>max_trx_id ：这个并不是 m_ids 的最大值，而是<strong>创建 Read View 时当前数据库中应该给下一个事务的 id 值</strong>，也就是全局事务中最大的事务 id 值 + 1；</li>
<li>creator_trx_id ：指的是<strong>创建该 Read View 的事务的事务 id</strong>。</li>
</ul>
<p>聚簇索引记录中的两个隐藏列</p>
<ul>
<li>trx_id，当一个事务对某条聚簇索引记录进行改动时，就会<strong>把该事务的事务 id 记录在 trx_id 隐藏列里</strong>；</li>
<li>roll_pointer，每次对某条聚簇索引记录进行改动时，都会把旧版本的记录写入到 undo 日志中，然后<strong>这个隐藏列是个指针，指向每一个旧版本记录</strong>，于是就可以通过它找到修改前的记录。</li>
</ul>
<p>创建 read view 之后，可以将记录中的 trx_id 划分为 3 种情况：</p>
<p><img  src="/ReadView.drawio.png"  ><span class="image-caption">img</span></p>
<p>如果记录 trx_id &lt; min_trx_id，那么该记录可见。（记录已提交）</p>
<p>如果记录 trx_id &gt; max_trx_id，那么该记录不可见。（记录在当前事务之后）</p>
<p>如果记录 min_trx_id &lt;= trx_id &lt;= max_trx_id：</p>
<ul>
<li>如果 trx_id 在 m_ids 列表中，不可见。（该记录活跃中）</li>
<li>如果 trx_id 不在 m_ids 列表中，可见。（该记录已提交）</li>
</ul>
<p><strong>这种通过「版本链」来控制并发事务访问同一个记录时的行为就叫 MVCC（多版本并发控制）。</strong></p>
<h3 id="MySQL-可重复读隔离级别，完全解决幻读了吗？"><a href="#MySQL-可重复读隔离级别，完全解决幻读了吗？" class="headerlink" title="MySQL 可重复读隔离级别，完全解决幻读了吗？"></a>MySQL 可重复读隔离级别，完全解决幻读了吗？</h3><ul>
<li>针对<strong>快照读</strong>（普通 select 语句），是<strong>通过 MVCC 方式解决了幻读</strong>，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。</li>
<li>针对<strong>当前读</strong>（select … for update 、update、delete 等除了普通 select 之外的语句），是<strong>通过 next-key lock（记录锁+间隙锁）方式解决了幻读</strong>，因为当执行 select … for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。</li>
</ul>
<p><strong>MySQL Innodb 中的 MVCC 并不能完全避免幻读现象</strong>。下面是一个例子：</p>
<p>A 事务先 select 没有，然后 B 事务 insert 有了，之后 A 事务 update 新插入的成功，A 事务 select 也有了。</p>
<p>因为 update 操作使得 trx_id 变成了 A 的 trx_id 之后就能查询到了。</p>
<p><strong>第二个例子</strong></p>
<p>除了上面这一种场景会发生幻读现象之外，还有下面这个场景也会发生幻读现象。</p>
<ul>
<li>T1 时刻：事务 A 先执行「快照读语句」：select * from t_test where id &gt; 100 得到了 3 条记录。</li>
<li>T2 时刻：事务 B 往插入一个 id= 200 的记录并提交；</li>
<li>T3 时刻：事务 A 再执行「当前读语句」 select * from t_test where id &gt; 100 for update 就会得到 4 条记录，此时也发生了幻读现象。</li>
</ul>
<p><strong>要避免这类特殊场景下发生幻读的现象的话，就是尽量在开启事务之后，马上执行 select … for update 这类当前读的语句</strong>，因为它会对记录加 next-key lock，从而避免其他事务插入一条新记录。</p>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h3><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">flush tables <span class="hljs-keyword">with</span> read lock<br></code></pre></td></tr></table></figure>
<p>执行后，<strong>整个数据库就处于只读状态了</strong>，这时其他线程执行以下操作，都会被阻塞：</p>
<ul>
<li>对数据的增删改操作，比如 insert、delete、update等语句；</li>
<li>对表结构的更改操作，比如 alter table、drop table 等语句。</li>
</ul>
<p>如果要释放全局锁，则要执行这条命令：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">unlock tables<br></code></pre></td></tr></table></figure>
<p>当然，当会话断开了，全局锁会被自动释放。</p>
<p>全局锁主要应用于做<strong>全库逻辑备份</strong>，这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。</p>
<p>如果数据库的引擎支持的事务支持<strong>可重复读的隔离级别</strong>，那么在备份数据库之前先开启事务，会先创建 Read View，然后整个事务执行期间都在用这个 Read View，而且由于 MVCC 的支持，备份期间业务依然可以对数据进行更新操作。</p>
<p>备份数据库的工具是 mysqldump，在使用 mysqldump 时加上 <code>–single-transaction</code> 参数的时候，就会在备份数据库之前先开启事务。这种方法只适用于支持「可重复读隔离级别的事务」的存储引擎。</p>
<p>InnoDB 存储引擎默认的事务隔离级别正是可重复读，因此可以采用这种方式来备份数据库。</p>
<p>但是，对于 MyISAM 这种不支持事务的引擎，在备份数据库时就要使用全局锁的方法。</p>
<h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h3><ul>
<li>表锁；</li>
<li>元数据锁（MDL）;</li>
<li>意向锁；</li>
<li>AUTO-INC 锁；</li>
</ul>
<h4 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a><strong>表锁</strong></h4><p>表锁本线程（会话）可以读本表的数据，但是不能写本表的数据，同时<strong>本线程不能访问其他表</strong>，其他线程可以对本表进行读操作，但是也不能对本表进行写操作，这时候写操作会发生阻塞。</p>
<h4 id="元数据锁（MDL）"><a href="#元数据锁（MDL）" class="headerlink" title="元数据锁（MDL）"></a><strong>元数据锁（MDL）</strong></h4><p>我们不需要显示的使用 MDL，因为当我们对数据库表进行操作时，会自动给这个表加上 MDL：</p>
<ul>
<li>对一张表进行 CRUD 操作时，加的是 <strong>MDL 读锁</strong>；</li>
<li>对一张表做结构变更操作的时候，加的是 <strong>MDL 写锁</strong>；</li>
</ul>
<p>MDL 是在事务提交后才会释放，这意味着<strong>事务执行期间，MDL 是一直持有的</strong>。</p>
<p>申请 MDL 锁的操作会形成一个队列，队列中<strong>写锁获取优先级高于读锁</strong>，一旦出现 MDL 写锁等待，会阻塞后续该表的所有 CRUD 操作。</p>
<p>所以为了能安全的对表结构进行变更，在对表结构变更前，先要看看数据库中的长事务，是否有事务已经对表加上了 MDL 读锁，如果可以考虑 kill 掉这个长事务，然后再做表结构的变更。</p>
<h4 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a><strong>意向锁</strong></h4><p><strong>意向锁的目的是为了快速判断表里是否有记录被加锁</strong></p>
<ul>
<li>在使用 InnoDB 引擎的表里对某些记录加上「共享锁」之前，需要先在表级别加上一个「意向共享锁」；</li>
<li>在使用 InnoDB 引擎的表里对某些纪录加上「独占锁」之前，需要先在表级别加上一个「意向独占锁」；</li>
</ul>
<p>也就是，当执行插入、更新、删除操作，需要先对表加上「意向独占锁」，然后对该记录加独占锁。</p>
<p>而普通的 select 是不会加行级锁的，普通的 select 语句是利用 MVCC 实现一致性读，是无锁的。</p>
<p>不过，select 也是可以对记录加共享锁和独占锁的，具体方式如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>先在表上加上意向共享锁，然后对读取的记录加共享锁<br><span class="hljs-keyword">select</span> ... lock <span class="hljs-keyword">in</span> share mode;<br><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>先表上加上意向独占锁，然后对读取的记录加独占锁<br><span class="hljs-keyword">select</span> ... <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>;<br></code></pre></td></tr></table></figure>
<p><strong>意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，只会和共享表锁（*lock tables … read*）和独占表锁（*lock tables … write*）发生冲突。</strong></p>
<p>表锁和行锁是满足读读共享、读写互斥、写写互斥的。</p>
<p>如果没有「意向锁」，那么加「独占表锁」时，就需要遍历表里所有记录，查看是否有记录存在独占锁，这样效率会很慢。</p>
<p>那么有了「意向锁」，由于在对记录加独占锁前，先会加上表级别的意向独占锁，那么在加「独占表锁」时，直接查该表是否有意向独占锁，如果有就意味着表里已经有记录被加了独占锁，这样就不用去遍历表里的记录。</p>
<h4 id="AUTO-INC-锁"><a href="#AUTO-INC-锁" class="headerlink" title="AUTO-INC 锁"></a><strong>AUTO-INC 锁</strong></h4><p>用于实现自增主键，AUTO-INC 锁是特殊的表锁机制，锁<strong>不是再一个事务提交后才释放，而是再执行完插入语句后就会立即释放</strong>。</p>
<p><strong>在插入数据时，会加一个表级别的 AUTO-INC 锁</strong>，然后为被 <code>AUTO_INCREMENT</code> 修饰的字段赋值递增的值，等插入语句执行完成后，才会把 AUTO-INC 锁释放掉。</p>
<p>但是， AUTO-INC 锁再对大量数据进行插入的时候，会影响插入性能，因为另一个事务中的插入会被阻塞。</p>
<p>因此， 在 MySQL 5.1.22 版本开始，InnoDB 存储引擎提供了一种<strong>轻量级的锁</strong>来实现自增。</p>
<p>一样也是在插入数据的时候，会为被 <code>AUTO_INCREMENT</code> 修饰的字段加上轻量级锁，<strong>然后给该字段赋值一个自增的值，就把这个轻量级锁释放了，而不需要等待整个插入语句执行完后才释放锁</strong>。</p>
<h3 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h3><ul>
<li>Record Lock，记录锁，也就是仅仅把一条记录锁上；</li>
<li>Gap Lock，间隙锁，锁定一个范围，但是不包含记录本身；</li>
<li>Next-Key Lock：Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。</li>
<li>插入意向锁</li>
</ul>
<p>InnoDB 引擎是支持行级锁的，而 MyISAM 引擎并不支持行级锁。</p>
<p>共享锁（S锁）满足读读共享，读写互斥。独占锁（X锁）满足写写互斥、读写互斥。</p>
<h4 id="Record-Lock"><a href="#Record-Lock" class="headerlink" title="Record Lock"></a>Record Lock</h4><p>Record Lock 称为记录锁，锁住的是一条记录。而且记录锁是有 S 锁和 X 锁之分的：</p>
<ul>
<li>S + S 可以</li>
<li>其他都不可以（S + X、X + X、X + S）</li>
</ul>
<h4 id="Gap-Lock"><a href="#Gap-Lock" class="headerlink" title="Gap Lock"></a>Gap Lock</h4><p>只存在于可重复读隔离级别，目的是为了解决可重复读隔离级别下幻读的现象。</p>
<p>间隙锁虽然存在 X 型间隙锁和 S 型间隙锁，但是并没有什么区别，<strong>间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出的</strong>。</p>
<h4 id="Next-Key-Lock"><a href="#Next-Key-Lock" class="headerlink" title="Next-Key Lock"></a><strong>Next-Key Lock</strong></h4><p>Next-Key Lock 称为临键锁，是 Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。</p>
<p>假设，表中有一个范围 id 为（3，5] 的 next-key lock，那么其他事务即不能插入 id = 4 记录，也不能修改 id = 5 这条记录。</p>
<p><img  src="/临键锁.drawio.png"  ><span class="image-caption">img</span></p>
<p><strong>next-key lock 是包含间隙锁+记录锁的，如果一个事务获取了 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，是会被阻塞的</strong>。</p>
<h4 id="插入意向锁"><a href="#插入意向锁" class="headerlink" title="插入意向锁"></a>插入意向锁</h4><p>一个事务在插入一条记录的时候，需要判断插入位置是否已被其他事务加了间隙锁（next-key lock 也包含间隙锁）。</p>
<p>插入意向锁名字虽然有意向锁，但是它并<strong>不是意向锁，它是一种特殊的间隙锁，属于行级别锁</strong>。</p>
<p>如果说间隙锁锁住的是一个区间，那么「插入意向锁」锁住的就是一个点。因而从这个角度来说，插入意向锁确实是一种特殊的间隙锁。</p>
<p>插入意向锁与间隙锁的另一个非常重要的差别是：尽管「插入意向锁」也属于间隙锁，但两个事务却不能在同一时间内，一个拥有间隙锁，另一个拥有该间隙区间内的插入意向锁（当然，插入意向锁如果不在间隙锁区间内则是可以的）。</p>
<h3 id="唯一索引等值查询"><a href="#唯一索引等值查询" class="headerlink" title="唯一索引等值查询"></a>唯一索引等值查询</h3><p>当我们用唯一索引进行等值查询的时候，查询的记录存不存在，加锁的规则也会不同：</p>
<ul>
<li>当查询的记录是「存在」的，在索引树上定位到这一条记录后，将该记录的索引中的 next-key lock 会<strong>退化成「记录锁」</strong>。</li>
<li>当查询的记录是「不存在」的，在索引树找到第一条大于该查询记录的记录后，将该记录的索引中的 next-key lock 会<strong>退化成「间隙锁」</strong>。</li>
</ul>
<h3 id="唯一索引范围查询"><a href="#唯一索引范围查询" class="headerlink" title="唯一索引范围查询"></a>唯一索引范围查询</h3><p>范围查询和等值查询的加锁规则是不同的。</p>
<p>当唯一索引进行范围查询时，<strong>会对每一个扫描到的索引加 next-key 锁，然后如果遇到下面这些情况，会退化成记录锁或者间隙锁</strong>：</p>
<ul>
<li>情况一：针对「大于等于」的范围查询，因为存在等值查询的条件，那么如果等值查询的记录是存在于表中，那么该记录的索引中的 next-key 锁会<strong>退化成记录锁</strong>。</li>
<li>情况二：针对「小于或者小于等于」的范围查询，要看条件值的记录是否存在于表中：<ul>
<li>当条件值的记录不在表中，那么不管是「小于」还是「小于等于」条件的范围查询，<strong>扫描到终止范围查询的记录时，该记录的索引的 next-key 锁会退化成间隙锁</strong>，其他扫描到的记录，都是在这些记录的索引上加 next-key 锁。</li>
<li>当条件值的记录在表中，如果是「小于」条件的范围查询，<strong>扫描到终止范围查询的记录时，该记录的索引的 next-key 锁会退化成间隙锁</strong>，其他扫描到的记录，都是在这些记录的索引上加 next-key 锁；如果「小于等于」条件的范围查询，扫描到终止范围查询的记录时，该记录的索引 next-key 锁不会退化成间隙锁。其他扫描到的记录，都是在这些记录的索引上加 next-key 锁。</li>
</ul>
</li>
</ul>
<h3 id="非唯一索引等值查询"><a href="#非唯一索引等值查询" class="headerlink" title="非唯一索引等值查询"></a>非唯一索引等值查询</h3><ul>
<li>当查询的记录「存在」时，由于不是唯一索引，所以肯定存在索引值相同的记录，于是<strong>非唯一索引等值查询的过程是一个扫描的过程，直到扫描到第一个不符合条件的二级索引记录就停止扫描，然后在扫描的过程中，对扫描到的二级索引记录加的是 next-key 锁，而对于第一个不符合条件的二级索引记录，该二级索引的 next-key 锁会退化成间隙锁。同时，在符合查询条件的记录的主键索引上加记录锁</strong>。</li>
<li>当查询的记录「不存在」时，<strong>扫描到第一条不符合条件的二级索引记录，该二级索引的 next-key 锁会退化成间隙锁。因为不存在满足查询条件的记录，所以不会对主键索引加锁</strong>。</li>
</ul>
<h3 id="非唯一索引范围查询"><a href="#非唯一索引范围查询" class="headerlink" title="非唯一索引范围查询"></a>非唯一索引范围查询</h3><p>非唯一索引进行范围查询时，对二级索引记录加锁都是加 next-key 锁。</p>
<h3 id="没有加索引的查询"><a href="#没有加索引的查询" class="headerlink" title="没有加索引的查询"></a>没有加索引的查询</h3><p><strong>如果锁定读查询语句，没有使用索引列作为查询条件，或者查询语句没有走索引查询，导致扫描是全表扫描。那么，每一条记录的索引上都会加 next-key 锁，这样就相当于锁住的全表，这时如果其他事务对该表进行增、删、改操作的时候，都会被阻塞</strong>。</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>死锁的四个必要条件：<strong>互斥、占有且等待、不可强占用、循环等待</strong>。只要系统发生死锁，这些条件必然成立，但是只要破坏任意一个条件就死锁就不会成立。</p>
<ul>
<li><strong>设置事务等待锁的超时时间</strong>。</li>
<li><strong>开启主动死锁检测</strong>。</li>
</ul>
<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><ul>
<li><strong>undo log（回滚日志）</strong>：是 Innodb 存储引擎层生成的日志，实现了事务中的<strong>原子性</strong>，主要<strong>用于事务回滚和 MVCC</strong>。</li>
<li><strong>redo log（重做日志）</strong>：是 Innodb 存储引擎层生成的日志，实现了事务中的<strong>持久性</strong>，主要<strong>用于掉电等故障恢复</strong>；</li>
<li><strong>binlog （归档日志）</strong>：是 Server 层生成的日志，主要<strong>用于数据备份和主从复制</strong>；</li>
</ul>
<h3 id="Undo-log"><a href="#Undo-log" class="headerlink" title="Undo log"></a>Undo log</h3><p><img  src="/回滚事务.png"  ><span class="image-caption">回滚事务</span></p>
<ul>
<li><strong>事务回滚</strong></li>
<li><strong>通过 ReadView + undo log 实现 MVCC（多版本并发控制）</strong>。</li>
</ul>
<h3 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h3><ul>
<li><strong>实现事务的持久性，让 MySQL 有 crash-safe 的能力</strong>，能够保证 MySQL 在任何时间段突然崩溃，重启后之前已提交的记录都不会丢失；</li>
<li><strong>将写操作从「随机写」变成了「顺序写」</strong>，提升 MySQL 写入磁盘的性能。</li>
</ul>
<p><strong>WAL （Write-Ahead Logging）技术指的是， MySQL 的写操作并不是立刻写到磁盘上，而是先写日志，然后在合适的时间再写到磁盘上</strong>。</p>
<p>redo log 是物理日志，记录了某个数据页做了什么修改，比如<strong>对 XXX 表空间中的 YYY 数据页 ZZZ 偏移量的地方做了AAA 更新</strong>，每当执行一个事务就会产生这样的一条或者多条物理日志。</p>
<p>在事务提交时，只要先将 redo log 持久化到磁盘即可，可以不需要等到将缓存在 Buffer Pool 里的脏页数据持久化到磁盘。</p>
<p>当系统崩溃时，虽然脏页数据没有持久化，但是 redo log 已经持久化，接着 MySQL 重启后，可以根据 redo log 的内容，将所有数据恢复到最新的状态。</p>
<ul>
<li>redo log 记录了此次事务「<strong>修改后</strong>」的数据状态，记录的是更新<strong>之后</strong>的值，<strong>主要用于事务崩溃恢复，保证事务的持久性</strong>。</li>
<li>undo log 记录了此次事务「<strong>修改前</strong>」的数据状态，记录的是更新<strong>之前</strong>的值，<strong>主要用于事务回滚，保证事务的原子性</strong>。</li>
</ul>
<p>写入 redo log 的方式使用了追加操作， 所以磁盘操作是<strong>顺序写</strong>，而写入数据需要先找到写入位置，然后才写到磁盘，所以磁盘操作是<strong>随机写</strong>。</p>
<p>磁盘的「顺序写 」比「随机写」 高效的多，因此 redo log 写入磁盘的开销更小。</p>
<h3 id="redo-log-什么时候刷盘？"><a href="#redo-log-什么时候刷盘？" class="headerlink" title="redo log 什么时候刷盘？"></a>redo log 什么时候刷盘？</h3><ul>
<li>MySQL 正常关闭时；</li>
<li>当 redo log buffer 中记录的写入量大于 redo log buffer 内存空间的一半时，会触发落盘；</li>
<li>InnoDB 的后台线程每隔 1 秒，将 redo log buffer 持久化到磁盘。</li>
<li>每次事务提交时都将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘（这个策略可由 innodb_flush_log_at_trx_commit 参数控制，下面会说）。</li>
</ul>
<h3 id="redo-log-满了"><a href="#redo-log-满了" class="headerlink" title="redo log 满了"></a>redo log 满了</h3><p><img  src="/checkpoint.png"   style="zoom:50%;" /><span class="image-caption">img</span></p>
<p>如果 write pos 追上了 checkpoint，就意味着 <strong>redo log 文件满了，这时 MySQL 不能再执行新的更新操作，也就是说 MySQL 会被阻塞</strong>（<em>因此所以针对并发量大的系统，适当设置 redo log 的文件大小非常重要</em>），此时<strong>会停下来将 Buffer Pool 中的脏页刷新到磁盘中，然后标记 redo log 哪些记录可以被擦除，接着对旧的 redo log 记录进行擦除，等擦除完旧记录腾出了空间，checkpoint 就会往后移动（图中顺时针）</strong>，然后 MySQL 恢复正常运行，继续执行新的更新操作。</p>
<h3 id="为什么需要-binlog-？"><a href="#为什么需要-binlog-？" class="headerlink" title="为什么需要 binlog ？"></a>为什么需要 binlog ？</h3><p>前面介绍的 undo log 和 redo log 这两个日志都是 Innodb 存储引擎生成的。</p>
<p>MySQL 在完成一条更新操作后，Server 层还会生成一条 binlog，等之后事务提交的时候，会将该事物执行过程中产生的所有 binlog 统一写 入 binlog 文件。</p>
<p><strong>redo log 和 binlog 的区别</strong></p>
<p><em>1、适用对象不同：</em></p>
<ul>
<li>binlog 是 MySQL 的 Server 层实现的日志，所有存储引擎都可以使用；</li>
<li>redo log 是 Innodb 存储引擎实现的日志；</li>
</ul>
<p><em>2、文件格式不同：</em></p>
<ul>
<li>binlog 有 3 种格式类型，分别是 STATEMENT（默认格式）、ROW、 MIXED，区别如下：<ul>
<li>STATEMENT：每一条修改数据的 SQL 都会被记录到 binlog 中（相当于记录了逻辑操作，所以针对这种格式， binlog 可以称为逻辑日志），主从复制中 slave 端再根据 SQL 语句重现。但 STATEMENT 有动态函数的问题，比如你用了 uuid 或者 now 这些函数，你在主库上执行的结果并不是你在从库执行的结果，这种随时在变的函数会导致复制的数据不一致；</li>
<li>ROW：记录行数据最终被修改成什么样了（这种格式的日志，就不能称为逻辑日志了），不会出现 STATEMENT 下动态函数的问题。但 ROW 的缺点是每行数据的变化结果都会被记录，比如执行批量 update 语句，更新多少行数据就会产生多少条记录，使 binlog 文件过大，而在 STATEMENT 格式下只会记录一个 update 语句而已；</li>
<li>MIXED：包含了 STATEMENT 和 ROW 模式，它会根据不同的情况自动使用 ROW 模式和 STATEMENT 模式；</li>
</ul>
</li>
<li>redo log 是物理日志，记录的是在某个数据页做了什么修改，比如对 XXX 表空间中的 YYY 数据页 ZZZ 偏移量的地方做了AAA 更新；</li>
</ul>
<p><em>3、写入方式不同：</em></p>
<ul>
<li>binlog 是追加写，写满一个文件，就创建一个新的文件继续写，不会覆盖以前的日志，保存的是全量的日志。</li>
<li>redo log 是循环写，日志空间大小是固定，全部写满就从头开始，保存未被刷入磁盘的脏页日志。</li>
</ul>
<p><em>4、用途不同：</em></p>
<ul>
<li>binlog 用于备份恢复、主从复制；</li>
<li>redo log 用于掉电等故障恢复。</li>
</ul>
<blockquote>
<p>如果不小心整个数据库的数据被删除了，能使用 redo log 文件恢复数据吗？</p>
</blockquote>
<p>不可以使用 redo log 文件恢复，只能使用 binlog 文件恢复。</p>
<p>因为 redo log 文件是循环写，是会边写边擦除日志的，只记录未被刷入磁盘的数据的物理日志，已经刷入磁盘的数据都会从 redo log 文件里擦除。</p>
<p>binlog 文件保存的是全量的日志，也就是保存了所有数据变更的情况，理论上只要记录在 binlog 上的数据，都可以恢复，所以如果不小心整个数据库的数据被删除了，得用 binlog 文件恢复数据。</p>
<h3 id="主从复制是怎么实现？"><a href="#主从复制是怎么实现？" class="headerlink" title="主从复制是怎么实现？"></a>主从复制是怎么实现？</h3><p>MySQL 的主从复制依赖于 binlog ，也就是记录 MySQL 上的所有变化并以二进制形式保存在磁盘上。复制的过程就是将 binlog 中的数据从主库传输到从库上。</p>
<p>这个过程一般是<strong>异步</strong>的，也就是主库上执行事务操作的线程不会等待复制 binlog 的线程同步完成。</p>
<p><img  src="/主从复制过程.drawio.png"   style="zoom: 80%;" /><span class="image-caption">MySQL 主从复制过程</span></p>
<ul>
<li><strong>写入 Binlog</strong>：主库写 binlog 日志，提交事务，并更新本地存储数据。</li>
<li><strong>同步 Binlog</strong>：把 binlog 复制到所有从库上，每个从库把 binlog 写到暂存日志中。</li>
<li><strong>回放 Binlog</strong>：回放 binlog，并更新存储引擎中的数据。</li>
</ul>
<p>具体详细过程如下：</p>
<ul>
<li>MySQL 主库在收到客户端提交事务的请求之后，会先写入 binlog，再提交事务，更新存储引擎中的数据，事务提交完成后，返回给客户端“操作成功”的响应。</li>
<li>从库会创建一个专门的 I/O 线程，连接主库的 log dump 线程，来接收主库的 binlog 日志，再把 binlog 信息写入 relay log 的中继日志里，再返回给主库“复制成功”的响应。</li>
<li>从库会创建一个用于回放 binlog 的线程，去读 relay log 中继日志，然后回放 binlog 更新存储引擎中的数据，最终实现主从的数据一致性。</li>
</ul>
<blockquote>
<p>从库是不是越多越好？</p>
</blockquote>
<p>不是的。</p>
<p>因为从库数量增加，从库连接上来的 I/O 线程也比较多，<strong>主库也要创建同样多的 log dump 线程来处理复制的请求，对主库资源消耗比较高，同时还受限于主库的网络带宽</strong>。</p>
<p>所以在实际使用中，一个主库一般跟 2～3 个从库（1 套数据库，1 主 2 从 1 备主），这就是一主多从的 MySQL 集群结构。</p>
<blockquote>
<p>MySQL 主从复制还有哪些模型？</p>
</blockquote>
<p>主要有三种：</p>
<ul>
<li><strong>同步复制</strong>：MySQL 主库提交事务的线程要等待所有从库的复制成功响应，才返回客户端结果。这种方式在实际项目中，基本上没法用，原因有两个：一是性能很差，因为要复制到所有节点才返回响应；二是可用性也很差，主库和所有从库任何一个数据库出问题，都会影响业务。</li>
<li><strong>异步复制</strong>（默认模型）：MySQL 主库提交事务的线程并不会等待 binlog 同步到各从库，就返回客户端结果。这种模式一旦主库宕机，数据就会发生丢失。</li>
<li><strong>半同步复制</strong>：MySQL 5.7 版本之后增加的一种复制方式，介于两者之间，事务线程不用等待所有的从库复制成功响应，只要一部分复制成功响应回来就行，比如一主二从的集群，只要数据成功复制到任意一个从库上，主库的事务线程就可以返回给客户端。这种<strong>半同步复制的方式，兼顾了异步复制和同步复制的优点，即使出现主库宕机，至少还有一个从库有最新的数据，不存在数据丢失的风险</strong>。</li>
</ul>
<h3 id="为什么需要两阶段提交？"><a href="#为什么需要两阶段提交？" class="headerlink" title="为什么需要两阶段提交？"></a>为什么需要两阶段提交？</h3><p><strong>MySQL 为了避免出现两份日志之间的逻辑不一致的问题，使用了「两阶段提交」来解决</strong>，两阶段提交其实是分布式事务一致性协议，它可以保证多个逻辑操作要不全部成功，要不全部失败，不会出现半成功的状态。</p>
<p><strong>两阶段提交把单个事务的提交拆分成了 2 个阶段，分别是「准备（Prepare）阶段」和「提交（Commit）阶段」</strong>，每个阶段都由协调者（Coordinator）和参与者（Participant）共同完成。注意，不要把提交（Commit）阶段和 commit 语句混淆了，commit 语句执行的时候，会包含提交（Commit）阶段。</p>
<p>MySQL 使用了<strong>内部 XA 事务</strong>（是的，也有外部 XA 事务，跟本文不太相关，我就不介绍了），内部 XA 事务由 binlog 作为协调者，存储引擎是参与者。</p>
<p>当客户端执行 commit 语句或者在自动提交的情况下，MySQL 内部开启一个 XA 事务，<strong>分两阶段来完成 XA 事务的提交</strong>，如下图：</p>
<p><img  src="/两阶段提交.drawio.png"   style="zoom:80%;" /><span class="image-caption">两阶段提交</span></p>
<p>从图中可看出，事务的提交过程有两个阶段，就是<strong>将 redo log 的写入拆成了两个步骤：prepare 和 commit，中间再穿插写入binlog</strong>，具体如下：</p>
<ul>
<li><strong>prepare 阶段</strong>：将 XID（内部 XA 事务的 ID） 写入到 redo log，同时将 redo log 对应的事务状态设置为 prepare，然后将 redo log 持久化到磁盘（innodb_flush_log_at_trx_commit = 1 的作用）；</li>
<li><strong>commit 阶段</strong>：把 XID 写入到 binlog，然后将 binlog 持久化到磁盘（sync_binlog = 1 的作用），接着调用引擎的提交事务接口，将 redo log 状态设置为 commit，此时该状态并不需要持久化到磁盘，只需要 write 到文件系统的 page cache 中就够了，因为只要 binlog 写磁盘成功，就算 redo log 的状态还是 prepare 也没有关系，一样会被认为事务已经执行成功；</li>
</ul>
<p>两阶段提交虽然保证了两个日志文件的数据一致性，但是性能很差，主要有两个方面的影响：</p>
<ul>
<li><strong>磁盘 I/O 次数高</strong>：对于“双1”配置，每个事务提交都会进行两次 fsync（刷盘），一次是 redo log 刷盘，另一次是 binlog 刷盘。</li>
<li><strong>锁竞争激烈</strong>：两阶段提交虽然能够保证「单事务」两个日志的内容一致，但在「多事务」的情况下，却不能保证两者的提交顺序一致，因此，在两阶段提交的流程基础上，还需要加一个锁来保证提交的原子性，从而保证多事务的情况下，两个日志的提交顺序一致。</li>
</ul>
<p><strong>MySQL 引入了 binlog 组提交（group commit）机制，当有多个事务提交的时候，会将多个 binlog 刷盘操作合并成一个，从而减少磁盘 I/O 的次数</strong>，如果说 10 个事务依次排队刷盘的时间成本是 10，那么将这 10 个事务一次性一起刷盘的时间成本则近似于 1。</p>
<p>引入了组提交机制后，prepare 阶段不变，只针对 commit 阶段，将 commit 阶段拆分为三个过程：</p>
<ul>
<li><strong>flush 阶段</strong>：多个事务按进入的顺序将 binlog 从 cache 写入文件（不刷盘）；</li>
<li><strong>sync 阶段</strong>：对 binlog 文件做 fsync 操作（多个事务的 binlog 合并一次刷盘）；</li>
<li><strong>commit 阶段</strong>：各个事务按顺序做 InnoDB commit 操作；</li>
</ul>
<p>上面的<strong>每个阶段都有一个队列</strong>，每个阶段有锁进行保护，因此保证了事务写入的顺序，第一个进入队列的事务会成为 leader，leader领导所在队列的所有事务，全权负责整队的操作，完成后通知队内其他事务操作结束。</p>
<p>对每个阶段引入了队列后，锁就只针对每个队列进行保护，不再锁住提交事务的整个过程，可以看的出来，<strong>锁粒度减小了，这样就使得多个阶段可以并发执行，从而提升效率</strong>。</p>
<h1 id="Redis-1"><a href="#Redis-1" class="headerlink" title="Redis"></a>Redis</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p><strong>String（字符串），Hash（哈希），List（列表），Set（集合）、Zset（有序集合）</strong>。</p>
<p><img  src="key.png"  ><span class="image-caption">img</span></p>
<p>后续增加了：BitMap（2.2 版新增）、HyperLogLog（2.8 版新增）、GEO（3.2 版新增）、Stream（5.0 版新增）。</p>
<ul>
<li>String 类型的应用场景：缓存对象、常规计数、分布式锁、共享 session 信息等。<ul>
<li>SDS（简单动态字符串），不仅可以保存文本数据，还可以保存二进制数据**。因为 SDS 使用 len 属性的值而不是空字符来判断字符串是否结束。</li>
<li><strong>SDS 获取字符串长度的时间复杂度是 O(1)</strong></li>
<li><strong>拼接字符串不会造成缓冲区溢出</strong></li>
</ul>
</li>
<li>List 类型的应用场景：消息队列（但是有两个问题：1. 生产者需要自行实现全局唯一 ID；2. 不能以消费组形式消费数据）等。<ul>
<li>压缩链表</li>
<li>双向链表</li>
<li>3.2 之后只有 quicklist</li>
</ul>
</li>
<li>Hash 类型：缓存对象、购物车等。<ul>
<li><strong>压缩列表或哈希表</strong></li>
</ul>
</li>
<li>Set 类型：聚合计算（并集、交集、差集）场景，比如点赞、共同关注、抽奖活动等。<ul>
<li>整数集合（元素都是整数且元素个数小于 512）</li>
<li><strong>哈希表</strong></li>
</ul>
</li>
<li>Zset 类型：排序场景，比如排行榜、电话和姓名排序等。<ul>
<li>压缩列表</li>
<li>跳表</li>
</ul>
</li>
</ul>
<p>Redis 后续版本又支持四种数据类型，它们的应用场景如下：</p>
<ul>
<li>BitMap（2.2 版新增）：二值状态统计的场景，比如签到、判断用户登陆状态、连续签到用户总数等；</li>
<li>HyperLogLog（2.8 版新增）：海量数据基数统计的场景，比如百万级网页 UV 计数等；</li>
<li>GEO（3.2 版新增）：存储地理位置信息的场景，比如滴滴叫车；</li>
<li>Stream（5.0 版新增）：消息队列，相比于基于 List 类型实现的消息队列，有这两个特有的特性：自动生成全局唯一消息ID，支持以消费组形式消费数据。</li>
</ul>
<h2 id="单线程模型"><a href="#单线程模型" class="headerlink" title="单线程模型"></a>单线程模型</h2><p><strong>Redis 单线程指的是「接收客户端请求-&gt;解析请求 -&gt;进行数据读写等操作-&gt;发送数据给客户端」这个过程是由一个线程（主线程）来完成的</strong>，这也是我们常说 Redis 是单线程的原因。</p>
<p>但是，<strong>Redis 程序并不是单线程的</strong>，Redis 在启动的时候，是会<strong>启动后台线程</strong>（BIO）的：</p>
<ul>
<li><strong>Redis 在 2.6 版本</strong>，会启动 2 个后台线程，分别处理关闭文件、AOF 刷盘这两个任务；</li>
<li><strong>Redis 在 4.0 版本之后</strong>，新增了一个新的后台线程，用来异步释放 Redis 内存，也就是 lazyfree 线程。例如执行 unlink key / flushdb async / flushall async 等命令，会把这些删除操作交给后台线程来执行，好处是不会导致 Redis 主线程卡顿。因此，当我们要删除一个大 key 的时候，不要使用 del 命令删除，因为 del 是在主线程处理的，这样会导致 Redis 主线程卡顿，因此我们应该使用 unlink 命令来异步删除大key。</li>
</ul>
<p>关闭文件、AOF 刷盘、释放内存这三个任务都有各自的任务队列：</p>
<ul>
<li><strong>BIO_CLOSE_FILE</strong>，关闭文件任务队列：当队列有任务后，后台线程会调用 close(fd) ，将文件关闭；</li>
<li><strong>BIO_AOF_FSYNC</strong>，AOF刷盘任务队列：当 AOF 日志配置成 everysec 选项后，主线程会把 AOF 写日志操作封装成一个任务，也放到队列中。当发现队列有任务后，后台线程会调用 fsync(fd)，将 AOF 文件刷盘，</li>
<li><strong>BIO_LAZY_FREE</strong>，lazy free 任务队列：当队列有任务后，后台线程会 free(obj) 释放对象 / free(dict) 删除数据库所有对象 / free(skiplist) 释放跳表对象；</li>
</ul>
<p><img  src="/redis单线程模型.drawio.png"   style="zoom: 50%;" /><span class="image-caption">img</span></p>
<ul>
<li>Redis 的大部分操作<strong>都在内存中完成</strong>，并且采用了高效的数据结构，因此 Redis 瓶颈可能是机器的内存或者网络带宽，而并非 CPU，既然 CPU 不是瓶颈，那么自然就采用单线程的解决方案了；</li>
<li>Redis 采用单线程模型可以<strong>避免了多线程之间的竞争</strong>，省去了多线程切换带来的时间和性能上的开销，而且也不会导致死锁问题。</li>
<li>Redis 采用了 <strong>I/O 多路复用机制</strong>处理大量的客户端 Socket 请求，IO 多路复用机制是指一个线程处理多个 IO 流，就是我们经常听到的 select/epoll 机制。</li>
</ul>
<h3 id="Redis-6-0-之前为什么使用单线程？"><a href="#Redis-6-0-之前为什么使用单线程？" class="headerlink" title="Redis 6.0 之前为什么使用单线程？"></a>Redis 6.0 之前为什么使用单线程？</h3><p><strong>CPU 并不是制约 Redis 性能表现的瓶颈所在</strong>，更多情况下是受到内存大小和网络I/O的限制，所以 Redis 核心网络模型使用单线程并没有什么问题，如果你想要使用服务的多核CPU，可以在一台服务器上启动多个节点或者采用分片集群的方式。</p>
<h3 id="Redis-6-0-之后为什么引入了多线程？"><a href="#Redis-6-0-之后为什么引入了多线程？" class="headerlink" title="Redis 6.0 之后为什么引入了多线程？"></a>Redis 6.0 之后为什么引入了多线程？</h3><p><strong>在 Redis 6.0 版本之后，也采用了多个 I/O 线程来处理网络请求</strong>，<strong>这是因为随着网络硬件的性能提升，Redis 的性能瓶颈有时会出现在网络 I/O 的处理上</strong>。</p>
<p>所以为了提高网络 I/O 的并行度，Redis 6.0 对于网络 I/O 采用多线程来处理。<strong>但是对于命令的执行，Redis 仍然使用单线程来处理，所以大家不要误解</strong> Redis 有多线程同时执行命令。</p>
<p>Redis 6.0 版本之后，Redis 在启动的时候，默认情况下会<strong>额外创建 6 个线程</strong>（<em>这里的线程数不包括主线程</em>）：</p>
<ul>
<li>Redis-server ： Redis的主线程，主要负责执行命令；</li>
<li>bio_close_file、bio_aof_fsync、bio_lazy_free：三个后台线程，分别异步处理关闭文件任务、AOF刷盘任务、释放内存任务；</li>
<li>io_thd_1、io_thd_2、io_thd_3：三个 I/O 线程，io-threads 默认是 4 ，所以会启动 3（4-1）个 I/O 多线程，用来分担 Redis 网络 I/O 的压力。</li>
</ul>
<h2 id="Redis-持久化"><a href="#Redis-持久化" class="headerlink" title="Redis 持久化"></a>Redis 持久化</h2><p>Redis 共有三种数据持久化的方式：</p>
<ul>
<li><strong>AOF 日志</strong>：每执行一条写操作命令，就把该命令以追加的方式写入到一个文件里；</li>
<li><strong>RDB 快照</strong>：将某一时刻的内存数据，以二进制的方式写入磁盘；</li>
<li><strong>混合持久化方式</strong>：Redis 4.0 新增的方式，集成了 AOF 和 RDB 的优点；</li>
</ul>
<h3 id="AOF-日志是如何实现的？"><a href="#AOF-日志是如何实现的？" class="headerlink" title="AOF 日志是如何实现的？"></a>AOF 日志是如何实现的？</h3><p>Redis 在执行完一条写操作命令后，就会把该命令以追加的方式写入到一个文件里，然后 Redis 重启时，会读取该文件记录的命令，然后逐一执行命令的方式来进行数据恢复。</p>
<p>为什么先执行命令，再把数据写入日志呢？</p>
<ul>
<li><strong>避免额外的检查开销</strong></li>
<li><strong>不会阻塞当前写操作命令的执行</strong>：因为当写操作命令执行成功后，才会将命令记录到 AOF 日志。</li>
</ul>
<p>风险</p>
<ul>
<li><strong>数据可能会丢失</strong></li>
<li><strong>可能阻塞其他操作</strong></li>
</ul>
<h3 id="AOF-写回策略有几种？"><a href="#AOF-写回策略有几种？" class="headerlink" title="AOF 写回策略有几种？"></a>AOF 写回策略有几种？</h3><ol>
<li>Redis 执行完写操作命令后，会将命令追加到 server.aof_buf 缓冲区；</li>
<li>然后通过 write() 系统调用，将 aof_buf 缓冲区的数据写入到 AOF 文件，此时数据并没有写入到硬盘，而是拷贝到了内核缓冲区 page cache，等待内核将数据写入硬盘；</li>
<li>具体内核缓冲区的数据什么时候写入到硬盘，由内核决定。</li>
</ol>
<p>Redis 提供了 3 种写回硬盘的策略，控制的就是上面说的第三步的过程。 在 Redis.conf 配置文件中的 appendfsync 配置项可以有以下 3 种参数可填：</p>
<ul>
<li><strong>Always</strong>，这个单词的意思是「总是」，所以它的意思是每次写操作命令执行完后，同步将 AOF 日志数据写回硬盘；</li>
<li><strong>Everysec</strong>，这个单词的意思是「每秒」，所以它的意思是每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，然后每隔一秒将缓冲区里的内容写回到硬盘；</li>
<li><strong>No</strong>，意味着不由 Redis 控制写回硬盘的时机，转交给操作系统控制写回的时机，也就是每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，再由操作系统决定何时将缓冲区内容写回硬盘。</li>
</ul>
<h3 id="AOF-日志过大，会触发什么机制？"><a href="#AOF-日志过大，会触发什么机制？" class="headerlink" title="AOF 日志过大，会触发什么机制？"></a>AOF 日志过大，会触发什么机制？</h3><p>Redis 为了避免 AOF 文件越写越大，提供了 <strong>AOF 重写机制</strong>，当 AOF 文件的大小超过所设定的阈值后，Redis 就会启用 AOF 重写机制，来压缩 AOF 文件。</p>
<p>AOF 重写机制是在重写时，读取当前数据库中的所有键值对，然后将每一个键值对用一条命令记录到「新的 AOF 文件」，等到全部记录完后，就将新的 AOF 文件替换掉现有的 AOF 文件。</p>
<h3 id="重写-AOF-日志的过程是怎样的？"><a href="#重写-AOF-日志的过程是怎样的？" class="headerlink" title="重写 AOF 日志的过程是怎样的？"></a>重写 AOF 日志的过程是怎样的？</h3><p>Redis 的<strong>重写 AOF 过程是由后台子进程 *bgrewriteaof* 来完成的</strong>，这么做可以达到两个好处：</p>
<ul>
<li>子进程进行 AOF 重写期间，主进程可以继续处理命令请求，从而避免阻塞主进程；</li>
<li>子进程带有主进程的数据副本，这里使用子进程而不是线程，因为如果是使用线程，多线程之间会共享内存，那么在修改共享内存数据的时候，需要通过加锁来保证数据的安全，而这样就会降低性能。而使用子进程，创建子进程时，父子进程是共享内存数据的，不过这个共享的内存只能以只读的方式，而当父子进程任意一方修改了该共享内存，就会发生「写时复制」，于是父子进程就有了独立的数据副本，就不用加锁来保证数据安全。</li>
</ul>
<p><strong>但是重写过程中，主进程依然可以正常处理命令</strong>，那问题来了，重写 AOF 日志过程中，如果主进程修改了已经存在 key-value，那么会发生写时复制，此时这个 key-value 数据在子进程的内存数据就跟主进程的内存数据不一致了，这时要怎么办呢？</p>
<p>为了解决这种数据不一致问题，Redis 设置了一个 <strong>AOF 重写缓冲区</strong>，这个缓冲区在创建 bgrewriteaof 子进程之后开始使用。</p>
<p>在重写 AOF 期间，当 Redis 执行完一个写命令之后，它会<strong>同时将这个写命令写入到 「AOF 缓冲区」和 「AOF 重写缓冲区」</strong>。</p>
<p><img  src="/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0ODI3Njc0,size_16,color_FFFFFF,t_70-20230309232301042.png"   style="zoom: 50%;" /><span class="image-caption">img</span></p>
<p>也就是说，在 bgrewriteaof 子进程执行 AOF 重写期间，主进程需要执行以下三个工作:</p>
<ul>
<li>执行客户端发来的命令；</li>
<li>将执行后的写命令追加到 「AOF 缓冲区」；</li>
<li>将执行后的写命令追加到 「AOF 重写缓冲区」；</li>
</ul>
<p>当子进程完成 AOF 重写工作（<em>扫描数据库中所有数据，逐一把内存数据的键值对转换成一条命令，再将命令记录到重写日志</em>）后，会向主进程发送一条信号，信号是进程间通讯的一种方式，且是异步的。</p>
<p>主进程收到该信号后，会调用一个信号处理函数，该函数主要做以下工作：</p>
<ul>
<li>将 AOF 重写缓冲区中的所有内容追加到新的 AOF 的文件中，使得新旧两个 AOF 文件所保存的数据库状态一致；</li>
<li>新的 AOF 的文件进行改名，覆盖现有的 AOF 文件。</li>
</ul>
<p>信号函数执行完后，主进程就可以继续像往常一样处理命令了。</p>
<h3 id="RDB-快照是如何实现的呢？"><a href="#RDB-快照是如何实现的呢？" class="headerlink" title="RDB 快照是如何实现的呢？"></a>RDB 快照是如何实现的呢？</h3><p>Redis 增加了 RDB 快照。RDB 快照就是记录某一个瞬间的内存数据，记录的是实际数据，而 AOF 文件记录的是命令操作的日志，而不是实际的数据。</p>
<p><strong>RDB 做快照时会阻塞线程吗？</strong></p>
<ul>
<li>执行了 save 命令，就会在主线程生成 RDB 文件，由于和执行操作命令在同一个线程，所以如果写入 RDB 文件的时间太长，<strong>会阻塞主线程</strong>；</li>
<li>执行了 bgsave 命令，会创建一个子进程来生成 RDB 文件，这样可以<strong>避免主线程的阻塞</strong>；</li>
</ul>
<p>Redis 的快照是<strong>全量快照</strong>，也就是说每次执行快照，都是把内存中的「所有数据」都记录到磁盘中。所以执行快照是一个比较重的操作，如果频率太频繁，可能会对 Redis 性能产生影响。如果频率太低，服务器故障时，丢失的数据会更多。</p>
<p><strong>RDB 在执行快照的时候，数据能修改吗？</strong></p>
<p>可以的，执行 bgsave 过程中，Redis 依然<strong>可以继续处理操作命令</strong>的，也就是数据是能被修改的，关键的技术就在于<strong>写时复制技术（Copy-On-Write, COW）。</strong></p>
<p>执行 bgsave 命令的时候，会通过 fork() 创建子进程，此时子进程和父进程是共享同一片内存数据的，因为创建子进程的时候，会复制父进程的页表，但是页表指向的物理内存还是一个，此时如果主线程执行读操作，则主线程和 bgsave 子进程互相不影响。</p>
<p>如果主线程执行写操作，则<strong>被修改的数据会复制一份副本</strong>，然后 bgsave 子进程会把该副本数据写入 RDB 文件，在这个过程中，主线程仍然可以直接修改原来的数据。</p>
<h3 id="为什么会有混合持久化？"><a href="#为什么会有混合持久化？" class="headerlink" title="为什么会有混合持久化？"></a>为什么会有混合持久化？</h3><p>混合持久化工作在 <strong>AOF 日志重写过程</strong>，当开启了混合持久化时，在 AOF 重写日志时，fork 出来的重写子进程会先将与主线程共享的内存数据<strong>（1）以 RDB 方式写入到 AOF 文件</strong>，然后主线程处理的操作命令会被记录在重写缓冲区里，<strong>（2）重写缓冲区里的增量命令会以 AOF 方式写入到 AOF 文件</strong>，写入完成后通知主进程将新的<strong>含有 RDB 格式和 AOF 格式的 AOF 文件替换旧的的 AOF 文件</strong>。</p>
<p>也就是说，使用了混合持久化，AOF 文件的<strong>前半部分是 RDB 格式的全量数据，后半部分是 AOF 格式的增量数据</strong>。</p>
<p><strong>混合持久化优点：</strong></p>
<ul>
<li>混合持久化结合了 RDB 和 AOF 持久化的优点，开头为 RDB 的格式，使得 Redis 可以更快的启动，同时结合 AOF 的优点，有减低了大量数据丢失的风险。</li>
</ul>
<p><strong>混合持久化缺点：</strong></p>
<ul>
<li>AOF 文件中添加了 RDB 格式的内容，使得 AOF 文件的可读性变得很差；</li>
<li>兼容性差，如果开启混合持久化，那么此混合持久化 AOF 文件，就不能用在 Redis 4.0 之前版本了。</li>
</ul>
<h2 id="Redis-集群"><a href="#Redis-集群" class="headerlink" title="Redis 集群"></a>Redis 集群</h2><h3 id="Redis-如何实现服务高可用？"><a href="#Redis-如何实现服务高可用？" class="headerlink" title="Redis 如何实现服务高可用？"></a>Redis 如何实现服务高可用？</h3><p>Redis 的主从复制、哨兵模式、切片集群。</p>
<h4 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a><strong>主从复制</strong></h4><p>主从复制是 Redis 高可用服务的最基础的保证，实现方案就是将从前的一台 Redis 服务器，同步数据到多台从 Redis 服务器上，即一主多从的模式，且主从服务器之间采用的是「读写分离」的方式。</p>
<p>主服务器可以进行读写操作，当发生写操作时自动将写操作同步给从服务器，而从服务器一般是只读，并接受主服务器同步过来写操作命令，然后执行这条命令。</p>
<p>主从服务器之间的命令复制是<strong>异步</strong>进行的。</p>
<p>具体来说，在主从服务器命令传播阶段，主服务器收到新的写命令后，会发送给从服务器。但是，主服务器并不会等到从服务器实际执行完命令后，再把结果返回给客户端，而是主服务器自己在本地执行完命令后，就会向客户端返回结果了。如果从服务器还没有执行主服务器同步过来的命令，主从服务器间的数据就不一致了。</p>
<p>具体包括：<strong>全量复制、基于长连接的命令传播、增量复制</strong>。</p>
<p>主从服务器第一次同步的时候，就是采用全量复制，此时主服务器会两个耗时的地方，分别是生成 RDB 文件和传输 RDB 文件。为了避免过多的从服务器和主服务器进行全量复制，可以把一部分从服务器升级为「经理角色」，让它也有自己的从服务器，通过这样可以分摊主服务器的压力。</p>
<p>第一次同步完成后，主从服务器都会维护着一个长连接，主服务器在接收到写操作命令后，就会通过这个连接将写命令传播给从服务器，来保证主从服务器的数据一致性。</p>
<p>如果遇到网络断开，增量复制就可以上场了，不过这个还跟 repl_backlog_size 这个大小有关系。</p>
<p>如果它配置的过小，主从服务器网络恢复时，可能发生「从服务器」想读的数据已经被覆盖了，那么这时就会导致主服务器采用全量复制的方式。所以为了避免这种情况的频繁发生，要调大这个参数的值，以降低主从服务器断开后全量同步的概率。</p>
<h4 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a><strong>哨兵模式</strong></h4><p>在使用 Redis 主从服务的时候，会有一个问题，就是当 Redis 的主从服务器出现故障宕机时，需要手动进行恢复。</p>
<p>为了解决这个问题，Redis 增加了哨兵模式（<strong>Redis Sentinel</strong>），因为哨兵模式做到了可以监控主从服务器，并且提供<strong>主从节点故障转移的功能。</strong></p>
<p>哨兵节点主要负责三件事情：<strong>监控、选主、通知</strong>。</p>
<p><strong>监控</strong></p>
<p>哨兵会每隔 1 秒给所有主从节点发送 PING 命令，当主从节点收到 PING 命令后，会发送一个响应命令给哨兵，这样就可以判断它们是否在正常运行。</p>
<p>如果主节点或者从节点没有在规定的时间内响应哨兵的 PING 命令，哨兵就会将它们标记为「<strong>主观下线</strong>」。</p>
<p>之所以针对「主节点」设计「主观下线」和「客观下线」两个状态，是因为有可能「主节点」其实并没有故障，可能只是因为主节点的系统压力比较大或者网络发送了拥塞，导致主节点没有在规定时间内响应哨兵的 PING 命令。</p>
<p>所以，为了减少误判的情况，哨兵在部署的时候不会只部署一个节点，而是用多个节点部署成<strong>哨兵集群</strong>（<em>最少需要三台机器来部署哨兵集群</em>），<strong>通过多个哨兵节点一起判断，就可以就可以避免单个哨兵因为自身网络状况不好，而误判主节点下线的情况</strong>。同时，多个哨兵的网络同时不稳定的概率较小，由它们一起做决策，误判率也能降低。</p>
<p>具体是怎么判定主节点为「客观下线」的呢？</p>
<p>当一个哨兵判断主节点为「主观下线」后，就会向其他哨兵发起命令，其他哨兵收到这个命令后，就会根据自身和主节点的网络状况，做出赞成投票或者拒绝投票的响应。</p>
<p>当这个哨兵的赞同票数达到哨兵配置文件中的 quorum 配置项设定的值后，这时主节点就会被该哨兵标记为「客观下线」。</p>
<p>哨兵判断完主节点客观下线后，哨兵就要开始在多个「从节点」中，选出一个从节点来做新主节点。</p>
<p><strong>选主</strong></p>
<p>为了更加“客观”的判断主节点故障了，一般不会只由单个哨兵的检测结果来判断，而是多个哨兵一起判断，这样可以减少误判概率，所以<strong>哨兵是以哨兵集群的方式存在的</strong>。</p>
<p>问题来了，由哨兵集群中的哪个节点进行主从故障转移呢？</p>
<p>所以这时候，还需要在哨兵集群中选出一个 leader，让 leader 来执行主从切换。</p>
<p>选举 leader 的过程其实是一个投票的过程，在投票开始前，肯定得有个「候选者」。</p>
<blockquote>
<p>那谁来作为候选者呢？</p>
</blockquote>
<p>哪个哨兵节点判断主节点为「客观下线」，这个哨兵节点就是候选者，所谓的候选者就是想当 Leader 的哨兵。</p>
<blockquote>
<p>候选者如何选举成为 Leader？</p>
</blockquote>
<p>候选者会向其他哨兵发送命令，表明希望成为 Leader 来执行主从切换，并让所有其他哨兵对它进行投票。</p>
<p>每个哨兵只有一次投票机会，如果用完后就不能参与投票了，可以投给自己或投给别人，但是只有候选者才能把票投给自己。</p>
<p>那么在投票过程中，任何一个「候选者」，要满足两个条件：</p>
<ul>
<li>第一，拿到半数以上的赞成票；</li>
<li>第二，拿到的票数同时还需要大于等于哨兵配置文件中的 quorum 值。</li>
</ul>
<p>举个例子，假设哨兵节点有 3 个，quorum 设置为 2，那么任何一个想成为 Leader 的哨兵只要拿到 2 张赞成票，就可以选举成功了。如果没有满足条件，就需要重新进行选举。</p>
<blockquote>
<p> 为什么哨兵节点至少要有 3 个？</p>
</blockquote>
<p>如果哨兵集群中只有 2 个哨兵节点，此时如果一个哨兵想要成功成为 Leader，必须获得 2 票，而不是 1 票。</p>
<p>Redis 1 主 4 从，5 个哨兵，quorum 设置为 3，如果 2 个哨兵故障，当主节点宕机时，哨兵能否判断主节点“客观下线”？主从能否自动切换？</p>
<ul>
<li><strong>哨兵集群可以判定主节点“客观下线”</strong>。哨兵集群还剩下 3 个哨兵，当一个哨兵判断主节点“主观下线”后，询问另外 2 个哨兵后，有可能能拿到 3 张赞同票，这时就达到了 quorum 的值，因此，哨兵集群可以判定主节点为“客观下线”。</li>
<li><strong>哨兵集群可以完成主从切换</strong>。当有个哨兵标记主节点为「客观下线」后，就会进行选举 Leader 的过程，因为此时哨兵集群还剩下 3 个哨兵，那么还是可以拿到半数以上（5/2+1=3）的票，而且也达到了 quorum 值，满足了选举 Leader 的两个条件，所以就能选举成功，因此哨兵集群可以完成主从切换。</li>
</ul>
<p>所以，<strong>quorum 的值建议设置为哨兵个数的二分之一加 1</strong>，例如 3 个哨兵就设置 2，5 个哨兵设置为 3，而且<strong>哨兵节点的数量应该是奇数</strong>。</p>
<h4 id="切片集群模式"><a href="#切片集群模式" class="headerlink" title="切片集群模式"></a>切片集群模式</h4><p>当 Redis 缓存数据量大到一台服务器无法缓存时，就需要使用 <strong>Redis 切片集群</strong>（Redis Cluster ）方案，它将数据分布在不同的服务器上，以此来降低系统对单主节点的依赖，从而提高 Redis 服务的读写性能。</p>
<p>Redis Cluster 方案采用哈希槽（Hash Slot），来处理数据和节点之间的映射关系。在 Redis Cluster 方案中，<strong>一个切片集群共有 16384 个哈希槽</strong>，这些哈希槽类似于数据分区，每个键值对都会根据它的 key，被映射到一个哈希槽中，具体执行过程分为两大步：</p>
<ul>
<li>根据键值对的 key，按照 <a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check">CRC16 算法</a>计算一个 16 bit 的值。</li>
<li>再用 16bit 值对 16384 取模，得到 0~16383 范围内的模数，每个模数代表一个相应编号的哈希槽。</li>
</ul>
<p>接下来的问题就是，这些哈希槽怎么被映射到具体的 Redis 节点上的呢？有两种方案：</p>
<ul>
<li><strong>平均分配：</strong> 在使用 cluster create 命令创建 Redis 集群时，Redis 会自动把所有哈希槽平均分布到集群节点上。比如集群中有 9 个节点，则每个节点上槽的个数为 16384/9 个。</li>
<li><strong>手动分配：</strong> 可以使用 cluster meet 命令手动建立节点间的连接，组成集群，再使用 cluster addslots 命令，指定每个节点上的哈希槽个数。</li>
</ul>
<p>需要注意的是，在手动分配哈希槽时，需要把 16384 个槽都分配完，否则 Redis 集群无法正常工作。</p>
<p><img  src="/webp.webp"  ><span class="image-caption">codis</span></p>
<p>Codis 使用 Go 语言开发，它是一个代理中间件，它和 Redis 一样也使用 Redis 协议对外提供服务，当客户端向 Codis 发送指令时，Codis 负责将指令转发到后面的 Redis 实例来执行，并将返回结果再转回给客户端。</p>
<p>Codis 上挂接的所有 Redis 实例构成一个 Redis 集群，当集群空间不足时，可以通过动态增加 Redis 实例来实现扩容需求。</p>
<p>客户端操纵 Codis 同操纵 Redis 几乎没有区别，还是可以使用相同的客户端 SDK，不需要任何变化。</p>
<p>因为 Codis 是无状态的，它只是一个转发代理中间件，这意味着我们可以启动多个 Codis 实例，供客户端使用，每个 Codis 节点都是对等的。因为单个 Codis 代理能支撑的 QPS 比较有限，通过启动多个 Codis 代理可以显著增加整体的 QPS 需求，还能起到容灾功能，挂掉一个 Codis 代理没关系，还有很多 Codis 代理可以继续服务。</p>
<p><img  src="/webp-1743050895082-7.webp"  ><span class="image-caption">img</span></p>
<h5 id="Codis-分片原理"><a href="#Codis-分片原理" class="headerlink" title="Codis 分片原理"></a>Codis 分片原理</h5><p>Codis 要负责将特定的 key 转发到特定的 Redis 实例，那么这种对应关系 Codis 是如何管理的呢？</p>
<p>Codis 将所有的 key 默认划分为 1024 个槽位(slot)，它首先对客户端传过来的 key 进行 crc32 运算计算哈希值，再将 hash 后的整数值对 1024 这个整数进行取模得到一个余数，这个余数就是对应 key 的槽位。</p>
<p>每个槽位都会唯一映射到后面的多个 Redis 实例之一，Codis 会在内存维护槽位和 Redis 实例的映射关系。这样有了上面 key 对应的槽位，那么它应该转发到哪个 Redis 实例就很明确了。</p>
<p>槽位数量默认是1024，它是可以配置的，如果集群节点比较多，建议将这个数值配置大一些，比如2048、4096。</p>
<h5 id="不同的-Codis-实例之间槽位关系如何同步？"><a href="#不同的-Codis-实例之间槽位关系如何同步？" class="headerlink" title="不同的 Codis 实例之间槽位关系如何同步？"></a>不同的 Codis 实例之间槽位关系如何同步？</h5><p>如果 Codis 的槽位映射关系只存储在内存里，那么不同的 Codis 实例之间的槽位关系就无法得到同步。所以 Codis 还需要一个分布式配置存储数据库专门用来持久化槽位关系。Codis 开始使用 ZooKeeper，后来连 etcd 也一块支持了。</p>
<p>Codis 将槽位关系存储在 zk 中，并且提供了一个 Dashboard 可以用来观察和修改槽位关系，当槽位关系变化时，Codis Proxy 会监听到变化并重新同步槽位关系，从而实现多个 Codis Proxy 之间共享相同的槽位关系配置。</p>
<h5 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h5><p>刚开始 Codis 后端只有一个 Redis 实例，1024 个槽位全部指向同一个 Redis。然后一个 Redis 实例内存不够了，所以又加了一个 Redis 实例。这时候需要对槽位关系进行调整，将一半的槽位划分到新的节点。这意味着需要对这一半的槽位对应的所有 key 进行迁移，迁移到新的 Redis 实例。</p>
<p><strong>那 Codis 如何找到槽位对应的所有 key 呢？</strong></p>
<p>Codis 对 Redis 进行了改造，增加了 SLOTSSCAN 指令，可以遍历指定 slot 下所有的 key。Codis 通过 SLOTSSCAN 扫描出待迁移槽位的所有的 key，然后挨个迁移每个 key 到新的 Redis 节点。</p>
<p>在迁移过程中，Codis 还是会接收到新的请求打在当前正在迁移的槽位上，因为当前槽位的数据同时存在于新旧两个槽位中，Codis 如何判断该将请求转发到后面的哪个具体实例呢？</p>
<p>Codis 无法判定迁移过程中的 key 究竟在哪个实例中，所以它采用了另一种完全不同的思路。当 Codis 接收到位于正在迁移槽位中的 key 后，会立即强制对当前的单个 key 进行迁移，迁移完成后，再将请求转发到新的 Redis 实例。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">slot_index = crc32(command.key) % 1024<br><span class="hljs-keyword">if</span> slot_index <span class="hljs-keyword">in</span> migrating_slots:<br>    do_migrate_key(command.key)  <span class="hljs-comment"># 强制执行迁移</span><br>    redis = slots[slot_index].new_redis<br><span class="hljs-keyword">else</span>:<br>    redis = slots[slot_index].redis<br>redis.do(<span class="hljs-built_in">command</span>)<br></code></pre></td></tr></table></figure>
<p>我们知道 Redis 支持的所有 Scan 指令都是无法避免重复的，同样 Codis 自定义的 SLOTSSCAN 也是一样，但是这并不会影响迁移。因为单个 key 被迁移一次后，在旧实例中它就彻底被删除了，也就不可能会再次被扫描出来了。</p>
<h5 id="自动均衡"><a href="#自动均衡" class="headerlink" title="自动均衡"></a>自动均衡</h5><p>Redis 新增实例，手工均衡slots太繁琐，所以 Codis 提供了自动均衡功能。自动均衡会在系统比较空闲的时候观察每个 Redis 实例对应的 Slots 数量，如果不平衡，就会自动进行迁移。</p>
<p><strong>Codis 的代价</strong></p>
<p>Codis 给 Redis 带来了扩容的同时，也损失了其它一些特性。因为 Codis 中所有的 key 分散在不同的 Redis 实例中，所以事务就不能再支持了，事务只能在单个 Redis 实例中完成。同样 rename 操作也很危险，它的参数是两个 key，如果这两个 key 在不同的 Redis 实例中，rename 操作是无法正确完成的。Codis 的官方文档中给出了一系列不支持的命令列表。</p>
<p>同样为了支持扩容，单个 key 对应的 value 不宜过大，因为集群的迁移的最小单位是 key，对于一个 hash 结构，它会一次性使用 hgetall 拉取所有的内容，然后使用 hmset 放置到另一个节点。如果 hash 内部的 kv 太多，可能会带来迁移卡顿。官方建议单个集合结构的总字节容量不要超过 1M。如果我们要放置社交关系数据，例如粉丝列表这种，就需要注意了，可以考虑分桶存储，在业务上作折中。</p>
<p>Codis 因为增加了 Proxy 作为中转层，所有在网络开销上要比单个 Redis 大，毕竟数据包多走了一个网络节点，整体在性能上要比单个 Redis 的性能有所下降。但是这部分性能损耗不是太明显，可以通过增加 Proxy 的数量来弥补性能上的不足。</p>
<p>Codis 的集群配置中心使用 zk 来实现，意味着在部署上增加了 zk 运维的代价，不过大部分互联网企业内部都有 zk 集群，可以使用现有的 zk 集群使用即可。</p>
<h3 id="集群脑裂导致数据丢失怎么办？"><a href="#集群脑裂导致数据丢失怎么办？" class="headerlink" title="集群脑裂导致数据丢失怎么办？"></a>集群脑裂导致数据丢失怎么办？</h3><p>在 Redis 主从架构中，部署方式一般是「一主多从」，主节点提供写操作，从节点提供读操作。 如果主节点的网络突然发生了问题，它与所有的从节点都失联了，但是此时的主节点和客户端的网络是正常的，这个客户端并不知道 Redis 内部已经出现了问题，还在照样的向这个失联的主节点写数据（过程A），此时这些数据被旧主节点缓存到了缓冲区里，因为主从节点之间的网络问题，这些数据都是无法同步给从节点的。</p>
<p>这时，哨兵也发现主节点失联了，它就认为主节点挂了（但实际上主节点正常运行，只是网络出问题了），于是哨兵就会在「从节点」中选举出一个 leader 作为主节点，这时集群就有两个主节点了 —— <strong>脑裂出现了</strong>。</p>
<p>然后，网络突然好了，哨兵因为之前已经选举出一个新主节点了，它就会把旧主节点降级为从节点（A），然后从节点（A）会向新主节点请求数据同步，<strong>因为第一次同步是全量同步的方式，此时的从节点（A）会清空掉自己本地的数据，然后再做全量同步。所以，之前客户端在过程 A 写入的数据就会丢失了，也就是集群产生脑裂数据丢失的问题</strong>。</p>
<p><strong>解决方案</strong></p>
<p>当主节点发现从节点下线或者通信超时的总数量小于阈值时，那么禁止主节点进行写数据，直接把错误返回给客户端。</p>
<p>在 Redis 的配置文件中有两个参数我们可以设置：</p>
<ul>
<li>min-slaves-to-write x，主节点必须要有至少 x 个从节点连接，如果小于这个数，主节点会禁止写数据。</li>
<li>min-slaves-max-lag x，主从数据复制和同步的延迟不能超过 x 秒，如果超过，主节点会禁止写数据。</li>
</ul>
<p>我们可以把 min-slaves-to-write 和 min-slaves-max-lag 这两个配置项搭配起来使用，分别给它们设置一定的阈值，假设为 N 和 T。</p>
<p>这两个配置项组合后的要求是，主库连接的从库中至少有 N 个从库，和主库进行数据复制时的 ACK 消息延迟不能超过 T 秒，否则，主库就不会再接收客户端的写请求了。</p>
<p>即使原主库是假故障，它在假故障期间也无法响应哨兵心跳，也不能和从库进行同步，自然也就无法和从库进行 ACK 确认了。这样一来，min-slaves-to-write 和 min-slaves-max-lag 的组合要求就无法得到满足，<strong>原主库就会被限制接收客户端写请求，客户端也就不能在原主库中写入新数据了</strong>。</p>
<p><strong>等到新主库上线时，就只有新主库能接收和处理客户端请求，此时，新写的数据会被直接写到新主库中。而原主库会被哨兵降为从库，即使它的数据被清空了，也不会有新数据丢失。</strong></p>
<h3 id="Raft-协议解决脑裂"><a href="#Raft-协议解决脑裂" class="headerlink" title="Raft 协议解决脑裂"></a>Raft 协议解决脑裂</h3><p>raft 保证了任意时刻最多只有一个合法 leader。</p>
<p>Raft协议通过以下核心机制解决分布式系统中的脑裂（Split-brain）问题，确保集群中任意时刻最多只有一个合法Leader，从而避免数据不一致性：</p>
<p><strong>基于任期（Term）的领导者选举机制</strong></p>
<ul>
<li><strong>任期递增规则</strong>：每个节点维护一个递增的任期号（Term），只有拥有更高任期的候选者才能参与选举。当网络分区发生时，分裂后的少数派节点无法获得多数投票，因此无法产生新Leader。</li>
<li><strong>多数派投票（Quorum）</strong>：候选者必须获得超过半数节点的投票才能成为Leader。例如，5节点集群需要至少3票。即使发生网络分区，只有包含多数节点的分区能选出新Leader，而少数派分区无法满足条件。</li>
</ul>
<p><strong>心跳机制与旧Leader自动退让</strong></p>
<ul>
<li><strong>心跳维持领导权</strong>：Leader定期发送心跳包（AppendEntries RPC）给Follower。若Follower在选举超时时间内未收到心跳，会触发新一轮选举。</li>
<li><strong>旧Leader退让</strong>：当网络恢复后，旧Leader（处于少数派分区）若收到新Leader（更高任期）的心跳，会立即退化为Follower，并同步新Leader的数据。</li>
</ul>
<p><strong>日志提交的严格条件</strong></p>
<ul>
<li><strong>日志提交规则</strong>：Leader必须在日志条目被复制到多数节点后，才会提交该条目并应用到状态机。若Leader处于少数派分区，其发起的写操作因无法获得多数确认而处于未提交状态，最终被丢弃。</li>
<li><strong>数据一致性保障</strong>：只有多数派分区的Leader能成功提交日志，而少数派分区的旧Leader无法提交数据，因此不会出现数据冲突。</li>
</ul>
<p><strong>网络分区恢复后的日志同步</strong></p>
<ul>
<li><strong>强制同步高任期日志</strong>：恢复通信后，高任期Leader会将自己的日志同步给所有Follower，覆盖低任期分区的未提交或冲突日志。</li>
<li><strong>Follower日志回滚</strong>：若Follower的日志与Leader冲突（如任期较低），会删除冲突部分并接受Leader的日志。</li>
</ul>
<p><strong>配置变更的联合共识机制</strong></p>
<ul>
<li><strong>避免扩缩容引发脑裂</strong>：在动态调整集群节点数量时，Raft使用“联合共识”（Joint Consensus）模式，确保新旧配置的多数派重叠，防止因节点变更导致分裂。</li>
<li><strong>分阶段提交配置变更</strong>：配置变更需先提交包含新旧配置的日志条目，确保所有节点达成一致后才生效，避免临时性脑裂。</li>
</ul>
<p><strong>脑裂场景下的具体处理示例</strong></p>
<p>假设一个5节点集群分裂为两个分区（A分区3节点，B分区2节点）：</p>
<ol>
<li><strong>A分区</strong>：能选出新Leader（需要3票中的2票），正常处理客户端请求并提交日志。</li>
<li><strong>B分区</strong>：旧Leader无法获得多数确认，所有写操作均未提交，客户端请求失败。</li>
<li><strong>网络恢复后</strong>：B分区的旧Leader发现A分区的新Leader任期更高，自动退化为Follower并同步日志，保证数据一致性。</li>
</ol>
<h2 id="Redis-过期删除与内存淘汰"><a href="#Redis-过期删除与内存淘汰" class="headerlink" title="Redis 过期删除与内存淘汰"></a>Redis 过期删除与内存淘汰</h2><h3 id="Redis-使用的过期删除策略是什么？"><a href="#Redis-使用的过期删除策略是什么？" class="headerlink" title="Redis 使用的过期删除策略是什么？"></a>Redis 使用的过期删除策略是什么？</h3><p>Redis 是可以对 key 设置过期时间的，因此需要有相应的机制将已过期的键值对删除，而做这个工作的就是过期键值删除策略。</p>
<p>每当我们对一个 key 设置了过期时间时，Redis 会把该 key 带上过期时间存储到一个<strong>过期字典</strong>（expires dict）中，也就是说「过期字典」保存了数据库中所有 key 的过期时间。</p>
<p>当我们查询一个 key 时，Redis 首先检查该 key 是否存在于过期字典中：</p>
<ul>
<li>如果不在，则正常读取键值；</li>
<li>如果存在，则会获取该 key 的过期时间，然后与当前系统时间进行比对，如果比系统时间大，那就没有过期，否则判定该 key 已过期。</li>
</ul>
<p>Redis 使用的过期删除策略是「<strong>惰性删除+定期删除</strong>」这两种策略配和使用。</p>
<blockquote>
<p>什么是惰性删除策略？</p>
</blockquote>
<p>惰性删除策略的做法是，<strong>不主动删除过期键，每次从数据库访问 key 时，都检测 key 是否过期，如果过期则删除该 key。</strong></p>
<p>惰性删除策略的<strong>优点</strong>：</p>
<ul>
<li>因为每次访问时，才会检查 key 是否过期，所以此策略只会使用很少的系统资源，因此，惰性删除策略对 CPU 时间最友好。</li>
</ul>
<p>惰性删除策略的<strong>缺点</strong>：</p>
<ul>
<li>如果一个 key 已经过期，而这个 key 又仍然保留在数据库中，那么只要这个过期 key 一直没有被访问，它所占用的内存就不会释放，造成了一定的内存空间浪费。所以，惰性删除策略对内存不友好。</li>
</ul>
<blockquote>
<p>什么是定期删除策略？</p>
</blockquote>
<p>定期删除策略的做法是，<strong>每隔一段时间「随机」从数据库中取出一定数量的 key 进行检查，并删除其中的过期key。</strong></p>
<p>redis 的定期删除的流程：</p>
<ol>
<li>从过期字典中随机抽取 20 个 key；</li>
<li>检查这 20 个 key 是否过期，并删除已过期的 key；</li>
<li>如果本轮检查的已过期 key 的数量，超过 5 个（20/4），也就是「已过期 key 的数量」占比「随机抽取 key 的数量」大于 25%，则继续重复步骤 1；如果已过期的 key 比例小于 25%，则停止继续删除过期 key，然后等待下一轮再检查。</li>
</ol>
<p>可以看到，定期删除是一个循环的流程。那 Redis 为了保证定期删除不会出现循环过度，导致线程卡死现象，为此增加了定期删除循环流程的时间上限，默认不会超过 25ms。</p>
<p>定期删除策略的<strong>优点</strong>：</p>
<ul>
<li>通过限制删除操作执行的时长和频率，来减少删除操作对 CPU 的影响，同时也能删除一部分过期的数据减少了过期键对空间的无效占用。</li>
</ul>
<p>定期删除策略的<strong>缺点</strong>：</p>
<ul>
<li>难以确定删除操作执行的时长和频率。如果执行的太频繁，就会对 CPU 不友好；如果执行的太少，那又和惰性删除一样了，过期 key 占用的内存不会及时得到释放。</li>
</ul>
<p>可以看到，惰性删除策略和定期删除策略都有各自的优点，所以 <strong>Redis 选择「惰性删除+定期删除」这两种策略配和使用</strong>，以求在合理使用 CPU 时间和避免内存浪费之间取得平衡。</p>
<h3 id="Redis-持久化时，对过期键会如何处理的？"><a href="#Redis-持久化时，对过期键会如何处理的？" class="headerlink" title="Redis 持久化时，对过期键会如何处理的？"></a>Redis 持久化时，对过期键会如何处理的？</h3><ul>
<li><strong>RDB 文件生成阶段</strong>：从内存状态持久化成 RDB（文件）的时候，会对 key 进行过期检查，<strong>过期的键「不会」被保存到新的 RDB 文件中</strong>，因此 Redis 中的过期键不会对生成新 RDB 文件产生任何影响。</li>
<li><strong>RDB 加载阶段</strong>：RDB 加载阶段时，要看服务器是主服务器还是从服务器，分别对应以下两种情况：<ul>
<li><strong>如果 Redis 是「主服务器」运行模式的话，在载入 RDB 文件时，程序会对文件中保存的键进行检查，过期键「不会」被载入到数据库中</strong>。所以过期键不会对载入 RDB 文件的主服务器造成影响；</li>
<li><strong>如果 Redis 是「从服务器」运行模式的话，在载入 RDB 文件时，不论键是否过期都会被载入到数据库中</strong>。但由于主从服务器在进行数据同步时，从服务器的数据会被清空。所以一般来说，过期键对载入 RDB 文件的从服务器也不会造成影响。</li>
</ul>
</li>
</ul>
<p>AOF 文件分为两个阶段，AOF 文件写入阶段和 AOF 重写阶段。</p>
<ul>
<li><strong>AOF 文件写入阶段</strong>：当 Redis 以 AOF 模式持久化时，<strong>如果数据库某个过期键还没被删除，那么 AOF 文件会保留此过期键，当此过期键被删除后，Redis 会向 AOF 文件追加一条 DEL 命令来显式地删除该键值</strong>。</li>
<li><strong>AOF 重写阶段</strong>：执行 AOF 重写时，会对 Redis 中的键值对进行检查，<strong>已过期的键不会被保存到重写后的 AOF 文件中</strong>，因此不会对 AOF 重写造成任何影响。</li>
</ul>
<h3 id="Redis-主从模式中，对过期键会如何处理？"><a href="#Redis-主从模式中，对过期键会如何处理？" class="headerlink" title="Redis 主从模式中，对过期键会如何处理？"></a>Redis 主从模式中，对过期键会如何处理？</h3><p>当 Redis 运行在主从模式下时，<strong>从库不会进行过期扫描，从库对过期的处理是被动的</strong>。也就是即使从库中的 key 过期了，如果有客户端访问从库时，依然可以得到 key 对应的值，像未过期的键值对一样返回。</p>
<p>从库的过期键处理依靠主服务器控制，<strong>主库在 key 到期时，会在 AOF 文件里增加一条 del 指令，同步到所有的从库</strong>，从库通过执行这条 del 指令来删除过期的 key。</p>
<h3 id="Redis-内存满了，会发生什么？"><a href="#Redis-内存满了，会发生什么？" class="headerlink" title="Redis 内存满了，会发生什么？"></a>Redis 内存满了，会发生什么？</h3><p>在 Redis 的运行内存达到了某个阀值，就会触发<strong>内存淘汰机制</strong>，这个阀值就是我们设置的最大运行内存，此值在 Redis 的配置文件中可以找到，配置项为 maxmemory。</p>
<h3 id="Redis-内存淘汰策略有哪些？"><a href="#Redis-内存淘汰策略有哪些？" class="headerlink" title="Redis 内存淘汰策略有哪些？"></a>Redis 内存淘汰策略有哪些？</h3><p>Redis 内存淘汰策略共有八种，这八种策略大体分为「不进行数据淘汰」和「进行数据淘汰」两类策略。</p>
<p><strong><em>1、不进行数据淘汰的策略</em></strong></p>
<p><strong>noeviction</strong>（Redis3.0之后，默认的内存淘汰策略） ：它表示当运行内存超过最大设置内存时，不淘汰任何数据，而是不再提供服务，直接返回错误。</p>
<p><strong><em>2、进行数据淘汰的策略</em></strong></p>
<p>针对「进行数据淘汰」这一类策略，又可以细分为「在设置了过期时间的数据中进行淘汰」和「在所有数据范围内进行淘汰」这两类策略。 在设置了过期时间的数据中进行淘汰：</p>
<ul>
<li><strong>volatile-random</strong>：随机淘汰设置了过期时间的任意键值；</li>
<li><strong>volatile-ttl</strong>：优先淘汰更早过期的键值。</li>
<li><strong>volatile-lru</strong>（Redis3.0 之前，默认的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最久未使用的键值；</li>
<li><strong>volatile-lfu</strong>（Redis 4.0 后新增的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最少使用的键值；</li>
</ul>
<p>在所有数据范围内进行淘汰：</p>
<ul>
<li><strong>allkeys-random</strong>：随机淘汰任意键值;</li>
<li><strong>allkeys-lru</strong>：淘汰整个键值中最久未使用的键值；</li>
<li><strong>allkeys-lfu</strong>（Redis 4.0 后新增的内存淘汰策略）：淘汰整个键值中最少使用的键值。</li>
</ul>
<h3 id="LRU-算法和-LFU-算法有什么区别？"><a href="#LRU-算法和-LFU-算法有什么区别？" class="headerlink" title="LRU 算法和 LFU 算法有什么区别？"></a>LRU 算法和 LFU 算法有什么区别？</h3><p><strong>LRU</strong> 全称是 Least Recently Used 翻译为<strong>最近最少使用</strong>，会选择淘汰最近最少使用的数据。</p>
<p>传统 LRU 算法的实现是基于「链表」结构，链表中的元素按照操作顺序从前往后排列，最新操作的键会被移动到表头，当需要内存淘汰时，只需要删除链表尾部的元素即可，因为链表尾部的元素就代表最久未被使用的元素。</p>
<p>Redis 并没有使用这样的方式实现 LRU 算法，因为传统的 LRU 算法存在两个问题：</p>
<ul>
<li>需要用链表管理所有的缓存数据，这会带来额外的空间开销；</li>
<li>当有数据被访问时，需要在链表上把该数据移动到头端，如果有大量数据被访问，就会带来很多链表移动操作，会很耗时，进而会降低 Redis 缓存性能。</li>
</ul>
<blockquote>
<p>Redis 是如何实现 LRU 算法的？</p>
</blockquote>
<p>Redis 实现的是一种<strong>近似 LRU 算法</strong>，目的是为了更好的节约内存，它的<strong>实现方式是在 Redis 的对象结构体中添加一个额外的字段，用于记录此数据的最后一次访问时间</strong>。</p>
<p>当 Redis 进行内存淘汰时，会使用<strong>随机采样的方式来淘汰数据</strong>，它是随机取 5 个值（此值可配置），然后<strong>淘汰最久没有使用的那个</strong>。</p>
<p>Redis 实现的 LRU 算法的优点：</p>
<ul>
<li>不用为所有的数据维护一个大链表，节省了空间占用；</li>
<li>不用在每次数据访问时都移动链表项，提升了缓存的性能；</li>
</ul>
<p>但是 LRU 算法有一个问题，<strong>无法解决缓存污染问题</strong>，比如应用一次读取了大量的数据，而这些数据只会被读取这一次，那么这些数据会留存在 Redis 缓存中很长一段时间，造成缓存污染。</p>
<p>因此，在 Redis 4.0 之后引入了 LFU 算法来解决这个问题。</p>
<blockquote>
<p>什么是 LFU 算法？</p>
</blockquote>
<p>LFU 全称是 Least Frequently Used 翻译为<strong>最近最不常用的</strong>，LFU 算法是根据数据访问次数来淘汰数据的，它的核心思想是“如果数据过去被访问多次，那么将来被访问的频率也更高”。</p>
<p>所以， LFU 算法会记录每个数据的访问次数。当一个数据被再次访问时，就会增加该数据的访问次数。这样就解决了偶尔被访问一次之后，数据留存在缓存中很长一段时间的问题，相比于 LRU 算法也更合理一些。</p>
<blockquote>
<p>Redis 是如何实现 LFU 算法的？</p>
</blockquote>
<p>LFU 算法相比于 LRU 算法的实现，多记录了「数据的访问频次」的信息。Redis 对象的结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisObject</span> &#123;</span><br>    ...<br>      <br>    <span class="hljs-comment">// 24 bits，用于记录对象的访问信息</span><br>    <span class="hljs-type">unsigned</span> lru:<span class="hljs-number">24</span>;  <br>    ...<br>&#125; robj;<br></code></pre></td></tr></table></figure>
<p>Redis 对象头中的 lru 字段，在 LRU 算法下和 LFU 算法下使用方式并不相同。</p>
<p><strong>在 LRU 算法中</strong>，Redis 对象头的 24 bits 的 lru 字段是用来记录 key 的访问时间戳，因此在 LRU 模式下，Redis可以根据对象头中的 lru 字段记录的值，来比较最后一次 key 的访问时间长，从而淘汰最久未被使用的 key。</p>
<p><strong>在 LFU 算法中</strong>，Redis对象头的 24 bits 的 lru 字段被分成两段来存储，高 16bit 存储 ldt(Last Decrement Time)，用来记录 key 的访问时间戳；低 8bit 存储 logc(Logistic Counter)，用来记录 key 的访问频次。</p>
<h2 id="场景题"><a href="#场景题" class="headerlink" title="场景题"></a>场景题</h2><h3 id="Redis-如何实现延迟队列？"><a href="#Redis-如何实现延迟队列？" class="headerlink" title="Redis 如何实现延迟队列？"></a>Redis 如何实现延迟队列？</h3><p>延迟队列是指把当前要做的事情，往后推迟一段时间再做。延迟队列的常见使用场景有以下几种：</p>
<ul>
<li>在淘宝、京东等购物平台上下单，超过一定时间未付款，订单会自动取消；</li>
<li>打车的时候，在规定时间没有车主接单，平台会取消你的单并提醒你暂时没有车主接单；</li>
<li>点外卖的时候，如果商家在10分钟还没接单，就会自动取消订单；</li>
</ul>
<p>在 Redis 可以使用有序集合（ZSet）的方式来实现延迟消息队列的，ZSet 有一个 Score 属性可以用来存储延迟执行的时间。</p>
<p>使用 zadd score1 value1 命令就可以一直往内存中生产消息。再利用 zrangebysocre 查询符合条件的所有待处理的任务， 通过循环执行队列任务即可。</p>
<p><img  src="/延迟队列.png"  ><span class="image-caption">img</span></p>
<h3 id="Redis-的大-key-如何处理？"><a href="#Redis-的大-key-如何处理？" class="headerlink" title="Redis 的大 key 如何处理？"></a>Redis 的大 key 如何处理？</h3><blockquote>
<p>什么是 Redis 大 key？</p>
</blockquote>
<p>大 key 并不是指 key 的值很大，而是 key 对应的 value 很大。</p>
<p>一般而言，下面这两种情况被称为大 key：</p>
<ul>
<li>String 类型的值大于 10 KB；</li>
<li>Hash、List、Set、ZSet 类型的元素的个数超过 5000个；</li>
</ul>
<blockquote>
<p>大 key 会造成什么问题？</p>
</blockquote>
<ul>
<li><strong>客户端超时阻塞</strong>。由于 Redis 执行命令是单线程处理，然后在操作大 key 时会比较耗时，那么就会阻塞 Redis，从客户端这一视角看，就是很久很久都没有响应。</li>
<li><strong>引发网络阻塞</strong>。每次获取大 key 产生的网络流量较大，如果一个 key 的大小是 1 MB，每秒访问量为 1000，那么每秒会产生 1000MB 的流量，这对于普通千兆网卡的服务器来说是灾难性的。</li>
<li><strong>阻塞工作线程</strong>。如果使用 del 删除大 key 时，会阻塞工作线程，这样就没办法处理后续的命令。</li>
<li><strong>内存分布不均</strong>。集群模型在 slot 分片均匀情况下，会出现数据和查询倾斜情况，部分有大 key 的 Redis 节点占用内存多，QPS 也会比较大。</li>
</ul>
<blockquote>
<p>如何找到大 key ？</p>
</blockquote>
<p><strong><em>1. redis-cli —bigkeys 查找大key</em></strong></p>
<ul>
<li>最好选择在从节点上执行该命令。因为主节点上执行时，会阻塞主节点；</li>
<li>如果没有从节点，那么可以选择在 Redis 实例业务压力的低峰阶段进行扫描查询，以免影响到实例的正常运行；或者可以使用 -i 参数控制扫描间隔，避免长时间扫描降低 Redis 实例的性能。</li>
</ul>
<ul>
<li>这个方法只能返回每种类型中最大的那个 bigkey，无法得到大小排在前 N 位的 bigkey；</li>
<li>对于集合类型来说，这个方法只统计集合元素个数的多少，而不是实际占用的内存量。但是，一个集合中的元素个数多，并不一定占用的内存就多。因为，有可能每个元素占用的内存很小，这样的话，即使元素个数有很多，总内存开销也不大；</li>
</ul>
<p><strong><em>2. 使用 SCAN 命令查找大 key</em></strong></p>
<p>使用 SCAN 命令对数据库扫描，然后用 TYPE 命令获取返回的每一个 key 的类型。</p>
<p>对于 String 类型，可以直接使用 STRLEN 命令获取字符串的长度，也就是占用的内存空间字节数。</p>
<p>对于集合类型来说，有两种方法可以获得它占用的内存大小：</p>
<ul>
<li>如果能够预先从业务层知道集合元素的平均大小，那么，可以使用下面的命令获取集合元素的个数，然后乘以集合元素的平均大小，这样就能获得集合占用的内存大小了。List 类型：<code>LLEN</code> 命令；Hash 类型：<code>HLEN</code> 命令；Set 类型：<code>SCARD</code> 命令；Sorted Set 类型：<code>ZCARD</code> 命令；</li>
<li>如果不能提前知道写入集合的元素大小，可以使用 <code>MEMORY USAGE</code> 命令（需要 Redis 4.0 及以上版本），查询一个键值对占用的内存空间。</li>
</ul>
<p><strong><em>3. 使用 RdbTools 工具查找大 key</em></strong></p>
<p>使用 RdbTools 第三方开源工具，可以用来解析 Redis 快照（RDB）文件，找到其中的大 key。</p>
<p>比如，下面这条命令，将大于 10 kb 的  key  输出到一个表格文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">rdb dump.rdb -c memory --bytes 10240 -f redis.csv<br></code></pre></td></tr></table></figure>
<h3 id="如何删除大-key？"><a href="#如何删除大-key？" class="headerlink" title="如何删除大 key？"></a>如何删除大 key？</h3><p><strong><em>1、分批次删除</em></strong></p>
<p><strong><em>2、异步删除</em></strong></p>
<p>从 Redis 4.0 版本开始，可以采用<strong>异步删除</strong>法，<strong>用 unlink 命令代替 del 来删除</strong>。</p>
<h3 id="Redis-事务支持回滚吗？"><a href="#Redis-事务支持回滚吗？" class="headerlink" title="Redis 事务支持回滚吗？"></a>Redis 事务支持回滚吗？</h3><p>MySQL 在执行事务时，会提供回滚机制，当事务执行发生错误时，事务中的所有操作都会撤销，已经修改的数据也会被恢复到事务执行前的状态。</p>
<p><strong>Redis 中并没有提供回滚机制</strong>，虽然 Redis 提供了 DISCARD 命令，但是这个命令只能用来主动放弃事务执行，把暂存的命令队列清空，起不到回滚的效果。</p>
<p>事务执行过程中，如果命令入队时没报错，而事务提交后，<strong>实际执行时报错了，正确的命令依然可以正常执行</strong>，所以这可以看出 <strong>Redis 并不一定保证原子性</strong>（原子性：事务中的命令要不全部成功，要不全部失败）。</p>
<blockquote>
<p>为什么Redis 不支持事务回滚？</p>
</blockquote>
<ul>
<li>他认为 Redis 事务的执行时，错误通常都是编程错误造成的，这种错误通常只会出现在开发环境中，而很少会在实际的生产环境中出现，所以他认为没有必要为 Redis 开发事务回滚功能；</li>
<li>不支持事务回滚是因为这种复杂的功能和 Redis 追求的简单高效的设计主旨不符合。</li>
</ul>
<p>这里不支持事务回滚，指的是不支持事务运行时错误的事务回滚。</p>
<blockquote>
<p>基于 Redis 实现分布式锁有什么优缺点？</p>
</blockquote>
<p>基于 Redis 实现分布式锁的<strong>优点</strong>：</p>
<ol>
<li>性能高效（这是选择缓存实现分布式锁最核心的出发点）。</li>
<li>实现方便。很多研发工程师选择使用 Redis 来实现分布式锁，很大成分上是因为 Redis 提供了 setnx 方法，实现分布式锁很方便。</li>
<li>避免单点故障（因为 Redis 是跨集群部署的，自然就避免了单点故障）。</li>
</ol>
<p>基于 Redis 实现分布式锁的<strong>缺点</strong>：</p>
<ul>
<li><p>超时时间不好设置</p>
<p>。如果锁的超时时间设置过长，会影响性能，如果设置的超时时间过短会保护不到共享资源。比如在有些场景中，一个线程 A 获取到了锁之后，由于业务代码执行时间可能比较长，导致超过了锁的超时时间，自动失效，注意 A 线程没执行完，后续线程 B 又意外的持有了锁，意味着可以操作共享资源，那么两个线程之间的共享资源就没办法进行保护了。</p>
<ul>
<li><strong>那么如何合理设置超时时间呢？</strong> 我们可以基于续约的方式设置超时时间：先给锁设置一个超时时间，然后启动一个守护线程，让守护线程在一段时间后，重新设置这个锁的超时时间。实现方式就是：写一个守护线程，然后去判断锁的情况，当锁快失效的时候，再次进行续约加锁，当主线程执行完成后，销毁续约锁即可，不过这种方式实现起来相对复杂。</li>
</ul>
</li>
<li><p><strong>Redis 主从复制模式中的数据是异步复制的，这样导致分布式锁的不可靠性</strong>。如果在 Redis 主节点获取到锁后，在没有同步到其他节点时，Redis 主节点宕机了，此时新的 Redis 主节点依然可以获取锁，所以多个应用服务就可以同时获取到锁。</p>
</li>
</ul>
<blockquote>
<p>Redis 如何解决集群情况下分布式锁的可靠性？</p>
</blockquote>
<p>为了保证集群环境下分布式锁的可靠性，Redis 官方已经设计了一个分布式锁算法 Redlock（红锁）。</p>
<p>它是基于<strong>多个 Redis 节点</strong>的分布式锁，即使有节点发生了故障，锁变量仍然是存在的，客户端还是可以完成锁操作。官方推荐是至少部署 5 个 Redis 节点，而且都是主节点，它们之间没有任何关系，都是一个个孤立的节点。</p>
<p>Redlock 算法的基本思路，<strong>是让客户端和多个独立的 Redis 节点依次请求申请加锁，如果客户端能够和半数以上的节点成功地完成加锁操作，那么我们就认为，客户端成功地获得分布式锁，否则加锁失败</strong>。</p>
<p>这样一来，即使有某个 Redis 节点发生故障，因为锁的数据在其他节点上也有保存，所以客户端仍然可以正常地进行锁操作，锁的数据也不会丢失。</p>
<p>Redlock 算法加锁三个过程：</p>
<ul>
<li>第一步是，客户端获取当前时间（t1）。</li>
<li>第二步是，客户端按顺序依次向 N 个 Redis 节点执行加锁操作：<ul>
<li>加锁操作使用 SET 命令，带上 NX，EX/PX 选项，以及带上客户端的唯一标识。</li>
<li>如果某个 Redis 节点发生故障了，为了保证在这种情况下，Redlock 算法能够继续运行，我们需要给「加锁操作」设置一个超时时间（不是对「锁」设置超时时间，而是对「加锁操作」设置超时时间），加锁操作的超时时间需要远远地小于锁的过期时间，一般也就是设置为几十毫秒。</li>
</ul>
</li>
<li>第三步是，一旦客户端从超过半数（大于等于 N/2+1）的 Redis 节点上成功获取到了锁，就再次获取当前时间（t2），然后计算计算整个加锁过程的总耗时（t2-t1）。如果 t2-t1 &lt; 锁的过期时间，此时，认为客户端加锁成功，否则认为加锁失败。</li>
</ul>
<p>可以看到，加锁成功要同时满足两个条件（<em>简述：如果有超过半数的 Redis 节点成功的获取到了锁，并且总耗时没有超过锁的有效时间，那么就是加锁成功</em>）：</p>
<ul>
<li>条件一：客户端从超过半数（大于等于 N/2+1）的 Redis 节点上成功获取到了锁；</li>
<li>条件二：客户端从大多数节点获取锁的总耗时（t2-t1）小于锁设置的过期时间。</li>
</ul>
<p>加锁成功后，客户端需要重新计算这把锁的有效时间，计算的结果是「锁最初设置的过期时间」减去「客户端从大多数节点获取锁的总耗时（t2-t1）」。如果计算的结果已经来不及完成共享数据的操作了，我们可以释放锁，以免出现还没完成数据操作，锁就过期了的情况。</p>
<p>加锁失败后，客户端向<strong>所有 Redis 节点发起释放锁的操作</strong>，释放锁的操作和在单节点上释放锁的操作一样，只要执行释放锁的 Lua 脚本就可以了。</p>
<h3 id="什么是热key？"><a href="#什么是热key？" class="headerlink" title="什么是热key？"></a>什么是热key？</h3><p>通常以其接收到的Key被请求频率来判定，例如：</p>
<ul>
<li>QPS集中在特定的Key：Redis实例的总QPS（每秒查询率）为10,000，而其中一个Key的每秒访问量达到了7,000。</li>
<li>带宽使用率集中在特定的Key：对一个拥有上千个成员且总大小为1 MB的HASH Key每秒发送大量的<strong>HGETALL</strong>操作请求。</li>
<li>CPU使用时间占比集中在特定的Key：对一个拥有数万个成员的Key（ZSET类型）每秒发送大量的<strong>ZRANGE</strong>操作请求。</li>
</ul>
<h3 id="如何解决热key问题？"><a href="#如何解决热key问题？" class="headerlink" title="如何解决热key问题？"></a>如何解决热key问题？</h3><ul>
<li>在Redis集群架构中对热Key进行复制。在Redis集群架构中，由于热Key的迁移粒度问题，无法将请求分散至其他数据分片，导致单个数据分片的压力无法下降。此时，可以将对应热Key进行复制并迁移至其他数据分片，例如将热Key foo复制出3个内容完全一样的Key并名为foo2、foo3、foo4，将这三个Key迁移到其他数据分片来解决单个数据分片的热Key压力。</li>
<li>使用读写分离架构。如果热Key的产生来自于读请求，您可以将实例改造成读写分离架构来降低每个数据分片的读请求压力，甚至可以不断地增加从节点。但是读写分离架构在增加业务代码复杂度的同时，也会增加Redis集群架构复杂度。不仅要为多个从节点提供转发层（如Proxy，LVS等）来实现负载均衡，还要考虑从节点数量显著增加后带来故障率增加的问题。Redis集群架构变更会为监控、运维、故障处理带来了更大的挑战。</li>
<li>拆分为多个 key，用本地缓存兜底</li>
</ul>
<h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><h3 id="JDK-动态代理（需要实现接口）"><a href="#JDK-动态代理（需要实现接口）" class="headerlink" title="JDK 动态代理（需要实现接口）"></a>JDK 动态代理（需要实现接口）</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.lang.reflect.Proxy;<br><br><span class="hljs-comment">// 1. 定义接口（抽象主题）</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserService</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">login</span><span class="hljs-params">(String username)</span>;<br>    String <span class="hljs-title function_">getUserInfo</span><span class="hljs-params">(<span class="hljs-type">int</span> userId)</span>;<br>&#125;<br><br><span class="hljs-comment">// 2. 实现类（真实主题）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserService</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">login</span><span class="hljs-params">(String username)</span> &#123;<br>        System.out.println(username + <span class="hljs-string">&quot; 登录成功&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getUserInfo</span><span class="hljs-params">(<span class="hljs-type">int</span> userId)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;用户ID：&quot;</span> + userId + <span class="hljs-string">&quot;，姓名：张三&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 3. 调用处理器（实现方法增强）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LogHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object target;  <span class="hljs-comment">// 被代理对象</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LogHandler</span><span class="hljs-params">(Object target)</span> &#123;<br>        <span class="hljs-built_in">this</span>.target = target;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        System.out.println(<span class="hljs-string">&quot;【日志】开始执行方法：&quot;</span> + method.getName());<br>        <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <br>        <span class="hljs-comment">// 调用原始方法</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> method.invoke(target, args);<br>        <br>        System.out.println(<span class="hljs-string">&quot;【日志】方法耗时：&quot;</span> + (System.currentTimeMillis() - start) + <span class="hljs-string">&quot;ms&quot;</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 4. 客户端使用动态代理</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DynamicProxyDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建目标对象</span><br>        <span class="hljs-type">UserService</span> <span class="hljs-variable">realService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserServiceImpl</span>();<br>        <br>        <span class="hljs-comment">// 创建代理对象</span><br>        <span class="hljs-type">UserService</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (UserService) Proxy.newProxyInstance(<br>            realService.getClass().getClassLoader(),<br>            realService.getClass().getInterfaces(),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">LogHandler</span>(realService)<br>        );<br><br>        <span class="hljs-comment">// 通过代理对象调用方法</span><br>        proxy.login(<span class="hljs-string">&quot;admin&quot;</span>);<br>        System.out.println(proxy.getUserInfo(<span class="hljs-number">1001</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">【日志】开始执行方法：login<br>admin 登录成功<br>【日志】方法耗时：1ms<br>【日志】开始执行方法：getUserInfo<br>【日志】方法耗时：0ms<br>用户ID：1001，姓名：张三<br></code></pre></td></tr></table></figure>
<h3 id="CGLIB-代理（不需要实现接口）"><a href="#CGLIB-代理（不需要实现接口）" class="headerlink" title="CGLIB 代理（不需要实现接口）"></a>CGLIB 代理（不需要实现接口）</h3><p>导入包：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cglib<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>cglib<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 定义目标类（无需实现接口）</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addUser</span><span class="hljs-params">(String name)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;添加用户：&quot;</span> + name);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 2. 实现方法拦截器</span><br><span class="hljs-keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;<br><span class="hljs-keyword">import</span> net.sf.cglib.proxy.MethodProxy;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MethodInterceptor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        System.out.println(<span class="hljs-string">&quot;【前置日志】方法调用：&quot;</span> + method.getName());<br>        <span class="hljs-comment">// 调用原始方法（通过子类调用父类方法）</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> proxy.invokeSuper(obj, args);<br>        System.out.println(<span class="hljs-string">&quot;【后置日志】方法执行完成&quot;</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 3. 生成代理对象</span><br><span class="hljs-keyword">import</span> net.sf.cglib.proxy.Enhancer;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CglibDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 1. 创建增强器</span><br>        <span class="hljs-type">Enhancer</span> <span class="hljs-variable">enhancer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Enhancer</span>();<br>        <span class="hljs-comment">// 2. 设置父类（目标类）</span><br>        enhancer.setSuperclass(UserService.class);<br>        <span class="hljs-comment">// 3. 设置回调（拦截逻辑）</span><br>        enhancer.setCallback(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LogInterceptor</span>());<br>        <span class="hljs-comment">// 4. 生成代理对象</span><br>        <span class="hljs-type">UserService</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (UserService) enhancer.create();<br>        <span class="hljs-comment">// 5. 调用方法</span><br>        proxy.addUser(<span class="hljs-string">&quot;Alice&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><code class="hljs mipsasm">【前置日志】方法调用：<span class="hljs-keyword">addUser</span><br><span class="hljs-keyword"></span>添加用户：Alice<br>【后置日志】方法执行完成<br></code></pre></td></tr></table></figure>
<p>CGLIB 使用 <strong>FastClass 机制</strong> 直接通过索引访问方法，避免反射调用，提升性能。</p>
<p><strong>生成含参构造函数代理</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 目标类需包含无参构造方法</span><br>enhancer.setCallback(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LogInterceptor</span>());<br><span class="hljs-comment">// 若目标类构造函数含参数：</span><br>enhancer.create(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;defaultUser&quot;</span>&#125;);<br></code></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"><strong>特性</strong></th>
<th style="text-align:center"><strong>CGLIB</strong></th>
<th style="text-align:center"><strong>JDK 动态代理</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">代理对象类型</td>
<td style="text-align:center">目标类的子类</td>
<td style="text-align:center">接口实现类</td>
</tr>
<tr>
<td style="text-align:center">依赖条件</td>
<td style="text-align:center">目标类不能为 <code>final</code></td>
<td style="text-align:center">目标类需实现接口</td>
</tr>
<tr>
<td style="text-align:center">性能</td>
<td style="text-align:center">高（FastClass 优化）</td>
<td style="text-align:center">较低（反射调用）</td>
</tr>
<tr>
<td style="text-align:center">适用场景</td>
<td style="text-align:center">无接口的类、AOP 框架底层实现</td>
<td style="text-align:center">Spring 默认代理（接口优先）</td>
</tr>
</tbody>
</table>
</div>
<p>Spring 默认优先使用 JDK 代理，若目标类无接口则自动切换为 CGLIB。</p>
<h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><h3 id="Spring的事务什么情况下会失效？"><a href="#Spring的事务什么情况下会失效？" class="headerlink" title="Spring的事务什么情况下会失效？"></a>Spring的事务什么情况下会失效？</h3><p>Spring Boot通过Spring框架的事务管理模块来支持事务操作。事务管理在Spring Boot中通常是通过 @Transactional 注解来实现的。事务可能会失效的一些常见情况包括:</p>
<ol>
<li><strong>未捕获异常</strong>: 如果一个事务方法中发生了未捕获的异常，并且异常未被处理或传播到事务边界之外，那么事务会失效，所有的数据库操作会回滚。</li>
<li><strong>非受检异常</strong>: 默认情况下，Spring对非受检异常（RuntimeException或其子类）进行回滚处理，这意味着当事务方法中抛出这些异常时，事务会回滚。</li>
<li><strong>事务传播属性设置不当</strong>: 如果在多个事务之间存在事务嵌套，且事务传播属性配置不正确，可能导致事务失效。特别是在方法内部调用有 @Transactional 注解的方法时要特别注意。</li>
<li><strong>多数据源的事务管理</strong>: 如果在使用多数据源时，事务管理没有正确配置或者存在多个 @Transactional 注解时，可能会导致事务失效。</li>
<li><strong>跨方法调用事务问题</strong>: 如果一个事务方法内部调用另一个方法，而这个被调用的方法没有 @Transactional 注解，这种情况下外层事务可能会失效。</li>
<li><strong>事务在非公开方法中失效</strong>: 如果 @Transactional 注解标注在私有方法上或者非 public 方法上，事务也会失效。</li>
</ol>
<h3 id="Spring的事务，使用this调用是否生效？"><a href="#Spring的事务，使用this调用是否生效？" class="headerlink" title="Spring的事务，使用this调用是否生效？"></a>Spring的事务，使用this调用是否生效？</h3><p>不能生效。</p>
<p>因为Spring事务是通过代理对象来控制的，只有通过代理对象的方法调用才会应用事务管理的相关规则。当使用<code>this</code>直接调用时，是绕过了Spring的代理机制，因此不会应用事务设置。</p>
<h3 id="Bean是否单例？"><a href="#Bean是否单例？" class="headerlink" title="Bean是否单例？"></a>Bean是否单例？</h3><p>Spring 中的 Bean 默认都是单例的。</p>
<p>就是说，每个Bean的实例只会被创建一次，并且会被存储在Spring容器的缓存中，以便在后续的请求中重复使用。这种单例模式可以提高应用程序的性能和内存效率。</p>
<p>但是，Spring也支持将Bean设置为多例模式，即每次请求都会创建一个新的Bean实例。要将Bean设置为多例模式，可以在Bean定义中通过设置scope属性为”prototype”来实现。</p>
<p>需要注意的是，虽然Spring的默认行为是将Bean设置为单例模式，但在一些情况下，使用多例模式是更为合适的，例如在创建状态不可变的Bean或有状态Bean时。此外，需要注意的是，如果Bean单例是有状态的，那么在使用时需要考虑线程安全性问题。</p>
<h3 id="Bean的单例和非单例，生命周期是否一样"><a href="#Bean的单例和非单例，生命周期是否一样" class="headerlink" title="Bean的单例和非单例，生命周期是否一样"></a>Bean的单例和非单例，生命周期是否一样</h3><p>不一样的，Spring Bean 的生命周期完全由 IoC 容器控制。Spring 只帮我们管理单例模式 Bean 的完整生命周期，对于 <code>prototype</code> 的 Bean，Spring 在创建好交给使用者之后，则不会再管理后续的生命周期。</p>
<p>具体区别如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"><strong>阶段</strong></th>
<th style="text-align:left"><strong>单例（Singleton）</strong></th>
<th style="text-align:left"><strong>非单例（如Prototype）</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>创建时机</strong></td>
<td style="text-align:left">容器启动时创建（或首次请求时，取决于配置）。</td>
<td style="text-align:left">每次请求时创建新实例。</td>
</tr>
<tr>
<td style="text-align:left"><strong>初始化流程</strong></td>
<td style="text-align:left">完整执行生命周期流程（属性注入、Aware接口、初始化方法等）。</td>
<td style="text-align:left">每次创建新实例时都会完整执行生命周期流程（仅到初始化完成）。</td>
</tr>
<tr>
<td style="text-align:left"><strong>销毁时机</strong></td>
<td style="text-align:left">容器关闭时销毁，触发<code>DisposableBean</code>或<code>destroy-method</code>。</td>
<td style="text-align:left"><strong>容器不管理销毁</strong>，需由调用者自行释放资源（Spring不跟踪实例）。</td>
</tr>
<tr>
<td style="text-align:left"><strong>内存占用</strong></td>
<td style="text-align:left">单实例常驻内存，高效但需注意线程安全。</td>
<td style="text-align:left">每次请求生成新实例，内存开销较大，需手动管理资源释放。</td>
</tr>
<tr>
<td style="text-align:left"><strong>适用场景</strong></td>
<td style="text-align:left">无状态服务（如Service、DAO层）。</td>
<td style="text-align:left">有状态对象（如用户会话、临时计算对象）。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Bean注入和xml注入最终得到了相同的效果，它们在底层是怎样做的"><a href="#Bean注入和xml注入最终得到了相同的效果，它们在底层是怎样做的" class="headerlink" title="Bean注入和xml注入最终得到了相同的效果，它们在底层是怎样做的"></a>Bean注入和xml注入最终得到了相同的效果，它们在底层是怎样做的</h3><p>在Spring框架中，<strong>基于注解的Bean注入（如<code>@Autowired</code>、<code>@Resource</code>）和基于XML的依赖注入</strong>虽然在配置方式上不同，但在底层最终都通过Spring容器的统一机制实现依赖注入。它们的核心流程可以归纳为以下步骤：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"><strong>阶段</strong></th>
<th style="text-align:left"><strong>注解注入</strong></th>
<th style="text-align:left"><strong>XML注入</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>配置解析</strong></td>
<td style="text-align:left">通过注解处理器扫描类路径，解析<code>@Component</code>、<code>@Autowired</code>等注解。</td>
<td style="text-align:left">解析XML文件中的<code>&lt;bean&gt;</code>、<code>&lt;property&gt;</code>、<code>&lt;constructor-arg&gt;</code>标签。</td>
</tr>
<tr>
<td style="text-align:left"><strong>生成BeanDefinition</strong></td>
<td style="text-align:left">将注解信息转换为<code>AnnotatedBeanDefinition</code>。</td>
<td style="text-align:left">将XML配置转换为<code>GenericBeanDefinition</code>。</td>
</tr>
<tr>
<td style="text-align:left"><strong>依赖注入</strong></td>
<td style="text-align:left">由<code>AutowiredAnnotationBeanPostProcessor</code>等后处理器处理。</td>
<td style="text-align:left">在BeanDefinition中直接记录属性或构造器参数，由容器直接注入。</td>
</tr>
<tr>
<td style="text-align:left"><strong>最终结果</strong></td>
<td style="text-align:left">生成完整的Bean实例，完成依赖注入。</td>
<td style="text-align:left">生成完整的Bean实例，完成依赖注入。</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>XML 注入</p>
</blockquote>
<p>使用 XML 文件进行 Bean 注入时，Spring 在启动时会读取 XML 配置文件，以下是其底层步骤：</p>
<ul>
<li><p><strong>Bean 定义解析</strong>：Spring 容器通过 <code>XmlBeanDefinitionReader</code> 类解析 XML 配置文件，读取其中的 <code>&lt;bean&gt;</code> 标签以获取 Bean 的定义信息。</p>
</li>
<li><p><strong>注册 Bean 定义</strong>：解析后的 Bean 信息被注册到 <code>BeanDefinitionRegistry</code>（如 <code>DefaultListableBeanFactory</code>）中，包括 Bean 的类、作用域、依赖关系、初始化和销毁方法等。</p>
</li>
<li><p>实例化和依赖注入</p>
<p>：当应用程序请求某个 Bean 时，Spring 容器会根据已经注册的 Bean 定义：</p>
<ul>
<li>首先，使用反射机制创建该 Bean 的实例。</li>
<li>然后，根据 Bean 定义中的配置，通过 setter 方法、构造函数或方法注入所需的依赖 Bean。</li>
</ul>
</li>
</ul>
<blockquote>
<p>注解注入</p>
</blockquote>
<p>使用注解进行 Bean 注入时，Spring 的处理过程如下：</p>
<ul>
<li><strong>类路径扫描</strong>：当 Spring 容器启动时，它首先会进行类路径扫描，查找带有特定注解（如 <code>@Component</code>、<code>@Service</code>、<code>@Repository</code> 和 <code>@Controller</code>）的类。</li>
<li><strong>注册 Bean 定义</strong>：找到的类会被注册到 <code>BeanDefinitionRegistry</code> 中，Spring 容器将为其生成 Bean 定义信息。这通常通过 <code>AnnotatedBeanDefinitionReader</code> 类来实现。</li>
<li><strong>依赖注入</strong>：与 XML 注入类似，Spring 在实例化 Bean 时，也会检查字段上是否有 <code>@Autowired</code>、<code>@Inject</code> 或 <code>@Resource</code> 注解。如果有，Spring 会根据注解的信息进行依赖注入。</li>
</ul>
<p>尽管使用的方式不同，但 XML 注入和注解注入在底层的实现机制是相似的，主要体现在以下几个方面：</p>
<ol>
<li><strong>BeanDefinition</strong>：无论是 XML 还是注解，最终都会生成 <code>BeanDefinition</code> 对象，并存储在同一个 <code>BeanDefinitionRegistry</code> 中。</li>
<li><strong>后处理器</strong>：<ul>
<li>Spring 提供了多个 Bean 后处理器（如 <code>AutowiredAnnotationBeanPostProcessor</code>），用于处理注解（如 <code>@Autowired</code>）的依赖注入。</li>
<li>对于 XML，Spring 也有相应的后处理器来处理 XML 配置的依赖注入。</li>
</ul>
</li>
<li><strong>依赖查找</strong>：在依赖注入时，Spring 容器会通过 <code>ApplicationContext</code> 中的 BeanFactory 方法来查找和注入依赖，无论是通过 XML 还是注解，都会调用类似的查找方法。</li>
</ol>
<h3 id="Spring给我们提供了很多扩展点，这些有了解吗？"><a href="#Spring给我们提供了很多扩展点，这些有了解吗？" class="headerlink" title="Spring给我们提供了很多扩展点，这些有了解吗？"></a>Spring给我们提供了很多扩展点，这些有了解吗？</h3><p>Spring框架提供了许多扩展点，使得开发者可以根据需求定制和扩展Spring的功能。以下是一些常用的扩展点：</p>
<ol>
<li>BeanFactoryPostProcessor：允许在Spring容器实例化bean之前修改bean的定义。常用于修改bean属性或改变bean的作用域。</li>
<li>BeanPostProcessor：可以在bean实例化、配置以及初始化之后对其进行额外处理。常用于代理bean、修改bean属性等。</li>
<li>PropertySource：用于定义不同的属性源，如文件、数据库等，以便在Spring应用中使用。</li>
<li>ImportSelector和ImportBeanDefinitionRegistrar：用于根据条件动态注册bean定义，实现配置类的模块化。</li>
<li>Spring MVC中的HandlerInterceptor：用于拦截处理请求，可以在请求处理前、处理中和处理后执行特定逻辑。</li>
<li>Spring MVC中的ControllerAdvice：用于全局处理控制器的异常、数据绑定和数据校验。</li>
<li>Spring Boot的自动配置：通过创建自定义的自动配置类，可以实现对框架和第三方库的自动配置。</li>
<li>自定义注解：创建自定义注解，用于实现特定功能或约定，如权限控制、日志记录等。</li>
</ol>
<h1 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h1><h2 id="Go-的基础"><a href="#Go-的基础" class="headerlink" title="Go 的基础"></a>Go 的基础</h2><h3 id="Go-的特点"><a href="#Go-的特点" class="headerlink" title="Go 的特点"></a>Go 的特点</h3><ul>
<li>语法简单</li>
<li>轻量级线程、通道、高效并发</li>
<li>内置垃圾回收</li>
</ul>
<h3 id="Go-和-Java-对比"><a href="#Go-和-Java-对比" class="headerlink" title="Go 和 Java 对比"></a>Go 和 Java 对比</h3><ul>
<li>Java使用广泛，但是Go比Java更适合高并发和轻量级的应用</li>
<li>Java通过线程和锁来处理并发，Go routines 和 channels 是Go语言的并发特性的核心</li>
<li>Java是一门功能丰富、面向对象的语言，支持面向对象编程、泛型等高级特性。Go语言的设计注重简洁和清晰，具有简单的语法和类型系统。它摒弃了一些复杂的特性，强调代码的可读性。</li>
<li>Go语言具有垃圾回收机制，开发者无需手动管理内存。Java同样拥有垃圾回收机制，这减轻了开发者的负担，但在一些情况下可能引入一些不可控的暂停。\</li>
<li>Go适用于构建高性能、高并发的后端服务、网络应用、云服务以及分布式系统。Java广泛应用于大型企业应用、Android应用、大规模分布式系统和企业级应用。</li>
</ul>
<h3 id="Go-中-make-和-new-的区别？"><a href="#Go-中-make-和-new-的区别？" class="headerlink" title="Go 中 make 和 new 的区别？"></a>Go 中 make 和 new 的区别？</h3><p>共同点：给变量分配内存</p>
<p>不同点：</p>
<ul>
<li>作用变量类型不同，new 给 string,int 和数组分配内存，make 给切片，map，channel 分配内存；</li>
<li>返回类型不一样，new返回指向变量的指针，make返回变量本身；</li>
<li>new 分配的空间被清零。make 分配空间后，会进行初始化；</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">关键字</th>
<th style="text-align:center">适用类型</th>
<th style="text-align:center">返回值</th>
<th style="text-align:center">分配位置（取决于逃逸分析）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>new</code></td>
<td style="text-align:center">任何类型</td>
<td style="text-align:center">指针</td>
<td style="text-align:center">栈（未逃逸）或堆（逃逸）</td>
</tr>
<tr>
<td style="text-align:center"><code>make</code></td>
<td style="text-align:center">切片、映射、通道</td>
<td style="text-align:center">引用类型</td>
<td style="text-align:center">元数据可能在栈，底层数据通常在堆（因规模或生命周期）</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Go-for-range-中临时变量-v-的地址是否变化？"><a href="#Go-for-range-中临时变量-v-的地址是否变化？" class="headerlink" title="Go for range 中临时变量 v 的地址是否变化？"></a>Go for range 中临时变量 <code>v</code> 的地址是否变化？</h3><p><strong>Go 1.22 之前</strong></p>
<p><strong>临时变量 <code>v</code> 的地址不变</strong>：每次迭代时，<code>v</code> 会被 <strong>复用同一个内存地址</strong>，仅将元素的值复制到该地址中。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">s := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> s &#123;<br>    fmt.Printf(<span class="hljs-string">&quot;%p\n&quot;</span>, &amp;v)  <span class="hljs-comment">// 输出相同的地址</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>后果</strong>：若在循环中将 <code>&amp;v</code> 保存到切片或映射中，所有指针最终会指向 <strong>最后一个元素的值</strong>。</p>
<p><strong>解决方法</strong>：</p>
<p><strong>显式创建局部变量</strong>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> s &#123;<br>    tmp := v  <span class="hljs-comment">// 每次迭代创建新变量</span><br>    funcs = <span class="hljs-built_in">append</span>(funcs, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; fmt.Println(tmp) &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>直接使用索引</strong>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> s &#123;<br>    funcs = <span class="hljs-built_in">append</span>(funcs, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; fmt.Println(s[i]) &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>Go 1.22 之后</strong></p>
<p><strong>临时变量 <code>v</code> 的地址会变</strong>：每次迭代时，<code>v</code> 会被分配到 <strong>新的内存地址</strong>，避免指针复用问题。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">s := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> s &#123;<br>    fmt.Printf(<span class="hljs-string">&quot;%p\n&quot;</span>, &amp;v)  <span class="hljs-comment">// 输出不同的地址</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="defer的执行顺序"><a href="#defer的执行顺序" class="headerlink" title="defer的执行顺序"></a>defer的执行顺序</h3><p>多个defer出现的时候，<strong>它是一个“栈”的关系，也就是先进后出</strong>。一个函数中，写在前面的defer会比写在后面的defer调用的晚。</p>
<h3 id="defer与return谁先谁后"><a href="#defer与return谁先谁后" class="headerlink" title="defer与return谁先谁后"></a>defer与return谁先谁后</h3><p>defer，return，return value（函数返回值） 执行顺序：首先return，其次return value，最后defer。</p>
<h3 id="函数的返回值初始化"><a href="#函数的返回值初始化" class="headerlink" title="函数的返回值初始化"></a>函数的返回值初始化</h3><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DeferFunc1</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> (t <span class="hljs-type">int</span>) &#123;<br><br>    fmt.Println(<span class="hljs-string">&quot;t = &quot;</span>, t)<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    DeferFunc11(<span class="hljs-number">10</span>)<br>&#125;<br><br><span class="hljs-comment">// 输出 t = 0</span><br></code></pre></td></tr></table></figure>
<h3 id="有名函数返回值遇见defer情况"><a href="#有名函数返回值遇见defer情况" class="headerlink" title="有名函数返回值遇见defer情况"></a>有名函数返回值遇见defer情况</h3><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">returnButDefer</span><span class="hljs-params">()</span></span> (t <span class="hljs-type">int</span>) &#123;  <span class="hljs-comment">//t初始化0， 并且作用域为该函数全域</span><br><br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        t = t * <span class="hljs-number">10</span><br>    &#125;()<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(returnButDefer())<br>&#125;<br><br><span class="hljs-comment">// $ go run test.go</span><br><span class="hljs-comment">// 10</span><br></code></pre></td></tr></table></figure>
<h3 id="defer下的函数参数包含子函数"><a href="#defer下的函数参数包含子函数" class="headerlink" title="defer下的函数参数包含子函数"></a>defer下的函数参数包含子函数</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br>func <span class="hljs-title function_">function</span><span class="hljs-params">(index <span class="hljs-type">int</span>, value <span class="hljs-type">int</span>)</span> <span class="hljs-type">int</span> &#123;<br><br>    fmt.Println(index)<br><br>    <span class="hljs-keyword">return</span> index<br>&#125;<br><br>func <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    defer <span class="hljs-title function_">function</span><span class="hljs-params">(<span class="hljs-number">1</span>, function(<span class="hljs-number">3</span>, <span class="hljs-number">0</span>)</span>)<br>    defer <span class="hljs-title function_">function</span><span class="hljs-params">(<span class="hljs-number">2</span>, function(<span class="hljs-number">4</span>, <span class="hljs-number">0</span>)</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">3<br>4<br>2<br>1<br></code></pre></td></tr></table></figure>
<h3 id="defer-的一些计算"><a href="#defer-的一些计算" class="headerlink" title="defer 的一些计算"></a>defer 的一些计算</h3><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DeferFunc1</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> (t <span class="hljs-type">int</span>) &#123;<br>    t = i<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        t += <span class="hljs-number">3</span><br>    &#125;()<br>    <span class="hljs-keyword">return</span> t<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DeferFunc2</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    t := i<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        t += <span class="hljs-number">3</span><br>    &#125;()<br>    <span class="hljs-keyword">return</span> t<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DeferFunc3</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> (t <span class="hljs-type">int</span>) &#123;<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        t += i<br>    &#125;()<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DeferFunc4</span><span class="hljs-params">()</span></span> (t <span class="hljs-type">int</span>) &#123;<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;<br>        fmt.Println(i)<br>        fmt.Println(t)<br>    &#125;(t)<br>    t = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(DeferFunc1(<span class="hljs-number">1</span>)) <span class="hljs-comment">// 4</span><br>    fmt.Println(DeferFunc2(<span class="hljs-number">1</span>)) <span class="hljs-comment">// 1</span><br>    fmt.Println(DeferFunc3(<span class="hljs-number">1</span>)) <span class="hljs-comment">// 3</span><br>    DeferFunc4() <span class="hljs-comment">// 0 2</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>第四个的情况：</p>
<ol>
<li>初始化返回值t为零值 0</li>
<li>首先执行defer的第一步，赋值defer中的func入参t为0</li>
<li>执行defer的第二步，将defer压栈</li>
<li>将t赋值为1</li>
<li>执行return语句，将返回值t赋值为2</li>
<li>执行defer的第三步，出栈并执行<br>因为在入栈时defer执行的func的入参已经赋值了，此时它作为的是一个形式参数，所以打印为0；相对应的因为最后已经将t的值修改为2，所以再打印一个2</li>
</ol>
<h3 id="rune-类型"><a href="#rune-类型" class="headerlink" title="rune 类型"></a>rune 类型</h3><p>相当 int32。</p>
<p>golang中的字符串底层实现是通过 byte 数组的，中文字符在 unicode 下占 2 个字节，在 utf-8 编码下占 3 个字节，而 golang 默认编码正好是 utf-8<br>byte 等同于 int8，常用来处理 ascii 字符<br>rune 等同于 int32，常用来处理 unicode 或 utf-8 字符</p>
<h3 id="golang-中解析-tag-是怎么实现的？反射原理是什么？"><a href="#golang-中解析-tag-是怎么实现的？反射原理是什么？" class="headerlink" title="golang 中解析 tag 是怎么实现的？反射原理是什么？"></a>golang 中解析 tag 是怎么实现的？反射原理是什么？</h3><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>	<span class="hljs-string">&quot;fmt&quot;</span><br>	<span class="hljs-string">&quot;reflect&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>	name <span class="hljs-type">string</span> <span class="hljs-string">`json:name-field`</span><br>	age  <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	user := &amp;User&#123;<span class="hljs-string">&quot;John Doe The Fourth&quot;</span>, <span class="hljs-number">20</span>&#125;<br><br>	field, ok := reflect.TypeOf(user).Elem().FieldByName(<span class="hljs-string">&quot;name&quot;</span>)<br>	<span class="hljs-keyword">if</span> !ok &#123;<br>		<span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;Field not found&quot;</span>)<br>	&#125;<br>	fmt.Println(getStructTag(field))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getStructTag</span><span class="hljs-params">(f reflect.StructField)</span></span> <span class="hljs-type">string</span> &#123;<br>	<span class="hljs-keyword">return</span> <span class="hljs-type">string</span>(f.Tag)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>输出：<code>json:name-field</code></p>
<p>由反射可直接得到结构域，调用结构域中的Tag即可获取到tag进行处理。</p>
<p><strong>gorm json yaml gRPC protobuf gin.Bind()都是通过反射来实现的</strong></p>
<h3 id="goroutine什么情况下会阻塞"><a href="#goroutine什么情况下会阻塞" class="headerlink" title="goroutine什么情况下会阻塞"></a>goroutine什么情况下会阻塞</h3><ol>
<li><strong>由于原子、互斥量或通道操作调用导致 Goroutine 阻塞</strong>，调度器将把当前阻塞的 Goroutine 切换出去，重新调度 LRQ 上的其他 Goroutine；</li>
<li><strong>由于网络请求和 IO 操作导致 Goroutine 阻塞。</strong>Go 程序提供了网络轮询器（NetPoller）来处理网络请求和 IO 操作的问题，其后台通过 kqueue（MacOS），epoll（Linux）或 iocp（Windows）来实现 IO 多路复用。通过<strong>使用 NetPoller 进行网络系统调用</strong>，调度器可以防止 Goroutine 在进行这些系统调用时阻塞 M。这可以让 M 执行 P 的 LRQ 中其他的 Goroutines，而不需要创建新的 M。执行网络系统调用不需要额外的 M，<strong>网络轮询器使用系统线程</strong>，它时刻处理一个有效的事件循环，有助于减少操作系统上的调度负载。用户层眼中看到的 Goroutine 中的“block socket”，实现了 goroutine-per-connection 简单的网络编程模式。实际上是通过 Go runtime 中的 netpoller 通过 Non-block socket + I/O 多路复用机制“模拟”出来的。</li>
<li>当调用一些系统方法的时候（如文件 I/O），如果<strong>系统方法调用的时候发生阻塞</strong>，这种情况下，网络轮询器（NetPoller）无法使用，而进行系统调用的 G1 将阻塞当前 M1。调度器引入 其它M 来服务 M1 的 P。</li>
<li>如果在 <strong>Goroutine 去执行一个 sleep 操作</strong>，导致 M 被阻塞了。Go 程序后台有一个监控线程 sysmon，它监控那些长时间运行的 G 任务然后设置可以强占的标识符，别的 Goroutine 就可以抢先进来执行。</li>
</ol>
<h3 id="select-语句"><a href="#select-语句" class="headerlink" title="select 语句"></a>select 语句</h3><p>go 的 select 为 golang 提供了多路 IO 复用机制，和其他 IO 复用一样，用于检测是否有读写事件是否 ready。linux 的系统 IO 模型有 select，poll，epoll，go 的 select 和 linux 系统 select 非常相似。</p>
<p><strong>用于实现停机</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  stop := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br>  <span class="hljs-keyword">go</span> loop(stop)<br>  &lt;- time.After(time.Millisecond)<br>  <span class="hljs-built_in">close</span>(stop) <span class="hljs-comment">// 也可使用 stop &lt;- struct&#123;&#125;&#123;&#125;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">loop</span><span class="hljs-params">(stop &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)</span></span> &#123;<br>  <span class="hljs-keyword">for</span> &#123;<br>    <span class="hljs-keyword">select</span> &#123;<br>    <span class="hljs-keyword">case</span> &lt;-stop:<br>      fmt.Println(<span class="hljs-string">&quot;stopped&quot;</span>)<br>      <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">default</span>:<br>      <span class="hljs-comment">//do business</span><br>      fmt.Println(<span class="hljs-string">&quot;looping&quot;</span>)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>结合 context 实现停机</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">func <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>  ctx, cancel := context.WithCancel(context.TODO())<br>  go <span class="hljs-title function_">func</span><span class="hljs-params">(ctx context.Context)</span> &#123;<br>    time.Sleep(time.Millisecond)<br>    select &#123;<br>    <span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>      fmt.Println(<span class="hljs-string">&quot;task canceled&quot;</span>)<br>    <span class="hljs-keyword">default</span>:<br>      fmt.Println(<span class="hljs-string">&quot;running&quot;</span>)<br>      <span class="hljs-comment">// do business</span><br>    &#125;<br>  &#125;(ctx)<br>  cancel()<br>  time.Sleep(<span class="hljs-number">2</span> * time.Millisecond)<br>&#125;<br><span class="hljs-comment">// task canceled</span><br></code></pre></td></tr></table></figure>
<p>Context 除支持直接取消外，还支持超时取消 (WithDeadline，WithTimeout)。</p>
<p><strong>优雅停机</strong></p>
<p>优雅停机的思路一般都较为类似：先改状态为停机，接收函数停止接收任务，等待任务队列排空后退出进程。</p>
<p>Java 应用优雅停机一般只需做前 2 步即可，第 3 步通常利用线程池完成（shutdown，awaitTermination）。</p>
<p>上文提到，Go 并没有线程池概念，但利用 WaitGroup 实现优雅停机非常简单，见如下代码：</p>
<ul>
<li>接收任务时，先检查 stop channnel 是否关闭，如果关闭则拒绝任务，反之WaitGroup 加 1 并新建 goroutine 执行任务，执行完成后，WaitGroup 减 1。</li>
<li>停机时，关闭 stop channel，随后调用 WaitGroup Wait 等待所有任务完成。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> wg = sync.WaitGroup&#123;&#125;<br><span class="hljs-keyword">var</span> stop = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">accept</span><span class="hljs-params">(task <span class="hljs-keyword">func</span>()</span></span>) <span class="hljs-type">error</span> &#123;<br>  <span class="hljs-keyword">select</span> &#123;<br>  <span class="hljs-keyword">case</span> &lt;-stop:<br>    <span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;reject&quot;</span>)<br>  <span class="hljs-keyword">default</span>:<br>    wg.Add(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>      <span class="hljs-keyword">defer</span> wg.Done()<br>      handle(task)<br>    &#125;()<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handle</span><span class="hljs-params">(task <span class="hljs-keyword">func</span>()</span></span>) &#123;<br>  task()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">shutdown</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-built_in">close</span>(stop)<br>  wg.Wait()<br>&#125;<br></code></pre></td></tr></table></figure>
<p>1）select 操作至少要有一个 case 语句，出现读写 nil 的 channel 该分支会忽略，在 nil 的 channel 上操作则会报错。<br>2）select 仅支持管道，而且是单协程操作。<br>3）每个 case 语句仅能处理一个管道，要么读要么写。<br>4）多个 case 语句的执行顺序是随机的。<br>5）存在 default 语句，select 将不会阻塞，但是存在 default 会影响性能。</p>
<h3 id="Go-的-defer-底层数据结构和一些特性？"><a href="#Go-的-defer-底层数据结构和一些特性？" class="headerlink" title="Go 的 defer 底层数据结构和一些特性？"></a><strong>Go 的 defer 底层数据结构和一些特性？</strong></h3><p>每个 defer 语句都对应一个 <code>_defer</code> 实例，多个实例使用指针连接起来形成一个单链表，保存在 gotoutine 数据结构中，每次插入_defer 实例，均插入到链表的头部，函数结束再一次从头部取出，从而形成后进先出的效果。</p>
<p><strong>defer 的规则总结</strong>：</p>
<ul>
<li>延迟函数的参数是 defer 语句出现的时候就已经确定了的。</li>
<li>延迟函数执行按照后进先出的顺序执行，即先出现的 defer 最后执行。</li>
<li>延迟函数可能操作主函数的返回值。</li>
<li>申请资源后立即使用 defer 关闭资源是个好习惯。</li>
</ul>
<h3 id="Go-string-和-byte-的区别"><a href="#Go-string-和-byte-的区别" class="headerlink" title="Go string 和 []byte 的区别"></a>Go string 和 []byte 的区别</h3><ul>
<li>string 不可变、[]byte 可变</li>
<li>string 底层是只读字符序列，[]byte 是动态字节数组</li>
</ul>
<h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><h2 id="如何保证幂等写？"><a href="#如何保证幂等写？" class="headerlink" title="如何保证幂等写？"></a>如何保证幂等写？</h2><p>幂等性是指 <strong>同一操作的多次执行对系统状态的影响与一次执行结果一致</strong>。例如，支付接口若因网络重试被多次调用，最终应确保仅扣款一次。实现幂等写的核心方案：</p>
<ul>
<li><p><strong>唯一标识（幂等键）</strong>：客户端为每个请求生成全局唯一ID（如 UUID、业务主键），服务端校验该ID是否已处理，适用场景接口调用、消息消费等。</p>
<ul>
<li><p>所谓请求序列号，其实就是每次向服务端请求时候附带一个短时间内唯一不重复的序列号，该序列号可以是一个有序 ID，也可以是一个订单号，一般由下游生成，在调用上游服务端接口时附加该序列号和用于认证的 ID。</p>
<p>当上游服务器收到请求信息后拿取该 序列号 和下游 认证ID 进行组合，形成用于操作 Redis 的 Key，然后到 Redis 中查询是否存在对应的 Key 的键值对，根据其结果：</p>
<ul>
<li>如果存在，就说明已经对该下游的该序列号的请求进行了业务处理，这时可以直接响应重复请求的错误信息。</li>
<li>如果不存在，就以该 Key 作为 Redis 的键，以下游关键信息作为存储的值（例如下游商传递的一些业务逻辑信息），将该键值对存储到 Redis 中 ，然后再正常执行对应的业务逻辑即可。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img  src="6376434288b6f4198640ad8bd6d28668.png"   style="zoom: 80%;" /><span class="image-caption">img</span></p>
<ul>
<li><strong>数据库事务 + 乐观锁</strong>：通过版本号或状态字段控制并发更新，确保多次更新等同于单次操作，适用场景数据库记录更新（如余额扣减、订单状态变更）。<ul>
<li>数据库乐观锁方案一般只能适用于执行“更新操作”的过程，我们可以提前在对应的数据表中多添加一个字段，充当当前数据的版本标识。这样每次对该数据库该表的这条数据执行更新时，都会将该版本标识作为一个条件，值为上次待更新数据中的版本标识的值。</li>
</ul>
</li>
</ul>
<p><img  src="1fb6403097c9e0103051a7d7582ad10d.png"   style="zoom:67%;" /><span class="image-caption">img</span></p>
<ul>
<li><p><strong>数据库唯一约束</strong>：利用数据库唯一索引防止重复数据写入，适用场景数据插入场景（如订单创建）。</p>
<ul>
<li><p>数据库唯一主键的实现主要是利用数据库中主键唯一约束的特性，一般来说唯一主键比较适用于“插入”时的幂等性，其能保证一张表中只能存在一条带该唯一主键的记录。</p>
<p>使用数据库唯一主键完成幂等性时需要注意的是，该主键一般来说并不是使用数据库中自增主键，而是使用分布式 ID 充当主键（可以参考 Java 中分布式 ID 的设计方案），这样才能能保证在分布式环境下 ID 的全局唯一性。</p>
</li>
</ul>
</li>
</ul>
<p><img  src="31362183369a11e7f38403e45eeb1463.png"   style="zoom:80%;" /><span class="image-caption">img</span></p>
<ul>
<li><strong>分布式锁</strong>：通过锁机制保证同一时刻仅有一个请求执行关键操作，适用场景高并发下的资源抢夺（如秒杀）。</li>
<li><strong>消息去重</strong>：消息队列生产者为每条消息生成唯一的消息 ID，消费者在处理消息前，先检查该消息 ID 是否已经处理过，如果已经处理过则丢弃该消息。</li>
</ul>
<h2 id="消息队列使用场景有哪些？"><a href="#消息队列使用场景有哪些？" class="headerlink" title="消息队列使用场景有哪些？"></a>消息队列使用场景有哪些？</h2><ul>
<li><strong>解耦</strong>：可以在多个系统之间进行解耦，将原本通过网络之间的调用的方式改为使用MQ进行消息的异步通讯，只要该操作不是需要同步的，就可以改为使用MQ进行不同系统之间的联系，这样项目之间不会存在耦合，系统之间不会产生太大的影响，就算一个系统挂了，也只是消息挤压在MQ里面没人进行消费而已，不会对其他的系统产生影响。</li>
<li><strong>异步</strong>：加入一个操作涉及到好几个步骤，这些步骤之间不需要同步完成，比如客户去创建了一个订单，还要去客户轨迹系统添加一条轨迹、去库存系统更新库存、去客户系统修改客户的状态等等。这样如果这个系统都直接进行调用，那么将会产生大量的时间，这样对于客户是无法接收的；并且像添加客户轨迹这种操作是不需要去同步操作的，如果使用MQ将客户创建订单时，将后面的轨迹、库存、状态等信息的更新全都放到MQ里面然后去异步操作，这样就可加快系统的访问速度，提供更好的客户体验。</li>
<li><strong>削峰</strong>：一个系统访问流量有高峰时期，也有低峰时期，比如说，中午整点有一个抢购活动等等。比如系统平时流量并不高，一秒钟只有100多个并发请求，系统处理没有任何压力，一切风平浪静，到了某个抢购活动时间，系统并发访问了剧增，比如达到了每秒5000个并发请求，而我们的系统每秒只能处理2000个请求，那么由于流量太大，我们的系统、数据库可能就会崩溃。这时如果使用MQ进行流量削峰，将用户的大量消息直接放到MQ里面，然后我们的系统去按自己的最大消费能力去消费这些消息，就可以保证系统的稳定，只是可能要跟进业务逻辑，给用户返回特定页面或者稍后通过其他方式通知其结果</li>
</ul>
<h2 id="消息重复消费怎么解决？"><a href="#消息重复消费怎么解决？" class="headerlink" title="消息重复消费怎么解决？"></a>消息重复消费怎么解决？</h2><p>生产端为了保证消息发送成功，可能会重复推送(直到收到成功ACK)，会产生重复消息。但是一个成熟的MQ Server框架一般会想办法解决，避免存储重复消息(比如：空间换时间，存储已处理过的message_id)，给生产端提供一个幂等性的发送消息接口。</p>
<p>但是消费端却无法根本解决这个问题，在高并发标准要求下，拉取消息+业务处理+提交消费位移需要做事务处理，另外消费端服务可能宕机，很可能会拉取到重复消息。</p>
<p>所以，只能业务端自己做控制，<strong>对于已经消费成功的消息，本地数据库表或Redis缓存业务标识，每次处理前先进行校验，保证幂等。</strong></p>
<h2 id="消息丢失怎么解决的消息丢失怎么解决的？"><a href="#消息丢失怎么解决的消息丢失怎么解决的？" class="headerlink" title="消息丢失怎么解决的消息丢失怎么解决的？"></a>消息丢失怎么解决的消息丢失怎么解决的？</h2><p>使用一个消息队列，其实就分为三大块：<strong>生产者、中间件、消费者</strong>，所以要保证消息就是保证三个环节都不能丢失数据。</p>
<p><img  src="1719381898719-af6c00bf-8760-4639-bd21-e6d422ef7779.webp"   style="zoom:80%;" /><span class="image-caption">img</span></p>
<ul>
<li><strong>消息生产阶段</strong>：生产者会不会丢消息，取决于生产者对于异常情况的处理是否合理。从消息被生产出来，然后提交给 MQ 的过程中，只要能正常收到 （ MQ 中间件） 的 ack 确认响应，就表示发送成功，所以只要处理好返回值和异常，如果返回异常则进行消息重发，那么这个阶段是不会出现消息丢失的。</li>
<li><strong>消息存储阶段</strong>：Kafka 在使用时是部署一个集群，生产者在发布消息时，队列中间件通常会写「多个节点」，也就是有多个副本，这样一来，即便其中一个节点挂了，也能保证集群的数据不丢失。</li>
<li><strong>消息消费阶段</strong>：消费者接收消息+消息处理之后，才回复 ack 的话，那么消息阶段的消息不会丢失。不能收到消息就回 ack，否则可能消息处理中途挂掉了，消息就丢失了。</li>
</ul>
<h2 id="消息队列的可靠性、顺序性怎么保证？"><a href="#消息队列的可靠性、顺序性怎么保证？" class="headerlink" title="消息队列的可靠性、顺序性怎么保证？"></a>消息队列的可靠性、顺序性怎么保证？</h2><p>消息可靠性可以通过下面这些方式来保证</p>
<ul>
<li><strong>消息持久化</strong>：确保消息队列能够持久化消息是非常关键的。在系统崩溃、重启或者网络故障等情况下，未处理的消息不应丢失。例如，像 RabbitMQ 可以通过配置将消息持久化到磁盘，通过将队列和消息都设置为持久化的方式（设置<code>durable = true</code>），这样在服务器重启后，消息依然可以被重新读取和处理。</li>
<li><strong>消息确认机制</strong>：消费者在成功处理消息后，应该向消息队列发送确认（acknowledgment）。消息队列只有收到确认后，才会将消息从队列中移除。如果没有收到确认，消息队列可能会在一定时间后重新发送消息给其他消费者或者再次发送给同一个消费者。以 Kafka 为例，消费者通过<code>commitSync</code>或者<code>commitAsync</code>方法来提交偏移量（offset），从而确认消息的消费。</li>
<li><strong>消息重试策略</strong>：当消费者处理消息失败时，需要有合理的重试策略。可以设置重试次数和重试间隔时间。例如，在第一次处理失败后，等待一段时间（如 5 秒）后进行第二次重试，如果重试多次（如 3 次）后仍然失败，可以将消息发送到死信队列，以便后续人工排查或者采取其他特殊处理。</li>
</ul>
<p>消息顺序性保证的方式如下：</p>
<ul>
<li><strong>有序消息处理场景识别</strong>：首先需要明确业务场景中哪些消息是需要保证顺序的。例如，在金融交易系统中，对于同用户的转账操作顺序是不能打乱的。对于需要顺序处理的消息，要确保消息队列和消费者能够按照特定的顺序进行处理。</li>
<li><strong>消息队列对顺序性的支持</strong>：部分消息队列本身提供了顺序性保证的功能。比如 Kafka 可以通过将消息划分到同一个分区（Partition）来保证消息在分区内是有序的，消费者按照分区顺序读取消息就可以保证消息顺序。但这也可能会限制消息的并行处理程度，需要在顺序性和吞吐量之间进行权衡。</li>
<li><strong>消费者顺序处理策略</strong>：消费者在处理顺序消息时，应该避免并发处理可能导致顺序打乱的情况。例如，可以通过单线程或者使用线程池并对顺序消息进行串行化处理等方式，确保消息按照正确的顺序被消费。</li>
</ul>
<h2 id="如何保证幂等写？-1"><a href="#如何保证幂等写？-1" class="headerlink" title="如何保证幂等写？"></a>如何保证幂等写？</h2><p>幂等性是指 <strong>同一操作的多次执行对系统状态的影响与一次执行结果一致</strong>。例如，支付接口若因网络重试被多次调用，最终应确保仅扣款一次。实现幂等写的核心方案：</p>
<ul>
<li>唯一标识（幂等键）：客户端为每个请求生成全局唯一ID（如 UUID、业务主键），服务端校验该ID是否已处理，适用场景接口调用、消息消费等。</li>
<li>数据库事务 + 乐观锁：通过版本号或状态字段控制并发更新，确保多次更新等同于单次操作，适用场景数据库记录更新（如余额扣减、订单状态变更）。</li>
<li>数据库唯一约束：利用数据库唯一索引防止重复数据写入，适用场景数据插入场景（如订单创建）。</li>
<li>分布式锁：通过锁机制保证同一时刻仅有一个请求执行关键操作，适用场景高并发下的资源抢夺（如秒杀）。</li>
<li>消息去重：消息队列生产者为每条消息生成唯一的消息 ID，消费者在处理消息前，先检查该消息 ID 是否已经处理过，如果已经处理过则丢弃该消息。</li>
</ul>
<h2 id="如何处理消息队列的消息积压问题？"><a href="#如何处理消息队列的消息积压问题？" class="headerlink" title="如何处理消息队列的消息积压问题？"></a>如何处理消息队列的消息积压问题？</h2><p>消息积压是因为生产者的生产速度，大于消费者的消费速度。遇到消息积压问题时，我们需要先排查，是不是有bug产生了。</p>
<p>如果不是bug，我们可以<strong>优化一下消费的逻辑</strong>，比如之前是一条一条消息消费处理的话，我们可以确认是不是可以优为<strong>批量处理消息</strong>。如果还是慢，我们可以考虑水平扩容，增加Topic的队列数，和消费组机器的数量，提升整体消费能力。</p>
<p>如果是bug导致几百万消息持续积压几小时。有如何处理呢？需要解决bug，<strong>临时紧急扩容</strong>，大概思路如下：</p>
<blockquote>
<ol>
<li>先修复consumer消费者的问题，以确保其恢复消费速度，然后将现有consumer 都停掉。</li>
<li>新建一个 topic，partition 是原来的 10 倍，临时建立好原先10倍的queue 数量。</li>
<li>然后写一个临时的分发数据的 consumer 程序，这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮询写入临时建立好的 10 倍数量的 queue。</li>
<li>接着临时征用 10 倍的机器来部署 consumer，每一批 consumer 消费一个临时 queue 的数据。这种做法相当于是临时将 queue 资源和 consumer 资源扩大 10 倍，以正常的 10 倍速度来消费数据。</li>
<li>等快速消费完积压数据之后，得恢复原先部署的架构，重新用原先的 consumer 机器来消费消息。</li>
</ol>
</blockquote>
<h2 id="如何保证数据一致性，事务消息如何实现？"><a href="#如何保证数据一致性，事务消息如何实现？" class="headerlink" title="如何保证数据一致性，事务消息如何实现？"></a>如何保证数据一致性，事务消息如何实现？</h2><p>一条普通的MQ消息，从产生到被消费，大概流程如下：</p>
<p><img  src="image-20250407142107477.png"   style="zoom:80%;" /><span class="image-caption">image-20250407142107477</span></p>
<ol>
<li>生产者产生消息，发送带MQ服务器</li>
<li>MQ收到消息后，将消息持久化到存储系统。</li>
<li>MQ服务器返回ACk到生产者。</li>
<li>MQ服务器把消息push给消费者</li>
<li>消费者消费完消息，响应ACK</li>
<li>MQ服务器收到ACK，认为消息消费成功，即在存储中删除消息。</li>
</ol>
<p>我们举个<strong>下订单</strong>的例子吧。订单系统创建完订单后，再发送消息给下游系统。如果订单创建成功，然后消息没有成功发送出去，下游系统就无法感知这个事情，出导致数据不一致。</p>
<p>如何保证数据一致性呢？可以使用<strong>事务消息</strong>。一起来看下事务消息是如何实现的吧。</p>
<p><img  src="image-20250407142122992.png"   style="zoom:80%;" /><span class="image-caption">image-20250407142122992</span></p>
<ol>
<li>生产者产生消息，发送一条<strong>半事务消息</strong>到MQ服务器</li>
<li>MQ收到消息后，将消息持久化到存储系统，这条消息的状态是<strong>待发送</strong>状态。</li>
<li>MQ服务器返回ACK确认到生产者，此时MQ不会触发消息推送事件</li>
<li>生产者执行本地事务</li>
<li>如果本地事务执行成功，即commit执行结果到MQ服务器；如果执行失败，发送rollback。</li>
<li>如果是正常的commit，MQ服务器更新消息状态为<strong>可发送</strong>；如果是rollback，即删除消息。</li>
<li>如果消息状态更新为可发送，则MQ服务器会push消息给消费者。消费者消费完就回ACK。</li>
<li>如果MQ服务器长时间没有收到生产者的commit或者rollback，它会反查生产者，然后根据查询到的结果执行最终状态。</li>
</ol>
<h2 id="消息队列是参考哪种设计模式？"><a href="#消息队列是参考哪种设计模式？" class="headerlink" title="消息队列是参考哪种设计模式？"></a>消息队列是参考哪种设计模式？</h2><p>是参考了观察者模式和发布订阅模式，两种设计模式思路是一样的，举个生活例子：</p>
<ul>
<li>观察者模式：某公司给自己员工发月饼发粽子，是由公司的行政部门发送的，这件事不适合交给第三方，原因是“公司”和“员工”是一个整体</li>
<li>发布-订阅模式：某公司要给其他人发各种快递，因为“公司”和“其他人”是独立的，其唯一的桥梁是“快递”，所以这件事适合交给第三方快递公司解决</li>
</ul>
<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>观察者模式实际上就是一个一对多的关系，在观察者模式中存在一个主题和多个观察者，主题也是被观察者，当我们主题发布消息时，会通知各个观察者，观察者将会收到最新消息，图解如下：每个观察者首先订阅主题，订阅成功后当主题发送消息时会循环整个观察者列表，逐一发送消息通知。 <img  src="1723798409094-5099fa2a-c72c-4c67-bab7-09bbca9e0834.webp"   style="zoom: 67%;" /><span class="image-caption">img</span></p>
<h3 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h3><p>发布订阅模式和观察者模式的区别就是发布者和订阅者完全解耦，通过中间的发布订阅中心进行消息通知，发布者并不知道自己发布的消息会通知给谁，因此发布订阅模式有三个重要角色，发布者-&gt;发布订阅中心-&gt;订阅者。</p>
<p>图解如下：当发布者发布消息到发布订阅中心后，发布订阅中心会将消息通知给所有订阅该发布者的订阅者 <img  src="1723798423949-97ae81c8-3536-40c6-bcc6-1509a3056a04.webp"   style="zoom: 67%;" /><span class="image-caption">img</span></p>
<h2 id="让你写一个消息队列，该如何进行架构设计？"><a href="#让你写一个消息队列，该如何进行架构设计？" class="headerlink" title="让你写一个消息队列，该如何进行架构设计？"></a>让你写一个消息队列，该如何进行架构设计？</h2><ol>
<li>首先是消息队列的整体流程，producer发送消息给broker，broker存储好，broker再发送给consumer消费，consumer回复消费确认等。</li>
<li>producer发送消息给broker，broker发消息给consumer消费，那就需要两次RPC了，RPC如何设计呢？可以参考开源框架Dubbo，你可以说说服务发现、序列化协议等等</li>
<li>broker考虑如何持久化呢，是放文件系统还是数据库呢，会不会消息堆积呢，消息堆积如何处理呢。</li>
<li>消费关系如何保存呢？点对点还是广播方式呢？广播关系又是如何维护呢？zk还是config server</li>
<li>消息可靠性如何保证呢？如果消息重复了，如何幂等处理呢？</li>
<li>消息队列的高可用如何设计呢？可以参考Kafka的高可用保障机制。多副本 -&gt; leader &amp; follower -&gt; broker 挂了重新选举 leader 即可对外服务。</li>
<li>消息事务特性，与本地业务同个事务，本地消息落库;消息投递到服务端，本地才删除；定时任务扫描本地消息库，补偿发送。</li>
<li>MQ得伸缩性和可扩展性，如果消息积压或者资源不够时，如何支持快速扩容，提高吞吐？可以参照一下 Kafka 的设计理念，broker -&gt; topic -&gt; partition，每个 partition 放一个机器，就存一部分数据。如果现在资源不够了，简单啊，给 topic 增加 partition，然后做数据迁移，增加机器，不就可以存放更多数据，提供更高的吞吐量了。</li>
</ol>
<h2 id="RocketMQ和Kafka的区别是什么？如何做技术选型？"><a href="#RocketMQ和Kafka的区别是什么？如何做技术选型？" class="headerlink" title="RocketMQ和Kafka的区别是什么？如何做技术选型？"></a>RocketMQ和Kafka的区别是什么？如何做技术选型？</h2><p>Kafka的优缺点：</p>
<ul>
<li>优点：首先，Kafka的最大优势就在于它的高吞吐量，在普通机器4CPU8G的配置下，一台机器可以抗住十几万的QPS，这一点还是相当优越的。Kafka支持集群部署，如果部分机器宕机不可用，则不影响Kafka的正常使用。</li>
<li>缺点：Kafka有可能会造成数据丢失，因为它在收到消息的时候，并不是直接写到物理磁盘的，而是先写入到磁盘缓冲区里面的。Kafka功能比较的单一 主要的就是支持收发消息，高级功能基本没有，就会造成适用场景受限。</li>
</ul>
<p>RocketMQ是阿里巴巴开源的消息中间件，优缺点</p>
<ul>
<li>优点：支持功能比较多，比如延迟队列、消息事务等等，吞吐量也高，单机吞吐量达到 10 万级，支持大规模集群部署，线性扩展方便，Java语言开发，满足了国内绝大部分公司技术栈</li>
<li>缺点：性能相比 kafka 是弱一点，因为 kafka 用到了 sendfile 的零拷贝技术，而 RocketMQ 主要是用 mmap+write 来实现零拷贝。</li>
</ul>
<p>该怎么选择呢？</p>
<ul>
<li>如果我们业务只是收发消息这种单一类型的需求，而且可以允许小部分数据丢失的可能性，但是又要求极高的吞吐量和高性能的话，就直接选Kafka就行了，就好比我们公司想要收集和传输用户行为日志以及其他相关日志的处理，就选用的Kafka中间件。</li>
<li>如果公司的需要通过 mq 来实现一些业务需求，比如延迟队列、消息事务等，公司技术栈主要是Java语言的话，就直接一步到位选择RocketMQ，这样会省很多事情。</li>
</ul>
<h2 id="RocketMQ延时消息的底层原理"><a href="#RocketMQ延时消息的底层原理" class="headerlink" title="RocketMQ延时消息的底层原理"></a>RocketMQ延时消息的底层原理</h2><p>总体的原理示意图，如下所示：</p>
<p><img  src="1720428795952-bba954e9-c9b6-45c5-aa05-8cc1d49c0e3c.png"   style="zoom: 50%;" /><span class="image-caption">img</span></p>
<p>broker 在接收到延时消息的时候，会将延时消息存入到延时Topic的队列中，然后ScheduleMessageService中，每个 queue 对应的定时任务会不停地被执行，检查 queue 中哪些消息已到设定时间，然后转发到消息的原始Topic，这些消息就会被各自的 producer 消费了。</p>
<h2 id="RocketMQ消息顺序怎么保证？"><a href="#RocketMQ消息顺序怎么保证？" class="headerlink" title="RocketMQ消息顺序怎么保证？"></a>RocketMQ消息顺序怎么保证？</h2><p>消息的有序性是指消息的消费顺序能够严格保存与消息的发送顺序一致。例如，一个订单产生了3条消息，分别是订单创建、订单付款和订单完成。在消息消费时，同一条订单要严格按照这个顺序进行消费，否则业务会发生混乱。同时，不同订单之间的消息又是可以并发消费的，比如可以先执行第三个订单的付款，再执行第二个订单的创建。</p>
<p>RocketMQ采用了局部顺序一致性的机制，实现了单个队列中的消息严格有序。也就是说，如果想要保证顺序消费，必须将一组消息发送到同一个队列中，然后再由消费者进行注意消费。</p>
<p>RocketMQ推荐的顺序消费解决方案是：按照业务划分不同的队列，然后将需要顺序消费的消息发往同一队列中即可，不同业务之间的消息仍采用并发消费。这种方式在满足顺序消费的同时提高了消息的处理速度，在一定程度上避免了消息堆积问题</p>
<p>RocketMQ 顺序消息的原理是：</p>
<ul>
<li>在 Producer（生产者） 把一批需要保证顺序的消息发送到同一个 MessageQueue</li>
<li>Consumer（消费者） 则通过加锁的机制来保证消息消费的顺序性，Broker 端通过对 MessageQueue 进行加锁，保证同一个 MessageQueue 只能被同一个 Consumer 进行消费。</li>
</ul>
<h2 id="对Kafka有什么了解吗？"><a href="#对Kafka有什么了解吗？" class="headerlink" title="对Kafka有什么了解吗？"></a>对Kafka有什么了解吗？</h2><p>Kafka特点如下：</p>
<ul>
<li>高吞吐量、低延迟：kafka每秒可以处理几十万条消息，它的延迟最低只有几毫秒，每个topic可以分多个partition, consumer group 对partition进行consume操作。</li>
<li>可扩展性：kafka集群支持热扩展</li>
<li>持久性、可靠性：消息被持久化到本地磁盘，并且支持数据备份防止数据丢失</li>
<li>容错性：允许集群中节点失败（若副本数量为n,则允许n-1个节点失败）</li>
<li>高并发：支持数千个客户端同时读写</li>
</ul>
<h2 id="Kafka-为什么这么快？"><a href="#Kafka-为什么这么快？" class="headerlink" title="Kafka 为什么这么快？"></a>Kafka 为什么这么快？</h2><ul>
<li><strong>顺序写入优化</strong>：Kafka将消息顺序写入磁盘，减少了磁盘的寻道时间。这种方式比随机写入更高效，因为磁盘读写头在顺序写入时只需移动一次。</li>
<li><strong>批量处理技术</strong>：Kafka支持批量发送消息，这意味着生产者在发送消息时可以等待直到有足够的数据积累到一定量，然后再发送。这种方法减少了网络开销和磁盘I/O操作的次数，从而提高了吞吐量。</li>
<li><strong>零拷贝技术</strong>：Kafka使用零拷贝技术，可以直接将数据从磁盘发送到网络套接字，避免了在用户空间和内核空间之间的多次数据拷贝。这大幅降低了CPU和内存的负载，提高了数据传输效率。</li>
<li><strong>压缩技术</strong>：Kafka支持对消息进行压缩，这不仅减少了网络传输的数据量，还提高了整体的吞吐量。</li>
</ul>
<h2 id="kafka的模型介绍一下，kafka是推送还是拉取？"><a href="#kafka的模型介绍一下，kafka是推送还是拉取？" class="headerlink" title="kafka的模型介绍一下，kafka是推送还是拉取？"></a>kafka的模型介绍一下，kafka是推送还是拉取？</h2><h3 id="消费者模型"><a href="#消费者模型" class="headerlink" title="消费者模型"></a>消费者模型</h3><p>消息由生产者发送到kafka集群后，会被消费者消费。一般来说我们的消费模型有两种：推送模型(psuh)和拉取模型(pull)。</p>
<p><strong>推送模型（push）</strong></p>
<ul>
<li>基于推送模型（push）的消息系统，有消息代理记录消费者的消费状态。</li>
<li>消息代理在将消息推送到消费者后，标记这条消息已经消费，但这种方式无法很好地保证消费被处理。</li>
<li>如果要保证消息被处理，消息代理发送完消息后，要设置状态为“已发送”，只要收到消费者的确认请求后才更新为“已消费”，这就需要代理中记录所有的消费状态，但显然这种方式不可取。</li>
</ul>
<p>缺点：</p>
<ul>
<li><strong>push模式很难适应消费速率不同的消费者</strong></li>
<li>因为消息发送速率是由broker决定的，push模式的目标是尽可能以最快速度传递消息，但是这样很容易造成consumer来不及处理消息，典型的表现就是拒绝服务以及网络拥塞。</li>
</ul>
<p><strong>拉取模型(pull)</strong></p>
<p>kafka采用拉取模型，由消费者自己记录消费状态，每个消费者互相独立地顺序拉取每个分区的消息。</p>
<p><img  src="/1717921512808-fb0372de-7ada-4bc4-bfb5-7e599d9335ac.png"  ><span class="image-caption">img</span></p>
<p>说明：</p>
<ul>
<li>有两个消费者（不同消费者组）拉取同一个主题的消息，消费者A的消费进度是3，消费者B的消费进度是6。</li>
<li>消费者拉取的最大上限通过最高水位（watermark）控制，生产者最新写入的消息如果还没有达到备份数量，对消费者是不可见的。</li>
<li>这种由消费者控制偏移量的优点是：<strong>消费者可以按照任意的顺序消费消息</strong>。比如，消费者可以重置到旧的偏移量，重新处理之前已经消费过的消息；或者直接跳到最近的位置，从当前的时刻开始消费。</li>
</ul>
<h3 id="消费者组"><a href="#消费者组" class="headerlink" title="消费者组"></a>消费者组</h3><p>kafka 消费者是以consumer group消费者组的方式工作，由一个或者多个消费者组成一个组，共同消费一个topic。每个分区在同一时间只能由group中的一个消费者读取，但是多个group可以同时消费这个partition。</p>
<p><img  src="/1717921705776-04ba7b13-4350-4444-b332-9b3607096fe2.png"  ><span class="image-caption">img</span></p>
<p>上图中，有一个由三个消费者组成的group，有一个消费者读取主题中的两个分区，另外两个分别读取一个分区。某个消费者读取某个分区，也可以叫做某个消费者是某个分区的拥有者。</p>
<p>优点在于：</p>
<ul>
<li>消费者可以通过水平扩展的方式同时读取大量的消息。</li>
<li>如果一个消费者失败了，那么其他的group成员会自动负载均衡读取之前失败的消费者读取的分区。</li>
</ul>
<h3 id="消费方式"><a href="#消费方式" class="headerlink" title="消费方式"></a>消费方式</h3><p>kafka 消费者采用 pull（拉）模式从 broker中读取数据。</p>
<p>pull 的优点：</p>
<ul>
<li>pull 模式可以根据 consumer 的消费能力以适当的速率消费消息</li>
</ul>
<p>缺点：</p>
<ul>
<li>如果 kafka 没有数据，消费者可能会陷入循环中，一直返回空数据。针对这一点，Kafka 的消费者在消费数据时会传入一个时长参数 timeout，如果当前没有数据可供消费，consumer 会等待一段时间之后再返回，这段时长即为 timeout。</li>
</ul>
<h2 id="Kafka-如何保证顺序读取消息？"><a href="#Kafka-如何保证顺序读取消息？" class="headerlink" title="Kafka 如何保证顺序读取消息？"></a>Kafka 如何保证顺序读取消息？</h2><p>Kafka 可以保证在同一个分区内消息是有序的，生产者写入到同一分区的消息会按照写入顺序追加到分区日志文件中，消费者从分区中读取消息时也会按照这个顺序。这是 Kafka 天然具备的特性。</p>
<p>要在 Kafka 中保证顺序读取消息，需要结合生产者、消费者的配置以及合适的业务处理逻辑来实现。以下具体说明如何实现顺序读取消息：</p>
<ul>
<li>生产者端确保消息顺序：为了保证消息写入同一分区从而确保顺序性，生产者需要将消息发送到指定分区。可以通过自定义分区器来实现，通过为消息指定相同的Key，保证相同Key的消息发送到同一分区。</li>
<li>消费者端保证顺序消费：消费者在消费消息时，需要单线程消费同一分区的消息，这样才能保证按顺序处理消息。如果使用多线程消费同一分区，就无法保证消息处理的顺序性。</li>
</ul>
<p>Kafka 本身不能保证跨分区的消息顺序性，如果需要全局的消息顺序性，通常有以下两种方法：</p>
<ul>
<li>只使用一个分区：将所有消息都写入到同一个分区，消费者也只从这个分区消费消息。但这种方式会导致 Kafka 的并行处理能力下降，因为 Kafka 的性能优势在于多分区并行处理。</li>
<li>业务层面保证：在业务代码中对消息进行编号或添加时间戳等标识，消费者在消费消息后，根据这些标识对消息进行排序处理。但这种方式会增加业务代码的复杂度。</li>
</ul>
<h2 id="kafka-消息积压怎么办？"><a href="#kafka-消息积压怎么办？" class="headerlink" title="kafka 消息积压怎么办？"></a>kafka 消息积压怎么办？</h2><p>Kafka 消息积压是一个常见的问题，它可能会导致数据处理延迟，甚至影响业务的正常运行，下面是一些解决 Kafka 消息积压问题的常用方法：</p>
<ul>
<li>增加消费者实例可以提高消息的消费速度，从而缓解积压问题。你需要确保消费者组中的消费者数量不超过分区数量，因为一个分区同一时间只能被一个消费者消费。</li>
<li>增加 Kafka 主题的分区数量可以提高消息的并行处理能力。在创建新分区后，你需要重新平衡消费者组，让更多的消费者可以同时消费消息。</li>
</ul>
<h2 id="Kafka为什么一个分区只能由消费者组的一个消费者消费？这样设计的意义是什么？"><a href="#Kafka为什么一个分区只能由消费者组的一个消费者消费？这样设计的意义是什么？" class="headerlink" title="Kafka为什么一个分区只能由消费者组的一个消费者消费？这样设计的意义是什么？"></a>Kafka为什么一个分区只能由消费者组的一个消费者消费？这样设计的意义是什么？</h2><p>同一时刻，一条消息只能被组中的一个消费者实例消费</p>
<p><img  src="1724653429445-22f12b17-9413-4611-9d78-c3599d8c7906.png"  ><span class="image-caption">img</span></p>
<p>如果两个消费者负责同一个分区，那么就意味着两个消费者同时读取分区的消息，由于消费者自己可以控制读取消息的offset，就有可能C1才读到2，而C1读到1，C1还没处理完，C2已经读到3了，则会造成很多浪费，因为这就相当于多线程读取同一个消息，会造成消息处理的重复，且不能保证消息的顺序。</p>
<h2 id="如果有一个消费主题-topic，有一个消费组-group，topic-有-10-个分区，消费线程数和分区数的关系是怎么样的？"><a href="#如果有一个消费主题-topic，有一个消费组-group，topic-有-10-个分区，消费线程数和分区数的关系是怎么样的？" class="headerlink" title="如果有一个消费主题 topic，有一个消费组 group，topic 有 10 个分区，消费线程数和分区数的关系是怎么样的？"></a>如果有一个消费主题 topic，有一个消费组 group，topic 有 10 个分区，消费线程数和分区数的关系是怎么样的？</h2><p>topic下的一个分区只能被同一个consumer group下的一个consumer线程来消费，但反之并不成立，即一个consumer线程可以消费多个分区的数据，比如Kafka提供的ConsoleConsumer，默认就只是一个线程来消费所有分区的数据。</p>
<p><img  src="1732606891790-bf7cb080-0209-46bc-80b4-5f96ad88453f.webp"  ><span class="image-caption">img</span></p>
<p>所以，<strong>分区数决定了同组消费者个数的上限</strong>。</p>
<p>如果你的分区数是N，那么最好线程数也保持为N，这样通常能够达到最大的吞吐量。超过N的配置只是浪费系统资源，因为多出的线程不会被分配到任何分区。</p>
<h2 id="消息中间件如何做到高可用？"><a href="#消息中间件如何做到高可用？" class="headerlink" title="消息中间件如何做到高可用？"></a>消息中间件如何做到高可用？</h2><p>消息中间件如何保证高可用呢？单机是没有高可用可言的，高可用都是对集群来说的，一起看下kafka的高可用吧。</p>
<p>Kafka 的基础集群架构，由多个<code>broker</code>组成，每个<code>broker</code>都是一个节点。当你创建一个<code>topic</code>时，它可以划分为多个<code>partition</code>，而每个<code>partition</code>放一部分数据，分别存在于不同的 broker 上。也就是说，一个 topic 的数据，是分散放在多个机器上的，每个机器就放一部分数据。</p>
<p>有些伙伴可能有疑问，每个<code>partition</code>放一部分数据，如果对应的broker挂了，那这部分数据是不是就丢失了？那还谈什么高可用呢？</p>
<blockquote>
<p>Kafka 0.8 之后，提供了复制品副本机制来保证高可用，即每个 partition 的数据都会同步到其它机器上，形成多个副本。然后所有的副本会选举一个 leader 出来，让leader去跟生产和消费者打交道，其他副本都是follower。写数据时，leader 负责把数据同步给所有的follower，读消息时， 直接读 leader 上的数据即可。如何保证高可用的？就是假设某个 broker 宕机，这个broker上的partition 在其他机器上都有副本的。如果挂的是leader的broker呢？其他follower会重新选一个leader出来。</p>
</blockquote>
<h2 id="Kafka-和-RocketMQ-消息确认机制有什么不同？"><a href="#Kafka-和-RocketMQ-消息确认机制有什么不同？" class="headerlink" title="Kafka 和 RocketMQ 消息确认机制有什么不同？"></a>Kafka 和 RocketMQ 消息确认机制有什么不同？</h2><p>Kafka的消息确认机制有三种：0，1，-1：</p>
<ul>
<li><strong>ACK=0</strong>：这是最不可靠的模式。生产者在发送消息后不会等待来自服务器的确认。这意味着消息可能会在发送之后丢失，而生产者将无法知道它是否成功到达服务器。</li>
<li><strong>ACK=1</strong>：这是默认模式，也是一种折衷方式。在这种模式下，生产者会在消息发送后等待来自分区领导者（leader）的确认，但不会等待所有副本（replicas）的确认。这意味着只要消息被写入分区领导者，生产者就会收到确认。如果分区领导者成功写入消息，但在同步到所有副本之前宕机，消息可能会丢失。</li>
<li><strong>ACK=-1</strong>：这是最可靠的模式。在这种模式下，生产者会在消息发送后等待所有副本的确认。只有在所有副本都成功写入消息后，生产者才会收到确认。这确保了消息的可靠性，但会导致更长的延迟。</li>
</ul>
<p>RocketMQ 提供了三种消息发送方式：同步发送、异步发送和单向发送：</p>
<ul>
<li><strong>同步发送</strong>：是指消息发送方发出一条消息后，会在收到服务端同步响应之后才发下一条消息的通讯方式。应用场景非常广泛，例如重要通知邮件、报名短信通知、营销短信系统等。</li>
<li><strong>异步发送</strong>：是指发送方发出一条消息后，不等服务端返回响应，接着发送下一条消息的通讯方式，但是需要实现异步发送回调接口（SendCallback）。消息发送方在发送了一条消息后，不需要等待服务端响应即可发送第二条消息。发送方通过回调接口接收服务端响应，并处理响应结果。适用于链路耗时较长，对响应时间较为敏感的业务场景，例如，视频上传后通知启动转码服务，转码完成后通知推送转码结果等。</li>
<li><strong>单向发送</strong>：发送方只负责发送消息，不等待服务端返回响应且没有回调函数触发，即只发送请求不等待应答。此方式发送消息的过程耗时非常短，一般在微秒级别。适用于某些耗时非常短，但对可靠性要求并不高的场景，例如日志收集。</li>
</ul>
<h2 id="Kafka-和-RocketMQ-的-broker-架构有什么区别"><a href="#Kafka-和-RocketMQ-的-broker-架构有什么区别" class="headerlink" title="Kafka 和 RocketMQ 的 broker 架构有什么区别"></a><strong>Kafka 和 RocketMQ 的 broker 架构有什么区别</strong></h2><ul>
<li>Kafka 的 broker 架构：Kafka 的 broker 架构采用了分布式的设计，<strong>每个 Kafka broker 是一个独立的服务实例</strong>，负责存储和处理一部分消息数据。Kafka 的 topic 被分区存储在不同的 broker 上，实现了水平扩展和高可用性。</li>
<li>RocketMQ 的 broker 架构：RocketMQ 的 broker 架构也是分布式的，但是<strong>每个 RocketMQ broker 有主从之分</strong>，一个主节点和多个从节点组成一个 broker 集群。主节点负责消息的写入和消费者的拉取，从节点负责消息的复制和消费者的负载均衡，提高了消息的可靠性和可用性。</li>
</ul>
<p>kakfa 通过多个 <code>topic</code> 对消息进行分类。</p>
<p><img  src="640.webp"   style="zoom:67%;" /><span class="image-caption">图片</span></p>
<p>为了提升单个 topic 的并发<strong>性能</strong>，将<strong>单个 topic</strong> 拆为多个 <code>partition</code>。</p>
<p><img  src="640-1744902123003-37.webp"   style="zoom:67%;" /><span class="image-caption">图片</span></p>
<ul>
<li>为了提升系统<strong>扩展性</strong>，将多个 partition 分别部署在不同 <code>broker</code> 上。</li>
<li>为了提升系统的<strong>可用性</strong>，为 partition 加了多个副本。</li>
<li>为了协调和管理 Kafka 集群的数据信息，引入<code>Zookeeper</code>作为协调节点。</li>
</ul>
<p><img  src="/640-1744902145814-40.webp"   style="zoom:67%;" /><span class="image-caption">图片</span></p>
<p>Kafka 已经是非常强的消息队列了，我们来看下 RocketMQ 在 Kafka 架构的基础上，还能玩出什么花样来。</p>
<p>但 Zookeeper 作为一个<strong>通用的</strong>分布式协调服务，它不仅可以用于服务注册与发现，还可以用于分布式锁、配置管理等场景。Kafka 其实只用到了它的部分功能，多少有点<strong>杀鸡用牛刀</strong>的味道。<strong>太重了</strong>。</p>
<p>所以 RocketMQ 直接将 Zookeeper 去掉，换成了 <strong>nameserver</strong>，用一种更轻量的方式，管理消息队列的集群信息。生产者通过 nameserver 获取到 topic 和 broker 的路由信息，然后再与 broker 通信，实现<strong>服务发现</strong>和<strong>负载均衡</strong>的效果。</p>
<p><img  src="640-1744902195772-43.webp"   style="zoom:67%;" /><span class="image-caption">图片</span></p>
<p>当然，开发 Kafka 的大佬们后来也意识到了 Zookeeper 过重的问题，所以从 2.8.0 版本就支持将 Zookeeper 移除，通过 在 broker 之间加入一致性算法 raft 实现同样的效果，这就是所谓的 <strong>KRaft</strong> 或 <strong>Quorum</strong> 模式。</p>
<p><img  src="640-1744902222021-46.webp"   style="zoom:67%;" /><span class="image-caption">图片</span></p>
<p>我们知道，Kafka 会将 topic 拆分为多个 partition，用来提升<strong>并发性能</strong>。</p>
<p><img  src="/640-1744902241282-49.webp"   style="zoom:67%;" /><span class="image-caption">图片</span></p>
<p>在 RocketMQ 里也一样，将 topic 拆分成了多个分区，但换了个名字，叫 <strong>Queue</strong>,也就是”<strong>队列</strong>“。</p>
<p><img  src="/640-1744902241282-50.webp"   style="zoom:67%;" /><span class="image-caption">图片</span></p>
<p>Kafka 中的 partition 会存储<strong>完整</strong>的消息体，而 RocketMQ 的 Queue 上却只存一些<strong>简要</strong>信息，比如消息偏移 offset，而消息的完整数据则放到”一个”叫 <code>commitlog</code> 的文件上，通过 offset 我们可以定位到 commitlog 上的某条消息。 </p>
<p>Kafka 消费消息，broker 只需要直接从 partition 读取消息返回就好，也就是读第<strong>一次</strong>就够了。</p>
<p>而在 RocketMQ 中，broker 则需要先从 Queue 上读取到 offset 的值，再跑到 commitlog 上将完整数据读出来，也就是需要读<strong>两次</strong>。</p>
<p>那么问题就来了，看起来 Kafka 的设计更高效？为什么 RocketMQ 不采用 Kafka 的设计？这就不得说一下 Kafka 的<strong>底层存储</strong>了</p>
<h3 id="Kafka-的底层存储"><a href="#Kafka-的底层存储" class="headerlink" title="Kafka 的底层存储"></a>Kafka 的底层存储</h3><p>Kafka 的 partition 分区，其实在底层由很多<strong>段</strong>（<strong>segment</strong>）组成，每个 segment 可以认为就是个<strong>小文件</strong>。将消息数据写入到 partition 分区，本质上就是将数据写入到某个 segment 文件下。</p>
<p>我们知道，操作系统的机械磁盘，<strong>顺序写</strong>的性能会比<strong>随机写</strong>快很多，差距高达几十倍。为了提升性能，Kafka 对每个小文件都是顺序写。如果只有<strong>一个</strong> segment 文件，那写文件的性能会很好。 </p>
<p>但当 topic 变多之后，topic 底下的 partition 分区也会变多，对应的 partition 底下的 segment 文件也会变多。同时写<strong>多个</strong> topic 底下的 partition，就是同时<strong>写多个文件</strong>，虽然每个文件内部都是顺序写，但多个文件存放在磁盘的不同地方，原本<strong>顺序写磁盘就可能劣化变成了随机写</strong>。于是写性能就降低了。</p>
<p>那问题又又来了，究竟多少 topic 才算多？这个看实际情况，但打太极从来不是我的风格。我给一个经验值<strong>仅供参考</strong>，8 个分区的情况下，超过 64 topic, Kafka 性能就会开始下降。</p>
<h3 id="RocketMQ-的底层存储"><a href="#RocketMQ-的底层存储" class="headerlink" title="RocketMQ 的底层存储"></a>RocketMQ 的底层存储</h3><p>为了缓解同时写多个文件带来的随机写问题，RocketMQ 索性将单个 broker 底下的多个 topic 数据，全都写到”<strong>一个</strong>“逻辑文件 <code>CommitLog</code> 上，这就消除了随机写多文件的问题，将所有写操作都变成了顺序写。大大提升了 RocketMQ 在多 topic 场景下的写性能。</p>
<p>注意上面提到的”<strong>一个</strong>“是带引号的，虽然逻辑上它是一个大文件，但实际上这个 CommitLog 由多个小文件组成。每个文件的大小是固定的，当一个文件被写满后，会创建一个新的文件来继续存储新的消息。这种方式可以方便地管理和清理旧的消息。</p>
<h3 id="简化备份模型"><a href="#简化备份模型" class="headerlink" title="简化备份模型"></a>简化备份模型</h3><p>我们知道，Kafka 会将 partiton 分散到多个 broker 中，并为 partiton 配置副本，将 partiton 分为 <code>leader</code>和 <code>follower</code>，也就是<strong>主和从</strong>。broker 中既可能有 A topic 的主 partiton，也可能有 B topic 的从 partiton。主从 partiton 之间会建立数据同步，本质上就是同步 partiton 底下的 segment 文件数据</p>
<p>RocketMQ 将 broker 上的所有 topic 数据到写到 CommitLog 上。如果还像 Kafka 那样给每个分区单独建立同步通信，就还得将 CommitLog 里的内容<strong>拆开</strong>，这就还是退化为<strong>随机读</strong>了。于是 RocketMQ 索性<strong>以 broker 为单位区分主从</strong>，主从之间同步 CommitLog 文件，保持高可用的同时，也大大简化了备份模型。</p>
<p>虽然 RocketMQ 的架构比 Kafka 的简单，但功能却比 Kafka 要更丰富，我们来看下。</p>
<h3 id="消息过滤"><a href="#消息过滤" class="headerlink" title="消息过滤"></a>消息过滤</h3><p>我们知道，Kafka 支持通过 topic 将数据进行分类，比如订单数据和用户数据是两个不同的 topic，但如果我还想<strong>再进一步分类</strong>呢？比如同样是用户数据，还能根据 vip 等级进一步分类。假设我们只需要获取 vip6 的用户数据，在 Kafka 里，消费者需要消费 topic 为用户数据的<strong>所有消息</strong>，再将 vip6 的用户过滤出来。</p>
<p>而 RocketMQ 支持对消息打上<strong>标记</strong>，也就是打 <strong>tag</strong>，消费者能根据 tag 过滤所需要的数据。比如我们可以在部分消息上标记 tag=vip6，这样消费者就能<strong>只获取</strong>这部分数据，省下了消费者过滤数据时的资源消耗。</p>
<h3 id="支持事务"><a href="#支持事务" class="headerlink" title="支持事务"></a>支持事务</h3><p>我们知道 Kafka 支持事务，比如生产者发三条消息 ABC，这三条消息要么同时发送成功，要么同时发送失败。</p>
<p>是，这确实也叫事务，但<strong>跟我们要的不太一样</strong>。</p>
<p>写业务代码的时候，我们更想要的事务是，”<strong>执行一些自定义逻辑</strong>“和”<strong>生产者发消息</strong>“这两件事，要么同时成功，要么同时失败。</p>
<p>而这正是 RocketMQ 支持的事务能力。</p>
<h3 id="加入延时队列"><a href="#加入延时队列" class="headerlink" title="加入延时队列"></a>加入延时队列</h3><p>如果我们希望消息投递出去之后，消费者不能立马消费到，而是过个一定时间后才消费，也就是所谓的<strong>延时消息</strong>，就像文章开头的定时外卖那样。如果我们使用 Kafka， 要实现类似的功能的话，就会很费劲。但 RocketMQ 天然支持<strong>延时队列</strong>，我们可以很方便实现这一功能。</p>
<h3 id="加入死信队列"><a href="#加入死信队列" class="headerlink" title="加入死信队列"></a>加入死信队列</h3><p>消费消息是有可能失败的，失败后一般可以设置<strong>重试</strong>。如果多次重试失败，RocketMQ 会将消息放到一个专门的队列，方便我们<strong>后面单独处理</strong>。这种专门存放失败消息的队列，就是<strong>死信队列</strong>。Kafka 原生不支持这个功能，需要我们自己实现。</p>
<h3 id="消息回溯"><a href="#消息回溯" class="headerlink" title="消息回溯"></a>消息回溯</h3><p>Kafka 支持通过<strong>调整 offset</strong> 来让消费者从某个地方开始消费，而 RocketMQ，除了可以调整 offset, 还支持<strong>调整时间</strong>（kafka在0.10.1后支持调时间）</p>
<p>所以<strong>不那么严谨</strong>的说， <strong>RocketMQ 本质就是在架构上做了减法，在功能上做了加法的 Kafka</strong>。这个总结是不是特别精辟。现在大家通了吗？</p>
<p>最后遗留一个问题。现在看起来，RocketMQ 好像各方面都比 Kafka 更能打。但 Kafka 却一直没被淘汰，说明 RocketMQ 必然是有着不如 Kafka 的地方。是啥呢？<strong>性能</strong>，严格来说是<strong>吞吐量</strong>。 </p>
<p>这就很奇怪了，<strong>为什么 RocketMQ 参考了 Kafka 的架构，性能却还不如 Kafka</strong>？这个问题，我们下期聊聊。</p>
<h2 id="RocketMQ-为什么性能不如-Kafka？"><a href="#RocketMQ-为什么性能不如-Kafka？" class="headerlink" title="RocketMQ 为什么性能不如 Kafka？"></a>RocketMQ 为什么性能不如 Kafka？</h2><p>但 kafka 却一直没被淘汰，说明 RocketMQ 必然是有着不如 kafka 的地方。</p>
<p>是啥呢？ <strong>性能</strong>，严格来说是<strong>吞吐量</strong>。阿里中间件团队对它们做过压测，同样条件下，kafka 比 RocketMQ 快 50%左右。但即使这样，RocketMQ 依然能每秒处理 10w 量级的数据，依旧非常能打。你不能说 RocketMQ 弱，只能说 Kafka 性能太强了。</p>
<p>不过这就很奇怪了，<strong>为什么 RocketMQ 参考了 kafka 的架构，却不能跟 kafka 保持一样的性能呢</strong>？在回答这个问题之前，我们来聊下什么是<strong>零拷贝</strong>。</p>
<p>一顿操作猛如虎，结果就是同样一份数据来回拷贝。有没有办法优化呢？有，它就是零拷贝技术，常见的方案有两种，分别是 <code>mmap</code> 和 <code>sendfile</code>。我们来看下它们是什么。</p>
<p><code>mmap</code> 是操作系统内核提供的一个方法，可以将内核空间的缓冲区<strong>映射</strong>到用户空间。</p>
<p><img  src="640-1744902717701-55.webp"   style="zoom:67%;" /><span class="image-caption">图片</span></p>
<p>用了它，整个发送流程就有了一些变化。程序发起<strong>系统调用</strong><code>mmap()</code>，尝试读取磁盘数据，具体情况如下：</p>
<ul>
<li>磁盘数据从设备<strong>拷贝</strong>到内核空间的缓冲区。</li>
<li>内核空间的缓冲区<strong>映射</strong>到用户空间，这里<strong>不需要</strong>拷贝。</li>
</ul>
<p>程序再发起<strong>系统调用</strong><code>write()</code>，将读到的数据发到网络：</p>
<ul>
<li>数据从内核空间缓冲区<strong>拷贝</strong>到 socket 发送缓冲区。</li>
<li>再从 socket 发送缓冲区<strong>拷贝</strong>到网卡。</li>
</ul>
<p><img  src="640-1744902717702-56.webp"   style="zoom:67%;" /><span class="image-caption">图片</span></p>
<p>整个过程，发生了 <code>2</code> 次系统调用，对应 <code>4</code> 次用户空间和内核空间的切换，以及 <code>3</code> 次数据拷贝，对比之前，省下<strong>一次</strong>内核空间到用户空间的拷贝。</p>
<p><img  src="/640-1744902717702-57.webp"  ><span class="image-caption">图片</span></p>
<p>看到这里大家估计也蒙了，不是说零拷贝吗？怎么还有 3 次拷贝。mmap 作为一种零拷贝技术，指的是用户空间到内核空间这个过程不需要拷贝，而不是指数据从磁盘到发送到网卡这个过程零拷贝。</p>
<p><img  src="/640-1744902717702-58.webp"  ><span class="image-caption">图片</span></p>
<p><strong>确实省了一点，但不多</strong>。有没有更彻底的零拷贝？有，用 <code>sendfile</code>.</p>
<h3 id="sendfile-是什么"><a href="#sendfile-是什么" class="headerlink" title="sendfile 是什么"></a>sendfile 是什么</h3><p><code>sendfile</code>，也是内核提供的一个方法，从名字可以看出，就是用来<strong>发送文件数据</strong>的。程序发起<strong>系统调用</strong><code>sendfile()</code>，内核会尝试读取磁盘数据然后发送，具体情况如下：</p>
<ul>
<li>• 磁盘数据从设备<strong>拷贝</strong>到内核空间的缓冲区。</li>
<li>• 内核空间缓冲区里的数据<strong>可以</strong>直接<strong>拷贝</strong>到网卡。</li>
</ul>
<p><img  src="640-1744902828697-67.webp"   style="zoom:67%;" /><span class="image-caption">图片</span></p>
<p>整个过程，发生了 <code>1</code> 次系统调用，对应 <code>2</code> 次用户空间和内核空间的切换，以及 <code>2</code> 次数据拷贝。这时候问题很多的小明就有意见了，说好的<strong>零</strong>拷贝怎么还有 <code>2</code> 次拷贝？</p>
<p><img  src="640-1744902828698-68.webp"   style="zoom:67%;" /><span class="image-caption">图片</span></p>
<p>其实，这里的零拷贝指的是<strong>零 CPU</strong>拷贝。也就是说 sendfile 场景下，需要的两次拷贝，都不是 CPU 直接参与的拷贝，而是其他硬件设备技术做的拷贝，不耽误我们 CPU 跑程序。</p>
<h3 id="kafka-为什么性能比-RocketMQ-好"><a href="#kafka-为什么性能比-RocketMQ-好" class="headerlink" title="kafka 为什么性能比 RocketMQ 好"></a>kafka 为什么性能比 RocketMQ 好</h3><p>聊完两种零拷贝技术，我们回过头来看下 kafka 为什么性能比 RocketMQ 好。这是因为 <strong>RocketMQ 使用的是 mmap 零拷贝技术，而 kafka 使用的是 sendfile</strong>。kafka 以更少的拷贝次数以及系统内核切换次数，获得了更高的性能。但问题又来了，为什么 RocketMQ 不使用 sendfile？参考 kafka 抄个作业也不难啊？我们来看下 <code>sendfile</code> 函数长啥样。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">sendfile</span><span class="hljs-params">(<span class="hljs-type">int</span> out_fd, <span class="hljs-type">int</span> in_fd, <span class="hljs-type">off_t</span>* offset, <span class="hljs-type">size_t</span> count)</span>;<br><span class="hljs-comment">// num = sendfile(xxx);</span><br></code></pre></td></tr></table></figure>
<p>再来看下 <code>mmap</code> 函数长啥样。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">mmap</span><span class="hljs-params">(<span class="hljs-type">void</span> *addr, <span class="hljs-type">size_t</span> length, <span class="hljs-type">int</span> prot, <span class="hljs-type">int</span> flags,</span><br><span class="hljs-params">           <span class="hljs-type">int</span> fd, <span class="hljs-type">off_t</span> offset)</span>;<br><span class="hljs-comment">// buf = mmap(xxx)</span><br></code></pre></td></tr></table></figure>
<h1 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><h3 id="JDK1-8-之前"><a href="#JDK1-8-之前" class="headerlink" title="JDK1.8 之前"></a>JDK1.8 之前</h3><p>JDK1.8 之前 HashMap 底层是 数组和链表 结合在一起使用也就是 链表散列。</p>
<p>HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 <code>(n - 1) &amp; hash</code> 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</p>
<p>所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。</p>
<p><img  src="jdk1.7_hashmap.png"  ><span class="image-caption">jdk1.8 之前的内部结构-HashMap</span></p>
<h3 id="JDK1-8-之后"><a href="#JDK1-8-之后" class="headerlink" title="JDK1.8 之后"></a>JDK1.8 之后</h3><p>相比于之前的版本，JDK1.8 以后在解决哈希冲突时有了较大的变化。</p>
<p>当链表长度大于阈值（默认为 8）时，会首先调用 <code>treeifyBin()</code>方法。这个方法会根据 HashMap 数组来决定是否转换为红黑树。只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，以减少搜索时间。否则，就是只是执行 <code>resize()</code> 方法对数组扩容。相关源码这里就不贴了，重点关注 <code>treeifyBin()</code>方法即可。</p>
<p><img  src="jdk1.8_hashmap.png"  ><span class="image-caption">jdk1.8之后的内部结构-HashMap</span></p>
<p><strong>loadFactor 负载因子</strong></p>
<p>loadFactor 负载因子是控制数组存放数据的疏密程度，loadFactor 越趋近于 1，那么 数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，loadFactor 越小，也就是趋近于 0，数组中存放的数据(entry)也就越少，也就越稀疏。</p>
<p><strong>loadFactor 太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor 的默认值为 0.75f 是官方给出的一个比较好的临界值</strong>。</p>
<p>给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，当数量超过了 16 * 0.75 = 12 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。</p>
<p><strong>threshold</strong></p>
<p><strong>threshold = capacity * loadFactor</strong>，<strong>当 Size&gt;threshold</strong>的时候，那么就要考虑对数组的扩增了，也就是说，这个的意思就是 <strong>衡量数组是否需要扩增的一个标准</strong>。</p>
<p>进行扩容，会伴随着一次重新 hash 分配，并且会遍历 hash 表中所有的元素，是非常耗时的。在编写程序中，要尽量避免 resize。resize 方法实际上是将 table 初始化和 table 扩容 进行了整合，底层的行为都是给 table 赋值一个新的数组。</p>
<h2 id="双端队列，栈和队列"><a href="#双端队列，栈和队列" class="headerlink" title="双端队列，栈和队列"></a>双端队列，栈和队列</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"><strong>操作类型</strong></th>
<th style="text-align:center"><strong>ArrayDeque</strong></th>
<th style="text-align:center"><strong>LinkedList</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>头尾插入/删除</strong></td>
<td style="text-align:center">O(1)，内存连续，缓存友好，循环数组实现</td>
<td style="text-align:center">O(1)，但需频繁创建节点对象，实际性能略低</td>
</tr>
<tr>
<td style="text-align:center"><strong>中间插入/删除</strong></td>
<td style="text-align:center">不支持（仅限两端操作）</td>
<td style="text-align:center">O(n)，需遍历链表找到位置</td>
</tr>
<tr>
<td style="text-align:center"><strong>随机访问</strong></td>
<td style="text-align:center">O(1)（通过索引直接访问）</td>
<td style="text-align:center">O(n)，需从头或尾遍历链表</td>
</tr>
<tr>
<td style="text-align:center"><strong>扩容开销</strong></td>
<td style="text-align:center">扩容时需复制数组，O(n)开销</td>
<td style="text-align:center">无固定容量限制，动态扩展无额外开销</td>
</tr>
</tbody>
</table>
</div>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><ul>
<li>完全二叉树：若二叉树的深度为 h，则除第 h 层外，其他层的结点全部达到最大值，且第 h 层的所有结点都集中在左子树。</li>
<li>满二叉树：满二叉树是一种特殊的的完全二叉树，所有层的结点都是最大值。</li>
</ul>
<p>堆通常是一个可以被看做一棵树的数组对象。堆总是满足下列性质：</p>
<ul>
<li>堆中某个节点的值总是不大于或不小于其父节点的值；</li>
<li>堆总是一棵完全二叉树。</li>
</ul>
<p><img  src="e4ecb1a8ef4456d88da12d8d472dcb81.png"   style="zoom:67%;" /><span class="image-caption">img</span></p>
<p><img  src="5ef19d242f141a1218580547e52f404d.png"   style="zoom:67%;" /><span class="image-caption">img</span></p>
<p>堆的定义如下：n个元素的序列{k1,k2,ki,…,kn}当且仅当满足下关系时，称之为堆。</p>
<p>(ki &lt;= k2i,ki &lt;= k2i+1)或者(ki &gt;= k2i,ki &gt;= k2i+1), (i = 1,2,3,4…n/2)</p>
<p><strong>注意： 在二叉树中，若当前节点的下标为 i， 则其父节点的下标为 i/2，其左子节点的下标为 i*2，其右子节点的下标为i*2+1；</strong></p>
<h3 id="堆的插入"><a href="#堆的插入" class="headerlink" title="堆的插入"></a>堆的插入</h3><p>每次插入都是将先将新数据放在数组最后，由于从这个新数据的父结点到根结点必然为一个有序的序列，现在的任务是将这个新数据插入到这个有序序列中——这就类似于直接插入排序中将一个数据并入到有序区间中。</p>
<p>我们通过一个插入例子来看看插入操作的细节。我们将数字 16 插入到这个堆中：</p>
<p><img  src="f5e2bd8c5cd23174ea4733b3de9bed13.png"  ><span class="image-caption">img</span></p>
<p>堆的数组是： [ 10, 7, 2, 5, 1 ]。</p>
<p>第一步是将新的元素插入到数组的尾部，数组变成：[ 10, 7, 2, 5, 1, 16 ]；</p>
<p>相应的树变成了：</p>
<p><img  src="476b7bea162959303bc60f29887f7d88.png"  ><span class="image-caption">img</span></p>
<p>16 被添加最后一行的第一个空位。</p>
<p>不行的是，现在堆属性不满足，因为 2 在 16 的上面，我们需要将大的数字在上面（这是一个最大堆）</p>
<p>为了恢复堆属性，我们需要交换 16 和 2。</p>
<p><img  src="b01e2fe15b0746e37648947e3dc52efe.png"  ><span class="image-caption">img</span></p>
<p>现在还没有完成，因为 10 也比 16 小。我们继续交换我们的插入元素和它的父节点，直到它的父节点比它大或者我们到达树的顶部。这就是所谓的 shift-up，每一次插入操作后都需要进行。它将一个太大或者太小的数字“浮起”到树的顶部。</p>
<p>最后我们得到的堆：</p>
<p><img  src="c4f062e9f353b77e73fa694bab67aac9.png"  ><span class="image-caption">img</span></p>
<p>现在每一个父节点都比它的子节点大。</p>
<h3 id="堆的删除"><a href="#堆的删除" class="headerlink" title="堆的删除"></a>堆的删除</h3><p>堆中每次都只能删除堆顶元素。为了便于重建堆，实际的操作是将最后一个数据的值赋给根结点，然后再从根结点开始进行一次从上向下的调整。调整时先在左右子结点中找最小的，如果父结点比这个最小的子结点还小说明不需要调整了，反之将父结点和它交换后再考虑后面的结点。相当于根结点数据的“下沉”过程。</p>
<p>我们将这个树中的 (10) 删除：</p>
<p><img  src="3b1843281df1093f2f51e695a6a22134.png"  ><span class="image-caption">img</span></p>
<p>现在顶部有一个空的节点，怎么处理？</p>
<p><img  src="a73d1b9388cf6190e3965df91c93e314.png"  ><span class="image-caption">img</span></p>
<p>当插入节点的时候，我们将新的值返给数组的尾部。现在我们来做相反的事情：我们取出数组中的最后一个元素，将它放到树的顶部，然后再修复堆属性。</p>
<p><img  src="48773339bf25b99d8c17a14c3a9655fc.png"  ><span class="image-caption">img</span></p>
<p>现在来看怎么 shift-down (1)。为了保持最大堆的堆属性，我们需要树的顶部是最大的数据。现在有两个数字可用于交换 7 和 2。我们选择这两者中的较大者称为最大值放在树的顶部，所以交换 7 和 1，现在树变成了：</p>
<p><img  src="7de49e3f8841aa1d9d7f6c865e316f86.png"  ><span class="image-caption">img</span></p>
<p>继续堆化直到该节点没有任何子节点或者它比两个子节点都要大为止。对于我们的堆，我们只需要再有一次交换就恢复了堆属性：</p>
<p><img  src="b8d775a60047391847a4be533697c7d0.png"  ><span class="image-caption">img</span></p>
<h3 id="从数组构造一个堆"><a href="#从数组构造一个堆" class="headerlink" title="从数组构造一个堆"></a>从数组构造一个堆</h3><p>原始数据为a[] = {4, 1, 3, 2, 16, 9, 10, 14, 8, 7}，采用顺序存储方式，对应的完全二叉树如下图所示：</p>
<p><img  src="bd6125df0507026075d897a710a5acd0.png"  ><span class="image-caption">img</span></p>
<p>基本思想：<br>首先将每个叶子节点视为一个堆，再将每个叶子节点与其父节点一起构造成一个包含更多节点的对。所以，在构造堆的时候，首先需要找到最后一个节点的父节点，从这个节点开始构造最大堆；直到该节点前面所有分支节点都处理完毕，这样最大堆就构造完毕了。<br>假设树的节点个数为n，以1为下标开始编号，直到n结束。对于节点i，其父节点为i/2；左孩子节点为i<em>2，右孩子节点为i</em>2+1。最后一个节点的下标为n，其父节点的下标为n/2。<br>我们边针对上边数组操作如下图所示，最后一个节点为7，其父节点为16，从16这个节点开始构造最大堆；构造完毕之后，转移到下一个父节点2，直到所有父节点都构造完毕。</p>
<p><img  src="038ba2c57f8352ffb48937a4a1cc010e.png"  ><span class="image-caption">img</span></p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><br>strcut MaxHeap<br>&#123;<br>	Etype *heap; <span class="hljs-comment">//数据元素存放的空间，下标从1开始存数数据，下标为0的作为工作空间，存储临时数据</span><br>	<span class="hljs-type">int</span> HeapSize;<span class="hljs-comment">//数据元素的个数</span><br>	<span class="hljs-type">int</span> MaxSize; <span class="hljs-comment">//存放数据元素空间的大小</span><br>&#125;;<br>MaxHeap H;<br> <br><span class="hljs-type">void</span> <span class="hljs-title function_">MaxHeapInit</span> <span class="hljs-params">(MaxHeap &amp;H)</span><br>&#123;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = H.HeapSize/<span class="hljs-number">2</span>; i&gt;=<span class="hljs-number">1</span>; i--)<br>	&#123;<br>		H.heap[<span class="hljs-number">0</span>] = H.heap[i];<br>		<span class="hljs-type">int</span> son = i*<span class="hljs-number">2</span>;<br>		<span class="hljs-keyword">while</span>(son &lt;= H.HeapSize)<br>		&#123;<br>			<span class="hljs-keyword">if</span>(son &lt; H.HeapSize &amp;&amp; H.heap[son] &lt; H.heap[son+<span class="hljs-number">1</span>])<br>				son++;<br>			<span class="hljs-keyword">if</span>(H.heap[<span class="hljs-number">0</span>] &gt;= H.heap[son])<br>				<span class="hljs-keyword">break</span>;<br>			<span class="hljs-keyword">else</span><br>			&#123;<br>				H.heap[son/<span class="hljs-number">2</span>] = H.heap[son];<br>				son *= <span class="hljs-number">2</span>;<br>			&#125;<br>		&#125;<br>		H.heap[son/<span class="hljs-number">2</span>] = H.heap[<span class="hljs-number">0</span>];<br>	&#125;<br></code></pre></td></tr></table></figure>
<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p><strong>操作系统会提供一种机制，将不同进程的虚拟地址和不同内存的物理地址映射起来。</strong></p>
<ul>
<li>我们程序所使用的内存地址叫做<strong>虚拟内存地址</strong>（<em>Virtual Memory Address</em>）。</li>
<li>实际存在硬件里面的空间地址叫<strong>物理内存地址</strong>（<em>Physical Memory Address</em>）。</li>
</ul>
<h3 id="内存分页"><a href="#内存分页" class="headerlink" title="内存分页"></a>内存分页</h3><p><strong>分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小</strong>。这样一个连续并且尺寸固定的内存空间，我们叫<strong>页</strong>（<em>Page</em>）。在 Linux 下，每一页的大小为 <code>4KB</code>。</p>
<p>虚拟地址与物理地址之间通过<strong>页表</strong>来映射，如下图：</p>
<p><img  src="08a8e315fedc4a858060db5cb4a654af.png"   style="zoom:67%;" /><span class="image-caption">img</span></p>
<p>页表是存储在内存里的，<strong>内存管理单元</strong> （<em>MMU</em>）就做将虚拟内存地址转换成物理地址的工作。</p>
<p>而当进程访问的虚拟地址在页表中查不到时，系统会产生一个<strong>缺页异常</strong>，进入系统内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行。</p>
<p>内存分页由于内存空间都是预先划分好的，也就不会像内存分段一样，在段与段之间会产生间隙非常小的内存，这正是分段会产生外部内存碎片的原因。而<strong>采用了分页，页与页之间是紧密排列的，所以不会有外部碎片。</strong></p>
<p>但是，因为内存分页机制分配内存的最小单位是一页，即使程序不足一页大小，我们最少只能分配一个页，所以页内会出现内存浪费，所以针对<strong>内存分页机制会有内部内存碎片</strong>的现象。</p>
<p>如果内存空间不够，操作系统会把其他正在运行的进程中的「最近没被使用」的内存页面给释放掉，也就是暂时写在硬盘上，称为<strong>换出</strong>（<em>Swap Out</em>）。一旦需要的时候，再加载进来，称为<strong>换入</strong>（<em>Swap In</em>）。所以，一次性写入磁盘的也只有少数的一个页或者几个页，不会花太多时间，<strong>内存交换的效率就相对比较高。</strong></p>
<p>更进一步地，分页的方式使得我们在加载程序的时候，不再需要一次性都把程序加载到物理内存中。我们完全可以在进行虚拟内存和物理内存的页之间的映射之后，并不真的把页加载到物理内存里，而是<strong>只有在程序运行中，需要用到对应虚拟内存页里面的指令和数据时，再加载到物理内存里面去。</strong></p>
<blockquote>
<p>分页机制下，虚拟地址和物理地址是如何映射的？</p>
</blockquote>
<p>在分页机制下，虚拟地址分为两部分，<strong>页号</strong>和<strong>页内偏移</strong>。页号作为页表的索引，<strong>页表</strong>包含物理页每页所在<strong>物理内存的基地址</strong>，这个基地址与页内偏移的组合就形成了物理内存地址，见下图。</p>
<p><img  src="7884f4d8db4949f7a5bb4bbd0f452609.png"   style="zoom:67%;" /><span class="image-caption">img</span></p>
<blockquote>
<p>简单的分页有什么缺陷吗？</p>
</blockquote>
<p>有空间上的缺陷。</p>
<p>因为操作系统是可以同时运行非常多的进程的，那这不就意味着页表会非常的庞大。</p>
<p>在 32 位的环境下，虚拟地址空间共有 4GB，假设一个页的大小是 4KB（2^12），那么就需要大约 100 万 （2^20） 个页，每个「页表项」需要 4 个字节大小来存储，那么整个 4GB 空间的映射就需要有 <code>4MB</code> 的内存来存储页表。</p>
<p>这 4MB 大小的页表，看起来也不是很大。但是要知道每个进程都是有自己的虚拟地址空间的，也就说都有自己的页表。</p>
<p>那么，<code>100</code> 个进程的话，就需要 <code>400MB</code> 的内存来存储页表，这是非常大的内存了，更别说 64 位的环境了。</p>
<h3 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h3><p>在前面我们知道了，对于单页表的实现方式，在 32 位和页大小 <code>4KB</code> 的环境下，一个进程的页表需要装下 100 多万个「页表项」，并且每个页表项是占用 4 字节大小的，于是相当于每个页表需占用 4MB 大小的空间。</p>
<p>我们把这个 100 多万个「页表项」的单级页表再分页，将页表（一级页表）分为 <code>1024</code> 个页表（二级页表），每个表（二级页表）中包含 <code>1024</code> 个「页表项」，形成<strong>二级分页</strong>。如下图所示：</p>
<p><img  src="19296e249b2240c29f9c52be70f611d5.png"   style="zoom: 50%;" /><span class="image-caption">img</span></p>
<blockquote>
<p>你可能会问，分了二级表，映射 4GB 地址空间就需要 4KB（一级页表）+ 4MB（二级页表）的内存，这样占用空间不是更大了吗？</p>
</blockquote>
<p>当然如果 4GB 的虚拟地址全部都映射到了物理内存上的话，二级分页占用空间确实是更大了，但是，我们往往不会为一个进程分配那么多内存。</p>
<p>其实我们应该换个角度来看问题，还记得计算机组成原理里面无处不在的<strong>局部性原理</strong>么？</p>
<p>每个进程都有 4GB 的虚拟地址空间，而显然对于大多数程序来说，其使用到的空间远未达到 4GB，因为会存在部分对应的页表项都是空的，根本没有分配，对于已分配的页表项，如果存在最近一定时间未访问的页表，在物理内存紧张的情况下，操作系统会将页面换出到硬盘，也就是说不会占用物理内存。</p>
<p>如果使用了二级分页，一级页表就可以覆盖整个 4GB 虚拟地址空间，但<strong>如果某个一级页表的页表项没有被用到，也就不需要创建这个页表项对应的二级页表了，即可以在需要时才创建二级页表</strong>。做个简单的计算，假设只有 20% 的一级页表项被用到了，那么页表占用的内存空间就只有 4KB（一级页表） + 20% * 4MB（二级页表）= <code>0.804MB</code>，这对比单级页表的 <code>4MB</code> 是不是一个巨大的节约？</p>
<p>对于 64 位的系统，两级分页肯定不够了，就变成了四级目录，分别是：</p>
<ul>
<li>全局页目录项 PGD（<em>Page Global Directory</em>）；</li>
<li>上层页目录项 PUD（<em>Page Upper Directory</em>）；</li>
<li>中间页目录项 PMD（<em>Page Middle Directory</em>）；</li>
<li>页表项 PTE（<em>Page Table Entry</em>）；</li>
</ul>
<p>我们就可以利用这一特性，把最常访问的几个页表项存储到访问速度更快的硬件，于是计算机科学家们，就在 CPU 芯片中，加入了一个专门存放程序最常访问的页表项的 Cache，这个 Cache 就是 TLB（<em>Translation Lookaside Buffer</em>） ，通常称为页表缓存、转址旁路缓存、快表等。</p>
<p><img  src="a3cdf27646b24614a64cfc5d7ccffa35.png"   style="zoom: 67%;" /><span class="image-caption">img</span></p>
<p>在 CPU 芯片里面，封装了内存管理单元（<em>Memory Management Unit</em>）芯片，它用来完成地址转换和 TLB 的访问与交互。</p>
<p>有了 TLB 后，那么 CPU 在寻址时，会先查 TLB，如果没找到，才会继续查常规的页表。</p>
<p>TLB 的命中率其实是很高的，因为程序最常访问的页就那么几个。</p>
<h3 id="malloc-是如何分配内存的？"><a href="#malloc-是如何分配内存的？" class="headerlink" title="malloc 是如何分配内存的？"></a>malloc 是如何分配内存的？</h3><p>实际上，malloc() 并不是系统调用，而是 C 库里的函数，用于动态分配内存。</p>
<p>malloc 申请内存的时候，会有两种方式向操作系统申请堆内存。</p>
<ul>
<li>方式一：通过 brk() 系统调用从堆分配内存</li>
<li>方式二：通过 mmap() 系统调用在文件映射区域分配内存；</li>
</ul>
<p>方式一实现的方式很简单，就是通过 brk() 函数将「堆顶」指针向高地址移动，获得新的内存空间。如下图：</p>
<p><img  src="/brk申请.png"   style="zoom:50%;" /><span class="image-caption">img</span></p>
<p>方式二通过 mmap() 系统调用中「私有匿名映射」的方式，在文件映射区分配一块内存，也就是从文件映射区“偷”了一块内存。如下图：</p>
<p><img  src="/mmap申请.png"   style="zoom:50%;" /><span class="image-caption">img</span></p>
<blockquote>
<p>什么场景下 malloc() 会通过 brk() 分配内存？又是什么场景下通过 mmap() 分配内存？</p>
</blockquote>
<p>malloc() 源码里默认定义了一个阈值：</p>
<ul>
<li>如果用户分配的内存小于 128 KB，则通过 brk() 申请内存；</li>
<li>如果用户分配的内存大于 128 KB，则通过 mmap() 申请内存；</li>
</ul>
<p>注意，不同的 glibc 版本定义的阈值也是不同的。</p>
<h3 id="malloc-分配的是物理内存吗？"><a href="#malloc-分配的是物理内存吗？" class="headerlink" title="malloc() 分配的是物理内存吗？"></a>malloc() 分配的是物理内存吗？</h3><p>不是的，<strong>malloc() 分配的是虚拟内存</strong>。</p>
<p>如果分配后的虚拟内存没有被访问的话，虚拟内存是不会映射到物理内存的，这样就不会占用物理内存了。</p>
<p>只有在访问已分配的虚拟地址空间的时候，操作系统通过查找页表，发现虚拟内存对应的页没有在物理内存中，就会触发缺页中断，然后操作系统会建立虚拟内存和物理内存之间的映射关系。</p>
<h3 id="malloc-1-会分配多大的虚拟内存？"><a href="#malloc-1-会分配多大的虚拟内存？" class="headerlink" title="malloc(1) 会分配多大的虚拟内存？"></a>malloc(1) 会分配多大的虚拟内存？</h3><p>malloc() 在分配内存的时候，并不是老老实实按用户预期申请的字节数来分配内存空间大小，而是<strong>会预分配更大的空间作为内存池</strong>。</p>
<p>具体会预分配多大的空间，跟 malloc 使用的内存管理器有关系，我们就以 malloc 默认的内存管理器（Ptmalloc2）来分析。</p>
<p>接下里，我们做个实验，用下面这个代码，通过 malloc 申请 1 字节的内存时，看看操作系统实际分配了多大的内存空间。</p>
<p>这个例子分配的内存小于 128 KB，所以是通过 brk() 系统调用向堆空间申请的内存，因此可以看到最右边有 [heap] 的标识。</p>
<p>可以看到，堆空间的内存地址范围是 00d73000-00d94000，这个范围大小是 132KB，也就说明了 <strong>malloc(1) 实际上预分配 132K 字节的内存</strong>。</p>
<p>可能有的同学注意到了，程序里打印的内存起始地址是 <code>d73010</code>，而 maps 文件显示堆内存空间的起始地址是 <code>d73000</code>，为什么会多出来 <code>0x10</code> （16字节）呢？这个问题，我们先放着，后面会说。</p>
<h3 id="free-释放内存，会归还给操作系统吗？"><a href="#free-释放内存，会归还给操作系统吗？" class="headerlink" title="free 释放内存，会归还给操作系统吗？"></a>free 释放内存，会归还给操作系统吗？</h3><ul>
<li>malloc 通过 <strong>brk()</strong> 方式申请的内存，free 释放内存的时候，<strong>并不会把内存归还给操作系统，而是缓存在 malloc 的内存池中，待下次使用</strong>；</li>
<li>malloc 通过 <strong>mmap()</strong> 方式申请的内存，free 释放内存的时候，<strong>会把内存归还给操作系统，内存得到真正的释放</strong>。</li>
</ul>
<h3 id="为什么不全部使用-mmap-来分配内存？"><a href="#为什么不全部使用-mmap-来分配内存？" class="headerlink" title="为什么不全部使用 mmap 来分配内存？"></a>为什么不全部使用 mmap 来分配内存？</h3><ul>
<li>mmap 要系统调用，因为 mmap 分配的内存释放的时候会归还给操作系统</li>
<li>mmap 要运行态切换 + 缺页中断</li>
</ul>
<p>因为向操作系统申请内存，是要通过系统调用的，执行系统调用是要进入内核态的，然后在回到用户态，运行态的切换会耗费不少时间。</p>
<p>所以，申请内存的操作应该避免频繁的系统调用，如果都用 mmap 来分配内存，等于每次都要执行系统调用。</p>
<p>另外，因为 mmap 分配的内存每次释放的时候，都会归还给操作系统，于是每次 mmap 分配的虚拟地址都是缺页状态的，然后在第一次访问该虚拟地址的时候，就会触发缺页中断。</p>
<p>也就是说，<strong>频繁通过 mmap 分配的内存话，不仅每次都会发生运行态的切换，还会发生缺页中断（在第一次访问虚拟地址后），这样会导致 CPU 消耗较大</strong>。</p>
<p>为了改进这两个问题，malloc 通过 brk() 系统调用在堆空间申请内存的时候，由于堆空间是连续的，所以直接预分配更大的内存来作为内存池，当内存释放的时候，就缓存在内存池中。</p>
<p><strong>等下次在申请内存的时候，就直接从内存池取出对应的内存块就行了，而且可能这个内存块的虚拟地址与物理地址的映射关系还存在，这样不仅减少了系统调用的次数，也减少了缺页中断的次数，这将大大降低 CPU 的消耗</strong>。</p>
<h3 id="既然-brk-那么牛逼，为什么不全部使用-brk-来分配？"><a href="#既然-brk-那么牛逼，为什么不全部使用-brk-来分配？" class="headerlink" title="既然 brk 那么牛逼，为什么不全部使用 brk 来分配？"></a>既然 brk 那么牛逼，为什么不全部使用 brk 来分配？</h3><ul>
<li>brk 会产生大量的内存碎片</li>
</ul>
<p>前面我们提到通过 brk 从堆空间分配的内存，并不会归还给操作系统，那么我们那考虑这样一个场景。</p>
<p>如果我们连续申请了 10k，20k，30k 这三片内存，如果 10k 和 20k 这两片释放了，变为了空闲内存空间，如果下次申请的内存小于 30k，那么就可以重用这个空闲内存空间。</p>
<p>但是如果下次申请的内存大于 30k，没有可用的空闲内存空间，必须向 OS 申请，实际使用内存继续增大。</p>
<p>因此，随着系统频繁地 malloc 和 free ，尤其对于小块内存，堆内将产生越来越多不可用的碎片，导致“内存泄露”。而这种“泄露”现象使用 valgrind 是无法检测出来的。</p>
<p>所以，malloc 实现中，充分考虑了 brk 和 mmap 行为上的差异及优缺点，默认分配大块内存 (128KB) 才使用 mmap 分配内存空间。</p>
<h3 id="free-函数只传入一个内存地址，为什么能知道要释放多大的内存？"><a href="#free-函数只传入一个内存地址，为什么能知道要释放多大的内存？" class="headerlink" title="free() 函数只传入一个内存地址，为什么能知道要释放多大的内存？"></a>free() 函数只传入一个内存地址，为什么能知道要释放多大的内存？</h3><p>还记得，我前面提到， malloc 返回给用户态的内存起始地址比进程的堆空间起始地址多了 16 字节吗？</p>
<p>这个多出来的 16 字节就是保存了该内存块的描述信息，比如有该内存块的大小。</p>
<p><img  src="cb6e3ce4532ff0a6bfd60fe3e52a806e.png"  ><span class="image-caption">图片</span></p>
<p>这样当执行 free() 函数时，free 会对传入进来的内存地址向左偏移 16 字节，然后从这个 16 字节的分析出当前的内存块的大小，自然就知道要释放多大的内存了。</p>
<h3 id="malloc内存分配器是怎样实现的？"><a href="#malloc内存分配器是怎样实现的？" class="headerlink" title="malloc内存分配器是怎样实现的？"></a>malloc内存分配器是怎样实现的？</h3><p><a href="https://mp.weixin.qq.com/s/Flt85kKbDEn_XD83mtYxUA?token=1646973705&amp;lang=zh_CN">https://mp.weixin.qq.com/s/Flt85kKbDEn_XD83mtYxUA?token=1646973705&amp;lang=zh_CN</a></p>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="线程崩溃了，进程也会崩溃吗？"><a href="#线程崩溃了，进程也会崩溃吗？" class="headerlink" title="线程崩溃了，进程也会崩溃吗？"></a>线程崩溃了，进程也会崩溃吗？</h3><p>一般来说如果线程是因为非法访问内存引起的崩溃，那么进程肯定会崩溃，为什么系统要让进程崩溃呢，这主要是因为在进程中，<strong>各个线程的地址空间是共享的</strong>，既然是共享，那么某个线程对地址的非法访问就会导致内存的不确定性，进而可能会影响到其他线程，这种操作是危险的，操作系统会认为这很可能导致一系列严重的后果，于是干脆让整个进程崩溃。</p>
<h3 id="进程是如何崩溃的"><a href="#进程是如何崩溃的" class="headerlink" title="进程是如何崩溃的"></a>进程是如何崩溃的</h3><p>那么线程崩溃后，进程是如何崩溃的呢，这背后的机制到底是怎样的，答案是<strong>信号</strong>。</p>
<p>大家想想要干掉一个正在运行的进程是不是经常用 kill -9 pid 这样的命令，这里的 kill 其实就是给指定 pid 发送终止信号的意思，其中的 9 就是信号。</p>
<p>其实信号有很多类型的，在 Linux 中可以通过 <code>kill -l</code>查看所有可用的信号：</p>
<p>那么发个信号进程怎么就崩溃了呢，这背后的原理到底是怎样的？</p>
<p>其背后的机制如下：</p>
<ol>
<li>CPU 执行正常的进程指令</li>
<li>调用 kill 系统调用向进程发送信号（假设为 11，即 SIGSEGV，一般非法访问内存报的都是这个错误）</li>
<li>进程收到操作系统发的信号，CPU 暂停当前程序运行，并将控制权转交给操作系统</li>
<li><strong>操作系统根据情况执行相应的信号处理程序（函数），一般执行完信号处理程序逻辑后会让进程退出</strong></li>
</ol>
<p>注意上面的第五步，如果进程没有注册自己的信号处理函数，那么操作系统会执行默认的信号处理程序（一般最后会让进程退出），但如果注册了，则会执行自己的信号处理函数，这样的话就给了进程一个垂死挣扎的机会，它收到 kill 信号后，可以调用 exit() 来退出，<strong>但也可以使用 sigsetjmp，siglongjmp 这两个函数来恢复进程的执行</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 自定义信号处理函数示例</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-comment">// 自定义信号处理函数，处理自定义逻辑后再调用 exit 退出</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">sigHandler</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span> &#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Signal %d catched!\n&quot;</span>, sig);<br>  <span class="hljs-built_in">exit</span>(sig);<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>  signal(SIGSEGV, sigHandler);<br>  <span class="hljs-type">int</span> *p = (<span class="hljs-type">int</span> *)<span class="hljs-number">0xC0000fff</span>;<br>  *p = <span class="hljs-number">10</span>; <span class="hljs-comment">// 针对不属于进程的内核空间写入数据，崩溃</span><br>&#125;<br><br><span class="hljs-comment">// 以上结果输出: Signal 11 catched!</span><br></code></pre></td></tr></table></figure>
<p><strong>如代码所示</strong>：注册信号处理函数后，当收到 SIGSEGV 信号后，先执行相关的逻辑再退出</p>
<p>另外当进程接收信号之后也可以不定义自己的信号处理函数，而是选择忽略信号，如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>  <span class="hljs-comment">// 忽略信号</span><br>  signal(SIGSEGV, SIG_IGN);<br><br>  <span class="hljs-comment">// 产生一个 SIGSEGV 信号</span><br>  raise(SIGSEGV);<br><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;正常结束&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>也就是说虽然给进程发送了 kill 信号，但如果进程自己定义了信号处理函数或者无视信号就有机会逃出生天，当然了 kill -9 命令例外，不管进程是否定义了信号处理函数，都会马上被干掉。</p>
<p>说到这大家是否想起了一道经典面试题：<strong>如何让正在运行的 Java 工程的优雅停机？</strong></p>
<p>通过上面的介绍大家不难发现，其实是 JVM 自己定义了信号处理函数，这样当发送 kill pid 命令（默认会传 15 也就是 SIGTERM）后，JVM 就可以在信号处理函数中执行一些资源清理之后再调用 exit 退出。</p>
<p>这种场景显然不能用 kill -9，不然一下把进程干掉了资源就来不及清除了。</p>
<h3 id="为什么线程崩溃不会导致-JVM-进程崩溃"><a href="#为什么线程崩溃不会导致-JVM-进程崩溃" class="headerlink" title="为什么线程崩溃不会导致 JVM 进程崩溃"></a>为什么线程崩溃不会导致 JVM 进程崩溃</h3><p><strong>因为 JVM 自定义了自己的信号处理函数，拦截了 SIGSEGV 信号，针对这两者不让它们崩溃</strong>。</p>
<h3 id="OpenJDK-源码"><a href="#OpenJDK-源码" class="headerlink" title="OpenJDK 源码"></a>OpenJDK 源码</h3><p><img  src="474ddf8657a0438da1822e0f6fa59af7.jpeg"   style="zoom:80%;" /><span class="image-caption">img</span></p>
<p>可以看到，在启动 JVM 的时候，也设置了信号处理函数，收到 SIGSEGV，SIGPIPE 等信号后最终会调用 JVM_handle_linux_signal 这个自定义信号处理函数，再来看下这个函数的主要逻辑。</p>
<ol>
<li>发生 stackoverflow 还有空指针错误，确实都发送了 SIGSEGV，只是虚拟机不选择退出，而是自己内部作了额外的处理，其实是恢复了线程的执行，并抛出 StackoverflowError 和 NPE，这就是为什么 JVM 不会崩溃且我们能捕获这两个错误/异常的原因</li>
<li>如果针对 SIGSEGV 等信号，在以上的函数中 JVM 没有做额外的处理，那么最终会走到 report_and_die 这个方法，这个方法主要做的事情是生成 hs_err_pid_xxx.log crash 文件（记录了一些堆栈信息或错误），然后退出</li>
</ol>
<p>至此我相信大家明白了为什么发生了 StackoverflowError 和 NPE 这两个非法访问内存的错误，JVM 却没有崩溃。</p>
<p><strong>原因其实就是虚拟机内部定义了信号处理函数，而在信号处理函数中对这两者做了额外的处理以让 JVM 不崩溃，另一方面也可以看出如果 JVM 不对信号做额外的处理，最后会自己退出并产生 crash 文件 hs_err_pid_xxx.log（可以通过 -XX:ErrorFile=/var/*log*/hs_err.log 这样的方式指定），这个文件记录了虚拟机崩溃的重要原因</strong>。</p>
<p>所以也可以说，虚拟机是否崩溃只要看它是否会产生此崩溃日志文件</p>
<h1 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h1><h2 id="秒杀系统"><a href="#秒杀系统" class="headerlink" title="秒杀系统"></a>秒杀系统</h2><p>系统架构分层设计如下。</p>
<p><strong>前端层：</strong></p>
<ul>
<li><strong>页面静态化</strong>：将商品展示页面等静态内容进行缓存，用户请求时可以直接从缓存中获取，减少服务器的渲染压力。例如，使用内容分发网络（CDN）缓存商品图片、详情介绍等静态资源。</li>
<li><strong>防刷机制</strong>：通过验证码、限制用户请求频率等方式防止恶意刷请求。例如，在秒杀开始前要求用户输入验证码，并且在一定时间内限制单个用户的请求次数，如每秒最多允许 3 次请求。</li>
</ul>
<p><strong>应用层：</strong></p>
<ul>
<li><strong>负载均衡</strong>：采用负载均衡器将用户请求均匀地分配到多个后端服务器，避免单点服务器过载。如使用 Nginx 作为负载均衡器，根据服务器的负载情况和性能动态分配请求。</li>
<li><strong>服务拆分与微服务化</strong>：将秒杀系统的不同功能模块拆分成独立的微服务，如用户服务、商品服务、订单服务等。这样可以独立部署和扩展各个模块，提高系统的灵活性和可维护性。</li>
<li><strong>缓存策略</strong>：在应用层使用缓存来提高系统性能。例如，使用 Redis 缓存商品库存信息，用户下单前先从 Redis 中查询库存，减少对数据库的直接访问。</li>
</ul>
<p><strong>数据层：</strong></p>
<ul>
<li><strong>数据库优化</strong>：对数据库进行性能优化，如数据库索引优化、SQL 语句优化等。对于库存表，可以为库存字段添加索引，加快库存查询和更新的速度。</li>
<li><strong>数据库集群与读写分离</strong>：采用数据库集群来提高数据库的处理能力，同时进行读写分离。将读操作（如查询商品信息）和写操作（如库存扣减、订单生成）分布到不同的数据库节点上，提高系统的并发处理能力。</li>
</ul>
<p><strong>高并发场景下扣减库存的方式：</strong></p>
<ul>
<li><strong>预扣库存</strong>：在用户下单时，先预扣库存，将库存数量在缓存（如 Redis）中进行减 1 操作。同时设置一个较短的过期时间，如 1 - 2 分钟。如果用户在过期时间内完成支付，正式扣减库存；如果未完成支付，库存自动回补。</li>
<li><strong>异步更新数据库：</strong>通过 Redis 判断之后，去更新数据库的请求都是必要的请求，这些请求数据库必须要处理，但是如果数据库还是处理不过来这些请求怎么办呢？这个时候就可以考虑削峰填谷操作了，削峰填谷最好的实践就是 MQ 了。经过 Redis 库存扣减判断之后，我们已经确保这次请求需要生成订单，我们就可以通过异步的形式通知订单服务生成订单并扣减库存。</li>
<li><strong>数据库乐观锁防止超卖</strong>：更新数据库减库存的时候，采用乐观锁方式，进行库存限制条件，<code>update goods set stock = stock - 1 where goods_id = ? and stock &gt;0</code></li>
</ul>
<h3 id="redis-分布式锁解决超卖问题"><a href="#redis-分布式锁解决超卖问题" class="headerlink" title="redis 分布式锁解决超卖问题"></a>redis 分布式锁解决超卖问题</h3><p>同一个锁key，同一时间只能有一个客户端拿到锁，其他客户端会陷入无限的等待来尝试获取那个锁，只有获取到锁的客户端才能执行下面的业务逻辑。</p>
<p>比如说，用户要一次性买 10 台手机，那么避免超卖的流程如下：</p>
<ul>
<li>只有一个订单系统实例可以成功加分布式锁，然后只有他一个实例可以查库存、判断库存是否充足、下单扣减库存，接着释放锁。</li>
<li>释放锁之后，另外一个订单系统实例才能加锁，接着查库存，一下发现库存只有 2 个了，库存不足，无法购买，下单失败，不会将库存扣减为-8的，就避免超卖的问题。</li>
</ul>
<p>这种方案的缺点是同一个商品在多用户同时下单的情况下，会基于分布式锁串行化处理，导致没法同时处理同一个商品的大量下单的请求。</p>
<h3 id="数据库层面解决超卖"><a href="#数据库层面解决超卖" class="headerlink" title="数据库层面解决超卖"></a>数据库层面解决超卖</h3><ol>
<li>在查询商品库存时加排他锁，执行如下语句：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> goods <span class="hljs-keyword">for</span> <span class="hljs-keyword">where</span> goods_id <span class="hljs-operator">=</span> ?  <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span><br></code></pre></td></tr></table></figure>
<p>在事务中线程A通过select * from goods for where goods_id=#{id} for update语句给goods_id为#{id}的数据行上了锁。那么其他线程此时可以使用select语句读取数据，但是如果也使用select for update语句加锁，或者使用update，delete都会阻塞，直到线程A将事务提交（或者回滚），其他线程中的某个线程排在线程A后的线程才能获取到锁。</p>
<ol>
<li>更新数据库减库存的时候，进行库存限制条件</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> goods <span class="hljs-keyword">set</span> stock <span class="hljs-operator">=</span> stock <span class="hljs-operator">-</span> <span class="hljs-number">1</span> <span class="hljs-keyword">where</span> goods_id <span class="hljs-operator">=</span> ? <span class="hljs-keyword">and</span> stock <span class="hljs-operator">&gt;</span><span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
<p>这种通过数据库加锁来解决的方案，性能不是很好，在高并发的情况下，还可能存在因为获取不到数据库连接或者因为超时等待而报错。</p>
<h3 id="利用分布式锁-分段缓存解决超卖"><a href="#利用分布式锁-分段缓存解决超卖" class="headerlink" title="利用分布式锁+分段缓存解决超卖"></a>利用分布式锁+分段缓存解决超卖</h3><p>把数据分成很多个段，每个段是一个单独的锁，所以多个线程过来并发修改数据的时候，可以并发的修改不同段的数据</p>
<p>假设场景：假如你现在商品有100个库存，在redis存放5个库存key，形如:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">key1<span class="hljs-operator">=</span>goods<span class="hljs-number">-01</span>,<span class="hljs-keyword">value</span><span class="hljs-operator">=</span><span class="hljs-number">20</span>;<br>key2<span class="hljs-operator">=</span>goods<span class="hljs-number">-02</span>,<span class="hljs-keyword">value</span><span class="hljs-operator">=</span><span class="hljs-number">20</span>;<br>key3<span class="hljs-operator">=</span>goods<span class="hljs-number">-03</span>，<span class="hljs-keyword">value</span><span class="hljs-operator">=</span><span class="hljs-number">20</span><br></code></pre></td></tr></table></figure>
<p>用户下单时对用户id进行%5计算，看落在哪个redis的key上，就去取哪个，这样每次就能够处理5个进程请求</p>
<p>这种方案可以解决同一个商品在多用户同时下单的情况，但有个坑需要解决：当某段锁的库存不足，一定要实现自动释放锁然后换下一个分段库存再次尝试加锁处理，此种方案复杂比较高。</p>
<h3 id="利用redis的incr、decr的原子性-异步队列解决超卖"><a href="#利用redis的incr、decr的原子性-异步队列解决超卖" class="headerlink" title="利用redis的incr、decr的原子性 + 异步队列解决超卖"></a>利用redis的incr、decr的原子性 + 异步队列解决超卖</h3><p>实现思路</p>
<ul>
<li>1、在系统初始化时，将商品的库存数量加载到redis缓存中</li>
<li>2、接收到秒杀请求时，在redis中进行预减库存（利用redis decr的原子性），当redis中的库存不足时，直接返回秒杀失败，否则继续进行第3步；</li>
<li>3、将请求放入异步队列中，返回正在排队中；</li>
<li>4、服务端异步队列将请求出队（哪些请求可以出队，可以根据业务来判定，比如：判断对应用户是否已经秒杀过对应商品，防止重复秒杀），出队成功的请求可以生成秒杀订单，减少数据库库存（在扣减库存的sql如下，返回秒杀订单详情）</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> goods <span class="hljs-keyword">set</span> stock <span class="hljs-operator">=</span> stock <span class="hljs-operator">-</span> <span class="hljs-number">1</span> <span class="hljs-keyword">where</span> goods_id <span class="hljs-operator">=</span> ? <span class="hljs-keyword">and</span> stock <span class="hljs-operator">&gt;</span><span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
<ul>
<li>5、用户在客户端申请秒杀请求后，进行轮询，查看是否秒杀成功，秒杀成功则进入秒杀订单详情，否则秒杀失败</li>
</ul>
<p>这种方案的缺点：由于是通过异步队列写入数据库中，可能存在数据不一致，其次引用多个组件复杂度比较高</p>
<h2 id="存算分离"><a href="#存算分离" class="headerlink" title="存算分离"></a>存算分离</h2><p>“<strong>存算分离（Storage and Compute Separation）</strong>”是现代云原生架构、分布式系统中非常重要的一种设计理念，它指的是<strong>将数据存储层（Storage）与计算执行层（Compute）进行解耦</strong>，使它们可以<strong>独立扩展、独立管理、分布式协同工作</strong>。</p>
<h3 id="什么是存算分离？"><a href="#什么是存算分离？" class="headerlink" title="什么是存算分离？"></a>什么是存算分离？</h3><p>传统模式中，<strong>计算和存储绑在一起</strong>：</p>
<ul>
<li>一台机器负责处理数据（算）+ 保存数据（存）</li>
<li>横向扩展能力有限</li>
</ul>
<p><strong>存算分离模式</strong>中，架构变成如下形式：</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><code class="hljs gcode">┌───────────────┐<br>│   Compute     │   ← 可弹性伸缩<br>│  <span class="hljs-comment">(如 Spark)</span>    │<br>└───────────────┘<br>       ↑<br>       ↓（网络传输）<br>┌───────────────┐<br>│   Storage     │   ← 持久保存数据<br>│ <span class="hljs-comment">(如 HDFS/S3)</span>   │<br>└───────────────┘<br></code></pre></td></tr></table></figure>
<p>即：计算层是 <strong>无状态的</strong>，而数据<strong>统一保存在独立的存储层</strong>。</p>
<h3 id="核心组件划分"><a href="#核心组件划分" class="headerlink" title="核心组件划分"></a>核心组件划分</h3><div class="table-container">
<table>
<thead>
<tr>
<th>层级</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>计算层</strong></td>
<td>Spark、Presto、Flink、ClickHouse、Trino、AI训练框架等</td>
</tr>
<tr>
<td><strong>存储层</strong></td>
<td>S3、HDFS、OSS、Ceph、Delta Lake、Iceberg 等</td>
</tr>
<tr>
<td><strong>缓存层（可选）</strong></td>
<td>Alluxio、Memcached、Redis、local SSD，用于提升 IO</td>
</tr>
</tbody>
</table>
</div>
<h3 id="存算分离的优点"><a href="#存算分离的优点" class="headerlink" title="存算分离的优点"></a>存算分离的优点</h3><ol>
<li>弹性计算能力</li>
</ol>
<ul>
<li>计算节点可以 <strong>按需启动和释放</strong>（容器化、Serverless）</li>
<li>非常适合 <strong>突发计算 / 多租户环境</strong></li>
</ul>
<ol>
<li>成本优化</li>
</ol>
<ul>
<li>存储层用<strong>低成本对象存储</strong>（如 S3）替代 HDFS 本地磁盘；</li>
<li>计算资源可临时用完即销毁，<strong>降低长期资源占用</strong></li>
</ul>
<ol>
<li>更好的资源隔离 &amp; 弹性扩展</li>
</ol>
<ul>
<li>多租户任务可共享存储、独立计算；</li>
<li>支持异构任务同时运行（如查询、训练）</li>
</ul>
<ol>
<li>更高可用性</li>
</ol>
<ul>
<li>存储故障不会影响计算，计算失败重启不影响数据持久性；</li>
<li>支持冷热分层存储，数据分区调度灵活</li>
</ul>
<h3 id="存算分离的挑战与优化"><a href="#存算分离的挑战与优化" class="headerlink" title="存算分离的挑战与优化"></a>存算分离的挑战与优化</h3><div class="table-container">
<table>
<thead>
<tr>
<th>问题</th>
<th>优化方式或解决策略</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>网络 IO 成本高</strong></td>
<td>引入缓存层（如 Alluxio、本地 SSD 缓存）</td>
</tr>
<tr>
<td><strong>延迟抖动大</strong></td>
<td>批量读、预取、压缩格式（Parquet/ORC）</td>
</tr>
<tr>
<td><strong>一致性和事务难处理</strong></td>
<td>引入表格式 Delta Lake / Apache Iceberg</td>
</tr>
<tr>
<td><strong>任务失败时恢复成本高</strong></td>
<td>支持 checkpoint + container 恢复机制</td>
</tr>
<tr>
<td><strong>存储与计算分区策略不匹配</strong></td>
<td>合理设计分区策略，使用分区裁剪（partition pruning）</td>
</tr>
</tbody>
</table>
</div>
<h2 id="Rocketmq-之类的消息队列怎么做存算分离"><a href="#Rocketmq-之类的消息队列怎么做存算分离" class="headerlink" title="Rocketmq 之类的消息队列怎么做存算分离"></a>Rocketmq 之类的消息队列怎么做存算分离</h2><p><strong>RocketMQ</strong> 以及其他消息队列（如 Kafka、Pulsar）本质上是<strong>日志存储 + 消费处理系统</strong>。在设计上，它们其实<strong>天然适合做存算分离</strong>，但每个系统的落地方式、分离程度和技术演进路径并不一样。</p>
<h3 id="消息队列中的“存”和“算”分别指什么？"><a href="#消息队列中的“存”和“算”分别指什么？" class="headerlink" title="消息队列中的“存”和“算”分别指什么？"></a>消息队列中的“存”和“算”分别指什么？</h3><div class="table-container">
<table>
<thead>
<tr>
<th>层级</th>
<th>RocketMQ 中的角色</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>存储层</strong></td>
<td>消息日志落盘、持久化、索引管理（如 CommitLog）</td>
</tr>
<tr>
<td><strong>计算层</strong></td>
<td>消费者处理、消息过滤、路由、Broker 转发</td>
</tr>
<tr>
<td><strong>中间层</strong></td>
<td>Broker 组件，既负责存，也参与转发计算</td>
</tr>
</tbody>
</table>
</div>
<h3 id="RocketMQ-的默认架构：存算耦合"><a href="#RocketMQ-的默认架构：存算耦合" class="headerlink" title="RocketMQ 的默认架构：存算耦合"></a>RocketMQ 的默认架构：存算耦合</h3><p>在传统 RocketMQ 架构中：</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade">Producer → Broker → Consumer<br><br>         Broker（存 + 算）<br>         ├── CommitLog（持久化）<br>         ├── ConsumeQueue / IndexFile<br>         └── Pull / <span class="hljs-built_in">Push</span> 消息调度转发<br></code></pre></td></tr></table></figure>
<p>Broker 同时：</p>
<ul>
<li>接收 Producer 消息</li>
<li>存盘落到 CommitLog（顺序写）</li>
<li>将消息转发给 Consumer（消费/过滤/确认）</li>
</ul>
<p>👉 <strong>计算和存储是耦合在 Broker 中的</strong>，这就限制了弹性伸缩、资源隔离。</p>
<h3 id="RocketMQ-如何实现存算分离？"><a href="#RocketMQ-如何实现存算分离？" class="headerlink" title="RocketMQ 如何实现存算分离？"></a>RocketMQ 如何实现存算分离？</h3><p>当前趋势：<strong>通过“Broker 分角色”+“共享存储”实现存算分离</strong></p>
<h4 id="Broker-角色分离（最新-RocketMQ-5-x-实现）"><a href="#Broker-角色分离（最新-RocketMQ-5-x-实现）" class="headerlink" title="Broker 角色分离（最新 RocketMQ 5.x 实现）"></a>Broker 角色分离（最新 RocketMQ 5.x 实现）</h4><p>RocketMQ 5.x 引入了 <strong>多角色 Broker 模型</strong>，实现计算和存储解耦：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><code class="hljs crmsh">┌────────────┐     ┌────────────┐<br>│ Proxy <span class="hljs-keyword">Node</span> <span class="hljs-title">│     │ Broker</span> <span class="hljs-keyword">Node</span><span class="hljs-title">│</span><br><span class="hljs-title">│（Compute</span>） │ --&gt; │（Storage） │<br>└────────────┘     └────────────┘<br>        ↑                   ↑<br>   Producer /           Shared Storage（如 NAS / S3）<br>    Consumer<br></code></pre></td></tr></table></figure>
<p><strong>具体做法：</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>角色</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Proxy Node</strong>（代理节点）</td>
<td>提供接口层、路由控制、访问控制、流控、消费逻辑处理（算）</td>
</tr>
<tr>
<td><strong>Storage Broker</strong></td>
<td>专注消息持久化、索引管理、数据写入/查询（存）</td>
</tr>
</tbody>
</table>
</div>
<p>💡 优势：</p>
<ul>
<li>计算节点可水平扩展，快速弹性部署；</li>
<li>存储节点使用高性能磁盘或对象存储；</li>
<li><strong>类似 Snowflake 的存算分离设计理念</strong>。</li>
</ul>
<h4 id="使用远程存储（RocketMQ-on-Cloud）"><a href="#使用远程存储（RocketMQ-on-Cloud）" class="headerlink" title="使用远程存储（RocketMQ-on-Cloud）"></a>使用远程存储（RocketMQ-on-Cloud）</h4><p><strong>云原生实现如：</strong></p>
<ul>
<li>阿里云消息队列 RocketMQ 版（Cloud）</li>
<li>腾讯云、华为云 MQ</li>
</ul>
<p>它们在内部使用：</p>
<ul>
<li><strong>Broker → 热存储（SSD）</strong></li>
<li><strong>冷数据 → OSS/S3 等对象存储</strong></li>
<li><strong>消费者访问数据 → 经由缓存 / Proxy 转发</strong></li>
</ul>
<p>这种模式进一步将 <strong>数据持久化职责剥离</strong>给存储服务，实现真正的“数据湖化 MQ”。</p>
<h4 id="结合-Alluxio-Tiered-Storage（冷热分层）"><a href="#结合-Alluxio-Tiered-Storage（冷热分层）" class="headerlink" title="结合 Alluxio / Tiered Storage（冷热分层）"></a>结合 Alluxio / Tiered Storage（冷热分层）</h4><ul>
<li>热消息：保留在本地 SSD / PageCache；</li>
<li>冷消息：定期归档到分布式文件系统或对象存储；</li>
<li>Broker 作为 IO 中转站，不承担全部存储压力。</li>
</ul>
<h1 id="AI"><a href="#AI" class="headerlink" title="AI"></a>AI</h1><h2 id="MCP"><a href="#MCP" class="headerlink" title="MCP"></a>MCP</h2><p>MCP 的核心定位是“被动服务”，仅响应调用请求，不参与决策或推理。</p>
<p><strong>优势</strong>：模块化设计，便于独立开发和扩展。　</p>
<p><strong>局限性</strong>：只能被动响应，无法主动解决问题。</p>
<p>MCP Server采用被动服务模式，仅在接收到请求时返回数据。例如，当模型需要抓取网页内容时，会通过HTTP/SSE协议发送请求，MCP Server抓取数据后返回。　</p>
<h2 id="Function-Call"><a href="#Function-Call" class="headerlink" title="Function Call"></a>Function Call</h2><p>Function Call是指大模型直接调用预定义函数的能力，允许模型生成请求参数并整合结果。例如，模型可以通过Function Call查询天气或执行简单的数学计算。它的本质是“代码级工具”，通常与模型绑定部署。　</p>
<p><strong>优势</strong>：高效便捷，无需额外通信开销。　</p>
<p><strong>局限性</strong>：受模型运行时资源限制，无法执行耗时任务。　</p>
<p>Function Call由模型运行时环境直接执行，开发者需预先定义函数并将其打包到模型服务中。这种方式适用于高频轻量任务。　</p>
<h2 id="Agent"><a href="#Agent" class="headerlink" title="Agent"></a>Agent</h2><p>Agent是一种具备自主决策能力的AI实体，能够感知环境、规划任务并调用工具（包括MCP Server和Function Call）完成目标。例如，一个Agent可以接到“撰写AI趋势报告”的任务后，自动抓取数据、分析内容并生成报告。　</p>
<p><strong>优势</strong>：高自主性，支持复杂流程。　</p>
<p><strong>局限性</strong>：开发复杂度较高，需要集成推理框架和状态管理。</p>
<p>Agent具备高自主性，不仅可以主动调用工具，还能与用户进行双向交互。例如，当用户提出模糊需求时，Agent可以进一步确认细节后再执行任务。　</p>
<h2 id="Transformer"><a href="#Transformer" class="headerlink" title="Transformer"></a>Transformer</h2><h3 id="介绍一下-Transformer"><a href="#介绍一下-Transformer" class="headerlink" title="介绍一下 Transformer"></a>介绍一下 Transformer</h3><h3 id="介绍一下-QKV-的计算过程"><a href="#介绍一下-QKV-的计算过程" class="headerlink" title="介绍一下 QKV 的计算过程"></a>介绍一下 QKV 的计算过程</h3><h3 id="介绍一下-QKV-的过程中的计算量"><a href="#介绍一下-QKV-的过程中的计算量" class="headerlink" title="介绍一下 QKV 的过程中的计算量"></a>介绍一下 QKV 的过程中的计算量</h3><h3 id="介绍一下-Transformer-中的参数量"><a href="#介绍一下-Transformer-中的参数量" class="headerlink" title="介绍一下 Transformer 中的参数量"></a>介绍一下 Transformer 中的参数量</h3><h3 id="介绍一下位置编码的演变"><a href="#介绍一下位置编码的演变" class="headerlink" title="介绍一下位置编码的演变"></a>介绍一下位置编码的演变</h3><h3 id="位置编码"><a href="#位置编码" class="headerlink" title="位置编码"></a>位置编码</h3><p><a href="https://zhuanlan.zhihu.com/p/11885471610">https://zhuanlan.zhihu.com/p/11885471610</a></p>
<h3 id="为什么-decoder-only-更有优势"><a href="#为什么-decoder-only-更有优势" class="headerlink" title="为什么 decoder-only 更有优势"></a>为什么 decoder-only 更有优势</h3><h3 id="为什么大模型的输入与输出-Token-的价格不一样贵"><a href="#为什么大模型的输入与输出-Token-的价格不一样贵" class="headerlink" title="为什么大模型的输入与输出 Token 的价格不一样贵"></a>为什么大模型的输入与输出 Token 的价格不一样贵</h3><h3 id="-2"><a href="#-2" class="headerlink" title=" "></a> </h3>]]></content>
      <tags>
        <tag>data structure, algorithm</tag>
      </tags>
  </entry>
</search>
